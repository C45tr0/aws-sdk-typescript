// Type definitions for aws-sdk
// Project: https://github.com/aws/aws-sdk-js
// Definitions by: https://github.com/ingenieux/aws-sdk-typescript
// GENERATED CODE - DO NOT EDIT

declare module "aws-sdk" {

  export var config: ClientConfig;

  export function Config(json: any): void;

  export class Credentials {
    constructor(accessKeyId: string, secretAccessKey: string, sessionToken?: string);
    accessKeyId: string;
    expired: boolean;
    expireTime: Date;
    expiryWindow: number;
    secretAccessKey: string;
    sessionToken: string;
    get(callback: (err?:Error) => void): void;
    needsRefresh(): boolean;
    refresh(callback: (err?:Error) => void): void;
  }

  export interface Logger {
    write?: (chunk: any, encoding?: string, callback?: () => void) => void;
    log?: (...messages: any[]) => void;
  }

  export interface HttpOptions {
    proxy?: string;
    agent?: any;
    timeout?: number;
    xhrAsync?: boolean;
    xhrWithCredentials?: boolean;
  }

  export interface Services {
    httpOptions?: HttpOptions;
    acm?: any;
    apigateway?: any;
    autoscaling?: any;
    cloudformation?: any;
    cloudfront?: any;
    cloudhsm?: any;
    cloudsearch?: any;
    cloudsearchdomain?: any;
    cloudtrail?: any;
    cloudwatch?: any;
    cloudwatchevents?: any;
    cloudwatchlogs?: any;
    codecommit?: any;
    codedeploy?: any;
    codepipeline?: any;
    cognitoidentity?: any;
    cognitosync?: any;
    configservice?: any;
    datapipeline?: any;
    devicefarm?: any;
    directconnect?: any;
    directoryservice?: any;
    dms?: any;
    dynamodb?: any;
    dynamodbstreams?: any;
    ec2?: any;
    ecr?: any;
    ecs?: any;
    efs?: any;
    elasticache?: any;
    elasticbeanstalk?: any;
    elb?: any;
    emr?: any;
    es?: any;
    elastictranscoder?: any;
    firehose?: any;
    gamelift?: any;
    glacier?: any;
    iam?: any;
    importexport?: any;
    inspector?: any;
    iot?: any;
    iotdata?: any;
    kinesis?: any;
    kms?: any;
    lambda?: any;
    machinelearning?: any;
    marketplacecommerceanalytics?: any;
    marketplacemetering?: any;
    mobileanalytics?: any;
    opsworks?: any;
    rds?: any;
    redshift?: any;
    route53?: any;
    route53domains?: any;
    s3?: any;
    ses?: any;
    simpledb?: any;
    sns?: any;
    sqs?: any;
    ssm?: any;
    storagegateway?: any;
    sts?: any;
    support?: any;
    swf?: any;
    waf?: any;
    workspaces?: any;
  }
  export interface ClientConfigPartial extends Services {
    credentials?: Credentials;
    region?: string;
    computeChecksums?: boolean;
    convertResponseTypes?: boolean;
    logger?: Logger;
    maxRedirects?: number;
    maxRetries?: number;
    paramValidation?: boolean;
    s3ForcePathStyle?: boolean;
    apiVersion?: any;
    apiVersions?: Services;
    signatureVersion?: string;
    sslEnabled?: boolean;
    systemClockOffset?: number;
  }

  export interface ClientConfig extends ClientConfigPartial {
    update?: (options: ClientConfigPartial, allUnknownKeys?: boolean) => void;
    getCredentials?: (callback: (err?: any) => void) => void ;
    loadFromPath?: (path: string) => void;
    credentials: Credentials;
    region: string;
  }

  export class Endpoint {
    constructor(endpoint:string);

    host:string;
    hostname:string;
    href:string;
    port:number;
    protocol:string;
  }

  export class Service {
    apiVersions:string[];
    makeRequest(operation:string, params:Object, callback:(error?:Error, data?:any) => void): void;
    makeUnauthenticatedRequest(operation:string, params:Object, callback: (error?:Error, data?:any) => void): void;
    setupRequestListeners(): void;
    waitFor(state:string, params:Object, callback:(error?:Error, data?:any) => void): void;
  }

  export module CognitoIdentity {
    export interface CognitoIdentityCredentialsParams {
      IdentityPoolId?: string;
      AccountId?: string;
      Logins?: {[k: string]: any};

      RoleArn?: string;
      RoleSessionName?: string;
      WebIdentityToken?: string;
      ProviderId?: string;
      Policy?: string;
      DurationSeconds?: number;

      IdentityId?: string;
    }
  }

  export class CognitoIdentityCredentials extends Credentials {
    constructor(params: CognitoIdentity.CognitoIdentityCredentialsParams);
  }

  export class Request extends EventEmitter {
    constructor(service:Service, operation:string, params:Object);

    on(event: string, listener: Function):Request;
    httpRequest: HttpRequest;
    startTime: Date;
    abort(): Request;
    createReadStream(): ReadableStream;
    eachItem(callback:Function): void;
    eachPage(callback: (err:Error, data:any, done?:() => void) => boolean|void): void;
    isPageable(): boolean;
    send(callback?: (err:Error, data:any) => void): void;
  }

  export class HttpRequest {
    body: string;
    endpoint: Endpoint;
    headers: {[index:string]: string};
    method: string;
    path: string;
    pathName(): string;
    search(): string;
  }

  export type Buffer = any;

  /*
   * Node-compatible interfaces
   */
  export class EventEmitter {
    addListener(event: string, listener: Function): EventEmitter;
    on(event: string, listener: Function): EventEmitter;
    once(event: string, listener: Function): EventEmitter;
    removeListener(event: string, listener: Function): EventEmitter;
    removeAllListeners(event?: string): EventEmitter;
    setMaxListeners(n: number): void;
    listeners(event: string): Function[];
    emit(event: string, ...args: any[]): boolean;
  }

  export interface ReadableStream extends EventEmitter {
    readable: boolean;
    read(size?: number): any;
    setEncoding(encoding: string): void;
    pause(): void;
    resume(): void;
    pipe<T extends WritableStream>(destination: T, options?: { end?: boolean; }): T;
    unpipe<T extends WritableStream>(destination?: T): void;
    unshift(chunk: string): void;
    unshift(chunk: Buffer): void;
    wrap(oldStream: ReadableStream): ReadableStream;
  }

  export interface WritableStream extends EventEmitter {
    writable: boolean;
    write: Function;
    end: Function;
  }
    
  export module DynamoDB {
    export class DocumentClient {
      /**
      * Creates a DynamoDB document client with a set of configuration options.
      *
      * @option options params [map] An optional map of parameters to bind to every
      *   request sent by this service object.
      * @option options service [AWS.DynamoDB] An optional pre-configured instance
      *  of the AWS.DynamoDB service object to use for requests. The object may
      *  bound parameters used by the document client.
      * @see AWS.DynamoDB.constructor
      *
      */
      constructor(options?: any);

      /**
      * Returns the attributes of one or more items from one or more tables
      * by delegating to `AWS.DynamoDB.batchGetItem()`.
      *
      * Supply the same parameters as {AWS.DynamoDB.batchGetItem} with
      * `AttributeValue`s substituted by native JavaScript types.
      *
      * @see AWS.DynamoDB.batchGetItem
      * @example Get items from multiple tables
      *  var params = {
      *    RequestItems: {
      *      'Table-1': {
      *        Keys: [
      *          {
      *             HashKey: 'haskey',
      *             NumberRangeKey: 1
      *          }
      *        ]
      *      },
      *      'Table-2': {
      *        Keys: [
      *          { foo: 'bar' },
      *        ]
      *      }
      *    }
      *  };
      *
      *  var docClient = new AWS.DynamoDB.DocumentClient();
      *
      *  docClient.batchGet(params, function(err, data) {
      *    if (err) console.log(err);
      *    else console.log(data);
      *  });
      *
      */
      batchGet(params: any, callback?: (err: any, data: any) => void): Request;

      /**
      * Puts or deletes multiple items in one or more tables by delegating
      * to `AWS.DynamoDB.batchWriteItem()`.
      *
      * Supply the same parameters as {AWS.DynamoDB.batchWriteItem} with
      * `AttributeValue`s substituted by native JavaScript types.
      *
      * @see AWS.DynamoDB.batchWriteItem
      * @example Write to and delete from a table
      *  var params = {
      *    RequestItems: {
      *      'Table-1': [
      *        {
      *          DeleteRequest: {
      *            Key: { HashKey: 'someKey' }
      *          }
      *        },
      *        {
      *          PutRequest: {
      *            Item: {
      *              HashKey: 'anotherKey',
      *              NumAttribute: 1,
      *              BoolAttribute: true,
      *              ListAttribute: [1, 'two', false],
      *              MapAttribute: { foo: 'bar' }
      *            }
      *          }
      *        }
      *      ]
      *    }
      *  };
      *
      *  var docClient = new AWS.DynamoDB.DocumentClient();
      *
      *  docClient.batchWrite(params, function(err, data) {
      *    if (err) console.log(err);
      *    else console.log(data);
      *  });
      *
      */
      batchWrite(params: any, callback?: (err: any, data: any) => void): Request;

      /**
      * Deletes a single item in a table by primary key by delegating to
      * `AWS.DynamoDB.deleteItem()`
      *
      * Supply the same parameters as {AWS.DynamoDB.deleteItem} with
      * `AttributeValue`s substituted by native JavaScript types.
      *
      * @see AWS.DynamoDB.deleteItem
      * @example Delete an item from a table
      *  var params = {
      *    TableName : 'Table',
      *    Key: {
      *      HashKey: 'hashkey',
      *      NumberRangeKey: 1
      *    }
      *  };
      *
      *  var docClient = new AWS.DynamoDB.DocumentClient();
      *
      *  docClient.delete(params, function(err, data) {
      *    if (err) console.log(err);
      *    else console.log(data);
      *  });
      *
      */
      delete(params: any, callback?: (err: any, data: any) => void): Request;

      /**
      * Returns a set of attributes for the item with the given primary key
      * by delegating to `AWS.DynamoDB.getItem()`.
      *
      * Supply the same parameters as {AWS.DynamoDB.getItem} with
      * `AttributeValue`s substituted by native JavaScript types.
      *
      * @see AWS.DynamoDB.getItem
      * @example Get an item from a table
      *  var params = {
      *    TableName : 'Table',
      *    Key: {
      *      HashKey: 'hashkey'
      *    }
      *  };
      *
      *  var docClient = new AWS.DynamoDB.DocumentClient();
      *
      *  docClient.get(params, function(err, data) {
      *    if (err) console.log(err);
      *    else console.log(data);
      *  });
      *
      */
      get(params: any, callback?: (err: any, data: any) => void): Request;

      /**
      * Creates a new item, or replaces an old item with a new item by
      * delegating to `AWS.DynamoDB.putItem()`.
      *
      * Supply the same parameters as {AWS.DynamoDB.putItem} with
      * `AttributeValue`s substituted by native JavaScript types.
      *
      * @see AWS.DynamoDB.putItem
      * @example Create a new item in a table
      *  var params = {
      *    TableName : 'Table',
      *    Item: {
      *       HashKey: 'haskey',
      *       NumAttribute: 1,
      *       BoolAttribute: true,
      *       ListAttribute: [1, 'two', false],
      *       MapAttribute: { foo: 'bar'},
      *       NullAttribute: null
      *    }
      *  };
      *
      *  var docClient = new AWS.DynamoDB.DocumentClient();
      *
      *  docClient.put(params, function(err, data) {
      *    if (err) console.log(err);
      *    else console.log(data);
      *  });
      *
      */
      put(params: any, callback?: (err: any, data: any) => void): Request;

      /**
      * Edits an existing item's attributes, or adds a new item to the table if
      * it does not already exist by delegating to `AWS.DynamoDB.updateItem()`.
      *
      * Supply the same parameters as {AWS.DynamoDB.updateItem} with
      * `AttributeValue`s substituted by native JavaScript types.
      *
      * @see AWS.DynamoDB.updateItem
      * @example Update an item with expressions
      *  var params = {
      *    TableName: 'Table',
      *    Key: { HashKey : 'hashkey' },
      *    UpdateExpression: 'set #a = :x + :y',
      *    ConditionExpression: '#a < :MAX',
      *    ExpressionAttributeNames: {'#a' : 'Sum'},
      *    ExpressionAttributeValues: {
      *      ':x' : 20,
      *      ':y' : 45,
      *      ':MAX' : 100,
      *    }
      *  };
      *
      *  var docClient = new AWS.DynamoDB.DocumentClient();
      *
      *  docClient.update(params, function(err, data) {
      *     if (err) console.log(err);
      *     else console.log(data);
      *  });
      *
      */
      update(params: any, callback?: (err: any, data: any) => void): Request;

      /**
      * Returns one or more items and item attributes by accessing every item
      * in a table or a secondary index.
      *
      * Supply the same parameters as {AWS.DynamoDB.scan} with
      * `AttributeValue`s substituted by native JavaScript types.
      *
      * @see AWS.DynamoDB.scan
      * @example Scan the table with a filter expression
      *  var params = {
      *    TableName : 'Table',
      *    FilterExpression : 'Year = :this_year',
      *    ExpressionAttributeValues : {':this_year' : 2015}
      *  };
      *
      *  var docClient = new AWS.DynamoDB.DocumentClient();
      *
      *  docClient.scan(params, function(err, data) {
      *     if (err) console.log(err);
      *     else console.log(data);
      *  });
      *
      */
      scan(params: any, callback?: (err: any, data: any) => void): Request;

      /**
      * Directly access items from a table by primary key or a secondary index.
      *
      * Supply the same parameters as {AWS.DynamoDB.query} with
      * `AttributeValue`s substituted by native JavaScript types.
      *
      * @see AWS.DynamoDB.query
      * @example Query an index
      *  var params = {
      *    TableName: 'Table',
      *    IndexName: 'Index',
      *    KeyConditionExpression: 'HashKey = :hkey and RangeKey > :rkey',
      *    ExpressionAttributeValues: {
      *      ':hkey': 'key',
      *      ':rkey': 2015
      *    }
      *  };
      *
      *  var docClient = new AWS.DynamoDB.DocumentClient();
      *
      *  docClient.query(params, function(err, data) {
      *     if (err) console.log(err);
      *     else console.log(data);
      *  });
      *
      */
      query(params: any, callback?: (err: any, data: any) => void): Request;

      /**
      * Creates a set of elements inferring the type of set from
      * the type of the first element. Amazon DynamoDB currently supports
      * the number sets, string sets, and binary sets. For more information
      * about DynamoDB data types see the documentation on the
      * [Amazon DynamoDB Data Model](http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DataModel.html#DataModel.DataTypes).
      *
      * @param list [Array] Collection to represent your DynamoDB Set
      * @param options [map]
      *  * **validate** [Boolean] set to true if you want to validate the type
      *    of each element in the set. Defaults to `false`.
      * @example Creating a number set
      *  var docClient = new AWS.DynamoDB.DocumentClient();
      *
      *  var params = {
      *    Item: {
      *      hashkey: 'hashkey'
      *      numbers: docClient.createSet([1, 2, 3]);
      *    }
      *  };
      *
      *  docClient.put(params, function(err, data) {
      *    if (err) console.log(err);
      *    else console.log(data);
      *  });
      *
      */
      createSet(params: any, callback?: (err: any, data: any) => void): Request;
    }
  }  

  /*
   * apiVersion: 2015-12-08
   * endpointPrefix: acm
   * serviceAbbreviation: ACM
   * signatureVersion: v4
   * protocol: json
   */
  export class ACM extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    deleteCertificate(params: ACM.DeleteCertificateRequest, callback?: (err: ACM.ResourceNotFoundException|ACM.ResourceInUseException|ACM.InvalidArnException|any, data: any) => void): Request;
    describeCertificate(params: ACM.DescribeCertificateRequest, callback?: (err: ACM.ResourceNotFoundException|ACM.InvalidArnException|any, data: ACM.DescribeCertificateResponse|any) => void): Request;
    getCertificate(params: ACM.GetCertificateRequest, callback?: (err: ACM.ResourceNotFoundException|ACM.RequestInProgressException|ACM.InvalidArnException|any, data: ACM.GetCertificateResponse|any) => void): Request;
    listCertificates(params: ACM.ListCertificatesRequest, callback?: (err: any, data: ACM.ListCertificatesResponse|any) => void): Request;
    requestCertificate(params: ACM.RequestCertificateRequest, callback?: (err: ACM.LimitExceededException|ACM.InvalidDomainValidationOptionsException|any, data: ACM.RequestCertificateResponse|any) => void): Request;
    resendValidationEmail(params: ACM.ResendValidationEmailRequest, callback?: (err: ACM.ResourceNotFoundException|ACM.InvalidStateException|ACM.InvalidArnException|ACM.InvalidDomainValidationOptionsException|any, data: any) => void): Request;

  }

  export module ACM {
    export type Arn = string;    // pattern: &quot;arn:[\w+=/,.@-]+:[\w+=/,.@-]+:[\w+=/,.@-]*:[0-9]+:[\w+=,.@-]+(/[\w+=/,.@-]+)*&quot;, max: 2048, min: 20
    export type CertificateBody = string;    // pattern: &quot;-{5}BEGIN CERTIFICATE-{5}\u000D?\u000A([A-Za-z0-9/+]{64}\u000D?\u000A)*[A-Za-z0-9/+]{1,64}={0,2}\u000D?\u000A-{5}END CERTIFICATE-{5}(\u000D?\u000A)?&quot;, max: 524288, min: 1
    export type CertificateChain = string;    // pattern: &quot;(-{5}BEGIN CERTIFICATE-{5}\u000D?\u000A([A-Za-z0-9/+]{64}\u000D?\u000A)*[A-Za-z0-9/+]{1,64}={0,2}\u000D?\u000A-{5}END CERTIFICATE-{5}\u000D?\u000A)*-{5}BEGIN CERTIFICATE-{5}\u000D?\u000A([A-Za-z0-9/+]{64}\u000D?\u000A)*[A-Za-z0-9/+]{1,64}={0,2}\u000D?\u000A-{5}END CERTIFICATE-{5}(\u000D?\u000A)?&quot;, max: 2097152, min: 1
    export type CertificateStatus = string;
    export type CertificateStatuses = CertificateStatus[];
    export type CertificateSummaryList = CertificateSummary[];
    export type DomainList = DomainNameString[];    // max: 1000, min: 1
    export type DomainNameString = string;    // pattern: &quot;^(\*\.)?(((?!-)[A-Za-z0-9-]{0,62}[A-Za-z0-9])\.)+((?!-)[A-Za-z0-9-]{1,62}[A-Za-z0-9])$&quot;, max: 253, min: 1
    export type DomainValidationList = DomainValidation[];    // max: 1000, min: 1
    export type DomainValidationOptionList = DomainValidationOption[];    // max: 1000, min: 1
    export type IdempotencyToken = string;    // pattern: &quot;\w+&quot;, max: 32, min: 1
    export type InUseList = String[];
    export type KeyAlgorithm = string;
    export type MaxItems = number;    // max: 1000, min: 1
    export type NextToken = string;    // pattern: &quot;[\u0009\u000A\u000D\u0020-\u00FF]*&quot;, max: 320, min: 1
    export type RevocationReason = string;
    export type String = string;
    export type TStamp = number;
    export type ValidationEmailList = String[];

    export interface CertificateDetail {
        CertificateArn?: Arn;
        DomainName?: DomainNameString;
        SubjectAlternativeNames?: DomainList;
        DomainValidationOptions?: DomainValidationList;
        Serial?: String;
        Subject?: String;
        Issuer?: String;
        CreatedAt?: TStamp;
        IssuedAt?: TStamp;
        Status?: CertificateStatus;
        RevokedAt?: TStamp;
        RevocationReason?: RevocationReason;
        NotBefore?: TStamp;
        NotAfter?: TStamp;
        KeyAlgorithm?: KeyAlgorithm;
        SignatureAlgorithm?: String;
        InUseBy?: InUseList;
    }
    export interface CertificateSummary {
        CertificateArn?: Arn;
        DomainName?: DomainNameString;
    }
    export interface DeleteCertificateRequest {
        CertificateArn: Arn;
    }
    export interface DescribeCertificateRequest {
        CertificateArn: Arn;
    }
    export interface DescribeCertificateResponse {
        Certificate?: CertificateDetail;
    }
    export interface DomainValidation {
        DomainName: DomainNameString;
        ValidationEmails?: ValidationEmailList;
        ValidationDomain?: DomainNameString;
    }
    export interface DomainValidationOption {
        DomainName: DomainNameString;
        ValidationDomain: DomainNameString;
    }
    export interface GetCertificateRequest {
        CertificateArn: Arn;
    }
    export interface GetCertificateResponse {
        Certificate?: CertificateBody;
        CertificateChain?: CertificateChain;
    }
    export interface InvalidArnException {
        message?: String;
    }
    export interface InvalidDomainValidationOptionsException {
        message?: String;
    }
    export interface InvalidStateException {
        message?: String;
    }
    export interface LimitExceededException {
        message?: String;
    }
    export interface ListCertificatesRequest {
        CertificateStatuses?: CertificateStatuses;
        NextToken?: NextToken;
        MaxItems?: MaxItems;
    }
    export interface ListCertificatesResponse {
        NextToken?: NextToken;
        CertificateSummaryList?: CertificateSummaryList;
    }
    export interface RequestCertificateRequest {
        DomainName: DomainNameString;
        SubjectAlternativeNames?: DomainList;
        IdempotencyToken?: IdempotencyToken;
        DomainValidationOptions?: DomainValidationOptionList;
    }
    export interface RequestCertificateResponse {
        CertificateArn?: Arn;
    }
    export interface RequestInProgressException {
        message?: String;
    }
    export interface ResendValidationEmailRequest {
        CertificateArn: Arn;
        Domain: DomainNameString;
        ValidationDomain: DomainNameString;
    }
    export interface ResourceInUseException {
        message?: String;
    }
    export interface ResourceNotFoundException {
        message?: String;
    }
  }

  /*
   * apiVersion: 2015-07-09
   * endpointPrefix: apigateway
   * serviceAbbreviation: 
   * signatureVersion: v4
   * protocol: rest-json
   */
  export class APIGateway extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    createApiKey(params: APIGateway.CreateApiKeyRequest, callback?: (err: APIGateway.UnauthorizedException|APIGateway.NotFoundException|APIGateway.TooManyRequestsException|APIGateway.LimitExceededException|APIGateway.BadRequestException|any, data: APIGateway.ApiKey|any) => void): Request;
    createAuthorizer(params: APIGateway.CreateAuthorizerRequest, callback?: (err: APIGateway.BadRequestException|APIGateway.UnauthorizedException|APIGateway.NotFoundException|APIGateway.LimitExceededException|APIGateway.TooManyRequestsException|any, data: APIGateway.Authorizer|any) => void): Request;
    createBasePathMapping(params: APIGateway.CreateBasePathMappingRequest, callback?: (err: APIGateway.UnauthorizedException|APIGateway.ConflictException|APIGateway.BadRequestException|APIGateway.NotFoundException|APIGateway.TooManyRequestsException|any, data: APIGateway.BasePathMapping|any) => void): Request;
    createDeployment(params: APIGateway.CreateDeploymentRequest, callback?: (err: APIGateway.UnauthorizedException|APIGateway.BadRequestException|APIGateway.NotFoundException|APIGateway.ConflictException|APIGateway.LimitExceededException|APIGateway.TooManyRequestsException|APIGateway.ServiceUnavailableException|any, data: APIGateway.Deployment|any) => void): Request;
    createDomainName(params: APIGateway.CreateDomainNameRequest, callback?: (err: APIGateway.UnauthorizedException|APIGateway.BadRequestException|APIGateway.TooManyRequestsException|any, data: APIGateway.DomainName|any) => void): Request;
    createModel(params: APIGateway.CreateModelRequest, callback?: (err: APIGateway.BadRequestException|APIGateway.UnauthorizedException|APIGateway.NotFoundException|APIGateway.ConflictException|APIGateway.LimitExceededException|APIGateway.TooManyRequestsException|any, data: APIGateway.Model|any) => void): Request;
    createResource(params: APIGateway.CreateResourceRequest, callback?: (err: APIGateway.UnauthorizedException|APIGateway.NotFoundException|APIGateway.ConflictException|APIGateway.LimitExceededException|APIGateway.BadRequestException|APIGateway.TooManyRequestsException|any, data: APIGateway.Resource|any) => void): Request;
    createRestApi(params: APIGateway.CreateRestApiRequest, callback?: (err: APIGateway.UnauthorizedException|APIGateway.LimitExceededException|APIGateway.BadRequestException|APIGateway.TooManyRequestsException|any, data: APIGateway.RestApi|any) => void): Request;
    createStage(params: APIGateway.CreateStageRequest, callback?: (err: APIGateway.UnauthorizedException|APIGateway.BadRequestException|APIGateway.NotFoundException|APIGateway.ConflictException|APIGateway.LimitExceededException|APIGateway.TooManyRequestsException|any, data: APIGateway.Stage|any) => void): Request;
    deleteApiKey(params: APIGateway.DeleteApiKeyRequest, callback?: (err: APIGateway.UnauthorizedException|APIGateway.NotFoundException|APIGateway.TooManyRequestsException|any, data: any) => void): Request;
    deleteAuthorizer(params: APIGateway.DeleteAuthorizerRequest, callback?: (err: APIGateway.UnauthorizedException|APIGateway.NotFoundException|APIGateway.TooManyRequestsException|APIGateway.BadRequestException|APIGateway.ConflictException|any, data: any) => void): Request;
    deleteBasePathMapping(params: APIGateway.DeleteBasePathMappingRequest, callback?: (err: APIGateway.UnauthorizedException|APIGateway.NotFoundException|APIGateway.TooManyRequestsException|any, data: any) => void): Request;
    deleteClientCertificate(params: APIGateway.DeleteClientCertificateRequest, callback?: (err: APIGateway.UnauthorizedException|APIGateway.TooManyRequestsException|APIGateway.BadRequestException|APIGateway.NotFoundException|any, data: any) => void): Request;
    deleteDeployment(params: APIGateway.DeleteDeploymentRequest, callback?: (err: APIGateway.UnauthorizedException|APIGateway.NotFoundException|APIGateway.BadRequestException|APIGateway.TooManyRequestsException|any, data: any) => void): Request;
    deleteDomainName(params: APIGateway.DeleteDomainNameRequest, callback?: (err: APIGateway.UnauthorizedException|APIGateway.NotFoundException|APIGateway.TooManyRequestsException|any, data: any) => void): Request;
    deleteIntegration(params: APIGateway.DeleteIntegrationRequest, callback?: (err: APIGateway.UnauthorizedException|APIGateway.NotFoundException|APIGateway.TooManyRequestsException|any, data: any) => void): Request;
    deleteIntegrationResponse(params: APIGateway.DeleteIntegrationResponseRequest, callback?: (err: APIGateway.UnauthorizedException|APIGateway.NotFoundException|APIGateway.TooManyRequestsException|any, data: any) => void): Request;
    deleteMethod(params: APIGateway.DeleteMethodRequest, callback?: (err: APIGateway.UnauthorizedException|APIGateway.NotFoundException|APIGateway.TooManyRequestsException|any, data: any) => void): Request;
    deleteMethodResponse(params: APIGateway.DeleteMethodResponseRequest, callback?: (err: APIGateway.UnauthorizedException|APIGateway.NotFoundException|APIGateway.TooManyRequestsException|any, data: any) => void): Request;
    deleteModel(params: APIGateway.DeleteModelRequest, callback?: (err: APIGateway.UnauthorizedException|APIGateway.NotFoundException|APIGateway.TooManyRequestsException|APIGateway.BadRequestException|APIGateway.ConflictException|any, data: any) => void): Request;
    deleteResource(params: APIGateway.DeleteResourceRequest, callback?: (err: APIGateway.UnauthorizedException|APIGateway.NotFoundException|APIGateway.BadRequestException|APIGateway.TooManyRequestsException|any, data: any) => void): Request;
    deleteRestApi(params: APIGateway.DeleteRestApiRequest, callback?: (err: APIGateway.UnauthorizedException|APIGateway.NotFoundException|APIGateway.TooManyRequestsException|any, data: any) => void): Request;
    deleteStage(params: APIGateway.DeleteStageRequest, callback?: (err: APIGateway.UnauthorizedException|APIGateway.NotFoundException|APIGateway.TooManyRequestsException|any, data: any) => void): Request;
    flushStageAuthorizersCache(params: APIGateway.FlushStageAuthorizersCacheRequest, callback?: (err: APIGateway.UnauthorizedException|APIGateway.NotFoundException|APIGateway.BadRequestException|APIGateway.TooManyRequestsException|any, data: any) => void): Request;
    flushStageCache(params: APIGateway.FlushStageCacheRequest, callback?: (err: APIGateway.UnauthorizedException|APIGateway.NotFoundException|APIGateway.BadRequestException|APIGateway.TooManyRequestsException|any, data: any) => void): Request;
    generateClientCertificate(params: APIGateway.GenerateClientCertificateRequest, callback?: (err: APIGateway.UnauthorizedException|APIGateway.TooManyRequestsException|APIGateway.LimitExceededException|any, data: APIGateway.ClientCertificate|any) => void): Request;
    getAccount(params: APIGateway.GetAccountRequest, callback?: (err: APIGateway.UnauthorizedException|APIGateway.NotFoundException|APIGateway.TooManyRequestsException|any, data: APIGateway.Account|any) => void): Request;
    getApiKey(params: APIGateway.GetApiKeyRequest, callback?: (err: APIGateway.UnauthorizedException|APIGateway.NotFoundException|APIGateway.TooManyRequestsException|any, data: APIGateway.ApiKey|any) => void): Request;
    getApiKeys(params: APIGateway.GetApiKeysRequest, callback?: (err: APIGateway.BadRequestException|APIGateway.UnauthorizedException|APIGateway.TooManyRequestsException|any, data: APIGateway.ApiKeys|any) => void): Request;
    getAuthorizer(params: APIGateway.GetAuthorizerRequest, callback?: (err: APIGateway.UnauthorizedException|APIGateway.NotFoundException|APIGateway.TooManyRequestsException|any, data: APIGateway.Authorizer|any) => void): Request;
    getAuthorizers(params: APIGateway.GetAuthorizersRequest, callback?: (err: APIGateway.BadRequestException|APIGateway.UnauthorizedException|APIGateway.NotFoundException|APIGateway.TooManyRequestsException|any, data: APIGateway.Authorizers|any) => void): Request;
    getBasePathMapping(params: APIGateway.GetBasePathMappingRequest, callback?: (err: APIGateway.UnauthorizedException|APIGateway.NotFoundException|APIGateway.TooManyRequestsException|any, data: APIGateway.BasePathMapping|any) => void): Request;
    getBasePathMappings(params: APIGateway.GetBasePathMappingsRequest, callback?: (err: APIGateway.UnauthorizedException|APIGateway.NotFoundException|APIGateway.TooManyRequestsException|any, data: APIGateway.BasePathMappings|any) => void): Request;
    getClientCertificate(params: APIGateway.GetClientCertificateRequest, callback?: (err: APIGateway.UnauthorizedException|APIGateway.NotFoundException|APIGateway.TooManyRequestsException|any, data: APIGateway.ClientCertificate|any) => void): Request;
    getClientCertificates(params: APIGateway.GetClientCertificatesRequest, callback?: (err: APIGateway.BadRequestException|APIGateway.UnauthorizedException|APIGateway.TooManyRequestsException|any, data: APIGateway.ClientCertificates|any) => void): Request;
    getDeployment(params: APIGateway.GetDeploymentRequest, callback?: (err: APIGateway.UnauthorizedException|APIGateway.NotFoundException|APIGateway.TooManyRequestsException|APIGateway.ServiceUnavailableException|any, data: APIGateway.Deployment|any) => void): Request;
    getDeployments(params: APIGateway.GetDeploymentsRequest, callback?: (err: APIGateway.BadRequestException|APIGateway.UnauthorizedException|APIGateway.TooManyRequestsException|APIGateway.ServiceUnavailableException|any, data: APIGateway.Deployments|any) => void): Request;
    getDomainName(params: APIGateway.GetDomainNameRequest, callback?: (err: APIGateway.UnauthorizedException|APIGateway.NotFoundException|APIGateway.ServiceUnavailableException|APIGateway.TooManyRequestsException|any, data: APIGateway.DomainName|any) => void): Request;
    getDomainNames(params: APIGateway.GetDomainNamesRequest, callback?: (err: APIGateway.BadRequestException|APIGateway.UnauthorizedException|APIGateway.TooManyRequestsException|any, data: APIGateway.DomainNames|any) => void): Request;
    getExport(params: APIGateway.GetExportRequest, callback?: (err: APIGateway.UnauthorizedException|APIGateway.NotFoundException|APIGateway.BadRequestException|APIGateway.TooManyRequestsException|any, data: APIGateway.ExportResponse|any) => void): Request;
    getIntegration(params: APIGateway.GetIntegrationRequest, callback?: (err: APIGateway.UnauthorizedException|APIGateway.NotFoundException|APIGateway.TooManyRequestsException|any, data: APIGateway.Integration|any) => void): Request;
    getIntegrationResponse(params: APIGateway.GetIntegrationResponseRequest, callback?: (err: APIGateway.UnauthorizedException|APIGateway.NotFoundException|APIGateway.TooManyRequestsException|any, data: APIGateway.IntegrationResponse|any) => void): Request;
    getMethod(params: APIGateway.GetMethodRequest, callback?: (err: APIGateway.UnauthorizedException|APIGateway.NotFoundException|APIGateway.TooManyRequestsException|any, data: APIGateway.Method|any) => void): Request;
    getMethodResponse(params: APIGateway.GetMethodResponseRequest, callback?: (err: APIGateway.UnauthorizedException|APIGateway.NotFoundException|APIGateway.TooManyRequestsException|any, data: APIGateway.MethodResponse|any) => void): Request;
    getModel(params: APIGateway.GetModelRequest, callback?: (err: APIGateway.UnauthorizedException|APIGateway.NotFoundException|APIGateway.TooManyRequestsException|any, data: APIGateway.Model|any) => void): Request;
    getModelTemplate(params: APIGateway.GetModelTemplateRequest, callback?: (err: APIGateway.UnauthorizedException|APIGateway.NotFoundException|APIGateway.BadRequestException|APIGateway.TooManyRequestsException|any, data: APIGateway.Template|any) => void): Request;
    getModels(params: APIGateway.GetModelsRequest, callback?: (err: APIGateway.BadRequestException|APIGateway.UnauthorizedException|APIGateway.NotFoundException|APIGateway.TooManyRequestsException|any, data: APIGateway.Models|any) => void): Request;
    getResource(params: APIGateway.GetResourceRequest, callback?: (err: APIGateway.UnauthorizedException|APIGateway.NotFoundException|APIGateway.TooManyRequestsException|any, data: APIGateway.Resource|any) => void): Request;
    getResources(params: APIGateway.GetResourcesRequest, callback?: (err: APIGateway.BadRequestException|APIGateway.UnauthorizedException|APIGateway.NotFoundException|APIGateway.TooManyRequestsException|any, data: APIGateway.Resources|any) => void): Request;
    getRestApi(params: APIGateway.GetRestApiRequest, callback?: (err: APIGateway.UnauthorizedException|APIGateway.NotFoundException|APIGateway.TooManyRequestsException|any, data: APIGateway.RestApi|any) => void): Request;
    getRestApis(params: APIGateway.GetRestApisRequest, callback?: (err: APIGateway.BadRequestException|APIGateway.UnauthorizedException|APIGateway.TooManyRequestsException|any, data: APIGateway.RestApis|any) => void): Request;
    getSdk(params: APIGateway.GetSdkRequest, callback?: (err: APIGateway.UnauthorizedException|APIGateway.NotFoundException|APIGateway.BadRequestException|APIGateway.TooManyRequestsException|any, data: APIGateway.SdkResponse|any) => void): Request;
    getStage(params: APIGateway.GetStageRequest, callback?: (err: APIGateway.UnauthorizedException|APIGateway.NotFoundException|APIGateway.TooManyRequestsException|any, data: APIGateway.Stage|any) => void): Request;
    getStages(params: APIGateway.GetStagesRequest, callback?: (err: APIGateway.UnauthorizedException|APIGateway.NotFoundException|APIGateway.TooManyRequestsException|any, data: APIGateway.Stages|any) => void): Request;
    putIntegration(params: APIGateway.PutIntegrationRequest, callback?: (err: APIGateway.UnauthorizedException|APIGateway.BadRequestException|APIGateway.NotFoundException|APIGateway.TooManyRequestsException|any, data: APIGateway.Integration|any) => void): Request;
    putIntegrationResponse(params: APIGateway.PutIntegrationResponseRequest, callback?: (err: APIGateway.UnauthorizedException|APIGateway.NotFoundException|APIGateway.LimitExceededException|APIGateway.BadRequestException|APIGateway.TooManyRequestsException|any, data: APIGateway.IntegrationResponse|any) => void): Request;
    putMethod(params: APIGateway.PutMethodRequest, callback?: (err: APIGateway.BadRequestException|APIGateway.UnauthorizedException|APIGateway.NotFoundException|APIGateway.ConflictException|APIGateway.LimitExceededException|APIGateway.TooManyRequestsException|any, data: APIGateway.Method|any) => void): Request;
    putMethodResponse(params: APIGateway.PutMethodResponseRequest, callback?: (err: APIGateway.UnauthorizedException|APIGateway.NotFoundException|APIGateway.ConflictException|APIGateway.LimitExceededException|APIGateway.BadRequestException|APIGateway.TooManyRequestsException|any, data: APIGateway.MethodResponse|any) => void): Request;
    testInvokeAuthorizer(params: APIGateway.TestInvokeAuthorizerRequest, callback?: (err: APIGateway.BadRequestException|APIGateway.UnauthorizedException|APIGateway.NotFoundException|APIGateway.TooManyRequestsException|any, data: APIGateway.TestInvokeAuthorizerResponse|any) => void): Request;
    testInvokeMethod(params: APIGateway.TestInvokeMethodRequest, callback?: (err: APIGateway.BadRequestException|APIGateway.UnauthorizedException|APIGateway.NotFoundException|APIGateway.TooManyRequestsException|any, data: APIGateway.TestInvokeMethodResponse|any) => void): Request;
    updateAccount(params: APIGateway.UpdateAccountRequest, callback?: (err: APIGateway.UnauthorizedException|APIGateway.BadRequestException|APIGateway.NotFoundException|APIGateway.TooManyRequestsException|any, data: APIGateway.Account|any) => void): Request;
    updateApiKey(params: APIGateway.UpdateApiKeyRequest, callback?: (err: APIGateway.UnauthorizedException|APIGateway.NotFoundException|APIGateway.BadRequestException|APIGateway.TooManyRequestsException|any, data: APIGateway.ApiKey|any) => void): Request;
    updateAuthorizer(params: APIGateway.UpdateAuthorizerRequest, callback?: (err: APIGateway.UnauthorizedException|APIGateway.NotFoundException|APIGateway.BadRequestException|APIGateway.TooManyRequestsException|any, data: APIGateway.Authorizer|any) => void): Request;
    updateBasePathMapping(params: APIGateway.UpdateBasePathMappingRequest, callback?: (err: APIGateway.UnauthorizedException|APIGateway.NotFoundException|APIGateway.ConflictException|APIGateway.BadRequestException|APIGateway.TooManyRequestsException|any, data: APIGateway.BasePathMapping|any) => void): Request;
    updateClientCertificate(params: APIGateway.UpdateClientCertificateRequest, callback?: (err: APIGateway.UnauthorizedException|APIGateway.TooManyRequestsException|APIGateway.BadRequestException|APIGateway.NotFoundException|any, data: APIGateway.ClientCertificate|any) => void): Request;
    updateDeployment(params: APIGateway.UpdateDeploymentRequest, callback?: (err: APIGateway.UnauthorizedException|APIGateway.NotFoundException|APIGateway.BadRequestException|APIGateway.TooManyRequestsException|APIGateway.ServiceUnavailableException|any, data: APIGateway.Deployment|any) => void): Request;
    updateDomainName(params: APIGateway.UpdateDomainNameRequest, callback?: (err: APIGateway.UnauthorizedException|APIGateway.NotFoundException|APIGateway.BadRequestException|APIGateway.TooManyRequestsException|any, data: APIGateway.DomainName|any) => void): Request;
    updateIntegration(params: APIGateway.UpdateIntegrationRequest, callback?: (err: APIGateway.UnauthorizedException|APIGateway.NotFoundException|APIGateway.BadRequestException|APIGateway.TooManyRequestsException|any, data: APIGateway.Integration|any) => void): Request;
    updateIntegrationResponse(params: APIGateway.UpdateIntegrationResponseRequest, callback?: (err: APIGateway.UnauthorizedException|APIGateway.NotFoundException|APIGateway.BadRequestException|APIGateway.TooManyRequestsException|any, data: APIGateway.IntegrationResponse|any) => void): Request;
    updateMethod(params: APIGateway.UpdateMethodRequest, callback?: (err: APIGateway.UnauthorizedException|APIGateway.NotFoundException|APIGateway.BadRequestException|APIGateway.TooManyRequestsException|any, data: APIGateway.Method|any) => void): Request;
    updateMethodResponse(params: APIGateway.UpdateMethodResponseRequest, callback?: (err: APIGateway.UnauthorizedException|APIGateway.NotFoundException|APIGateway.ConflictException|APIGateway.LimitExceededException|APIGateway.BadRequestException|APIGateway.TooManyRequestsException|any, data: APIGateway.MethodResponse|any) => void): Request;
    updateModel(params: APIGateway.UpdateModelRequest, callback?: (err: APIGateway.UnauthorizedException|APIGateway.NotFoundException|APIGateway.BadRequestException|APIGateway.TooManyRequestsException|any, data: APIGateway.Model|any) => void): Request;
    updateResource(params: APIGateway.UpdateResourceRequest, callback?: (err: APIGateway.UnauthorizedException|APIGateway.NotFoundException|APIGateway.ConflictException|APIGateway.BadRequestException|APIGateway.TooManyRequestsException|any, data: APIGateway.Resource|any) => void): Request;
    updateRestApi(params: APIGateway.UpdateRestApiRequest, callback?: (err: APIGateway.UnauthorizedException|APIGateway.NotFoundException|APIGateway.ConflictException|APIGateway.BadRequestException|APIGateway.TooManyRequestsException|any, data: APIGateway.RestApi|any) => void): Request;
    updateStage(params: APIGateway.UpdateStageRequest, callback?: (err: APIGateway.UnauthorizedException|APIGateway.NotFoundException|APIGateway.ConflictException|APIGateway.BadRequestException|APIGateway.TooManyRequestsException|any, data: APIGateway.Stage|any) => void): Request;

  }

  export module APIGateway {
    export type AuthorizerType = string;
    export type Blob = any;    // type: blob
    export type Boolean = boolean;
    export type CacheClusterSize = string;
    export type CacheClusterStatus = string;
    export type Double = number;
    export type Integer = number;
    export type IntegrationType = string;
    export type ListOfApiKey = ApiKey[];
    export type ListOfAuthorizer = Authorizer[];
    export type ListOfBasePathMapping = BasePathMapping[];
    export type ListOfClientCertificate = ClientCertificate[];
    export type ListOfDeployment = Deployment[];
    export type ListOfDomainName = DomainName[];
    export type ListOfModel = Model[];
    export type ListOfPatchOperation = PatchOperation[];
    export type ListOfResource = Resource[];
    export type ListOfRestApi = RestApi[];
    export type ListOfStage = Stage[];
    export type ListOfStageKeys = StageKey[];
    export type ListOfString = String[];
    export type Long = number;
    export type MapOfHeaderValues = {[key:string]: String};
    export type MapOfIntegrationResponse = {[key:string]: IntegrationResponse};
    export type MapOfMethod = {[key:string]: Method};
    export type MapOfMethodResponse = {[key:string]: MethodResponse};
    export type MapOfMethodSettings = {[key:string]: MethodSetting};
    export type MapOfMethodSnapshot = {[key:string]: MethodSnapshot};
    export type MapOfStringToBoolean = {[key:string]: NullableBoolean};
    export type MapOfStringToList = {[key:string]: ListOfString};
    export type MapOfStringToString = {[key:string]: String};
    export type NullableBoolean = boolean;
    export type NullableInteger = number;
    export type PathToMapOfMethodSnapshot = {[key:string]: MapOfMethodSnapshot};
    export type StatusCode = string;    // pattern: &quot;[1-5]\d\d&quot;
    export type String = string;
    export type Timestamp = number;
    export type UnauthorizedCacheControlHeaderStrategy = string;
    export type op = string;

    export interface Account {
        cloudwatchRoleArn?: String;
        throttleSettings?: ThrottleSettings;
    }
    export interface ApiKey {
        id?: String;
        name?: String;
        description?: String;
        enabled?: Boolean;
        stageKeys?: ListOfString;
        createdDate?: Timestamp;
        lastUpdatedDate?: Timestamp;
    }
    export interface ApiKeys {
        position?: String;
        items?: ListOfApiKey;
    }
    export interface Authorizer {
        id?: String;
        name?: String;
        type?: AuthorizerType;
        authorizerUri?: String;
        authorizerCredentials?: String;
        identitySource?: String;
        identityValidationExpression?: String;
        authorizerResultTtlInSeconds?: NullableInteger;
    }
    export interface Authorizers {
        position?: String;
        items?: ListOfAuthorizer;
    }
    export interface BadRequestException {
        message?: String;
    }
    export interface BasePathMapping {
        basePath?: String;
        restApiId?: String;
        stage?: String;
    }
    export interface BasePathMappings {
        position?: String;
        items?: ListOfBasePathMapping;
    }
    export interface ClientCertificate {
        clientCertificateId?: String;
        description?: String;
        pemEncodedCertificate?: String;
        createdDate?: Timestamp;
        expirationDate?: Timestamp;
    }
    export interface ClientCertificates {
        position?: String;
        items?: ListOfClientCertificate;
    }
    export interface ConflictException {
        message?: String;
    }
    export interface CreateApiKeyRequest {
        name?: String;
        description?: String;
        enabled?: Boolean;
        stageKeys?: ListOfStageKeys;
    }
    export interface CreateAuthorizerRequest {
        restApiId: String;
        name: String;
        type: AuthorizerType;
        authorizerUri: String;
        authorizerCredentials?: String;
        identitySource: String;
        identityValidationExpression?: String;
        authorizerResultTtlInSeconds?: NullableInteger;
    }
    export interface CreateBasePathMappingRequest {
        domainName: String;
        basePath?: String;
        restApiId: String;
        stage?: String;
    }
    export interface CreateDeploymentRequest {
        restApiId: String;
        stageName: String;
        stageDescription?: String;
        description?: String;
        cacheClusterEnabled?: NullableBoolean;
        cacheClusterSize?: CacheClusterSize;
        variables?: MapOfStringToString;
    }
    export interface CreateDomainNameRequest {
        domainName: String;
        certificateName: String;
        certificateBody: String;
        certificatePrivateKey: String;
        certificateChain: String;
    }
    export interface CreateModelRequest {
        restApiId: String;
        name: String;
        description?: String;
        schema?: String;
        contentType: String;
    }
    export interface CreateResourceRequest {
        restApiId: String;
        parentId: String;
        pathPart: String;
    }
    export interface CreateRestApiRequest {
        name: String;
        description?: String;
        cloneFrom?: String;
    }
    export interface CreateStageRequest {
        restApiId: String;
        stageName: String;
        deploymentId: String;
        description?: String;
        cacheClusterEnabled?: Boolean;
        cacheClusterSize?: CacheClusterSize;
        variables?: MapOfStringToString;
    }
    export interface DeleteApiKeyRequest {
        apiKey: String;
    }
    export interface DeleteAuthorizerRequest {
        restApiId: String;
        authorizerId: String;
    }
    export interface DeleteBasePathMappingRequest {
        domainName: String;
        basePath: String;
    }
    export interface DeleteClientCertificateRequest {
        clientCertificateId: String;
    }
    export interface DeleteDeploymentRequest {
        restApiId: String;
        deploymentId: String;
    }
    export interface DeleteDomainNameRequest {
        domainName: String;
    }
    export interface DeleteIntegrationRequest {
        restApiId: String;
        resourceId: String;
        httpMethod: String;
    }
    export interface DeleteIntegrationResponseRequest {
        restApiId: String;
        resourceId: String;
        httpMethod: String;
        statusCode: StatusCode;
    }
    export interface DeleteMethodRequest {
        restApiId: String;
        resourceId: String;
        httpMethod: String;
    }
    export interface DeleteMethodResponseRequest {
        restApiId: String;
        resourceId: String;
        httpMethod: String;
        statusCode: StatusCode;
    }
    export interface DeleteModelRequest {
        restApiId: String;
        modelName: String;
    }
    export interface DeleteResourceRequest {
        restApiId: String;
        resourceId: String;
    }
    export interface DeleteRestApiRequest {
        restApiId: String;
    }
    export interface DeleteStageRequest {
        restApiId: String;
        stageName: String;
    }
    export interface Deployment {
        id?: String;
        description?: String;
        createdDate?: Timestamp;
        apiSummary?: PathToMapOfMethodSnapshot;
    }
    export interface Deployments {
        position?: String;
        items?: ListOfDeployment;
    }
    export interface DomainName {
        domainName?: String;
        certificateName?: String;
        certificateUploadDate?: Timestamp;
        distributionDomainName?: String;
    }
    export interface DomainNames {
        position?: String;
        items?: ListOfDomainName;
    }
    export interface ExportResponse {
        contentType?: String;
        contentDisposition?: String;
        body?: Blob;
    }
    export interface FlushStageAuthorizersCacheRequest {
        restApiId: String;
        stageName: String;
    }
    export interface FlushStageCacheRequest {
        restApiId: String;
        stageName: String;
    }
    export interface GenerateClientCertificateRequest {
        description?: String;
    }
    export interface GetAccountRequest {
    }
    export interface GetApiKeyRequest {
        apiKey: String;
    }
    export interface GetApiKeysRequest {
        position?: String;
        limit?: NullableInteger;
    }
    export interface GetAuthorizerRequest {
        restApiId: String;
        authorizerId: String;
    }
    export interface GetAuthorizersRequest {
        restApiId: String;
        position?: String;
        limit?: NullableInteger;
    }
    export interface GetBasePathMappingRequest {
        domainName: String;
        basePath: String;
    }
    export interface GetBasePathMappingsRequest {
        domainName: String;
        position?: String;
        limit?: NullableInteger;
    }
    export interface GetClientCertificateRequest {
        clientCertificateId: String;
    }
    export interface GetClientCertificatesRequest {
        position?: String;
        limit?: NullableInteger;
    }
    export interface GetDeploymentRequest {
        restApiId: String;
        deploymentId: String;
    }
    export interface GetDeploymentsRequest {
        restApiId: String;
        position?: String;
        limit?: NullableInteger;
    }
    export interface GetDomainNameRequest {
        domainName: String;
    }
    export interface GetDomainNamesRequest {
        position?: String;
        limit?: NullableInteger;
    }
    export interface GetExportRequest {
        restApiId: String;
        stageName: String;
        exportType: String;
        parameters?: MapOfStringToString;
        accepts?: String;
    }
    export interface GetIntegrationRequest {
        restApiId: String;
        resourceId: String;
        httpMethod: String;
    }
    export interface GetIntegrationResponseRequest {
        restApiId: String;
        resourceId: String;
        httpMethod: String;
        statusCode: StatusCode;
    }
    export interface GetMethodRequest {
        restApiId: String;
        resourceId: String;
        httpMethod: String;
    }
    export interface GetMethodResponseRequest {
        restApiId: String;
        resourceId: String;
        httpMethod: String;
        statusCode: StatusCode;
    }
    export interface GetModelRequest {
        restApiId: String;
        modelName: String;
        flatten?: Boolean;
    }
    export interface GetModelTemplateRequest {
        restApiId: String;
        modelName: String;
    }
    export interface GetModelsRequest {
        restApiId: String;
        position?: String;
        limit?: NullableInteger;
    }
    export interface GetResourceRequest {
        restApiId: String;
        resourceId: String;
    }
    export interface GetResourcesRequest {
        restApiId: String;
        position?: String;
        limit?: NullableInteger;
    }
    export interface GetRestApiRequest {
        restApiId: String;
    }
    export interface GetRestApisRequest {
        position?: String;
        limit?: NullableInteger;
    }
    export interface GetSdkRequest {
        restApiId: String;
        stageName: String;
        sdkType: String;
        parameters?: MapOfStringToString;
    }
    export interface GetStageRequest {
        restApiId: String;
        stageName: String;
    }
    export interface GetStagesRequest {
        restApiId: String;
        deploymentId?: String;
    }
    export interface Integration {
        type?: IntegrationType;
        httpMethod?: String;
        uri?: String;
        credentials?: String;
        requestParameters?: MapOfStringToString;
        requestTemplates?: MapOfStringToString;
        cacheNamespace?: String;
        cacheKeyParameters?: ListOfString;
        integrationResponses?: MapOfIntegrationResponse;
    }
    export interface IntegrationResponse {
        statusCode?: StatusCode;
        selectionPattern?: String;
        responseParameters?: MapOfStringToString;
        responseTemplates?: MapOfStringToString;
    }
    export interface LimitExceededException {
        retryAfterSeconds?: String;
        message?: String;
    }
    export interface Method {
        httpMethod?: String;
        authorizationType?: String;
        authorizerId?: String;
        apiKeyRequired?: NullableBoolean;
        requestParameters?: MapOfStringToBoolean;
        requestModels?: MapOfStringToString;
        methodResponses?: MapOfMethodResponse;
        methodIntegration?: Integration;
    }
    export interface MethodResponse {
        statusCode?: StatusCode;
        responseParameters?: MapOfStringToBoolean;
        responseModels?: MapOfStringToString;
    }
    export interface MethodSetting {
        metricsEnabled?: Boolean;
        loggingLevel?: String;
        dataTraceEnabled?: Boolean;
        throttlingBurstLimit?: Integer;
        throttlingRateLimit?: Double;
        cachingEnabled?: Boolean;
        cacheTtlInSeconds?: Integer;
        cacheDataEncrypted?: Boolean;
        requireAuthorizationForCacheControl?: Boolean;
        unauthorizedCacheControlHeaderStrategy?: UnauthorizedCacheControlHeaderStrategy;
    }
    export interface MethodSnapshot {
        authorizationType?: String;
        apiKeyRequired?: Boolean;
    }
    export interface Model {
        id?: String;
        name?: String;
        description?: String;
        schema?: String;
        contentType?: String;
    }
    export interface Models {
        position?: String;
        items?: ListOfModel;
    }
    export interface NotFoundException {
        message?: String;
    }
    export interface PatchOperation {
        op?: op;
        path?: String;
        value?: String;
        from?: String;
    }
    export interface PutIntegrationRequest {
        restApiId: String;
        resourceId: String;
        httpMethod: String;
        type: IntegrationType;
        integrationHttpMethod?: String;
        uri?: String;
        credentials?: String;
        requestParameters?: MapOfStringToString;
        requestTemplates?: MapOfStringToString;
        cacheNamespace?: String;
        cacheKeyParameters?: ListOfString;
    }
    export interface PutIntegrationResponseRequest {
        restApiId: String;
        resourceId: String;
        httpMethod: String;
        statusCode: StatusCode;
        selectionPattern?: String;
        responseParameters?: MapOfStringToString;
        responseTemplates?: MapOfStringToString;
    }
    export interface PutMethodRequest {
        restApiId: String;
        resourceId: String;
        httpMethod: String;
        authorizationType: String;
        authorizerId?: String;
        apiKeyRequired?: Boolean;
        requestParameters?: MapOfStringToBoolean;
        requestModels?: MapOfStringToString;
    }
    export interface PutMethodResponseRequest {
        restApiId: String;
        resourceId: String;
        httpMethod: String;
        statusCode: StatusCode;
        responseParameters?: MapOfStringToBoolean;
        responseModels?: MapOfStringToString;
    }
    export interface Resource {
        id?: String;
        parentId?: String;
        pathPart?: String;
        path?: String;
        resourceMethods?: MapOfMethod;
    }
    export interface Resources {
        position?: String;
        items?: ListOfResource;
    }
    export interface RestApi {
        id?: String;
        name?: String;
        description?: String;
        createdDate?: Timestamp;
    }
    export interface RestApis {
        position?: String;
        items?: ListOfRestApi;
    }
    export interface SdkResponse {
        contentType?: String;
        contentDisposition?: String;
        body?: Blob;
    }
    export interface ServiceUnavailableException {
        retryAfterSeconds?: String;
        message?: String;
    }
    export interface Stage {
        deploymentId?: String;
        clientCertificateId?: String;
        stageName?: String;
        description?: String;
        cacheClusterEnabled?: Boolean;
        cacheClusterSize?: CacheClusterSize;
        cacheClusterStatus?: CacheClusterStatus;
        methodSettings?: MapOfMethodSettings;
        variables?: MapOfStringToString;
        createdDate?: Timestamp;
        lastUpdatedDate?: Timestamp;
    }
    export interface StageKey {
        restApiId?: String;
        stageName?: String;
    }
    export interface Stages {
        item?: ListOfStage;
    }
    export interface Template {
        value?: String;
    }
    export interface TestInvokeAuthorizerRequest {
        restApiId: String;
        authorizerId: String;
        headers?: MapOfHeaderValues;
        pathWithQueryString?: String;
        body?: String;
        stageVariables?: MapOfStringToString;
        additionalContext?: MapOfStringToString;
    }
    export interface TestInvokeAuthorizerResponse {
        clientStatus?: Integer;
        log?: String;
        latency?: Long;
        principalId?: String;
        policy?: String;
        authorization?: MapOfStringToList;
    }
    export interface TestInvokeMethodRequest {
        restApiId: String;
        resourceId: String;
        httpMethod: String;
        pathWithQueryString?: String;
        body?: String;
        headers?: MapOfHeaderValues;
        clientCertificateId?: String;
        stageVariables?: MapOfStringToString;
    }
    export interface TestInvokeMethodResponse {
        status?: Integer;
        body?: String;
        headers?: MapOfHeaderValues;
        log?: String;
        latency?: Long;
    }
    export interface ThrottleSettings {
        burstLimit?: Integer;
        rateLimit?: Double;
    }
    export interface TooManyRequestsException {
        retryAfterSeconds?: String;
        message?: String;
    }
    export interface UnauthorizedException {
        message?: String;
    }
    export interface UpdateAccountRequest {
        patchOperations?: ListOfPatchOperation;
    }
    export interface UpdateApiKeyRequest {
        apiKey: String;
        patchOperations?: ListOfPatchOperation;
    }
    export interface UpdateAuthorizerRequest {
        restApiId: String;
        authorizerId: String;
        patchOperations?: ListOfPatchOperation;
    }
    export interface UpdateBasePathMappingRequest {
        domainName: String;
        basePath: String;
        patchOperations?: ListOfPatchOperation;
    }
    export interface UpdateClientCertificateRequest {
        clientCertificateId: String;
        patchOperations?: ListOfPatchOperation;
    }
    export interface UpdateDeploymentRequest {
        restApiId: String;
        deploymentId: String;
        patchOperations?: ListOfPatchOperation;
    }
    export interface UpdateDomainNameRequest {
        domainName: String;
        patchOperations?: ListOfPatchOperation;
    }
    export interface UpdateIntegrationRequest {
        restApiId: String;
        resourceId: String;
        httpMethod: String;
        patchOperations?: ListOfPatchOperation;
    }
    export interface UpdateIntegrationResponseRequest {
        restApiId: String;
        resourceId: String;
        httpMethod: String;
        statusCode: StatusCode;
        patchOperations?: ListOfPatchOperation;
    }
    export interface UpdateMethodRequest {
        restApiId: String;
        resourceId: String;
        httpMethod: String;
        patchOperations?: ListOfPatchOperation;
    }
    export interface UpdateMethodResponseRequest {
        restApiId: String;
        resourceId: String;
        httpMethod: String;
        statusCode: StatusCode;
        patchOperations?: ListOfPatchOperation;
    }
    export interface UpdateModelRequest {
        restApiId: String;
        modelName: String;
        patchOperations?: ListOfPatchOperation;
    }
    export interface UpdateResourceRequest {
        restApiId: String;
        resourceId: String;
        patchOperations?: ListOfPatchOperation;
    }
    export interface UpdateRestApiRequest {
        restApiId: String;
        patchOperations?: ListOfPatchOperation;
    }
    export interface UpdateStageRequest {
        restApiId: String;
        stageName: String;
        patchOperations?: ListOfPatchOperation;
    }
  }

  /*
   * apiVersion: 2011-01-01
   * endpointPrefix: autoscaling
   * serviceAbbreviation: 
   * signatureVersion: v4
   * protocol: query
   */
  export class AutoScaling extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    attachInstances(params: AutoScaling.AttachInstancesQuery, callback?: (err: AutoScaling.ResourceContentionFault|any, data: any) => void): Request;
    attachLoadBalancers(params: AutoScaling.AttachLoadBalancersType, callback?: (err: AutoScaling.ResourceContentionFault|any, data: AutoScaling.AttachLoadBalancersResultType|any) => void): Request;
    completeLifecycleAction(params: AutoScaling.CompleteLifecycleActionType, callback?: (err: AutoScaling.ResourceContentionFault|any, data: AutoScaling.CompleteLifecycleActionAnswer|any) => void): Request;
    createAutoScalingGroup(params: AutoScaling.CreateAutoScalingGroupType, callback?: (err: AutoScaling.AlreadyExistsFault|AutoScaling.LimitExceededFault|AutoScaling.ResourceContentionFault|any, data: any) => void): Request;
    createLaunchConfiguration(params: AutoScaling.CreateLaunchConfigurationType, callback?: (err: AutoScaling.AlreadyExistsFault|AutoScaling.LimitExceededFault|AutoScaling.ResourceContentionFault|any, data: any) => void): Request;
    createOrUpdateTags(params: AutoScaling.CreateOrUpdateTagsType, callback?: (err: AutoScaling.LimitExceededFault|AutoScaling.AlreadyExistsFault|AutoScaling.ResourceContentionFault|any, data: any) => void): Request;
    deleteAutoScalingGroup(params: AutoScaling.DeleteAutoScalingGroupType, callback?: (err: AutoScaling.ScalingActivityInProgressFault|AutoScaling.ResourceInUseFault|AutoScaling.ResourceContentionFault|any, data: any) => void): Request;
    deleteLaunchConfiguration(params: AutoScaling.LaunchConfigurationNameType, callback?: (err: AutoScaling.ResourceInUseFault|AutoScaling.ResourceContentionFault|any, data: any) => void): Request;
    deleteLifecycleHook(params: AutoScaling.DeleteLifecycleHookType, callback?: (err: AutoScaling.ResourceContentionFault|any, data: AutoScaling.DeleteLifecycleHookAnswer|any) => void): Request;
    deleteNotificationConfiguration(params: AutoScaling.DeleteNotificationConfigurationType, callback?: (err: AutoScaling.ResourceContentionFault|any, data: any) => void): Request;
    deletePolicy(params: AutoScaling.DeletePolicyType, callback?: (err: AutoScaling.ResourceContentionFault|any, data: any) => void): Request;
    deleteScheduledAction(params: AutoScaling.DeleteScheduledActionType, callback?: (err: AutoScaling.ResourceContentionFault|any, data: any) => void): Request;
    deleteTags(params: AutoScaling.DeleteTagsType, callback?: (err: AutoScaling.ResourceContentionFault|any, data: any) => void): Request;
    describeAccountLimits(callback?: (err: AutoScaling.ResourceContentionFault|any, data: AutoScaling.DescribeAccountLimitsAnswer|any) => void): Request;
    describeAdjustmentTypes(callback?: (err: AutoScaling.ResourceContentionFault|any, data: AutoScaling.DescribeAdjustmentTypesAnswer|any) => void): Request;
    describeAutoScalingGroups(params: AutoScaling.AutoScalingGroupNamesType, callback?: (err: AutoScaling.InvalidNextToken|AutoScaling.ResourceContentionFault|any, data: AutoScaling.AutoScalingGroupsType|any) => void): Request;
    describeAutoScalingInstances(params: AutoScaling.DescribeAutoScalingInstancesType, callback?: (err: AutoScaling.InvalidNextToken|AutoScaling.ResourceContentionFault|any, data: AutoScaling.AutoScalingInstancesType|any) => void): Request;
    describeAutoScalingNotificationTypes(callback?: (err: AutoScaling.ResourceContentionFault|any, data: AutoScaling.DescribeAutoScalingNotificationTypesAnswer|any) => void): Request;
    describeLaunchConfigurations(params: AutoScaling.LaunchConfigurationNamesType, callback?: (err: AutoScaling.InvalidNextToken|AutoScaling.ResourceContentionFault|any, data: AutoScaling.LaunchConfigurationsType|any) => void): Request;
    describeLifecycleHookTypes(callback?: (err: AutoScaling.ResourceContentionFault|any, data: AutoScaling.DescribeLifecycleHookTypesAnswer|any) => void): Request;
    describeLifecycleHooks(params: AutoScaling.DescribeLifecycleHooksType, callback?: (err: AutoScaling.ResourceContentionFault|any, data: AutoScaling.DescribeLifecycleHooksAnswer|any) => void): Request;
    describeLoadBalancers(params: AutoScaling.DescribeLoadBalancersRequest, callback?: (err: AutoScaling.ResourceContentionFault|any, data: AutoScaling.DescribeLoadBalancersResponse|any) => void): Request;
    describeMetricCollectionTypes(callback?: (err: AutoScaling.ResourceContentionFault|any, data: AutoScaling.DescribeMetricCollectionTypesAnswer|any) => void): Request;
    describeNotificationConfigurations(params: AutoScaling.DescribeNotificationConfigurationsType, callback?: (err: AutoScaling.InvalidNextToken|AutoScaling.ResourceContentionFault|any, data: AutoScaling.DescribeNotificationConfigurationsAnswer|any) => void): Request;
    describePolicies(params: AutoScaling.DescribePoliciesType, callback?: (err: AutoScaling.InvalidNextToken|AutoScaling.ResourceContentionFault|any, data: AutoScaling.PoliciesType|any) => void): Request;
    describeScalingActivities(params: AutoScaling.DescribeScalingActivitiesType, callback?: (err: AutoScaling.InvalidNextToken|AutoScaling.ResourceContentionFault|any, data: AutoScaling.ActivitiesType|any) => void): Request;
    describeScalingProcessTypes(callback?: (err: AutoScaling.ResourceContentionFault|any, data: AutoScaling.ProcessesType|any) => void): Request;
    describeScheduledActions(params: AutoScaling.DescribeScheduledActionsType, callback?: (err: AutoScaling.InvalidNextToken|AutoScaling.ResourceContentionFault|any, data: AutoScaling.ScheduledActionsType|any) => void): Request;
    describeTags(params: AutoScaling.DescribeTagsType, callback?: (err: AutoScaling.InvalidNextToken|AutoScaling.ResourceContentionFault|any, data: AutoScaling.TagsType|any) => void): Request;
    describeTerminationPolicyTypes(callback?: (err: AutoScaling.ResourceContentionFault|any, data: AutoScaling.DescribeTerminationPolicyTypesAnswer|any) => void): Request;
    detachInstances(params: AutoScaling.DetachInstancesQuery, callback?: (err: AutoScaling.ResourceContentionFault|any, data: AutoScaling.DetachInstancesAnswer|any) => void): Request;
    detachLoadBalancers(params: AutoScaling.DetachLoadBalancersType, callback?: (err: AutoScaling.ResourceContentionFault|any, data: AutoScaling.DetachLoadBalancersResultType|any) => void): Request;
    disableMetricsCollection(params: AutoScaling.DisableMetricsCollectionQuery, callback?: (err: AutoScaling.ResourceContentionFault|any, data: any) => void): Request;
    enableMetricsCollection(params: AutoScaling.EnableMetricsCollectionQuery, callback?: (err: AutoScaling.ResourceContentionFault|any, data: any) => void): Request;
    enterStandby(params: AutoScaling.EnterStandbyQuery, callback?: (err: AutoScaling.ResourceContentionFault|any, data: AutoScaling.EnterStandbyAnswer|any) => void): Request;
    executePolicy(params: AutoScaling.ExecutePolicyType, callback?: (err: AutoScaling.ScalingActivityInProgressFault|AutoScaling.ResourceContentionFault|any, data: any) => void): Request;
    exitStandby(params: AutoScaling.ExitStandbyQuery, callback?: (err: AutoScaling.ResourceContentionFault|any, data: AutoScaling.ExitStandbyAnswer|any) => void): Request;
    putLifecycleHook(params: AutoScaling.PutLifecycleHookType, callback?: (err: AutoScaling.LimitExceededFault|AutoScaling.ResourceContentionFault|any, data: AutoScaling.PutLifecycleHookAnswer|any) => void): Request;
    putNotificationConfiguration(params: AutoScaling.PutNotificationConfigurationType, callback?: (err: AutoScaling.LimitExceededFault|AutoScaling.ResourceContentionFault|any, data: any) => void): Request;
    putScalingPolicy(params: AutoScaling.PutScalingPolicyType, callback?: (err: AutoScaling.LimitExceededFault|AutoScaling.ResourceContentionFault|any, data: AutoScaling.PolicyARNType|any) => void): Request;
    putScheduledUpdateGroupAction(params: AutoScaling.PutScheduledUpdateGroupActionType, callback?: (err: AutoScaling.AlreadyExistsFault|AutoScaling.LimitExceededFault|AutoScaling.ResourceContentionFault|any, data: any) => void): Request;
    recordLifecycleActionHeartbeat(params: AutoScaling.RecordLifecycleActionHeartbeatType, callback?: (err: AutoScaling.ResourceContentionFault|any, data: AutoScaling.RecordLifecycleActionHeartbeatAnswer|any) => void): Request;
    resumeProcesses(params: AutoScaling.ScalingProcessQuery, callback?: (err: AutoScaling.ResourceInUseFault|AutoScaling.ResourceContentionFault|any, data: any) => void): Request;
    setDesiredCapacity(params: AutoScaling.SetDesiredCapacityType, callback?: (err: AutoScaling.ScalingActivityInProgressFault|AutoScaling.ResourceContentionFault|any, data: any) => void): Request;
    setInstanceHealth(params: AutoScaling.SetInstanceHealthQuery, callback?: (err: AutoScaling.ResourceContentionFault|any, data: any) => void): Request;
    setInstanceProtection(params: AutoScaling.SetInstanceProtectionQuery, callback?: (err: AutoScaling.LimitExceededFault|AutoScaling.ResourceContentionFault|any, data: AutoScaling.SetInstanceProtectionAnswer|any) => void): Request;
    suspendProcesses(params: AutoScaling.ScalingProcessQuery, callback?: (err: AutoScaling.ResourceInUseFault|AutoScaling.ResourceContentionFault|any, data: any) => void): Request;
    terminateInstanceInAutoScalingGroup(params: AutoScaling.TerminateInstanceInAutoScalingGroupType, callback?: (err: AutoScaling.ScalingActivityInProgressFault|AutoScaling.ResourceContentionFault|any, data: AutoScaling.ActivityType|any) => void): Request;
    updateAutoScalingGroup(params: AutoScaling.UpdateAutoScalingGroupType, callback?: (err: AutoScaling.ScalingActivityInProgressFault|AutoScaling.ResourceContentionFault|any, data: any) => void): Request;

  }

  export module AutoScaling {
    export type Activities = Activity[];
    export type ActivityIds = XmlString[];
    export type AdjustmentTypes = AdjustmentType[];
    export type Alarms = Alarm[];
    export type AsciiStringMaxLen255 = string;    // pattern: &quot;[A-Za-z0-9\-_\/]+&quot;, max: 255, min: 1
    export type AssociatePublicIpAddress = boolean;
    export type AutoScalingGroupDesiredCapacity = number;
    export type AutoScalingGroupMaxSize = number;
    export type AutoScalingGroupMinSize = number;
    export type AutoScalingGroupNames = ResourceName[];
    export type AutoScalingGroups = AutoScalingGroup[];
    export type AutoScalingInstances = AutoScalingInstanceDetails[];
    export type AutoScalingNotificationTypes = XmlStringMaxLen255[];
    export type AvailabilityZones = XmlStringMaxLen255[];    // min: 1
    export type BlockDeviceEbsDeleteOnTermination = boolean;
    export type BlockDeviceEbsEncrypted = boolean;
    export type BlockDeviceEbsIops = number;    // max: 20000, min: 100
    export type BlockDeviceEbsVolumeSize = number;    // max: 16384, min: 1
    export type BlockDeviceEbsVolumeType = string;    // max: 255, min: 1
    export type BlockDeviceMappings = BlockDeviceMapping[];
    export type ClassicLinkVPCSecurityGroups = XmlStringMaxLen255[];
    export type Cooldown = number;
    export type EbsOptimized = boolean;
    export type EnabledMetrics = EnabledMetric[];
    export type EstimatedInstanceWarmup = number;
    export type Filters = Filter[];
    export type ForceDelete = boolean;
    export type GlobalTimeout = number;
    export type HealthCheckGracePeriod = number;
    export type HeartbeatTimeout = number;
    export type HonorCooldown = boolean;
    export type InstanceIds = XmlStringMaxLen19[];
    export type InstanceProtected = boolean;
    export type Instances = Instance[];
    export type LaunchConfigurationNames = ResourceName[];
    export type LaunchConfigurations = LaunchConfiguration[];
    export type LifecycleActionResult = string;
    export type LifecycleActionToken = string;    // max: 36, min: 36
    export type LifecycleHookNames = AsciiStringMaxLen255[];
    export type LifecycleHooks = LifecycleHook[];
    export type LifecycleState = string;
    export type LifecycleTransition = string;
    export type LoadBalancerNames = XmlStringMaxLen255[];
    export type LoadBalancerStates = LoadBalancerState[];
    export type MaxNumberOfAutoScalingGroups = number;
    export type MaxNumberOfLaunchConfigurations = number;
    export type MaxRecords = number;
    export type MetricCollectionTypes = MetricCollectionType[];
    export type MetricGranularityTypes = MetricGranularityType[];
    export type MetricScale = number;
    export type Metrics = XmlStringMaxLen255[];
    export type MinAdjustmentMagnitude = number;
    export type MinAdjustmentStep = number;
    export type MonitoringEnabled = boolean;
    export type NoDevice = boolean;
    export type NotificationConfigurations = NotificationConfiguration[];
    export type NotificationTargetResourceName = string;    // pattern: &quot;[\u0020-\uD7FF\uE000-\uFFFD\uD800\uDC00-\uDBFF\uDFFF\r\n\t]*&quot;, max: 1600
    export type NumberOfAutoScalingGroups = number;
    export type NumberOfLaunchConfigurations = number;
    export type PolicyIncrement = number;
    export type PolicyNames = ResourceName[];
    export type PolicyTypes = XmlStringMaxLen64[];
    export type ProcessNames = XmlStringMaxLen255[];
    export type Processes = ProcessType[];
    export type Progress = number;
    export type PropagateAtLaunch = boolean;
    export type ProtectedFromScaleIn = boolean;
    export type ResourceName = string;    // pattern: &quot;[\u0020-\uD7FF\uE000-\uFFFD\uD800\uDC00-\uDBFF\uDFFF\r\n\t]*&quot;, max: 1600, min: 1
    export type ScalingActivityStatusCode = string;
    export type ScalingPolicies = ScalingPolicy[];
    export type ScheduledActionNames = ResourceName[];
    export type ScheduledUpdateGroupActions = ScheduledUpdateGroupAction[];
    export type SecurityGroups = XmlString[];
    export type ShouldDecrementDesiredCapacity = boolean;
    export type ShouldRespectGracePeriod = boolean;
    export type SpotPrice = string;    // max: 255, min: 1
    export type StepAdjustments = StepAdjustment[];
    export type SuspendedProcesses = SuspendedProcess[];
    export type TagDescriptionList = TagDescription[];
    export type TagKey = string;    // pattern: &quot;[\u0020-\uD7FF\uE000-\uFFFD\uD800\uDC00-\uDBFF\uDFFF\r\n\t]*&quot;, max: 128, min: 1
    export type TagValue = string;    // pattern: &quot;[\u0020-\uD7FF\uE000-\uFFFD\uD800\uDC00-\uDBFF\uDFFF\r\n\t]*&quot;, max: 256
    export type Tags = Tag[];
    export type TerminationPolicies = XmlStringMaxLen1600[];
    export type TimestampType = number;
    export type Values = XmlString[];
    export type XmlString = string;    // pattern: &quot;[\u0020-\uD7FF\uE000-\uFFFD\uD800\uDC00-\uDBFF\uDFFF\r\n\t]*&quot;
    export type XmlStringMaxLen1023 = string;    // pattern: &quot;[\u0020-\uD7FF\uE000-\uFFFD\uD800\uDC00-\uDBFF\uDFFF\r\n\t]*&quot;, max: 1023, min: 1
    export type XmlStringMaxLen1600 = string;    // pattern: &quot;[\u0020-\uD7FF\uE000-\uFFFD\uD800\uDC00-\uDBFF\uDFFF\r\n\t]*&quot;, max: 1600, min: 1
    export type XmlStringMaxLen19 = string;    // pattern: &quot;[\u0020-\uD7FF\uE000-\uFFFD\uD800\uDC00-\uDBFF\uDFFF\r\n\t]*&quot;, max: 19, min: 1
    export type XmlStringMaxLen255 = string;    // pattern: &quot;[\u0020-\uD7FF\uE000-\uFFFD\uD800\uDC00-\uDBFF\uDFFF\r\n\t]*&quot;, max: 255, min: 1
    export type XmlStringMaxLen32 = string;    // pattern: &quot;[\u0020-\uD7FF\uE000-\uFFFD\uD800\uDC00-\uDBFF\uDFFF\r\n\t]*&quot;, max: 32, min: 1
    export type XmlStringMaxLen64 = string;    // pattern: &quot;[\u0020-\uD7FF\uE000-\uFFFD\uD800\uDC00-\uDBFF\uDFFF\r\n\t]*&quot;, max: 64, min: 1
    export type XmlStringUserData = string;    // pattern: &quot;[\u0020-\uD7FF\uE000-\uFFFD\uD800\uDC00-\uDBFF\uDFFF\r\n\t]*&quot;, max: 21847

    export interface ActivitiesType {
        Activities: Activities;
        NextToken?: XmlString;
    }
    export interface Activity {
        ActivityId: XmlString;
        AutoScalingGroupName: XmlStringMaxLen255;
        Description?: XmlString;
        Cause: XmlStringMaxLen1023;
        StartTime: TimestampType;
        EndTime?: TimestampType;
        StatusCode: ScalingActivityStatusCode;
        StatusMessage?: XmlStringMaxLen255;
        Progress?: Progress;
        Details?: XmlString;
    }
    export interface ActivityType {
        Activity?: Activity;
    }
    export interface AdjustmentType {
        AdjustmentType?: XmlStringMaxLen255;
    }
    export interface Alarm {
        AlarmName?: XmlStringMaxLen255;
        AlarmARN?: ResourceName;
    }
    export interface AlreadyExistsFault {
        message?: XmlStringMaxLen255;
    }
    export interface AttachInstancesQuery {
        InstanceIds?: InstanceIds;
        AutoScalingGroupName: ResourceName;
    }
    export interface AttachLoadBalancersResultType {
    }
    export interface AttachLoadBalancersType {
        AutoScalingGroupName?: ResourceName;
        LoadBalancerNames?: LoadBalancerNames;
    }
    export interface AutoScalingGroup {
        AutoScalingGroupName: XmlStringMaxLen255;
        AutoScalingGroupARN?: ResourceName;
        LaunchConfigurationName?: XmlStringMaxLen255;
        MinSize: AutoScalingGroupMinSize;
        MaxSize: AutoScalingGroupMaxSize;
        DesiredCapacity: AutoScalingGroupDesiredCapacity;
        DefaultCooldown: Cooldown;
        AvailabilityZones: AvailabilityZones;
        LoadBalancerNames?: LoadBalancerNames;
        HealthCheckType: XmlStringMaxLen32;
        HealthCheckGracePeriod?: HealthCheckGracePeriod;
        Instances?: Instances;
        CreatedTime: TimestampType;
        SuspendedProcesses?: SuspendedProcesses;
        PlacementGroup?: XmlStringMaxLen255;
        VPCZoneIdentifier?: XmlStringMaxLen255;
        EnabledMetrics?: EnabledMetrics;
        Status?: XmlStringMaxLen255;
        Tags?: TagDescriptionList;
        TerminationPolicies?: TerminationPolicies;
        NewInstancesProtectedFromScaleIn?: InstanceProtected;
    }
    export interface AutoScalingGroupNamesType {
        AutoScalingGroupNames?: AutoScalingGroupNames;
        NextToken?: XmlString;
        MaxRecords?: MaxRecords;
    }
    export interface AutoScalingGroupsType {
        AutoScalingGroups: AutoScalingGroups;
        NextToken?: XmlString;
    }
    export interface AutoScalingInstanceDetails {
        InstanceId: XmlStringMaxLen19;
        AutoScalingGroupName: XmlStringMaxLen255;
        AvailabilityZone: XmlStringMaxLen255;
        LifecycleState: XmlStringMaxLen32;
        HealthStatus: XmlStringMaxLen32;
        LaunchConfigurationName: XmlStringMaxLen255;
        ProtectedFromScaleIn: InstanceProtected;
    }
    export interface AutoScalingInstancesType {
        AutoScalingInstances?: AutoScalingInstances;
        NextToken?: XmlString;
    }
    export interface BlockDeviceMapping {
        VirtualName?: XmlStringMaxLen255;
        DeviceName: XmlStringMaxLen255;
        Ebs?: Ebs;
        NoDevice?: NoDevice;
    }
    export interface CompleteLifecycleActionAnswer {
    }
    export interface CompleteLifecycleActionType {
        LifecycleHookName: AsciiStringMaxLen255;
        AutoScalingGroupName: ResourceName;
        LifecycleActionToken?: LifecycleActionToken;
        LifecycleActionResult: LifecycleActionResult;
        InstanceId?: XmlStringMaxLen19;
    }
    export interface CreateAutoScalingGroupType {
        AutoScalingGroupName: XmlStringMaxLen255;
        LaunchConfigurationName?: ResourceName;
        InstanceId?: XmlStringMaxLen19;
        MinSize: AutoScalingGroupMinSize;
        MaxSize: AutoScalingGroupMaxSize;
        DesiredCapacity?: AutoScalingGroupDesiredCapacity;
        DefaultCooldown?: Cooldown;
        AvailabilityZones?: AvailabilityZones;
        LoadBalancerNames?: LoadBalancerNames;
        HealthCheckType?: XmlStringMaxLen32;
        HealthCheckGracePeriod?: HealthCheckGracePeriod;
        PlacementGroup?: XmlStringMaxLen255;
        VPCZoneIdentifier?: XmlStringMaxLen255;
        TerminationPolicies?: TerminationPolicies;
        NewInstancesProtectedFromScaleIn?: InstanceProtected;
        Tags?: Tags;
    }
    export interface CreateLaunchConfigurationType {
        LaunchConfigurationName: XmlStringMaxLen255;
        ImageId?: XmlStringMaxLen255;
        KeyName?: XmlStringMaxLen255;
        SecurityGroups?: SecurityGroups;
        ClassicLinkVPCId?: XmlStringMaxLen255;
        ClassicLinkVPCSecurityGroups?: ClassicLinkVPCSecurityGroups;
        UserData?: XmlStringUserData;
        InstanceId?: XmlStringMaxLen19;
        InstanceType?: XmlStringMaxLen255;
        KernelId?: XmlStringMaxLen255;
        RamdiskId?: XmlStringMaxLen255;
        BlockDeviceMappings?: BlockDeviceMappings;
        InstanceMonitoring?: InstanceMonitoring;
        SpotPrice?: SpotPrice;
        IamInstanceProfile?: XmlStringMaxLen1600;
        EbsOptimized?: EbsOptimized;
        AssociatePublicIpAddress?: AssociatePublicIpAddress;
        PlacementTenancy?: XmlStringMaxLen64;
    }
    export interface CreateOrUpdateTagsType {
        Tags: Tags;
    }
    export interface DeleteAutoScalingGroupType {
        AutoScalingGroupName: ResourceName;
        ForceDelete?: ForceDelete;
    }
    export interface DeleteLifecycleHookAnswer {
    }
    export interface DeleteLifecycleHookType {
        LifecycleHookName: AsciiStringMaxLen255;
        AutoScalingGroupName: ResourceName;
    }
    export interface DeleteNotificationConfigurationType {
        AutoScalingGroupName: ResourceName;
        TopicARN: ResourceName;
    }
    export interface DeletePolicyType {
        AutoScalingGroupName?: ResourceName;
        PolicyName: ResourceName;
    }
    export interface DeleteScheduledActionType {
        AutoScalingGroupName?: ResourceName;
        ScheduledActionName: ResourceName;
    }
    export interface DeleteTagsType {
        Tags: Tags;
    }
    export interface DescribeAccountLimitsAnswer {
        MaxNumberOfAutoScalingGroups?: MaxNumberOfAutoScalingGroups;
        MaxNumberOfLaunchConfigurations?: MaxNumberOfLaunchConfigurations;
        NumberOfAutoScalingGroups?: NumberOfAutoScalingGroups;
        NumberOfLaunchConfigurations?: NumberOfLaunchConfigurations;
    }
    export interface DescribeAdjustmentTypesAnswer {
        AdjustmentTypes?: AdjustmentTypes;
    }
    export interface DescribeAutoScalingInstancesType {
        InstanceIds?: InstanceIds;
        MaxRecords?: MaxRecords;
        NextToken?: XmlString;
    }
    export interface DescribeAutoScalingNotificationTypesAnswer {
        AutoScalingNotificationTypes?: AutoScalingNotificationTypes;
    }
    export interface DescribeLifecycleHookTypesAnswer {
        LifecycleHookTypes?: AutoScalingNotificationTypes;
    }
    export interface DescribeLifecycleHooksAnswer {
        LifecycleHooks?: LifecycleHooks;
    }
    export interface DescribeLifecycleHooksType {
        AutoScalingGroupName: ResourceName;
        LifecycleHookNames?: LifecycleHookNames;
    }
    export interface DescribeLoadBalancersRequest {
        AutoScalingGroupName: ResourceName;
        NextToken?: XmlString;
        MaxRecords?: MaxRecords;
    }
    export interface DescribeLoadBalancersResponse {
        LoadBalancers?: LoadBalancerStates;
        NextToken?: XmlString;
    }
    export interface DescribeMetricCollectionTypesAnswer {
        Metrics?: MetricCollectionTypes;
        Granularities?: MetricGranularityTypes;
    }
    export interface DescribeNotificationConfigurationsAnswer {
        NotificationConfigurations: NotificationConfigurations;
        NextToken?: XmlString;
    }
    export interface DescribeNotificationConfigurationsType {
        AutoScalingGroupNames?: AutoScalingGroupNames;
        NextToken?: XmlString;
        MaxRecords?: MaxRecords;
    }
    export interface DescribePoliciesType {
        AutoScalingGroupName?: ResourceName;
        PolicyNames?: PolicyNames;
        PolicyTypes?: PolicyTypes;
        NextToken?: XmlString;
        MaxRecords?: MaxRecords;
    }
    export interface DescribeScalingActivitiesType {
        ActivityIds?: ActivityIds;
        AutoScalingGroupName?: ResourceName;
        MaxRecords?: MaxRecords;
        NextToken?: XmlString;
    }
    export interface DescribeScheduledActionsType {
        AutoScalingGroupName?: ResourceName;
        ScheduledActionNames?: ScheduledActionNames;
        StartTime?: TimestampType;
        EndTime?: TimestampType;
        NextToken?: XmlString;
        MaxRecords?: MaxRecords;
    }
    export interface DescribeTagsType {
        Filters?: Filters;
        NextToken?: XmlString;
        MaxRecords?: MaxRecords;
    }
    export interface DescribeTerminationPolicyTypesAnswer {
        TerminationPolicyTypes?: TerminationPolicies;
    }
    export interface DetachInstancesAnswer {
        Activities?: Activities;
    }
    export interface DetachInstancesQuery {
        InstanceIds?: InstanceIds;
        AutoScalingGroupName: ResourceName;
        ShouldDecrementDesiredCapacity: ShouldDecrementDesiredCapacity;
    }
    export interface DetachLoadBalancersResultType {
    }
    export interface DetachLoadBalancersType {
        AutoScalingGroupName?: ResourceName;
        LoadBalancerNames?: LoadBalancerNames;
    }
    export interface DisableMetricsCollectionQuery {
        AutoScalingGroupName: ResourceName;
        Metrics?: Metrics;
    }
    export interface Ebs {
        SnapshotId?: XmlStringMaxLen255;
        VolumeSize?: BlockDeviceEbsVolumeSize;
        VolumeType?: BlockDeviceEbsVolumeType;
        DeleteOnTermination?: BlockDeviceEbsDeleteOnTermination;
        Iops?: BlockDeviceEbsIops;
        Encrypted?: BlockDeviceEbsEncrypted;
    }
    export interface EnableMetricsCollectionQuery {
        AutoScalingGroupName: ResourceName;
        Metrics?: Metrics;
        Granularity: XmlStringMaxLen255;
    }
    export interface EnabledMetric {
        Metric?: XmlStringMaxLen255;
        Granularity?: XmlStringMaxLen255;
    }
    export interface EnterStandbyAnswer {
        Activities?: Activities;
    }
    export interface EnterStandbyQuery {
        InstanceIds?: InstanceIds;
        AutoScalingGroupName: ResourceName;
        ShouldDecrementDesiredCapacity: ShouldDecrementDesiredCapacity;
    }
    export interface ExecutePolicyType {
        AutoScalingGroupName?: ResourceName;
        PolicyName: ResourceName;
        HonorCooldown?: HonorCooldown;
        MetricValue?: MetricScale;
        BreachThreshold?: MetricScale;
    }
    export interface ExitStandbyAnswer {
        Activities?: Activities;
    }
    export interface ExitStandbyQuery {
        InstanceIds?: InstanceIds;
        AutoScalingGroupName: ResourceName;
    }
    export interface Filter {
        Name?: XmlString;
        Values?: Values;
    }
    export interface Instance {
        InstanceId: XmlStringMaxLen19;
        AvailabilityZone: XmlStringMaxLen255;
        LifecycleState: LifecycleState;
        HealthStatus: XmlStringMaxLen32;
        LaunchConfigurationName: XmlStringMaxLen255;
        ProtectedFromScaleIn: InstanceProtected;
    }
    export interface InstanceMonitoring {
        Enabled?: MonitoringEnabled;
    }
    export interface InvalidNextToken {
        message?: XmlStringMaxLen255;
    }
    export interface LaunchConfiguration {
        LaunchConfigurationName: XmlStringMaxLen255;
        LaunchConfigurationARN?: ResourceName;
        ImageId: XmlStringMaxLen255;
        KeyName?: XmlStringMaxLen255;
        SecurityGroups?: SecurityGroups;
        ClassicLinkVPCId?: XmlStringMaxLen255;
        ClassicLinkVPCSecurityGroups?: ClassicLinkVPCSecurityGroups;
        UserData?: XmlStringUserData;
        InstanceType: XmlStringMaxLen255;
        KernelId?: XmlStringMaxLen255;
        RamdiskId?: XmlStringMaxLen255;
        BlockDeviceMappings?: BlockDeviceMappings;
        InstanceMonitoring?: InstanceMonitoring;
        SpotPrice?: SpotPrice;
        IamInstanceProfile?: XmlStringMaxLen1600;
        CreatedTime: TimestampType;
        EbsOptimized?: EbsOptimized;
        AssociatePublicIpAddress?: AssociatePublicIpAddress;
        PlacementTenancy?: XmlStringMaxLen64;
    }
    export interface LaunchConfigurationNameType {
        LaunchConfigurationName: ResourceName;
    }
    export interface LaunchConfigurationNamesType {
        LaunchConfigurationNames?: LaunchConfigurationNames;
        NextToken?: XmlString;
        MaxRecords?: MaxRecords;
    }
    export interface LaunchConfigurationsType {
        LaunchConfigurations: LaunchConfigurations;
        NextToken?: XmlString;
    }
    export interface LifecycleHook {
        LifecycleHookName?: AsciiStringMaxLen255;
        AutoScalingGroupName?: ResourceName;
        LifecycleTransition?: LifecycleTransition;
        NotificationTargetARN?: ResourceName;
        RoleARN?: ResourceName;
        NotificationMetadata?: XmlStringMaxLen1023;
        HeartbeatTimeout?: HeartbeatTimeout;
        GlobalTimeout?: GlobalTimeout;
        DefaultResult?: LifecycleActionResult;
    }
    export interface LimitExceededFault {
        message?: XmlStringMaxLen255;
    }
    export interface LoadBalancerState {
        LoadBalancerName?: XmlStringMaxLen255;
        State?: XmlStringMaxLen255;
    }
    export interface MetricCollectionType {
        Metric?: XmlStringMaxLen255;
    }
    export interface MetricGranularityType {
        Granularity?: XmlStringMaxLen255;
    }
    export interface NotificationConfiguration {
        AutoScalingGroupName?: ResourceName;
        TopicARN?: ResourceName;
        NotificationType?: XmlStringMaxLen255;
    }
    export interface PoliciesType {
        ScalingPolicies?: ScalingPolicies;
        NextToken?: XmlString;
    }
    export interface PolicyARNType {
        PolicyARN?: ResourceName;
    }
    export interface ProcessType {
        ProcessName: XmlStringMaxLen255;
    }
    export interface ProcessesType {
        Processes?: Processes;
    }
    export interface PutLifecycleHookAnswer {
    }
    export interface PutLifecycleHookType {
        LifecycleHookName: AsciiStringMaxLen255;
        AutoScalingGroupName: ResourceName;
        LifecycleTransition?: LifecycleTransition;
        RoleARN?: ResourceName;
        NotificationTargetARN?: NotificationTargetResourceName;
        NotificationMetadata?: XmlStringMaxLen1023;
        HeartbeatTimeout?: HeartbeatTimeout;
        DefaultResult?: LifecycleActionResult;
    }
    export interface PutNotificationConfigurationType {
        AutoScalingGroupName: ResourceName;
        TopicARN: ResourceName;
        NotificationTypes: AutoScalingNotificationTypes;
    }
    export interface PutScalingPolicyType {
        AutoScalingGroupName: ResourceName;
        PolicyName: XmlStringMaxLen255;
        PolicyType?: XmlStringMaxLen64;
        AdjustmentType: XmlStringMaxLen255;
        MinAdjustmentStep?: MinAdjustmentStep;
        MinAdjustmentMagnitude?: MinAdjustmentMagnitude;
        ScalingAdjustment?: PolicyIncrement;
        Cooldown?: Cooldown;
        MetricAggregationType?: XmlStringMaxLen32;
        StepAdjustments?: StepAdjustments;
        EstimatedInstanceWarmup?: EstimatedInstanceWarmup;
    }
    export interface PutScheduledUpdateGroupActionType {
        AutoScalingGroupName: ResourceName;
        ScheduledActionName: XmlStringMaxLen255;
        Time?: TimestampType;
        StartTime?: TimestampType;
        EndTime?: TimestampType;
        Recurrence?: XmlStringMaxLen255;
        MinSize?: AutoScalingGroupMinSize;
        MaxSize?: AutoScalingGroupMaxSize;
        DesiredCapacity?: AutoScalingGroupDesiredCapacity;
    }
    export interface RecordLifecycleActionHeartbeatAnswer {
    }
    export interface RecordLifecycleActionHeartbeatType {
        LifecycleHookName: AsciiStringMaxLen255;
        AutoScalingGroupName: ResourceName;
        LifecycleActionToken?: LifecycleActionToken;
        InstanceId?: XmlStringMaxLen19;
    }
    export interface ResourceContentionFault {
        message?: XmlStringMaxLen255;
    }
    export interface ResourceInUseFault {
        message?: XmlStringMaxLen255;
    }
    export interface ScalingActivityInProgressFault {
        message?: XmlStringMaxLen255;
    }
    export interface ScalingPolicy {
        AutoScalingGroupName?: XmlStringMaxLen255;
        PolicyName?: XmlStringMaxLen255;
        PolicyARN?: ResourceName;
        PolicyType?: XmlStringMaxLen64;
        AdjustmentType?: XmlStringMaxLen255;
        MinAdjustmentStep?: MinAdjustmentStep;
        MinAdjustmentMagnitude?: MinAdjustmentMagnitude;
        ScalingAdjustment?: PolicyIncrement;
        Cooldown?: Cooldown;
        StepAdjustments?: StepAdjustments;
        MetricAggregationType?: XmlStringMaxLen32;
        EstimatedInstanceWarmup?: EstimatedInstanceWarmup;
        Alarms?: Alarms;
    }
    export interface ScalingProcessQuery {
        AutoScalingGroupName: ResourceName;
        ScalingProcesses?: ProcessNames;
    }
    export interface ScheduledActionsType {
        ScheduledUpdateGroupActions?: ScheduledUpdateGroupActions;
        NextToken?: XmlString;
    }
    export interface ScheduledUpdateGroupAction {
        AutoScalingGroupName?: XmlStringMaxLen255;
        ScheduledActionName?: XmlStringMaxLen255;
        ScheduledActionARN?: ResourceName;
        Time?: TimestampType;
        StartTime?: TimestampType;
        EndTime?: TimestampType;
        Recurrence?: XmlStringMaxLen255;
        MinSize?: AutoScalingGroupMinSize;
        MaxSize?: AutoScalingGroupMaxSize;
        DesiredCapacity?: AutoScalingGroupDesiredCapacity;
    }
    export interface SetDesiredCapacityType {
        AutoScalingGroupName: ResourceName;
        DesiredCapacity: AutoScalingGroupDesiredCapacity;
        HonorCooldown?: HonorCooldown;
    }
    export interface SetInstanceHealthQuery {
        InstanceId: XmlStringMaxLen19;
        HealthStatus: XmlStringMaxLen32;
        ShouldRespectGracePeriod?: ShouldRespectGracePeriod;
    }
    export interface SetInstanceProtectionAnswer {
    }
    export interface SetInstanceProtectionQuery {
        InstanceIds: InstanceIds;
        AutoScalingGroupName: ResourceName;
        ProtectedFromScaleIn: ProtectedFromScaleIn;
    }
    export interface StepAdjustment {
        MetricIntervalLowerBound?: MetricScale;
        MetricIntervalUpperBound?: MetricScale;
        ScalingAdjustment: PolicyIncrement;
    }
    export interface SuspendedProcess {
        ProcessName?: XmlStringMaxLen255;
        SuspensionReason?: XmlStringMaxLen255;
    }
    export interface Tag {
        ResourceId?: XmlString;
        ResourceType?: XmlString;
        Key: TagKey;
        Value?: TagValue;
        PropagateAtLaunch?: PropagateAtLaunch;
    }
    export interface TagDescription {
        ResourceId?: XmlString;
        ResourceType?: XmlString;
        Key?: TagKey;
        Value?: TagValue;
        PropagateAtLaunch?: PropagateAtLaunch;
    }
    export interface TagsType {
        Tags?: TagDescriptionList;
        NextToken?: XmlString;
    }
    export interface TerminateInstanceInAutoScalingGroupType {
        InstanceId: XmlStringMaxLen19;
        ShouldDecrementDesiredCapacity: ShouldDecrementDesiredCapacity;
    }
    export interface UpdateAutoScalingGroupType {
        AutoScalingGroupName: ResourceName;
        LaunchConfigurationName?: ResourceName;
        MinSize?: AutoScalingGroupMinSize;
        MaxSize?: AutoScalingGroupMaxSize;
        DesiredCapacity?: AutoScalingGroupDesiredCapacity;
        DefaultCooldown?: Cooldown;
        AvailabilityZones?: AvailabilityZones;
        HealthCheckType?: XmlStringMaxLen32;
        HealthCheckGracePeriod?: HealthCheckGracePeriod;
        PlacementGroup?: XmlStringMaxLen255;
        VPCZoneIdentifier?: XmlStringMaxLen255;
        TerminationPolicies?: TerminationPolicies;
        NewInstancesProtectedFromScaleIn?: InstanceProtected;
    }
  }

  /*
   * apiVersion: 2010-05-15
   * endpointPrefix: cloudformation
   * serviceAbbreviation: 
   * signatureVersion: v4
   * protocol: query
   */
  export class CloudFormation extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    cancelUpdateStack(params: CloudFormation.CancelUpdateStackInput, callback?: (err: any, data: any) => void): Request;
    continueUpdateRollback(params: CloudFormation.ContinueUpdateRollbackInput, callback?: (err: any, data: CloudFormation.ContinueUpdateRollbackOutput|any) => void): Request;
    createStack(params: CloudFormation.CreateStackInput, callback?: (err: CloudFormation.LimitExceededException|CloudFormation.AlreadyExistsException|CloudFormation.InsufficientCapabilitiesException|any, data: CloudFormation.CreateStackOutput|any) => void): Request;
    deleteStack(params: CloudFormation.DeleteStackInput, callback?: (err: any, data: any) => void): Request;
    describeAccountLimits(params: CloudFormation.DescribeAccountLimitsInput, callback?: (err: any, data: CloudFormation.DescribeAccountLimitsOutput|any) => void): Request;
    describeStackEvents(params: CloudFormation.DescribeStackEventsInput, callback?: (err: any, data: CloudFormation.DescribeStackEventsOutput|any) => void): Request;
    describeStackResource(params: CloudFormation.DescribeStackResourceInput, callback?: (err: any, data: CloudFormation.DescribeStackResourceOutput|any) => void): Request;
    describeStackResources(params: CloudFormation.DescribeStackResourcesInput, callback?: (err: any, data: CloudFormation.DescribeStackResourcesOutput|any) => void): Request;
    describeStacks(params: CloudFormation.DescribeStacksInput, callback?: (err: any, data: CloudFormation.DescribeStacksOutput|any) => void): Request;
    estimateTemplateCost(params: CloudFormation.EstimateTemplateCostInput, callback?: (err: any, data: CloudFormation.EstimateTemplateCostOutput|any) => void): Request;
    getStackPolicy(params: CloudFormation.GetStackPolicyInput, callback?: (err: any, data: CloudFormation.GetStackPolicyOutput|any) => void): Request;
    getTemplate(params: CloudFormation.GetTemplateInput, callback?: (err: any, data: CloudFormation.GetTemplateOutput|any) => void): Request;
    getTemplateSummary(params: CloudFormation.GetTemplateSummaryInput, callback?: (err: any, data: CloudFormation.GetTemplateSummaryOutput|any) => void): Request;
    listStackResources(params: CloudFormation.ListStackResourcesInput, callback?: (err: any, data: CloudFormation.ListStackResourcesOutput|any) => void): Request;
    listStacks(params: CloudFormation.ListStacksInput, callback?: (err: any, data: CloudFormation.ListStacksOutput|any) => void): Request;
    setStackPolicy(params: CloudFormation.SetStackPolicyInput, callback?: (err: any, data: any) => void): Request;
    signalResource(params: CloudFormation.SignalResourceInput, callback?: (err: any, data: any) => void): Request;
    updateStack(params: CloudFormation.UpdateStackInput, callback?: (err: CloudFormation.InsufficientCapabilitiesException|any, data: CloudFormation.UpdateStackOutput|any) => void): Request;
    validateTemplate(params: CloudFormation.ValidateTemplateInput, callback?: (err: any, data: CloudFormation.ValidateTemplateOutput|any) => void): Request;

  }

  export module CloudFormation {
    export type AccountLimitList = AccountLimit[];
    export type AllowedValue = string;
    export type AllowedValues = AllowedValue[];
    export type Capabilities = Capability[];
    export type CapabilitiesReason = string;
    export type Capability = string;
    export type CreationTime = number;
    export type DeletionTime = number;
    export type Description = string;
    export type DisableRollback = boolean;
    export type EventId = string;
    export type LastUpdatedTime = number;
    export type LimitName = string;
    export type LimitValue = number;
    export type LogicalResourceId = string;
    export type Metadata = string;
    export type NextToken = string;    // max: 1024, min: 1
    export type NoEcho = boolean;
    export type NotificationARN = string;
    export type NotificationARNs = NotificationARN[];    // max: 5
    export type OnFailure = string;
    export type OutputKey = string;
    export type OutputValue = string;
    export type Outputs = Output[];
    export type ParameterDeclarations = ParameterDeclaration[];
    export type ParameterKey = string;
    export type ParameterType = string;
    export type ParameterValue = string;
    export type Parameters = Parameter[];
    export type PhysicalResourceId = string;
    export type ResourceProperties = string;
    export type ResourceSignalStatus = string;
    export type ResourceSignalUniqueId = string;    // max: 64, min: 1
    export type ResourceStatus = string;
    export type ResourceStatusReason = string;
    export type ResourceType = string;
    export type ResourceTypes = ResourceType[];
    export type RetainResources = LogicalResourceId[];
    export type StackEvents = StackEvent[];
    export type StackId = string;
    export type StackName = string;
    export type StackNameOrId = string;    // pattern: &quot;([a-zA-Z][-a-zA-Z0-9]*)|(arn:\b(aws|aws-us-gov|aws-cn)\b:[-a-zA-Z0-9:/._+]*)&quot;, min: 1
    export type StackPolicyBody = string;    // max: 16384, min: 1
    export type StackPolicyDuringUpdateBody = string;    // max: 16384, min: 1
    export type StackPolicyDuringUpdateURL = string;    // max: 1350, min: 1
    export type StackPolicyURL = string;    // max: 1350, min: 1
    export type StackResourceSummaries = StackResourceSummary[];
    export type StackResources = StackResource[];
    export type StackStatus = string;
    export type StackStatusFilter = StackStatus[];
    export type StackStatusReason = string;
    export type StackSummaries = StackSummary[];
    export type Stacks = Stack[];
    export type TagKey = string;
    export type TagValue = string;
    export type Tags = Tag[];
    export type TemplateBody = string;    // min: 1
    export type TemplateDescription = string;
    export type TemplateParameters = TemplateParameter[];
    export type TemplateURL = string;    // max: 1024, min: 1
    export type TimeoutMinutes = number;    // min: 1
    export type Timestamp = number;
    export type Url = string;
    export type UsePreviousTemplate = boolean;
    export type UsePreviousValue = boolean;
    export type Version = string;

    export interface AccountLimit {
        Name?: LimitName;
        Value?: LimitValue;
    }
    export interface AlreadyExistsException {
    }
    export interface CancelUpdateStackInput {
        StackName: StackName;
    }
    export interface ContinueUpdateRollbackInput {
        StackName: StackNameOrId;
    }
    export interface ContinueUpdateRollbackOutput {
    }
    export interface CreateStackInput {
        StackName: StackName;
        TemplateBody?: TemplateBody;
        TemplateURL?: TemplateURL;
        Parameters?: Parameters;
        DisableRollback?: DisableRollback;
        TimeoutInMinutes?: TimeoutMinutes;
        NotificationARNs?: NotificationARNs;
        Capabilities?: Capabilities;
        ResourceTypes?: ResourceTypes;
        OnFailure?: OnFailure;
        StackPolicyBody?: StackPolicyBody;
        StackPolicyURL?: StackPolicyURL;
        Tags?: Tags;
    }
    export interface CreateStackOutput {
        StackId?: StackId;
    }
    export interface DeleteStackInput {
        StackName: StackName;
        RetainResources?: RetainResources;
    }
    export interface DescribeAccountLimitsInput {
        NextToken?: NextToken;
    }
    export interface DescribeAccountLimitsOutput {
        AccountLimits?: AccountLimitList;
        NextToken?: NextToken;
    }
    export interface DescribeStackEventsInput {
        StackName?: StackName;
        NextToken?: NextToken;
    }
    export interface DescribeStackEventsOutput {
        StackEvents?: StackEvents;
        NextToken?: NextToken;
    }
    export interface DescribeStackResourceInput {
        StackName: StackName;
        LogicalResourceId: LogicalResourceId;
    }
    export interface DescribeStackResourceOutput {
        StackResourceDetail?: StackResourceDetail;
    }
    export interface DescribeStackResourcesInput {
        StackName?: StackName;
        LogicalResourceId?: LogicalResourceId;
        PhysicalResourceId?: PhysicalResourceId;
    }
    export interface DescribeStackResourcesOutput {
        StackResources?: StackResources;
    }
    export interface DescribeStacksInput {
        StackName?: StackName;
        NextToken?: NextToken;
    }
    export interface DescribeStacksOutput {
        Stacks?: Stacks;
        NextToken?: NextToken;
    }
    export interface EstimateTemplateCostInput {
        TemplateBody?: TemplateBody;
        TemplateURL?: TemplateURL;
        Parameters?: Parameters;
    }
    export interface EstimateTemplateCostOutput {
        Url?: Url;
    }
    export interface GetStackPolicyInput {
        StackName: StackName;
    }
    export interface GetStackPolicyOutput {
        StackPolicyBody?: StackPolicyBody;
    }
    export interface GetTemplateInput {
        StackName: StackName;
    }
    export interface GetTemplateOutput {
        TemplateBody?: TemplateBody;
    }
    export interface GetTemplateSummaryInput {
        TemplateBody?: TemplateBody;
        TemplateURL?: TemplateURL;
        StackName?: StackNameOrId;
    }
    export interface GetTemplateSummaryOutput {
        Parameters?: ParameterDeclarations;
        Description?: Description;
        Capabilities?: Capabilities;
        CapabilitiesReason?: CapabilitiesReason;
        ResourceTypes?: ResourceTypes;
        Version?: Version;
        Metadata?: Metadata;
    }
    export interface InsufficientCapabilitiesException {
    }
    export interface LimitExceededException {
    }
    export interface ListStackResourcesInput {
        StackName: StackName;
        NextToken?: NextToken;
    }
    export interface ListStackResourcesOutput {
        StackResourceSummaries?: StackResourceSummaries;
        NextToken?: NextToken;
    }
    export interface ListStacksInput {
        NextToken?: NextToken;
        StackStatusFilter?: StackStatusFilter;
    }
    export interface ListStacksOutput {
        StackSummaries?: StackSummaries;
        NextToken?: NextToken;
    }
    export interface Output {
        OutputKey?: OutputKey;
        OutputValue?: OutputValue;
        Description?: Description;
    }
    export interface Parameter {
        ParameterKey?: ParameterKey;
        ParameterValue?: ParameterValue;
        UsePreviousValue?: UsePreviousValue;
    }
    export interface ParameterConstraints {
        AllowedValues?: AllowedValues;
    }
    export interface ParameterDeclaration {
        ParameterKey?: ParameterKey;
        DefaultValue?: ParameterValue;
        ParameterType?: ParameterType;
        NoEcho?: NoEcho;
        Description?: Description;
        ParameterConstraints?: ParameterConstraints;
    }
    export interface SetStackPolicyInput {
        StackName: StackName;
        StackPolicyBody?: StackPolicyBody;
        StackPolicyURL?: StackPolicyURL;
    }
    export interface SignalResourceInput {
        StackName: StackNameOrId;
        LogicalResourceId: LogicalResourceId;
        UniqueId: ResourceSignalUniqueId;
        Status: ResourceSignalStatus;
    }
    export interface Stack {
        StackId?: StackId;
        StackName: StackName;
        Description?: Description;
        Parameters?: Parameters;
        CreationTime: CreationTime;
        LastUpdatedTime?: LastUpdatedTime;
        StackStatus: StackStatus;
        StackStatusReason?: StackStatusReason;
        DisableRollback?: DisableRollback;
        NotificationARNs?: NotificationARNs;
        TimeoutInMinutes?: TimeoutMinutes;
        Capabilities?: Capabilities;
        Outputs?: Outputs;
        Tags?: Tags;
    }
    export interface StackEvent {
        StackId: StackId;
        EventId: EventId;
        StackName: StackName;
        LogicalResourceId?: LogicalResourceId;
        PhysicalResourceId?: PhysicalResourceId;
        ResourceType?: ResourceType;
        Timestamp: Timestamp;
        ResourceStatus?: ResourceStatus;
        ResourceStatusReason?: ResourceStatusReason;
        ResourceProperties?: ResourceProperties;
    }
    export interface StackResource {
        StackName?: StackName;
        StackId?: StackId;
        LogicalResourceId: LogicalResourceId;
        PhysicalResourceId?: PhysicalResourceId;
        ResourceType: ResourceType;
        Timestamp: Timestamp;
        ResourceStatus: ResourceStatus;
        ResourceStatusReason?: ResourceStatusReason;
        Description?: Description;
    }
    export interface StackResourceDetail {
        StackName?: StackName;
        StackId?: StackId;
        LogicalResourceId: LogicalResourceId;
        PhysicalResourceId?: PhysicalResourceId;
        ResourceType: ResourceType;
        LastUpdatedTimestamp: Timestamp;
        ResourceStatus: ResourceStatus;
        ResourceStatusReason?: ResourceStatusReason;
        Description?: Description;
        Metadata?: Metadata;
    }
    export interface StackResourceSummary {
        LogicalResourceId: LogicalResourceId;
        PhysicalResourceId?: PhysicalResourceId;
        ResourceType: ResourceType;
        LastUpdatedTimestamp: Timestamp;
        ResourceStatus: ResourceStatus;
        ResourceStatusReason?: ResourceStatusReason;
    }
    export interface StackSummary {
        StackId?: StackId;
        StackName: StackName;
        TemplateDescription?: TemplateDescription;
        CreationTime: CreationTime;
        LastUpdatedTime?: LastUpdatedTime;
        DeletionTime?: DeletionTime;
        StackStatus: StackStatus;
        StackStatusReason?: StackStatusReason;
    }
    export interface Tag {
        Key?: TagKey;
        Value?: TagValue;
    }
    export interface TemplateParameter {
        ParameterKey?: ParameterKey;
        DefaultValue?: ParameterValue;
        NoEcho?: NoEcho;
        Description?: Description;
    }
    export interface UpdateStackInput {
        StackName: StackName;
        TemplateBody?: TemplateBody;
        TemplateURL?: TemplateURL;
        UsePreviousTemplate?: UsePreviousTemplate;
        StackPolicyDuringUpdateBody?: StackPolicyDuringUpdateBody;
        StackPolicyDuringUpdateURL?: StackPolicyDuringUpdateURL;
        Parameters?: Parameters;
        Capabilities?: Capabilities;
        ResourceTypes?: ResourceTypes;
        StackPolicyBody?: StackPolicyBody;
        StackPolicyURL?: StackPolicyURL;
        NotificationARNs?: NotificationARNs;
        Tags?: Tags;
    }
    export interface UpdateStackOutput {
        StackId?: StackId;
    }
    export interface ValidateTemplateInput {
        TemplateBody?: TemplateBody;
        TemplateURL?: TemplateURL;
    }
    export interface ValidateTemplateOutput {
        Parameters?: TemplateParameters;
        Description?: Description;
        Capabilities?: Capabilities;
        CapabilitiesReason?: CapabilitiesReason;
    }
  }

  /*
   * apiVersion: 2016-01-28
   * endpointPrefix: cloudfront
   * serviceAbbreviation: CloudFront
   * signatureVersion: v4
   * protocol: rest-xml
   */
  export class CloudFront extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    createCloudFrontOriginAccessIdentity(params: CloudFront.CreateCloudFrontOriginAccessIdentityRequest, callback?: (err: CloudFront.CloudFrontOriginAccessIdentityAlreadyExists|CloudFront.MissingBody|CloudFront.TooManyCloudFrontOriginAccessIdentities|CloudFront.InvalidArgument|CloudFront.InconsistentQuantities|any, data: CloudFront.CreateCloudFrontOriginAccessIdentityResult|any) => void): Request;
    createDistribution(params: CloudFront.CreateDistributionRequest, callback?: (err: CloudFront.CNAMEAlreadyExists|CloudFront.DistributionAlreadyExists|CloudFront.InvalidOrigin|CloudFront.InvalidOriginAccessIdentity|CloudFront.AccessDenied|CloudFront.TooManyTrustedSigners|CloudFront.TrustedSignerDoesNotExist|CloudFront.InvalidViewerCertificate|CloudFront.InvalidMinimumProtocolVersion|CloudFront.MissingBody|CloudFront.TooManyDistributionCNAMEs|CloudFront.TooManyDistributions|CloudFront.InvalidDefaultRootObject|CloudFront.InvalidRelativePath|CloudFront.InvalidErrorCode|CloudFront.InvalidResponseCode|CloudFront.InvalidArgument|CloudFront.InvalidRequiredProtocol|CloudFront.NoSuchOrigin|CloudFront.TooManyOrigins|CloudFront.TooManyCacheBehaviors|CloudFront.TooManyCookieNamesInWhiteList|CloudFront.InvalidForwardCookies|CloudFront.TooManyHeadersInForwardedValues|CloudFront.InvalidHeadersForS3Origin|CloudFront.InconsistentQuantities|CloudFront.TooManyCertificates|CloudFront.InvalidLocationCode|CloudFront.InvalidGeoRestrictionParameter|CloudFront.InvalidProtocolSettings|CloudFront.InvalidTTLOrder|CloudFront.InvalidWebACLId|CloudFront.TooManyOriginCustomHeaders|any, data: CloudFront.CreateDistributionResult|any) => void): Request;
    createInvalidation(params: CloudFront.CreateInvalidationRequest, callback?: (err: CloudFront.AccessDenied|CloudFront.MissingBody|CloudFront.InvalidArgument|CloudFront.NoSuchDistribution|CloudFront.BatchTooLarge|CloudFront.TooManyInvalidationsInProgress|CloudFront.InconsistentQuantities|any, data: CloudFront.CreateInvalidationResult|any) => void): Request;
    createStreamingDistribution(params: CloudFront.CreateStreamingDistributionRequest, callback?: (err: CloudFront.CNAMEAlreadyExists|CloudFront.StreamingDistributionAlreadyExists|CloudFront.InvalidOrigin|CloudFront.InvalidOriginAccessIdentity|CloudFront.AccessDenied|CloudFront.TooManyTrustedSigners|CloudFront.TrustedSignerDoesNotExist|CloudFront.MissingBody|CloudFront.TooManyStreamingDistributionCNAMEs|CloudFront.TooManyStreamingDistributions|CloudFront.InvalidArgument|CloudFront.InconsistentQuantities|any, data: CloudFront.CreateStreamingDistributionResult|any) => void): Request;
    deleteCloudFrontOriginAccessIdentity(params: CloudFront.DeleteCloudFrontOriginAccessIdentityRequest, callback?: (err: CloudFront.AccessDenied|CloudFront.InvalidIfMatchVersion|CloudFront.NoSuchCloudFrontOriginAccessIdentity|CloudFront.PreconditionFailed|CloudFront.CloudFrontOriginAccessIdentityInUse|any, data: any) => void): Request;
    deleteDistribution(params: CloudFront.DeleteDistributionRequest, callback?: (err: CloudFront.AccessDenied|CloudFront.DistributionNotDisabled|CloudFront.InvalidIfMatchVersion|CloudFront.NoSuchDistribution|CloudFront.PreconditionFailed|any, data: any) => void): Request;
    deleteStreamingDistribution(params: CloudFront.DeleteStreamingDistributionRequest, callback?: (err: CloudFront.AccessDenied|CloudFront.StreamingDistributionNotDisabled|CloudFront.InvalidIfMatchVersion|CloudFront.NoSuchStreamingDistribution|CloudFront.PreconditionFailed|any, data: any) => void): Request;
    getCloudFrontOriginAccessIdentity(params: CloudFront.GetCloudFrontOriginAccessIdentityRequest, callback?: (err: CloudFront.NoSuchCloudFrontOriginAccessIdentity|CloudFront.AccessDenied|any, data: CloudFront.GetCloudFrontOriginAccessIdentityResult|any) => void): Request;
    getCloudFrontOriginAccessIdentityConfig(params: CloudFront.GetCloudFrontOriginAccessIdentityConfigRequest, callback?: (err: CloudFront.NoSuchCloudFrontOriginAccessIdentity|CloudFront.AccessDenied|any, data: CloudFront.GetCloudFrontOriginAccessIdentityConfigResult|any) => void): Request;
    getDistribution(params: CloudFront.GetDistributionRequest, callback?: (err: CloudFront.NoSuchDistribution|CloudFront.AccessDenied|any, data: CloudFront.GetDistributionResult|any) => void): Request;
    getDistributionConfig(params: CloudFront.GetDistributionConfigRequest, callback?: (err: CloudFront.NoSuchDistribution|CloudFront.AccessDenied|any, data: CloudFront.GetDistributionConfigResult|any) => void): Request;
    getInvalidation(params: CloudFront.GetInvalidationRequest, callback?: (err: CloudFront.NoSuchInvalidation|CloudFront.NoSuchDistribution|CloudFront.AccessDenied|any, data: CloudFront.GetInvalidationResult|any) => void): Request;
    getStreamingDistribution(params: CloudFront.GetStreamingDistributionRequest, callback?: (err: CloudFront.NoSuchStreamingDistribution|CloudFront.AccessDenied|any, data: CloudFront.GetStreamingDistributionResult|any) => void): Request;
    getStreamingDistributionConfig(params: CloudFront.GetStreamingDistributionConfigRequest, callback?: (err: CloudFront.NoSuchStreamingDistribution|CloudFront.AccessDenied|any, data: CloudFront.GetStreamingDistributionConfigResult|any) => void): Request;
    listCloudFrontOriginAccessIdentities(params: CloudFront.ListCloudFrontOriginAccessIdentitiesRequest, callback?: (err: CloudFront.InvalidArgument|any, data: CloudFront.ListCloudFrontOriginAccessIdentitiesResult|any) => void): Request;
    listDistributions(params: CloudFront.ListDistributionsRequest, callback?: (err: CloudFront.InvalidArgument|any, data: CloudFront.ListDistributionsResult|any) => void): Request;
    listDistributionsByWebACLId(params: CloudFront.ListDistributionsByWebACLIdRequest, callback?: (err: CloudFront.InvalidArgument|CloudFront.InvalidWebACLId|any, data: CloudFront.ListDistributionsByWebACLIdResult|any) => void): Request;
    listInvalidations(params: CloudFront.ListInvalidationsRequest, callback?: (err: CloudFront.InvalidArgument|CloudFront.NoSuchDistribution|CloudFront.AccessDenied|any, data: CloudFront.ListInvalidationsResult|any) => void): Request;
    listStreamingDistributions(params: CloudFront.ListStreamingDistributionsRequest, callback?: (err: CloudFront.InvalidArgument|any, data: CloudFront.ListStreamingDistributionsResult|any) => void): Request;
    updateCloudFrontOriginAccessIdentity(params: CloudFront.UpdateCloudFrontOriginAccessIdentityRequest, callback?: (err: CloudFront.AccessDenied|CloudFront.IllegalUpdate|CloudFront.InvalidIfMatchVersion|CloudFront.MissingBody|CloudFront.NoSuchCloudFrontOriginAccessIdentity|CloudFront.PreconditionFailed|CloudFront.InvalidArgument|CloudFront.InconsistentQuantities|any, data: CloudFront.UpdateCloudFrontOriginAccessIdentityResult|any) => void): Request;
    updateDistribution(params: CloudFront.UpdateDistributionRequest, callback?: (err: CloudFront.AccessDenied|CloudFront.CNAMEAlreadyExists|CloudFront.IllegalUpdate|CloudFront.InvalidIfMatchVersion|CloudFront.MissingBody|CloudFront.NoSuchDistribution|CloudFront.PreconditionFailed|CloudFront.TooManyDistributionCNAMEs|CloudFront.InvalidDefaultRootObject|CloudFront.InvalidRelativePath|CloudFront.InvalidErrorCode|CloudFront.InvalidResponseCode|CloudFront.InvalidArgument|CloudFront.InvalidOriginAccessIdentity|CloudFront.TooManyTrustedSigners|CloudFront.TrustedSignerDoesNotExist|CloudFront.InvalidViewerCertificate|CloudFront.InvalidMinimumProtocolVersion|CloudFront.InvalidRequiredProtocol|CloudFront.NoSuchOrigin|CloudFront.TooManyOrigins|CloudFront.TooManyCacheBehaviors|CloudFront.TooManyCookieNamesInWhiteList|CloudFront.InvalidForwardCookies|CloudFront.TooManyHeadersInForwardedValues|CloudFront.InvalidHeadersForS3Origin|CloudFront.InconsistentQuantities|CloudFront.TooManyCertificates|CloudFront.InvalidLocationCode|CloudFront.InvalidGeoRestrictionParameter|CloudFront.InvalidTTLOrder|CloudFront.InvalidWebACLId|CloudFront.TooManyOriginCustomHeaders|any, data: CloudFront.UpdateDistributionResult|any) => void): Request;
    updateStreamingDistribution(params: CloudFront.UpdateStreamingDistributionRequest, callback?: (err: CloudFront.AccessDenied|CloudFront.CNAMEAlreadyExists|CloudFront.IllegalUpdate|CloudFront.InvalidIfMatchVersion|CloudFront.MissingBody|CloudFront.NoSuchStreamingDistribution|CloudFront.PreconditionFailed|CloudFront.TooManyStreamingDistributionCNAMEs|CloudFront.InvalidArgument|CloudFront.InvalidOriginAccessIdentity|CloudFront.TooManyTrustedSigners|CloudFront.TrustedSignerDoesNotExist|CloudFront.InconsistentQuantities|any, data: CloudFront.UpdateStreamingDistributionResult|any) => void): Request;

    /***
     * Found on JS Sources - Sorry for the inconvenience :)
     * 
     **/
    setupRequestListeners(...args: any[]): any
  }

  export module CloudFront {
    export type AliasList = string[];
    export type AwsAccountNumberList = string[];
    export type CacheBehaviorList = CacheBehavior[];
    export type CertificateSource = string;
    export type CloudFrontOriginAccessIdentitySummaryList = CloudFrontOriginAccessIdentitySummary[];
    export type CookieNameList = string[];
    export type CustomErrorResponseList = CustomErrorResponse[];
    export type DistributionSummaryList = DistributionSummary[];
    export type GeoRestrictionType = string;
    export type HeaderList = string[];
    export type InvalidationSummaryList = InvalidationSummary[];
    export type ItemSelection = string;
    export type KeyPairIdList = string[];
    export type LocationList = string[];
    export type Method = string;
    export type MethodsList = Method[];
    export type MinimumProtocolVersion = string;
    export type OriginCustomHeadersList = OriginCustomHeader[];
    export type OriginList = Origin[];    // min: 1
    export type OriginProtocolPolicy = string;
    export type PathList = string[];
    export type PriceClass = string;
    export type SSLSupportMethod = string;
    export type SignerList = Signer[];
    export type SslProtocol = string;
    export type SslProtocolsList = SslProtocol[];
    export type StreamingDistributionSummaryList = StreamingDistributionSummary[];
    export type ViewerProtocolPolicy = string;
    export type integer = number;
    export type long = number;
    export type timestamp = number;

    export interface AccessDenied {
        Message?: string;
    }
    export interface ActiveTrustedSigners {
        Enabled: boolean;
        Quantity: integer;
        Items?: SignerList;
    }
    export interface Aliases {
        Quantity: integer;
        Items?: AliasList;
    }
    export interface AllowedMethods {
        Quantity: integer;
        Items: MethodsList;
        CachedMethods?: CachedMethods;
    }
    export interface BatchTooLarge {
        Message?: string;
    }
    export interface CNAMEAlreadyExists {
        Message?: string;
    }
    export interface CacheBehavior {
        PathPattern: string;
        TargetOriginId: string;
        ForwardedValues: ForwardedValues;
        TrustedSigners: TrustedSigners;
        ViewerProtocolPolicy: ViewerProtocolPolicy;
        MinTTL: long;
        AllowedMethods?: AllowedMethods;
        SmoothStreaming?: boolean;
        DefaultTTL?: long;
        MaxTTL?: long;
        Compress?: boolean;
    }
    export interface CacheBehaviors {
        Quantity: integer;
        Items?: CacheBehaviorList;
    }
    export interface CachedMethods {
        Quantity: integer;
        Items: MethodsList;
    }
    export interface CloudFrontOriginAccessIdentity {
        Id: string;
        S3CanonicalUserId: string;
        CloudFrontOriginAccessIdentityConfig?: CloudFrontOriginAccessIdentityConfig;
    }
    export interface CloudFrontOriginAccessIdentityAlreadyExists {
        Message?: string;
    }
    export interface CloudFrontOriginAccessIdentityConfig {
        CallerReference: string;
        Comment: string;
    }
    export interface CloudFrontOriginAccessIdentityInUse {
        Message?: string;
    }
    export interface CloudFrontOriginAccessIdentityList {
        Marker: string;
        NextMarker?: string;
        MaxItems: integer;
        IsTruncated: boolean;
        Quantity: integer;
        Items?: CloudFrontOriginAccessIdentitySummaryList;
    }
    export interface CloudFrontOriginAccessIdentitySummary {
        Id: string;
        S3CanonicalUserId: string;
        Comment: string;
    }
    export interface CookieNames {
        Quantity: integer;
        Items?: CookieNameList;
    }
    export interface CookiePreference {
        Forward: ItemSelection;
        WhitelistedNames?: CookieNames;
    }
    export interface CreateCloudFrontOriginAccessIdentityRequest {
        CloudFrontOriginAccessIdentityConfig: CloudFrontOriginAccessIdentityConfig;
    }
    export interface CreateCloudFrontOriginAccessIdentityResult {
        CloudFrontOriginAccessIdentity?: CloudFrontOriginAccessIdentity;
        Location?: string;
        ETag?: string;
    }
    export interface CreateDistributionRequest {
        DistributionConfig: DistributionConfig;
    }
    export interface CreateDistributionResult {
        Distribution?: Distribution;
        Location?: string;
        ETag?: string;
    }
    export interface CreateInvalidationRequest {
        DistributionId: string;
        InvalidationBatch: InvalidationBatch;
    }
    export interface CreateInvalidationResult {
        Location?: string;
        Invalidation?: Invalidation;
    }
    export interface CreateStreamingDistributionRequest {
        StreamingDistributionConfig: StreamingDistributionConfig;
    }
    export interface CreateStreamingDistributionResult {
        StreamingDistribution?: StreamingDistribution;
        Location?: string;
        ETag?: string;
    }
    export interface CustomErrorResponse {
        ErrorCode: integer;
        ResponsePagePath?: string;
        ResponseCode?: string;
        ErrorCachingMinTTL?: long;
    }
    export interface CustomErrorResponses {
        Quantity: integer;
        Items?: CustomErrorResponseList;
    }
    export interface CustomHeaders {
        Quantity: integer;
        Items?: OriginCustomHeadersList;
    }
    export interface CustomOriginConfig {
        HTTPPort: integer;
        HTTPSPort: integer;
        OriginProtocolPolicy: OriginProtocolPolicy;
        OriginSslProtocols?: OriginSslProtocols;
    }
    export interface DefaultCacheBehavior {
        TargetOriginId: string;
        ForwardedValues: ForwardedValues;
        TrustedSigners: TrustedSigners;
        ViewerProtocolPolicy: ViewerProtocolPolicy;
        MinTTL: long;
        AllowedMethods?: AllowedMethods;
        SmoothStreaming?: boolean;
        DefaultTTL?: long;
        MaxTTL?: long;
        Compress?: boolean;
    }
    export interface DeleteCloudFrontOriginAccessIdentityRequest {
        Id: string;
        IfMatch?: string;
    }
    export interface DeleteDistributionRequest {
        Id: string;
        IfMatch?: string;
    }
    export interface DeleteStreamingDistributionRequest {
        Id: string;
        IfMatch?: string;
    }
    export interface Distribution {
        Id: string;
        Status: string;
        LastModifiedTime: timestamp;
        InProgressInvalidationBatches: integer;
        DomainName: string;
        ActiveTrustedSigners: ActiveTrustedSigners;
        DistributionConfig: DistributionConfig;
    }
    export interface DistributionAlreadyExists {
        Message?: string;
    }
    export interface DistributionConfig {
        CallerReference: string;
        Aliases?: Aliases;
        DefaultRootObject?: string;
        Origins: Origins;
        DefaultCacheBehavior: DefaultCacheBehavior;
        CacheBehaviors?: CacheBehaviors;
        CustomErrorResponses?: CustomErrorResponses;
        Comment: string;
        Logging?: LoggingConfig;
        PriceClass?: PriceClass;
        Enabled: boolean;
        ViewerCertificate?: ViewerCertificate;
        Restrictions?: Restrictions;
        WebACLId?: string;
    }
    export interface DistributionList {
        Marker: string;
        NextMarker?: string;
        MaxItems: integer;
        IsTruncated: boolean;
        Quantity: integer;
        Items?: DistributionSummaryList;
    }
    export interface DistributionNotDisabled {
        Message?: string;
    }
    export interface DistributionSummary {
        Id: string;
        Status: string;
        LastModifiedTime: timestamp;
        DomainName: string;
        Aliases: Aliases;
        Origins: Origins;
        DefaultCacheBehavior: DefaultCacheBehavior;
        CacheBehaviors: CacheBehaviors;
        CustomErrorResponses: CustomErrorResponses;
        Comment: string;
        PriceClass: PriceClass;
        Enabled: boolean;
        ViewerCertificate: ViewerCertificate;
        Restrictions: Restrictions;
        WebACLId: string;
    }
    export interface ForwardedValues {
        QueryString: boolean;
        Cookies: CookiePreference;
        Headers?: Headers;
    }
    export interface GeoRestriction {
        RestrictionType: GeoRestrictionType;
        Quantity: integer;
        Items?: LocationList;
    }
    export interface GetCloudFrontOriginAccessIdentityConfigRequest {
        Id: string;
    }
    export interface GetCloudFrontOriginAccessIdentityConfigResult {
        CloudFrontOriginAccessIdentityConfig?: CloudFrontOriginAccessIdentityConfig;
        ETag?: string;
    }
    export interface GetCloudFrontOriginAccessIdentityRequest {
        Id: string;
    }
    export interface GetCloudFrontOriginAccessIdentityResult {
        CloudFrontOriginAccessIdentity?: CloudFrontOriginAccessIdentity;
        ETag?: string;
    }
    export interface GetDistributionConfigRequest {
        Id: string;
    }
    export interface GetDistributionConfigResult {
        DistributionConfig?: DistributionConfig;
        ETag?: string;
    }
    export interface GetDistributionRequest {
        Id: string;
    }
    export interface GetDistributionResult {
        Distribution?: Distribution;
        ETag?: string;
    }
    export interface GetInvalidationRequest {
        DistributionId: string;
        Id: string;
    }
    export interface GetInvalidationResult {
        Invalidation?: Invalidation;
    }
    export interface GetStreamingDistributionConfigRequest {
        Id: string;
    }
    export interface GetStreamingDistributionConfigResult {
        StreamingDistributionConfig?: StreamingDistributionConfig;
        ETag?: string;
    }
    export interface GetStreamingDistributionRequest {
        Id: string;
    }
    export interface GetStreamingDistributionResult {
        StreamingDistribution?: StreamingDistribution;
        ETag?: string;
    }
    export interface Headers {
        Quantity: integer;
        Items?: HeaderList;
    }
    export interface IllegalUpdate {
        Message?: string;
    }
    export interface InconsistentQuantities {
        Message?: string;
    }
    export interface InvalidArgument {
        Message?: string;
    }
    export interface InvalidDefaultRootObject {
        Message?: string;
    }
    export interface InvalidErrorCode {
        Message?: string;
    }
    export interface InvalidForwardCookies {
        Message?: string;
    }
    export interface InvalidGeoRestrictionParameter {
        Message?: string;
    }
    export interface InvalidHeadersForS3Origin {
        Message?: string;
    }
    export interface InvalidIfMatchVersion {
        Message?: string;
    }
    export interface InvalidLocationCode {
        Message?: string;
    }
    export interface InvalidMinimumProtocolVersion {
        Message?: string;
    }
    export interface InvalidOrigin {
        Message?: string;
    }
    export interface InvalidOriginAccessIdentity {
        Message?: string;
    }
    export interface InvalidProtocolSettings {
        Message?: string;
    }
    export interface InvalidRelativePath {
        Message?: string;
    }
    export interface InvalidRequiredProtocol {
        Message?: string;
    }
    export interface InvalidResponseCode {
        Message?: string;
    }
    export interface InvalidTTLOrder {
        Message?: string;
    }
    export interface InvalidViewerCertificate {
        Message?: string;
    }
    export interface InvalidWebACLId {
        Message?: string;
    }
    export interface Invalidation {
        Id: string;
        Status: string;
        CreateTime: timestamp;
        InvalidationBatch: InvalidationBatch;
    }
    export interface InvalidationBatch {
        Paths: Paths;
        CallerReference: string;
    }
    export interface InvalidationList {
        Marker: string;
        NextMarker?: string;
        MaxItems: integer;
        IsTruncated: boolean;
        Quantity: integer;
        Items?: InvalidationSummaryList;
    }
    export interface InvalidationSummary {
        Id: string;
        CreateTime: timestamp;
        Status: string;
    }
    export interface KeyPairIds {
        Quantity: integer;
        Items?: KeyPairIdList;
    }
    export interface ListCloudFrontOriginAccessIdentitiesRequest {
        Marker?: string;
        MaxItems?: string;
    }
    export interface ListCloudFrontOriginAccessIdentitiesResult {
        CloudFrontOriginAccessIdentityList?: CloudFrontOriginAccessIdentityList;
    }
    export interface ListDistributionsByWebACLIdRequest {
        Marker?: string;
        MaxItems?: string;
        WebACLId: string;
    }
    export interface ListDistributionsByWebACLIdResult {
        DistributionList?: DistributionList;
    }
    export interface ListDistributionsRequest {
        Marker?: string;
        MaxItems?: string;
    }
    export interface ListDistributionsResult {
        DistributionList?: DistributionList;
    }
    export interface ListInvalidationsRequest {
        DistributionId: string;
        Marker?: string;
        MaxItems?: string;
    }
    export interface ListInvalidationsResult {
        InvalidationList?: InvalidationList;
    }
    export interface ListStreamingDistributionsRequest {
        Marker?: string;
        MaxItems?: string;
    }
    export interface ListStreamingDistributionsResult {
        StreamingDistributionList?: StreamingDistributionList;
    }
    export interface LoggingConfig {
        Enabled: boolean;
        IncludeCookies: boolean;
        Bucket: string;
        Prefix: string;
    }
    export interface MissingBody {
        Message?: string;
    }
    export interface NoSuchCloudFrontOriginAccessIdentity {
        Message?: string;
    }
    export interface NoSuchDistribution {
        Message?: string;
    }
    export interface NoSuchInvalidation {
        Message?: string;
    }
    export interface NoSuchOrigin {
        Message?: string;
    }
    export interface NoSuchStreamingDistribution {
        Message?: string;
    }
    export interface Origin {
        Id: string;
        DomainName: string;
        OriginPath?: string;
        CustomHeaders?: CustomHeaders;
        S3OriginConfig?: S3OriginConfig;
        CustomOriginConfig?: CustomOriginConfig;
    }
    export interface OriginCustomHeader {
        HeaderName: string;
        HeaderValue: string;
    }
    export interface OriginSslProtocols {
        Quantity: integer;
        Items: SslProtocolsList;
    }
    export interface Origins {
        Quantity: integer;
        Items?: OriginList;
    }
    export interface Paths {
        Quantity: integer;
        Items?: PathList;
    }
    export interface PreconditionFailed {
        Message?: string;
    }
    export interface Restrictions {
        GeoRestriction: GeoRestriction;
    }
    export interface S3Origin {
        DomainName: string;
        OriginAccessIdentity: string;
    }
    export interface S3OriginConfig {
        OriginAccessIdentity: string;
    }
    export interface Signer {
        AwsAccountNumber?: string;
        KeyPairIds?: KeyPairIds;
    }
    export interface StreamingDistribution {
        Id: string;
        Status: string;
        LastModifiedTime?: timestamp;
        DomainName: string;
        ActiveTrustedSigners: ActiveTrustedSigners;
        StreamingDistributionConfig: StreamingDistributionConfig;
    }
    export interface StreamingDistributionAlreadyExists {
        Message?: string;
    }
    export interface StreamingDistributionConfig {
        CallerReference: string;
        S3Origin: S3Origin;
        Aliases?: Aliases;
        Comment: string;
        Logging?: StreamingLoggingConfig;
        TrustedSigners: TrustedSigners;
        PriceClass?: PriceClass;
        Enabled: boolean;
    }
    export interface StreamingDistributionList {
        Marker: string;
        NextMarker?: string;
        MaxItems: integer;
        IsTruncated: boolean;
        Quantity: integer;
        Items?: StreamingDistributionSummaryList;
    }
    export interface StreamingDistributionNotDisabled {
        Message?: string;
    }
    export interface StreamingDistributionSummary {
        Id: string;
        Status: string;
        LastModifiedTime: timestamp;
        DomainName: string;
        S3Origin: S3Origin;
        Aliases: Aliases;
        TrustedSigners: TrustedSigners;
        Comment: string;
        PriceClass: PriceClass;
        Enabled: boolean;
    }
    export interface StreamingLoggingConfig {
        Enabled: boolean;
        Bucket: string;
        Prefix: string;
    }
    export interface TooManyCacheBehaviors {
        Message?: string;
    }
    export interface TooManyCertificates {
        Message?: string;
    }
    export interface TooManyCloudFrontOriginAccessIdentities {
        Message?: string;
    }
    export interface TooManyCookieNamesInWhiteList {
        Message?: string;
    }
    export interface TooManyDistributionCNAMEs {
        Message?: string;
    }
    export interface TooManyDistributions {
        Message?: string;
    }
    export interface TooManyHeadersInForwardedValues {
        Message?: string;
    }
    export interface TooManyInvalidationsInProgress {
        Message?: string;
    }
    export interface TooManyOriginCustomHeaders {
        Message?: string;
    }
    export interface TooManyOrigins {
        Message?: string;
    }
    export interface TooManyStreamingDistributionCNAMEs {
        Message?: string;
    }
    export interface TooManyStreamingDistributions {
        Message?: string;
    }
    export interface TooManyTrustedSigners {
        Message?: string;
    }
    export interface TrustedSignerDoesNotExist {
        Message?: string;
    }
    export interface TrustedSigners {
        Enabled: boolean;
        Quantity: integer;
        Items?: AwsAccountNumberList;
    }
    export interface UpdateCloudFrontOriginAccessIdentityRequest {
        CloudFrontOriginAccessIdentityConfig: CloudFrontOriginAccessIdentityConfig;
        Id: string;
        IfMatch?: string;
    }
    export interface UpdateCloudFrontOriginAccessIdentityResult {
        CloudFrontOriginAccessIdentity?: CloudFrontOriginAccessIdentity;
        ETag?: string;
    }
    export interface UpdateDistributionRequest {
        DistributionConfig: DistributionConfig;
        Id: string;
        IfMatch?: string;
    }
    export interface UpdateDistributionResult {
        Distribution?: Distribution;
        ETag?: string;
    }
    export interface UpdateStreamingDistributionRequest {
        StreamingDistributionConfig: StreamingDistributionConfig;
        Id: string;
        IfMatch?: string;
    }
    export interface UpdateStreamingDistributionResult {
        StreamingDistribution?: StreamingDistribution;
        ETag?: string;
    }
    export interface ViewerCertificate {
        CloudFrontDefaultCertificate?: boolean;
        IAMCertificateId?: string;
        ACMCertificateArn?: string;
        SSLSupportMethod?: SSLSupportMethod;
        MinimumProtocolVersion?: MinimumProtocolVersion;
        Certificate?: string;
        CertificateSource?: CertificateSource;
    }
  }

  /*
   * apiVersion: 2014-05-30
   * endpointPrefix: cloudhsm
   * serviceAbbreviation: CloudHSM
   * signatureVersion: v4
   * protocol: json
   */
  export class CloudHSM extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    addTagsToResource(params: CloudHSM.AddTagsToResourceRequest, callback?: (err: CloudHSM.CloudHsmServiceException|CloudHSM.CloudHsmInternalException|CloudHSM.InvalidRequestException|any, data: CloudHSM.AddTagsToResourceResponse|any) => void): Request;
    createHapg(params: CloudHSM.CreateHapgRequest, callback?: (err: CloudHSM.CloudHsmServiceException|CloudHSM.CloudHsmInternalException|CloudHSM.InvalidRequestException|any, data: CloudHSM.CreateHapgResponse|any) => void): Request;
    createHsm(params: CloudHSM.CreateHsmRequest, callback?: (err: CloudHSM.CloudHsmServiceException|CloudHSM.CloudHsmInternalException|CloudHSM.InvalidRequestException|any, data: CloudHSM.CreateHsmResponse|any) => void): Request;
    createLunaClient(params: CloudHSM.CreateLunaClientRequest, callback?: (err: CloudHSM.CloudHsmServiceException|CloudHSM.CloudHsmInternalException|CloudHSM.InvalidRequestException|any, data: CloudHSM.CreateLunaClientResponse|any) => void): Request;
    deleteHapg(params: CloudHSM.DeleteHapgRequest, callback?: (err: CloudHSM.CloudHsmServiceException|CloudHSM.CloudHsmInternalException|CloudHSM.InvalidRequestException|any, data: CloudHSM.DeleteHapgResponse|any) => void): Request;
    deleteHsm(params: CloudHSM.DeleteHsmRequest, callback?: (err: CloudHSM.CloudHsmServiceException|CloudHSM.CloudHsmInternalException|CloudHSM.InvalidRequestException|any, data: CloudHSM.DeleteHsmResponse|any) => void): Request;
    deleteLunaClient(params: CloudHSM.DeleteLunaClientRequest, callback?: (err: CloudHSM.CloudHsmServiceException|CloudHSM.CloudHsmInternalException|CloudHSM.InvalidRequestException|any, data: CloudHSM.DeleteLunaClientResponse|any) => void): Request;
    describeHapg(params: CloudHSM.DescribeHapgRequest, callback?: (err: CloudHSM.CloudHsmServiceException|CloudHSM.CloudHsmInternalException|CloudHSM.InvalidRequestException|any, data: CloudHSM.DescribeHapgResponse|any) => void): Request;
    describeHsm(params: CloudHSM.DescribeHsmRequest, callback?: (err: CloudHSM.CloudHsmServiceException|CloudHSM.CloudHsmInternalException|CloudHSM.InvalidRequestException|any, data: CloudHSM.DescribeHsmResponse|any) => void): Request;
    describeLunaClient(params: CloudHSM.DescribeLunaClientRequest, callback?: (err: CloudHSM.CloudHsmServiceException|CloudHSM.CloudHsmInternalException|CloudHSM.InvalidRequestException|any, data: CloudHSM.DescribeLunaClientResponse|any) => void): Request;
    getConfig(params: CloudHSM.GetConfigRequest, callback?: (err: CloudHSM.CloudHsmServiceException|CloudHSM.CloudHsmInternalException|CloudHSM.InvalidRequestException|any, data: CloudHSM.GetConfigResponse|any) => void): Request;
    listAvailableZones(params: CloudHSM.ListAvailableZonesRequest, callback?: (err: CloudHSM.CloudHsmServiceException|CloudHSM.CloudHsmInternalException|CloudHSM.InvalidRequestException|any, data: CloudHSM.ListAvailableZonesResponse|any) => void): Request;
    listHapgs(params: CloudHSM.ListHapgsRequest, callback?: (err: CloudHSM.CloudHsmServiceException|CloudHSM.CloudHsmInternalException|CloudHSM.InvalidRequestException|any, data: CloudHSM.ListHapgsResponse|any) => void): Request;
    listHsms(params: CloudHSM.ListHsmsRequest, callback?: (err: CloudHSM.CloudHsmServiceException|CloudHSM.CloudHsmInternalException|CloudHSM.InvalidRequestException|any, data: CloudHSM.ListHsmsResponse|any) => void): Request;
    listLunaClients(params: CloudHSM.ListLunaClientsRequest, callback?: (err: CloudHSM.CloudHsmServiceException|CloudHSM.CloudHsmInternalException|CloudHSM.InvalidRequestException|any, data: CloudHSM.ListLunaClientsResponse|any) => void): Request;
    listTagsForResource(params: CloudHSM.ListTagsForResourceRequest, callback?: (err: CloudHSM.CloudHsmServiceException|CloudHSM.CloudHsmInternalException|CloudHSM.InvalidRequestException|any, data: CloudHSM.ListTagsForResourceResponse|any) => void): Request;
    modifyHapg(params: CloudHSM.ModifyHapgRequest, callback?: (err: CloudHSM.CloudHsmServiceException|CloudHSM.CloudHsmInternalException|CloudHSM.InvalidRequestException|any, data: CloudHSM.ModifyHapgResponse|any) => void): Request;
    modifyHsm(params: CloudHSM.ModifyHsmRequest, callback?: (err: CloudHSM.CloudHsmServiceException|CloudHSM.CloudHsmInternalException|CloudHSM.InvalidRequestException|any, data: CloudHSM.ModifyHsmResponse|any) => void): Request;
    modifyLunaClient(params: CloudHSM.ModifyLunaClientRequest, callback?: (err: CloudHSM.CloudHsmServiceException|any, data: CloudHSM.ModifyLunaClientResponse|any) => void): Request;
    removeTagsFromResource(params: CloudHSM.RemoveTagsFromResourceRequest, callback?: (err: CloudHSM.CloudHsmServiceException|CloudHSM.CloudHsmInternalException|CloudHSM.InvalidRequestException|any, data: CloudHSM.RemoveTagsFromResourceResponse|any) => void): Request;

  }

  export module CloudHSM {
    export type AZ = string;    // pattern: &quot;[a-zA-Z0-9\-]*&quot;
    export type AZList = AZ[];
    export type Boolean = boolean;
    export type Certificate = string;    // pattern: &quot;[\w :+=./\n-]*&quot;, max: 2400, min: 600
    export type CertificateFingerprint = string;    // pattern: &quot;([0-9a-fA-F][0-9a-fA-F]:){15}[0-9a-fA-F][0-9a-fA-F]&quot;
    export type ClientArn = string;    // pattern: &quot;arn:aws(-iso)?:cloudhsm:[a-zA-Z0-9\-]*:[0-9]{12}:client-[0-9a-f]{8}&quot;
    export type ClientLabel = string;    // pattern: &quot;[a-zA-Z0-9_.-]{2,64}&quot;
    export type ClientList = ClientArn[];
    export type ClientToken = string;    // pattern: &quot;[a-zA-Z0-9]{1,64}&quot;
    export type ClientVersion = string;
    export type CloudHsmObjectState = string;
    export type EniId = string;    // pattern: &quot;eni-[0-9a-f]{8}&quot;
    export type ExternalId = string;    // pattern: &quot;[\w :+=./-]*&quot;
    export type HapgArn = string;    // pattern: &quot;arn:aws(-iso)?:cloudhsm:[a-zA-Z0-9\-]*:[0-9]{12}:hapg-[0-9a-f]{8}&quot;
    export type HapgList = HapgArn[];
    export type HsmArn = string;    // pattern: &quot;arn:aws(-iso)?:cloudhsm:[a-zA-Z0-9\-]*:[0-9]{12}:hsm-[0-9a-f]{8}&quot;
    export type HsmList = HsmArn[];
    export type HsmSerialNumber = string;    // pattern: &quot;\d{1,16}&quot;
    export type HsmStatus = string;
    export type IamRoleArn = string;    // pattern: &quot;arn:aws(-iso)?:iam::[0-9]{12}:role/[a-zA-Z0-9_\+=,\.\-@]{1,64}&quot;
    export type IpAddress = string;    // pattern: &quot;\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}&quot;
    export type Label = string;    // pattern: &quot;[a-zA-Z0-9_.-]{1,64}&quot;
    export type PaginationToken = string;    // pattern: &quot;[a-zA-Z0-9+/]*&quot;
    export type PartitionArn = string;    // pattern: &quot;arn:aws(-iso)?:cloudhsm:[a-zA-Z0-9\-]*:[0-9]{12}:hsm-[0-9a-f]{8}/partition-[0-9]{6,12}&quot;
    export type PartitionList = PartitionArn[];
    export type PartitionSerial = string;    // pattern: &quot;\d{6,12}&quot;
    export type PartitionSerialList = PartitionSerial[];
    export type SshKey = string;    // pattern: &quot;[a-zA-Z0-9+/= ._:\\@-]*&quot;
    export type String = string;    // pattern: &quot;[\w :+=./\\-]*&quot;
    export type SubnetId = string;    // pattern: &quot;subnet-[0-9a-f]{8}&quot;
    export type SubscriptionType = string;
    export type TagKey = string;    // max: 128, min: 1
    export type TagKeyList = TagKey[];
    export type TagList = Tag[];
    export type TagValue = string;    // max: 256
    export type Timestamp = string;    // pattern: &quot;\d*&quot;
    export type VpcId = string;    // pattern: &quot;vpc-[0-9a-f]{8}&quot;

    export interface AddTagsToResourceRequest {
        ResourceArn: String;
        TagList: TagList;
    }
    export interface AddTagsToResourceResponse {
        Status: String;
    }
    export interface CloudHsmInternalException {
    }
    export interface CloudHsmServiceException {
        message?: String;
        retryable?: Boolean;
    }
    export interface CreateHapgRequest {
        Label: Label;
    }
    export interface CreateHapgResponse {
        HapgArn?: HapgArn;
    }
    export interface CreateHsmRequest {
        SubnetId: SubnetId;
        SshKey: SshKey;
        EniIp?: IpAddress;
        IamRoleArn: IamRoleArn;
        ExternalId?: ExternalId;
        SubscriptionType: SubscriptionType;
        ClientToken?: ClientToken;
        SyslogIp?: IpAddress;
    }
    export interface CreateHsmResponse {
        HsmArn?: HsmArn;
    }
    export interface CreateLunaClientRequest {
        Label?: ClientLabel;
        Certificate: Certificate;
    }
    export interface CreateLunaClientResponse {
        ClientArn?: ClientArn;
    }
    export interface DeleteHapgRequest {
        HapgArn: HapgArn;
    }
    export interface DeleteHapgResponse {
        Status: String;
    }
    export interface DeleteHsmRequest {
        HsmArn: HsmArn;
    }
    export interface DeleteHsmResponse {
        Status: String;
    }
    export interface DeleteLunaClientRequest {
        ClientArn: ClientArn;
    }
    export interface DeleteLunaClientResponse {
        Status: String;
    }
    export interface DescribeHapgRequest {
        HapgArn: HapgArn;
    }
    export interface DescribeHapgResponse {
        HapgArn?: HapgArn;
        HapgSerial?: String;
        HsmsLastActionFailed?: HsmList;
        HsmsPendingDeletion?: HsmList;
        HsmsPendingRegistration?: HsmList;
        Label?: Label;
        LastModifiedTimestamp?: Timestamp;
        PartitionSerialList?: PartitionSerialList;
        State?: CloudHsmObjectState;
    }
    export interface DescribeHsmRequest {
        HsmArn?: HsmArn;
        HsmSerialNumber?: HsmSerialNumber;
    }
    export interface DescribeHsmResponse {
        HsmArn?: HsmArn;
        Status?: HsmStatus;
        StatusDetails?: String;
        AvailabilityZone?: AZ;
        EniId?: EniId;
        EniIp?: IpAddress;
        SubscriptionType?: SubscriptionType;
        SubscriptionStartDate?: Timestamp;
        SubscriptionEndDate?: Timestamp;
        VpcId?: VpcId;
        SubnetId?: SubnetId;
        IamRoleArn?: IamRoleArn;
        SerialNumber?: HsmSerialNumber;
        VendorName?: String;
        HsmType?: String;
        SoftwareVersion?: String;
        SshPublicKey?: SshKey;
        SshKeyLastUpdated?: Timestamp;
        ServerCertUri?: String;
        ServerCertLastUpdated?: Timestamp;
        Partitions?: PartitionList;
    }
    export interface DescribeLunaClientRequest {
        ClientArn?: ClientArn;
        CertificateFingerprint?: CertificateFingerprint;
    }
    export interface DescribeLunaClientResponse {
        ClientArn?: ClientArn;
        Certificate?: Certificate;
        CertificateFingerprint?: CertificateFingerprint;
        LastModifiedTimestamp?: Timestamp;
        Label?: Label;
    }
    export interface GetConfigRequest {
        ClientArn: ClientArn;
        ClientVersion: ClientVersion;
        HapgList: HapgList;
    }
    export interface GetConfigResponse {
        ConfigType?: String;
        ConfigFile?: String;
        ConfigCred?: String;
    }
    export interface InvalidRequestException {
    }
    export interface ListAvailableZonesRequest {
    }
    export interface ListAvailableZonesResponse {
        AZList?: AZList;
    }
    export interface ListHapgsRequest {
        NextToken?: PaginationToken;
    }
    export interface ListHapgsResponse {
        HapgList: HapgList;
        NextToken?: PaginationToken;
    }
    export interface ListHsmsRequest {
        NextToken?: PaginationToken;
    }
    export interface ListHsmsResponse {
        HsmList?: HsmList;
        NextToken?: PaginationToken;
    }
    export interface ListLunaClientsRequest {
        NextToken?: PaginationToken;
    }
    export interface ListLunaClientsResponse {
        ClientList: ClientList;
        NextToken?: PaginationToken;
    }
    export interface ListTagsForResourceRequest {
        ResourceArn: String;
    }
    export interface ListTagsForResourceResponse {
        TagList: TagList;
    }
    export interface ModifyHapgRequest {
        HapgArn: HapgArn;
        Label?: Label;
        PartitionSerialList?: PartitionSerialList;
    }
    export interface ModifyHapgResponse {
        HapgArn?: HapgArn;
    }
    export interface ModifyHsmRequest {
        HsmArn: HsmArn;
        SubnetId?: SubnetId;
        EniIp?: IpAddress;
        IamRoleArn?: IamRoleArn;
        ExternalId?: ExternalId;
        SyslogIp?: IpAddress;
    }
    export interface ModifyHsmResponse {
        HsmArn?: HsmArn;
    }
    export interface ModifyLunaClientRequest {
        ClientArn: ClientArn;
        Certificate: Certificate;
    }
    export interface ModifyLunaClientResponse {
        ClientArn?: ClientArn;
    }
    export interface RemoveTagsFromResourceRequest {
        ResourceArn: String;
        TagKeyList: TagKeyList;
    }
    export interface RemoveTagsFromResourceResponse {
        Status: String;
    }
    export interface Tag {
        Key: TagKey;
        Value: TagValue;
    }
  }

  /*
   * apiVersion: 2013-01-01
   * endpointPrefix: cloudsearch
   * serviceAbbreviation: 
   * signatureVersion: v4
   * protocol: query
   */
  export class CloudSearch extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    buildSuggesters(params: CloudSearch.BuildSuggestersRequest, callback?: (err: CloudSearch.BaseException|CloudSearch.InternalException|CloudSearch.ResourceNotFoundException|any, data: CloudSearch.BuildSuggestersResponse|any) => void): Request;
    createDomain(params: CloudSearch.CreateDomainRequest, callback?: (err: CloudSearch.BaseException|CloudSearch.InternalException|CloudSearch.LimitExceededException|any, data: CloudSearch.CreateDomainResponse|any) => void): Request;
    defineAnalysisScheme(params: CloudSearch.DefineAnalysisSchemeRequest, callback?: (err: CloudSearch.BaseException|CloudSearch.InternalException|CloudSearch.LimitExceededException|CloudSearch.InvalidTypeException|CloudSearch.ResourceNotFoundException|any, data: CloudSearch.DefineAnalysisSchemeResponse|any) => void): Request;
    defineExpression(params: CloudSearch.DefineExpressionRequest, callback?: (err: CloudSearch.BaseException|CloudSearch.InternalException|CloudSearch.LimitExceededException|CloudSearch.InvalidTypeException|CloudSearch.ResourceNotFoundException|any, data: CloudSearch.DefineExpressionResponse|any) => void): Request;
    defineIndexField(params: CloudSearch.DefineIndexFieldRequest, callback?: (err: CloudSearch.BaseException|CloudSearch.InternalException|CloudSearch.LimitExceededException|CloudSearch.InvalidTypeException|CloudSearch.ResourceNotFoundException|any, data: CloudSearch.DefineIndexFieldResponse|any) => void): Request;
    defineSuggester(params: CloudSearch.DefineSuggesterRequest, callback?: (err: CloudSearch.BaseException|CloudSearch.InternalException|CloudSearch.LimitExceededException|CloudSearch.InvalidTypeException|CloudSearch.ResourceNotFoundException|any, data: CloudSearch.DefineSuggesterResponse|any) => void): Request;
    deleteAnalysisScheme(params: CloudSearch.DeleteAnalysisSchemeRequest, callback?: (err: CloudSearch.BaseException|CloudSearch.InternalException|CloudSearch.InvalidTypeException|CloudSearch.ResourceNotFoundException|any, data: CloudSearch.DeleteAnalysisSchemeResponse|any) => void): Request;
    deleteDomain(params: CloudSearch.DeleteDomainRequest, callback?: (err: CloudSearch.BaseException|CloudSearch.InternalException|any, data: CloudSearch.DeleteDomainResponse|any) => void): Request;
    deleteExpression(params: CloudSearch.DeleteExpressionRequest, callback?: (err: CloudSearch.BaseException|CloudSearch.InternalException|CloudSearch.InvalidTypeException|CloudSearch.ResourceNotFoundException|any, data: CloudSearch.DeleteExpressionResponse|any) => void): Request;
    deleteIndexField(params: CloudSearch.DeleteIndexFieldRequest, callback?: (err: CloudSearch.BaseException|CloudSearch.InternalException|CloudSearch.InvalidTypeException|CloudSearch.ResourceNotFoundException|any, data: CloudSearch.DeleteIndexFieldResponse|any) => void): Request;
    deleteSuggester(params: CloudSearch.DeleteSuggesterRequest, callback?: (err: CloudSearch.BaseException|CloudSearch.InternalException|CloudSearch.InvalidTypeException|CloudSearch.ResourceNotFoundException|any, data: CloudSearch.DeleteSuggesterResponse|any) => void): Request;
    describeAnalysisSchemes(params: CloudSearch.DescribeAnalysisSchemesRequest, callback?: (err: CloudSearch.BaseException|CloudSearch.InternalException|CloudSearch.ResourceNotFoundException|any, data: CloudSearch.DescribeAnalysisSchemesResponse|any) => void): Request;
    describeAvailabilityOptions(params: CloudSearch.DescribeAvailabilityOptionsRequest, callback?: (err: CloudSearch.BaseException|CloudSearch.InternalException|CloudSearch.InvalidTypeException|CloudSearch.LimitExceededException|CloudSearch.ResourceNotFoundException|CloudSearch.DisabledOperationException|any, data: CloudSearch.DescribeAvailabilityOptionsResponse|any) => void): Request;
    describeDomains(params: CloudSearch.DescribeDomainsRequest, callback?: (err: CloudSearch.BaseException|CloudSearch.InternalException|any, data: CloudSearch.DescribeDomainsResponse|any) => void): Request;
    describeExpressions(params: CloudSearch.DescribeExpressionsRequest, callback?: (err: CloudSearch.BaseException|CloudSearch.InternalException|CloudSearch.ResourceNotFoundException|any, data: CloudSearch.DescribeExpressionsResponse|any) => void): Request;
    describeIndexFields(params: CloudSearch.DescribeIndexFieldsRequest, callback?: (err: CloudSearch.BaseException|CloudSearch.InternalException|CloudSearch.ResourceNotFoundException|any, data: CloudSearch.DescribeIndexFieldsResponse|any) => void): Request;
    describeScalingParameters(params: CloudSearch.DescribeScalingParametersRequest, callback?: (err: CloudSearch.BaseException|CloudSearch.InternalException|CloudSearch.ResourceNotFoundException|any, data: CloudSearch.DescribeScalingParametersResponse|any) => void): Request;
    describeServiceAccessPolicies(params: CloudSearch.DescribeServiceAccessPoliciesRequest, callback?: (err: CloudSearch.BaseException|CloudSearch.InternalException|CloudSearch.ResourceNotFoundException|any, data: CloudSearch.DescribeServiceAccessPoliciesResponse|any) => void): Request;
    describeSuggesters(params: CloudSearch.DescribeSuggestersRequest, callback?: (err: CloudSearch.BaseException|CloudSearch.InternalException|CloudSearch.ResourceNotFoundException|any, data: CloudSearch.DescribeSuggestersResponse|any) => void): Request;
    indexDocuments(params: CloudSearch.IndexDocumentsRequest, callback?: (err: CloudSearch.BaseException|CloudSearch.InternalException|CloudSearch.ResourceNotFoundException|any, data: CloudSearch.IndexDocumentsResponse|any) => void): Request;
    listDomainNames(callback?: (err: CloudSearch.BaseException|any, data: CloudSearch.ListDomainNamesResponse|any) => void): Request;
    updateAvailabilityOptions(params: CloudSearch.UpdateAvailabilityOptionsRequest, callback?: (err: CloudSearch.BaseException|CloudSearch.InternalException|CloudSearch.InvalidTypeException|CloudSearch.LimitExceededException|CloudSearch.ResourceNotFoundException|CloudSearch.DisabledOperationException|any, data: CloudSearch.UpdateAvailabilityOptionsResponse|any) => void): Request;
    updateScalingParameters(params: CloudSearch.UpdateScalingParametersRequest, callback?: (err: CloudSearch.BaseException|CloudSearch.InternalException|CloudSearch.LimitExceededException|CloudSearch.ResourceNotFoundException|CloudSearch.InvalidTypeException|any, data: CloudSearch.UpdateScalingParametersResponse|any) => void): Request;
    updateServiceAccessPolicies(params: CloudSearch.UpdateServiceAccessPoliciesRequest, callback?: (err: CloudSearch.BaseException|CloudSearch.InternalException|CloudSearch.LimitExceededException|CloudSearch.ResourceNotFoundException|CloudSearch.InvalidTypeException|any, data: CloudSearch.UpdateServiceAccessPoliciesResponse|any) => void): Request;

  }

  export module CloudSearch {
    export type APIVersion = string;
    export type ARN = string;
    export type AlgorithmicStemming = string;
    export type AnalysisSchemeLanguage = string;
    export type AnalysisSchemeStatusList = AnalysisSchemeStatus[];
    export type Boolean = boolean;
    export type DomainId = string;    // max: 64, min: 1
    export type DomainName = string;    // pattern: &quot;[a-z][a-z0-9\-]+&quot;, max: 28, min: 3
    export type DomainNameList = DomainName[];
    export type DomainNameMap = {[key:string]: APIVersion};
    export type DomainStatusList = DomainStatus[];
    export type Double = number;
    export type DynamicFieldName = string;    // pattern: &quot;([a-z][a-z0-9_]*\*?|\*[a-z0-9_]*)&quot;, max: 64, min: 1
    export type DynamicFieldNameList = DynamicFieldName[];
    export type ErrorCode = string;
    export type ErrorMessage = string;
    export type ExpressionStatusList = ExpressionStatus[];
    export type ExpressionValue = string;    // max: 10240, min: 1
    export type FieldName = string;    // pattern: &quot;[a-z][a-z0-9_]*&quot;, max: 64, min: 1
    export type FieldNameCommaList = string;    // pattern: &quot;\s*[a-z*][a-z0-9_]*\*?\s*(,\s*[a-z*][a-z0-9_]*\*?\s*)*&quot;
    export type FieldNameList = FieldName[];
    export type FieldValue = string;    // max: 1024
    export type IndexFieldStatusList = IndexFieldStatus[];
    export type IndexFieldType = string;
    export type InstanceCount = number;    // min: 1
    export type Long = number;
    export type MaximumPartitionCount = number;    // min: 1
    export type MaximumReplicationCount = number;    // min: 1
    export type MultiAZ = boolean;
    export type OptionState = string;
    export type PartitionCount = number;    // min: 1
    export type PartitionInstanceType = string;
    export type PolicyDocument = string;
    export type SearchInstanceType = string;
    export type ServiceUrl = string;
    export type StandardName = string;    // pattern: &quot;[a-z][a-z0-9_]*&quot;, max: 64, min: 1
    export type StandardNameList = StandardName[];
    export type String = string;
    export type SuggesterFuzzyMatching = string;
    export type SuggesterStatusList = SuggesterStatus[];
    export type UIntValue = number;
    export type UpdateTimestamp = number;
    export type Word = string;    // pattern: &quot;[\S]+&quot;

    export interface AccessPoliciesStatus {
        Options: PolicyDocument;
        Status: OptionStatus;
    }
    export interface AnalysisOptions {
        Synonyms?: String;
        Stopwords?: String;
        StemmingDictionary?: String;
        JapaneseTokenizationDictionary?: String;
        AlgorithmicStemming?: AlgorithmicStemming;
    }
    export interface AnalysisScheme {
        AnalysisSchemeName: StandardName;
        AnalysisSchemeLanguage: AnalysisSchemeLanguage;
        AnalysisOptions?: AnalysisOptions;
    }
    export interface AnalysisSchemeStatus {
        Options: AnalysisScheme;
        Status: OptionStatus;
    }
    export interface AvailabilityOptionsStatus {
        Options: MultiAZ;
        Status: OptionStatus;
    }
    export interface BaseException {
        Code?: ErrorCode;
        Message?: ErrorMessage;
    }
    export interface BuildSuggestersRequest {
        DomainName: DomainName;
    }
    export interface BuildSuggestersResponse {
        FieldNames?: FieldNameList;
    }
    export interface CreateDomainRequest {
        DomainName: DomainName;
    }
    export interface CreateDomainResponse {
        DomainStatus?: DomainStatus;
    }
    export interface DateArrayOptions {
        DefaultValue?: FieldValue;
        SourceFields?: FieldNameCommaList;
        FacetEnabled?: Boolean;
        SearchEnabled?: Boolean;
        ReturnEnabled?: Boolean;
    }
    export interface DateOptions {
        DefaultValue?: FieldValue;
        SourceField?: FieldName;
        FacetEnabled?: Boolean;
        SearchEnabled?: Boolean;
        ReturnEnabled?: Boolean;
        SortEnabled?: Boolean;
    }
    export interface DefineAnalysisSchemeRequest {
        DomainName: DomainName;
        AnalysisScheme: AnalysisScheme;
    }
    export interface DefineAnalysisSchemeResponse {
        AnalysisScheme: AnalysisSchemeStatus;
    }
    export interface DefineExpressionRequest {
        DomainName: DomainName;
        Expression: Expression;
    }
    export interface DefineExpressionResponse {
        Expression: ExpressionStatus;
    }
    export interface DefineIndexFieldRequest {
        DomainName: DomainName;
        IndexField: IndexField;
    }
    export interface DefineIndexFieldResponse {
        IndexField: IndexFieldStatus;
    }
    export interface DefineSuggesterRequest {
        DomainName: DomainName;
        Suggester: Suggester;
    }
    export interface DefineSuggesterResponse {
        Suggester: SuggesterStatus;
    }
    export interface DeleteAnalysisSchemeRequest {
        DomainName: DomainName;
        AnalysisSchemeName: StandardName;
    }
    export interface DeleteAnalysisSchemeResponse {
        AnalysisScheme: AnalysisSchemeStatus;
    }
    export interface DeleteDomainRequest {
        DomainName: DomainName;
    }
    export interface DeleteDomainResponse {
        DomainStatus?: DomainStatus;
    }
    export interface DeleteExpressionRequest {
        DomainName: DomainName;
        ExpressionName: StandardName;
    }
    export interface DeleteExpressionResponse {
        Expression: ExpressionStatus;
    }
    export interface DeleteIndexFieldRequest {
        DomainName: DomainName;
        IndexFieldName: DynamicFieldName;
    }
    export interface DeleteIndexFieldResponse {
        IndexField: IndexFieldStatus;
    }
    export interface DeleteSuggesterRequest {
        DomainName: DomainName;
        SuggesterName: StandardName;
    }
    export interface DeleteSuggesterResponse {
        Suggester: SuggesterStatus;
    }
    export interface DescribeAnalysisSchemesRequest {
        DomainName: DomainName;
        AnalysisSchemeNames?: StandardNameList;
        Deployed?: Boolean;
    }
    export interface DescribeAnalysisSchemesResponse {
        AnalysisSchemes: AnalysisSchemeStatusList;
    }
    export interface DescribeAvailabilityOptionsRequest {
        DomainName: DomainName;
        Deployed?: Boolean;
    }
    export interface DescribeAvailabilityOptionsResponse {
        AvailabilityOptions?: AvailabilityOptionsStatus;
    }
    export interface DescribeDomainsRequest {
        DomainNames?: DomainNameList;
    }
    export interface DescribeDomainsResponse {
        DomainStatusList: DomainStatusList;
    }
    export interface DescribeExpressionsRequest {
        DomainName: DomainName;
        ExpressionNames?: StandardNameList;
        Deployed?: Boolean;
    }
    export interface DescribeExpressionsResponse {
        Expressions: ExpressionStatusList;
    }
    export interface DescribeIndexFieldsRequest {
        DomainName: DomainName;
        FieldNames?: DynamicFieldNameList;
        Deployed?: Boolean;
    }
    export interface DescribeIndexFieldsResponse {
        IndexFields: IndexFieldStatusList;
    }
    export interface DescribeScalingParametersRequest {
        DomainName: DomainName;
    }
    export interface DescribeScalingParametersResponse {
        ScalingParameters: ScalingParametersStatus;
    }
    export interface DescribeServiceAccessPoliciesRequest {
        DomainName: DomainName;
        Deployed?: Boolean;
    }
    export interface DescribeServiceAccessPoliciesResponse {
        AccessPolicies: AccessPoliciesStatus;
    }
    export interface DescribeSuggestersRequest {
        DomainName: DomainName;
        SuggesterNames?: StandardNameList;
        Deployed?: Boolean;
    }
    export interface DescribeSuggestersResponse {
        Suggesters: SuggesterStatusList;
    }
    export interface DisabledOperationException {
    }
    export interface DocumentSuggesterOptions {
        SourceField: FieldName;
        FuzzyMatching?: SuggesterFuzzyMatching;
        SortExpression?: String;
    }
    export interface DomainStatus {
        DomainId: DomainId;
        DomainName: DomainName;
        ARN?: ARN;
        Created?: Boolean;
        Deleted?: Boolean;
        DocService?: ServiceEndpoint;
        SearchService?: ServiceEndpoint;
        RequiresIndexDocuments: Boolean;
        Processing?: Boolean;
        SearchInstanceType?: SearchInstanceType;
        SearchPartitionCount?: PartitionCount;
        SearchInstanceCount?: InstanceCount;
        Limits?: Limits;
    }
    export interface DoubleArrayOptions {
        DefaultValue?: Double;
        SourceFields?: FieldNameCommaList;
        FacetEnabled?: Boolean;
        SearchEnabled?: Boolean;
        ReturnEnabled?: Boolean;
    }
    export interface DoubleOptions {
        DefaultValue?: Double;
        SourceField?: FieldName;
        FacetEnabled?: Boolean;
        SearchEnabled?: Boolean;
        ReturnEnabled?: Boolean;
        SortEnabled?: Boolean;
    }
    export interface Expression {
        ExpressionName: StandardName;
        ExpressionValue: ExpressionValue;
    }
    export interface ExpressionStatus {
        Options: Expression;
        Status: OptionStatus;
    }
    export interface IndexDocumentsRequest {
        DomainName: DomainName;
    }
    export interface IndexDocumentsResponse {
        FieldNames?: FieldNameList;
    }
    export interface IndexField {
        IndexFieldName: DynamicFieldName;
        IndexFieldType: IndexFieldType;
        IntOptions?: IntOptions;
        DoubleOptions?: DoubleOptions;
        LiteralOptions?: LiteralOptions;
        TextOptions?: TextOptions;
        DateOptions?: DateOptions;
        LatLonOptions?: LatLonOptions;
        IntArrayOptions?: IntArrayOptions;
        DoubleArrayOptions?: DoubleArrayOptions;
        LiteralArrayOptions?: LiteralArrayOptions;
        TextArrayOptions?: TextArrayOptions;
        DateArrayOptions?: DateArrayOptions;
    }
    export interface IndexFieldStatus {
        Options: IndexField;
        Status: OptionStatus;
    }
    export interface IntArrayOptions {
        DefaultValue?: Long;
        SourceFields?: FieldNameCommaList;
        FacetEnabled?: Boolean;
        SearchEnabled?: Boolean;
        ReturnEnabled?: Boolean;
    }
    export interface IntOptions {
        DefaultValue?: Long;
        SourceField?: FieldName;
        FacetEnabled?: Boolean;
        SearchEnabled?: Boolean;
        ReturnEnabled?: Boolean;
        SortEnabled?: Boolean;
    }
    export interface InternalException {
    }
    export interface InvalidTypeException {
    }
    export interface LatLonOptions {
        DefaultValue?: FieldValue;
        SourceField?: FieldName;
        FacetEnabled?: Boolean;
        SearchEnabled?: Boolean;
        ReturnEnabled?: Boolean;
        SortEnabled?: Boolean;
    }
    export interface LimitExceededException {
    }
    export interface Limits {
        MaximumReplicationCount: MaximumReplicationCount;
        MaximumPartitionCount: MaximumPartitionCount;
    }
    export interface ListDomainNamesResponse {
        DomainNames?: DomainNameMap;
    }
    export interface LiteralArrayOptions {
        DefaultValue?: FieldValue;
        SourceFields?: FieldNameCommaList;
        FacetEnabled?: Boolean;
        SearchEnabled?: Boolean;
        ReturnEnabled?: Boolean;
    }
    export interface LiteralOptions {
        DefaultValue?: FieldValue;
        SourceField?: FieldName;
        FacetEnabled?: Boolean;
        SearchEnabled?: Boolean;
        ReturnEnabled?: Boolean;
        SortEnabled?: Boolean;
    }
    export interface OptionStatus {
        CreationDate: UpdateTimestamp;
        UpdateDate: UpdateTimestamp;
        UpdateVersion?: UIntValue;
        State: OptionState;
        PendingDeletion?: Boolean;
    }
    export interface ResourceNotFoundException {
    }
    export interface ScalingParameters {
        DesiredInstanceType?: PartitionInstanceType;
        DesiredReplicationCount?: UIntValue;
        DesiredPartitionCount?: UIntValue;
    }
    export interface ScalingParametersStatus {
        Options: ScalingParameters;
        Status: OptionStatus;
    }
    export interface ServiceEndpoint {
        Endpoint?: ServiceUrl;
    }
    export interface Suggester {
        SuggesterName: StandardName;
        DocumentSuggesterOptions: DocumentSuggesterOptions;
    }
    export interface SuggesterStatus {
        Options: Suggester;
        Status: OptionStatus;
    }
    export interface TextArrayOptions {
        DefaultValue?: FieldValue;
        SourceFields?: FieldNameCommaList;
        ReturnEnabled?: Boolean;
        HighlightEnabled?: Boolean;
        AnalysisScheme?: Word;
    }
    export interface TextOptions {
        DefaultValue?: FieldValue;
        SourceField?: FieldName;
        ReturnEnabled?: Boolean;
        SortEnabled?: Boolean;
        HighlightEnabled?: Boolean;
        AnalysisScheme?: Word;
    }
    export interface UpdateAvailabilityOptionsRequest {
        DomainName: DomainName;
        MultiAZ: Boolean;
    }
    export interface UpdateAvailabilityOptionsResponse {
        AvailabilityOptions?: AvailabilityOptionsStatus;
    }
    export interface UpdateScalingParametersRequest {
        DomainName: DomainName;
        ScalingParameters: ScalingParameters;
    }
    export interface UpdateScalingParametersResponse {
        ScalingParameters: ScalingParametersStatus;
    }
    export interface UpdateServiceAccessPoliciesRequest {
        DomainName: DomainName;
        AccessPolicies: PolicyDocument;
    }
    export interface UpdateServiceAccessPoliciesResponse {
        AccessPolicies: AccessPoliciesStatus;
    }
  }

  /*
   * apiVersion: 2013-01-01
   * endpointPrefix: cloudsearchdomain
   * serviceAbbreviation: 
   * signatureVersion: v4
   * protocol: rest-json
   */
  export class CloudSearchDomain extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    search(params: CloudSearchDomain.SearchRequest, callback?: (err: CloudSearchDomain.SearchException|any, data: CloudSearchDomain.SearchResponse|any) => void): Request;
    suggest(params: CloudSearchDomain.SuggestRequest, callback?: (err: CloudSearchDomain.SearchException|any, data: CloudSearchDomain.SuggestResponse|any) => void): Request;
    uploadDocuments(params: CloudSearchDomain.UploadDocumentsRequest, callback?: (err: CloudSearchDomain.DocumentServiceException|any, data: CloudSearchDomain.UploadDocumentsResponse|any) => void): Request;

  }

  export module CloudSearchDomain {
    export type Adds = number;
    export type Blob = any;    // type: blob
    export type BucketList = Bucket[];
    export type ContentType = string;
    export type Cursor = string;
    export type Deletes = number;
    export type DocumentServiceWarnings = DocumentServiceWarning[];
    export type Double = number;
    export type Expr = string;
    export type Exprs = {[key:string]: String};
    export type Facet = string;
    export type Facets = {[key:string]: BucketInfo};
    export type FieldValue = String[];
    export type Fields = {[key:string]: FieldValue};
    export type FilterQuery = string;
    export type Highlight = string;
    export type Highlights = {[key:string]: String};
    export type HitList = Hit[];
    export type Long = number;
    export type Partial = boolean;
    export type Query = string;
    export type QueryOptions = string;
    export type QueryParser = string;
    export type Return = string;
    export type Size = number;
    export type Sort = string;
    export type Start = number;
    export type Stat = string;
    export type Stats = {[key:string]: FieldStats};
    export type String = string;
    export type Suggester = string;
    export type Suggestions = SuggestionMatch[];
    export type SuggestionsSize = number;

    export interface Bucket {
        value?: String;
        count?: Long;
    }
    export interface BucketInfo {
        buckets?: BucketList;
    }
    export interface DocumentServiceException {
        status?: String;
        message?: String;
    }
    export interface DocumentServiceWarning {
        message?: String;
    }
    export interface FieldStats {
        min?: String;
        max?: String;
        count?: Long;
        missing?: Long;
        sum?: Double;
        sumOfSquares?: Double;
        mean?: String;
        stddev?: Double;
    }
    export interface Hit {
        id?: String;
        fields?: Fields;
        exprs?: Exprs;
        highlights?: Highlights;
    }
    export interface Hits {
        found?: Long;
        start?: Long;
        cursor?: String;
        hit?: HitList;
    }
    export interface SearchException {
        message?: String;
    }
    export interface SearchRequest {
        cursor?: Cursor;
        expr?: Expr;
        facet?: Facet;
        filterQuery?: FilterQuery;
        highlight?: Highlight;
        partial?: Partial;
        query: Query;
        queryOptions?: QueryOptions;
        queryParser?: QueryParser;
        return?: Return;
        size?: Size;
        sort?: Sort;
        start?: Start;
        stats?: Stat;
    }
    export interface SearchResponse {
        status?: SearchStatus;
        hits?: Hits;
        facets?: Facets;
        stats?: Stats;
    }
    export interface SearchStatus {
        timems?: Long;
        rid?: String;
    }
    export interface SuggestModel {
        query?: String;
        found?: Long;
        suggestions?: Suggestions;
    }
    export interface SuggestRequest {
        query: Query;
        suggester: Suggester;
        size?: SuggestionsSize;
    }
    export interface SuggestResponse {
        status?: SuggestStatus;
        suggest?: SuggestModel;
    }
    export interface SuggestStatus {
        timems?: Long;
        rid?: String;
    }
    export interface SuggestionMatch {
        suggestion?: String;
        score?: Long;
        id?: String;
    }
    export interface UploadDocumentsRequest {
        documents: Blob;
        contentType: ContentType;
    }
    export interface UploadDocumentsResponse {
        status?: String;
        adds?: Adds;
        deletes?: Deletes;
        warnings?: DocumentServiceWarnings;
    }
  }

  /*
   * apiVersion: 2013-11-01
   * endpointPrefix: cloudtrail
   * serviceAbbreviation: CloudTrail
   * signatureVersion: v4
   * protocol: json
   */
  export class CloudTrail extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    addTags(params: CloudTrail.AddTagsRequest, callback?: (err: CloudTrail.ResourceNotFoundException|CloudTrail.CloudTrailARNInvalidException|CloudTrail.ResourceTypeNotSupportedException|CloudTrail.TagsLimitExceededException|CloudTrail.InvalidTrailNameException|CloudTrail.InvalidTagParameterException|CloudTrail.UnsupportedOperationException|CloudTrail.OperationNotPermittedException|any, data: CloudTrail.AddTagsResponse|any) => void): Request;
    createTrail(params: CloudTrail.CreateTrailRequest, callback?: (err: CloudTrail.MaximumNumberOfTrailsExceededException|CloudTrail.TrailAlreadyExistsException|CloudTrail.S3BucketDoesNotExistException|CloudTrail.InsufficientS3BucketPolicyException|CloudTrail.InsufficientSnsTopicPolicyException|CloudTrail.InsufficientEncryptionPolicyException|CloudTrail.InvalidS3BucketNameException|CloudTrail.InvalidS3PrefixException|CloudTrail.InvalidSnsTopicNameException|CloudTrail.InvalidKmsKeyIdException|CloudTrail.InvalidTrailNameException|CloudTrail.TrailNotProvidedException|CloudTrail.InvalidParameterCombinationException|CloudTrail.KmsKeyNotFoundException|CloudTrail.KmsKeyDisabledException|CloudTrail.InvalidCloudWatchLogsLogGroupArnException|CloudTrail.InvalidCloudWatchLogsRoleArnException|CloudTrail.CloudWatchLogsDeliveryUnavailableException|CloudTrail.UnsupportedOperationException|CloudTrail.OperationNotPermittedException|any, data: CloudTrail.CreateTrailResponse|any) => void): Request;
    deleteTrail(params: CloudTrail.DeleteTrailRequest, callback?: (err: CloudTrail.TrailNotFoundException|CloudTrail.InvalidTrailNameException|CloudTrail.InvalidHomeRegionException|any, data: CloudTrail.DeleteTrailResponse|any) => void): Request;
    describeTrails(params: CloudTrail.DescribeTrailsRequest, callback?: (err: CloudTrail.UnsupportedOperationException|CloudTrail.OperationNotPermittedException|any, data: CloudTrail.DescribeTrailsResponse|any) => void): Request;
    getTrailStatus(params: CloudTrail.GetTrailStatusRequest, callback?: (err: CloudTrail.TrailNotFoundException|CloudTrail.InvalidTrailNameException|any, data: CloudTrail.GetTrailStatusResponse|any) => void): Request;
    listPublicKeys(params: CloudTrail.ListPublicKeysRequest, callback?: (err: CloudTrail.InvalidTimeRangeException|CloudTrail.UnsupportedOperationException|CloudTrail.OperationNotPermittedException|CloudTrail.InvalidTokenException|any, data: CloudTrail.ListPublicKeysResponse|any) => void): Request;
    listTags(params: CloudTrail.ListTagsRequest, callback?: (err: CloudTrail.ResourceNotFoundException|CloudTrail.CloudTrailARNInvalidException|CloudTrail.ResourceTypeNotSupportedException|CloudTrail.InvalidTrailNameException|CloudTrail.UnsupportedOperationException|CloudTrail.OperationNotPermittedException|CloudTrail.InvalidTokenException|any, data: CloudTrail.ListTagsResponse|any) => void): Request;
    lookupEvents(params: CloudTrail.LookupEventsRequest, callback?: (err: CloudTrail.InvalidLookupAttributesException|CloudTrail.InvalidTimeRangeException|CloudTrail.InvalidMaxResultsException|CloudTrail.InvalidNextTokenException|any, data: CloudTrail.LookupEventsResponse|any) => void): Request;
    removeTags(params: CloudTrail.RemoveTagsRequest, callback?: (err: CloudTrail.ResourceNotFoundException|CloudTrail.CloudTrailARNInvalidException|CloudTrail.ResourceTypeNotSupportedException|CloudTrail.InvalidTrailNameException|CloudTrail.InvalidTagParameterException|CloudTrail.UnsupportedOperationException|CloudTrail.OperationNotPermittedException|any, data: CloudTrail.RemoveTagsResponse|any) => void): Request;
    startLogging(params: CloudTrail.StartLoggingRequest, callback?: (err: CloudTrail.TrailNotFoundException|CloudTrail.InvalidTrailNameException|CloudTrail.InvalidHomeRegionException|any, data: CloudTrail.StartLoggingResponse|any) => void): Request;
    stopLogging(params: CloudTrail.StopLoggingRequest, callback?: (err: CloudTrail.TrailNotFoundException|CloudTrail.InvalidTrailNameException|CloudTrail.InvalidHomeRegionException|any, data: CloudTrail.StopLoggingResponse|any) => void): Request;
    updateTrail(params: CloudTrail.UpdateTrailRequest, callback?: (err: CloudTrail.S3BucketDoesNotExistException|CloudTrail.InsufficientS3BucketPolicyException|CloudTrail.InsufficientSnsTopicPolicyException|CloudTrail.InsufficientEncryptionPolicyException|CloudTrail.TrailNotFoundException|CloudTrail.InvalidS3BucketNameException|CloudTrail.InvalidS3PrefixException|CloudTrail.InvalidSnsTopicNameException|CloudTrail.InvalidKmsKeyIdException|CloudTrail.InvalidTrailNameException|CloudTrail.TrailNotProvidedException|CloudTrail.InvalidParameterCombinationException|CloudTrail.InvalidHomeRegionException|CloudTrail.KmsKeyNotFoundException|CloudTrail.KmsKeyDisabledException|CloudTrail.InvalidCloudWatchLogsLogGroupArnException|CloudTrail.InvalidCloudWatchLogsRoleArnException|CloudTrail.CloudWatchLogsDeliveryUnavailableException|CloudTrail.UnsupportedOperationException|CloudTrail.OperationNotPermittedException|any, data: CloudTrail.UpdateTrailResponse|any) => void): Request;

  }

  export module CloudTrail {
    export type Boolean = boolean;
    export type ByteBuffer = any;    // type: blob
    export type Date = number;
    export type EventsList = Event[];
    export type LookupAttributeKey = string;
    export type LookupAttributesList = LookupAttribute[];
    export type MaxResults = number;    // max: 50, min: 1
    export type NextToken = string;
    export type PublicKeyList = PublicKey[];
    export type ResourceIdList = String[];
    export type ResourceList = Resource[];
    export type ResourceTagList = ResourceTag[];
    export type String = string;
    export type TagsList = Tag[];
    export type TrailList = Trail[];
    export type TrailNameList = String[];

    export interface AddTagsRequest {
        ResourceId: String;
        TagsList?: TagsList;
    }
    export interface AddTagsResponse {
    }
    export interface CloudTrailARNInvalidException {
    }
    export interface CloudWatchLogsDeliveryUnavailableException {
    }
    export interface CreateTrailRequest {
        Name: String;
        S3BucketName: String;
        S3KeyPrefix?: String;
        SnsTopicName?: String;
        IncludeGlobalServiceEvents?: Boolean;
        IsMultiRegionTrail?: Boolean;
        EnableLogFileValidation?: Boolean;
        CloudWatchLogsLogGroupArn?: String;
        CloudWatchLogsRoleArn?: String;
        KmsKeyId?: String;
    }
    export interface CreateTrailResponse {
        Name?: String;
        S3BucketName?: String;
        S3KeyPrefix?: String;
        SnsTopicName?: String;
        IncludeGlobalServiceEvents?: Boolean;
        IsMultiRegionTrail?: Boolean;
        TrailARN?: String;
        LogFileValidationEnabled?: Boolean;
        CloudWatchLogsLogGroupArn?: String;
        CloudWatchLogsRoleArn?: String;
        KmsKeyId?: String;
    }
    export interface DeleteTrailRequest {
        Name: String;
    }
    export interface DeleteTrailResponse {
    }
    export interface DescribeTrailsRequest {
        trailNameList?: TrailNameList;
        includeShadowTrails?: Boolean;
    }
    export interface DescribeTrailsResponse {
        trailList?: TrailList;
    }
    export interface Event {
        EventId?: String;
        EventName?: String;
        EventTime?: Date;
        Username?: String;
        Resources?: ResourceList;
        CloudTrailEvent?: String;
    }
    export interface GetTrailStatusRequest {
        Name: String;
    }
    export interface GetTrailStatusResponse {
        IsLogging?: Boolean;
        LatestDeliveryError?: String;
        LatestNotificationError?: String;
        LatestDeliveryTime?: Date;
        LatestNotificationTime?: Date;
        StartLoggingTime?: Date;
        StopLoggingTime?: Date;
        LatestCloudWatchLogsDeliveryError?: String;
        LatestCloudWatchLogsDeliveryTime?: Date;
        LatestDigestDeliveryTime?: Date;
        LatestDigestDeliveryError?: String;
        LatestDeliveryAttemptTime?: String;
        LatestNotificationAttemptTime?: String;
        LatestNotificationAttemptSucceeded?: String;
        LatestDeliveryAttemptSucceeded?: String;
        TimeLoggingStarted?: String;
        TimeLoggingStopped?: String;
    }
    export interface InsufficientEncryptionPolicyException {
    }
    export interface InsufficientS3BucketPolicyException {
    }
    export interface InsufficientSnsTopicPolicyException {
    }
    export interface InvalidCloudWatchLogsLogGroupArnException {
    }
    export interface InvalidCloudWatchLogsRoleArnException {
    }
    export interface InvalidHomeRegionException {
    }
    export interface InvalidKmsKeyIdException {
    }
    export interface InvalidLookupAttributesException {
    }
    export interface InvalidMaxResultsException {
    }
    export interface InvalidNextTokenException {
    }
    export interface InvalidParameterCombinationException {
    }
    export interface InvalidS3BucketNameException {
    }
    export interface InvalidS3PrefixException {
    }
    export interface InvalidSnsTopicNameException {
    }
    export interface InvalidTagParameterException {
    }
    export interface InvalidTimeRangeException {
    }
    export interface InvalidTokenException {
    }
    export interface InvalidTrailNameException {
    }
    export interface KmsKeyDisabledException {
    }
    export interface KmsKeyNotFoundException {
    }
    export interface ListPublicKeysRequest {
        StartTime?: Date;
        EndTime?: Date;
        NextToken?: String;
    }
    export interface ListPublicKeysResponse {
        PublicKeyList?: PublicKeyList;
        NextToken?: String;
    }
    export interface ListTagsRequest {
        ResourceIdList: ResourceIdList;
        NextToken?: String;
    }
    export interface ListTagsResponse {
        ResourceTagList?: ResourceTagList;
        NextToken?: String;
    }
    export interface LookupAttribute {
        AttributeKey: LookupAttributeKey;
        AttributeValue: String;
    }
    export interface LookupEventsRequest {
        LookupAttributes?: LookupAttributesList;
        StartTime?: Date;
        EndTime?: Date;
        MaxResults?: MaxResults;
        NextToken?: NextToken;
    }
    export interface LookupEventsResponse {
        Events?: EventsList;
        NextToken?: NextToken;
    }
    export interface MaximumNumberOfTrailsExceededException {
    }
    export interface OperationNotPermittedException {
    }
    export interface PublicKey {
        Value?: ByteBuffer;
        ValidityStartTime?: Date;
        ValidityEndTime?: Date;
        Fingerprint?: String;
    }
    export interface RemoveTagsRequest {
        ResourceId: String;
        TagsList?: TagsList;
    }
    export interface RemoveTagsResponse {
    }
    export interface Resource {
        ResourceType?: String;
        ResourceName?: String;
    }
    export interface ResourceNotFoundException {
    }
    export interface ResourceTag {
        ResourceId?: String;
        TagsList?: TagsList;
    }
    export interface ResourceTypeNotSupportedException {
    }
    export interface S3BucketDoesNotExistException {
    }
    export interface StartLoggingRequest {
        Name: String;
    }
    export interface StartLoggingResponse {
    }
    export interface StopLoggingRequest {
        Name: String;
    }
    export interface StopLoggingResponse {
    }
    export interface Tag {
        Key: String;
        Value?: String;
    }
    export interface TagsLimitExceededException {
    }
    export interface Trail {
        Name?: String;
        S3BucketName?: String;
        S3KeyPrefix?: String;
        SnsTopicName?: String;
        IncludeGlobalServiceEvents?: Boolean;
        IsMultiRegionTrail?: Boolean;
        HomeRegion?: String;
        TrailARN?: String;
        LogFileValidationEnabled?: Boolean;
        CloudWatchLogsLogGroupArn?: String;
        CloudWatchLogsRoleArn?: String;
        KmsKeyId?: String;
    }
    export interface TrailAlreadyExistsException {
    }
    export interface TrailNotFoundException {
    }
    export interface TrailNotProvidedException {
    }
    export interface UnsupportedOperationException {
    }
    export interface UpdateTrailRequest {
        Name: String;
        S3BucketName?: String;
        S3KeyPrefix?: String;
        SnsTopicName?: String;
        IncludeGlobalServiceEvents?: Boolean;
        IsMultiRegionTrail?: Boolean;
        EnableLogFileValidation?: Boolean;
        CloudWatchLogsLogGroupArn?: String;
        CloudWatchLogsRoleArn?: String;
        KmsKeyId?: String;
    }
    export interface UpdateTrailResponse {
        Name?: String;
        S3BucketName?: String;
        S3KeyPrefix?: String;
        SnsTopicName?: String;
        IncludeGlobalServiceEvents?: Boolean;
        IsMultiRegionTrail?: Boolean;
        TrailARN?: String;
        LogFileValidationEnabled?: Boolean;
        CloudWatchLogsLogGroupArn?: String;
        CloudWatchLogsRoleArn?: String;
        KmsKeyId?: String;
    }
  }

  /*
   * apiVersion: 2010-08-01
   * endpointPrefix: monitoring
   * serviceAbbreviation: CloudWatch
   * signatureVersion: v4
   * protocol: query
   */
  export class CloudWatch extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    deleteAlarms(params: CloudWatch.DeleteAlarmsInput, callback?: (err: CloudWatch.ResourceNotFound|any, data: any) => void): Request;
    describeAlarmHistory(params: CloudWatch.DescribeAlarmHistoryInput, callback?: (err: CloudWatch.InvalidNextToken|any, data: CloudWatch.DescribeAlarmHistoryOutput|any) => void): Request;
    describeAlarms(params: CloudWatch.DescribeAlarmsInput, callback?: (err: CloudWatch.InvalidNextToken|any, data: CloudWatch.DescribeAlarmsOutput|any) => void): Request;
    describeAlarmsForMetric(params: CloudWatch.DescribeAlarmsForMetricInput, callback?: (err: any, data: CloudWatch.DescribeAlarmsForMetricOutput|any) => void): Request;
    disableAlarmActions(params: CloudWatch.DisableAlarmActionsInput, callback?: (err: any, data: any) => void): Request;
    enableAlarmActions(params: CloudWatch.EnableAlarmActionsInput, callback?: (err: any, data: any) => void): Request;
    getMetricStatistics(params: CloudWatch.GetMetricStatisticsInput, callback?: (err: CloudWatch.InvalidParameterValueException|CloudWatch.MissingRequiredParameterException|CloudWatch.InvalidParameterCombinationException|CloudWatch.InternalServiceFault|any, data: CloudWatch.GetMetricStatisticsOutput|any) => void): Request;
    listMetrics(params: CloudWatch.ListMetricsInput, callback?: (err: CloudWatch.InternalServiceFault|CloudWatch.InvalidParameterValueException|any, data: CloudWatch.ListMetricsOutput|any) => void): Request;
    putMetricAlarm(params: CloudWatch.PutMetricAlarmInput, callback?: (err: CloudWatch.LimitExceededFault|any, data: any) => void): Request;
    putMetricData(params: CloudWatch.PutMetricDataInput, callback?: (err: CloudWatch.InvalidParameterValueException|CloudWatch.MissingRequiredParameterException|CloudWatch.InvalidParameterCombinationException|CloudWatch.InternalServiceFault|any, data: any) => void): Request;
    setAlarmState(params: CloudWatch.SetAlarmStateInput, callback?: (err: CloudWatch.ResourceNotFound|CloudWatch.InvalidFormatFault|any, data: any) => void): Request;

  }

  export module CloudWatch {
    export type ActionPrefix = string;    // max: 1024, min: 1
    export type ActionsEnabled = boolean;
    export type AlarmArn = string;    // max: 1600, min: 1
    export type AlarmDescription = string;    // max: 1024
    export type AlarmHistoryItems = AlarmHistoryItem[];
    export type AlarmName = string;    // max: 255, min: 1
    export type AlarmNamePrefix = string;    // max: 255, min: 1
    export type AlarmNames = AlarmName[];    // max: 100
    export type AwsQueryErrorMessage = string;
    export type ComparisonOperator = string;
    export type DatapointValue = number;
    export type Datapoints = Datapoint[];
    export type DimensionFilters = DimensionFilter[];    // max: 10
    export type DimensionName = string;    // max: 255, min: 1
    export type DimensionValue = string;    // max: 255, min: 1
    export type Dimensions = Dimension[];    // max: 10
    export type ErrorMessage = string;    // max: 255, min: 1
    export type EvaluationPeriods = number;    // min: 1
    export type FaultDescription = string;
    export type HistoryData = string;    // max: 4095, min: 1
    export type HistoryItemType = string;
    export type HistorySummary = string;    // max: 255, min: 1
    export type MaxRecords = number;    // max: 100, min: 1
    export type MetricAlarms = MetricAlarm[];
    export type MetricData = MetricDatum[];
    export type MetricLabel = string;
    export type MetricName = string;    // max: 255, min: 1
    export type Metrics = Metric[];
    export type Namespace = string;    // pattern: &quot;[^:].*&quot;, max: 255, min: 1
    export type NextToken = string;    // max: 1024
    export type Period = number;    // min: 60
    export type ResourceList = ResourceName[];    // max: 5
    export type ResourceName = string;    // max: 1024, min: 1
    export type StandardUnit = string;
    export type StateReason = string;    // max: 1023
    export type StateReasonData = string;    // max: 4000
    export type StateValue = string;
    export type Statistic = string;
    export type Statistics = Statistic[];    // max: 5, min: 1
    export type Threshold = number;
    export type Timestamp = number;

    export interface AlarmHistoryItem {
        AlarmName?: AlarmName;
        Timestamp?: Timestamp;
        HistoryItemType?: HistoryItemType;
        HistorySummary?: HistorySummary;
        HistoryData?: HistoryData;
    }
    export interface Datapoint {
        Timestamp?: Timestamp;
        SampleCount?: DatapointValue;
        Average?: DatapointValue;
        Sum?: DatapointValue;
        Minimum?: DatapointValue;
        Maximum?: DatapointValue;
        Unit?: StandardUnit;
    }
    export interface DeleteAlarmsInput {
        AlarmNames: AlarmNames;
    }
    export interface DescribeAlarmHistoryInput {
        AlarmName?: AlarmName;
        HistoryItemType?: HistoryItemType;
        StartDate?: Timestamp;
        EndDate?: Timestamp;
        MaxRecords?: MaxRecords;
        NextToken?: NextToken;
    }
    export interface DescribeAlarmHistoryOutput {
        AlarmHistoryItems?: AlarmHistoryItems;
        NextToken?: NextToken;
    }
    export interface DescribeAlarmsForMetricInput {
        MetricName: MetricName;
        Namespace: Namespace;
        Statistic?: Statistic;
        Dimensions?: Dimensions;
        Period?: Period;
        Unit?: StandardUnit;
    }
    export interface DescribeAlarmsForMetricOutput {
        MetricAlarms?: MetricAlarms;
    }
    export interface DescribeAlarmsInput {
        AlarmNames?: AlarmNames;
        AlarmNamePrefix?: AlarmNamePrefix;
        StateValue?: StateValue;
        ActionPrefix?: ActionPrefix;
        MaxRecords?: MaxRecords;
        NextToken?: NextToken;
    }
    export interface DescribeAlarmsOutput {
        MetricAlarms?: MetricAlarms;
        NextToken?: NextToken;
    }
    export interface Dimension {
        Name: DimensionName;
        Value: DimensionValue;
    }
    export interface DimensionFilter {
        Name: DimensionName;
        Value?: DimensionValue;
    }
    export interface DisableAlarmActionsInput {
        AlarmNames: AlarmNames;
    }
    export interface EnableAlarmActionsInput {
        AlarmNames: AlarmNames;
    }
    export interface GetMetricStatisticsInput {
        Namespace: Namespace;
        MetricName: MetricName;
        Dimensions?: Dimensions;
        StartTime: Timestamp;
        EndTime: Timestamp;
        Period: Period;
        Statistics: Statistics;
        Unit?: StandardUnit;
    }
    export interface GetMetricStatisticsOutput {
        Label?: MetricLabel;
        Datapoints?: Datapoints;
    }
    export interface InternalServiceFault {
        Message?: FaultDescription;
    }
    export interface InvalidFormatFault {
        message?: ErrorMessage;
    }
    export interface InvalidNextToken {
        message?: ErrorMessage;
    }
    export interface InvalidParameterCombinationException {
        message?: AwsQueryErrorMessage;
    }
    export interface InvalidParameterValueException {
        message?: AwsQueryErrorMessage;
    }
    export interface LimitExceededFault {
        message?: ErrorMessage;
    }
    export interface ListMetricsInput {
        Namespace?: Namespace;
        MetricName?: MetricName;
        Dimensions?: DimensionFilters;
        NextToken?: NextToken;
    }
    export interface ListMetricsOutput {
        Metrics?: Metrics;
        NextToken?: NextToken;
    }
    export interface Metric {
        Namespace?: Namespace;
        MetricName?: MetricName;
        Dimensions?: Dimensions;
    }
    export interface MetricAlarm {
        AlarmName?: AlarmName;
        AlarmArn?: AlarmArn;
        AlarmDescription?: AlarmDescription;
        AlarmConfigurationUpdatedTimestamp?: Timestamp;
        ActionsEnabled?: ActionsEnabled;
        OKActions?: ResourceList;
        AlarmActions?: ResourceList;
        InsufficientDataActions?: ResourceList;
        StateValue?: StateValue;
        StateReason?: StateReason;
        StateReasonData?: StateReasonData;
        StateUpdatedTimestamp?: Timestamp;
        MetricName?: MetricName;
        Namespace?: Namespace;
        Statistic?: Statistic;
        Dimensions?: Dimensions;
        Period?: Period;
        Unit?: StandardUnit;
        EvaluationPeriods?: EvaluationPeriods;
        Threshold?: Threshold;
        ComparisonOperator?: ComparisonOperator;
    }
    export interface MetricDatum {
        MetricName: MetricName;
        Dimensions?: Dimensions;
        Timestamp?: Timestamp;
        Value?: DatapointValue;
        StatisticValues?: StatisticSet;
        Unit?: StandardUnit;
    }
    export interface MissingRequiredParameterException {
        message?: AwsQueryErrorMessage;
    }
    export interface PutMetricAlarmInput {
        AlarmName: AlarmName;
        AlarmDescription?: AlarmDescription;
        ActionsEnabled?: ActionsEnabled;
        OKActions?: ResourceList;
        AlarmActions?: ResourceList;
        InsufficientDataActions?: ResourceList;
        MetricName: MetricName;
        Namespace: Namespace;
        Statistic: Statistic;
        Dimensions?: Dimensions;
        Period: Period;
        Unit?: StandardUnit;
        EvaluationPeriods: EvaluationPeriods;
        Threshold: Threshold;
        ComparisonOperator: ComparisonOperator;
    }
    export interface PutMetricDataInput {
        Namespace: Namespace;
        MetricData: MetricData;
    }
    export interface ResourceNotFound {
        message?: ErrorMessage;
    }
    export interface SetAlarmStateInput {
        AlarmName: AlarmName;
        StateValue: StateValue;
        StateReason: StateReason;
        StateReasonData?: StateReasonData;
    }
    export interface StatisticSet {
        SampleCount: DatapointValue;
        Sum: DatapointValue;
        Minimum: DatapointValue;
        Maximum: DatapointValue;
    }
  }

  /*
   * apiVersion: 2015-10-07
   * endpointPrefix: events
   * serviceAbbreviation: 
   * signatureVersion: v4
   * protocol: json
   */
  export class CloudWatchEvents extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    deleteRule(params: CloudWatchEvents.DeleteRuleRequest, callback?: (err: CloudWatchEvents.ConcurrentModificationException|CloudWatchEvents.InternalException|any, data: any) => void): Request;
    describeRule(params: CloudWatchEvents.DescribeRuleRequest, callback?: (err: CloudWatchEvents.ResourceNotFoundException|CloudWatchEvents.InternalException|any, data: CloudWatchEvents.DescribeRuleResponse|any) => void): Request;
    disableRule(params: CloudWatchEvents.DisableRuleRequest, callback?: (err: CloudWatchEvents.ResourceNotFoundException|CloudWatchEvents.ConcurrentModificationException|CloudWatchEvents.InternalException|any, data: any) => void): Request;
    enableRule(params: CloudWatchEvents.EnableRuleRequest, callback?: (err: CloudWatchEvents.ResourceNotFoundException|CloudWatchEvents.ConcurrentModificationException|CloudWatchEvents.InternalException|any, data: any) => void): Request;
    listRuleNamesByTarget(params: CloudWatchEvents.ListRuleNamesByTargetRequest, callback?: (err: CloudWatchEvents.InternalException|any, data: CloudWatchEvents.ListRuleNamesByTargetResponse|any) => void): Request;
    listRules(params: CloudWatchEvents.ListRulesRequest, callback?: (err: CloudWatchEvents.InternalException|any, data: CloudWatchEvents.ListRulesResponse|any) => void): Request;
    listTargetsByRule(params: CloudWatchEvents.ListTargetsByRuleRequest, callback?: (err: CloudWatchEvents.ResourceNotFoundException|CloudWatchEvents.InternalException|any, data: CloudWatchEvents.ListTargetsByRuleResponse|any) => void): Request;
    putEvents(params: CloudWatchEvents.PutEventsRequest, callback?: (err: CloudWatchEvents.InternalException|any, data: CloudWatchEvents.PutEventsResponse|any) => void): Request;
    putRule(params: CloudWatchEvents.PutRuleRequest, callback?: (err: CloudWatchEvents.InvalidEventPatternException|CloudWatchEvents.LimitExceededException|CloudWatchEvents.ConcurrentModificationException|CloudWatchEvents.InternalException|any, data: CloudWatchEvents.PutRuleResponse|any) => void): Request;
    putTargets(params: CloudWatchEvents.PutTargetsRequest, callback?: (err: CloudWatchEvents.ResourceNotFoundException|CloudWatchEvents.ConcurrentModificationException|CloudWatchEvents.LimitExceededException|CloudWatchEvents.InternalException|any, data: CloudWatchEvents.PutTargetsResponse|any) => void): Request;
    removeTargets(params: CloudWatchEvents.RemoveTargetsRequest, callback?: (err: CloudWatchEvents.ResourceNotFoundException|CloudWatchEvents.ConcurrentModificationException|CloudWatchEvents.InternalException|any, data: CloudWatchEvents.RemoveTargetsResponse|any) => void): Request;
    testEventPattern(params: CloudWatchEvents.TestEventPatternRequest, callback?: (err: CloudWatchEvents.InvalidEventPatternException|CloudWatchEvents.InternalException|any, data: CloudWatchEvents.TestEventPatternResponse|any) => void): Request;

  }

  export module CloudWatchEvents {
    export type Boolean = boolean;
    export type ErrorCode = string;
    export type ErrorMessage = string;
    export type EventId = string;
    export type EventPattern = string;    // max: 2048
    export type EventResource = string;
    export type EventResourceList = EventResource[];
    export type EventTime = number;
    export type Integer = number;
    export type LimitMax100 = number;    // max: 100, min: 1
    export type NextToken = string;    // max: 2048, min: 1
    export type PutEventsRequestEntryList = PutEventsRequestEntry[];    // max: 10, min: 1
    export type PutEventsResultEntryList = PutEventsResultEntry[];
    export type PutTargetsResultEntryList = PutTargetsResultEntry[];
    export type RemoveTargetsResultEntryList = RemoveTargetsResultEntry[];
    export type RoleArn = string;    // max: 1600, min: 1
    export type RuleArn = string;    // max: 1600, min: 1
    export type RuleDescription = string;    // max: 512
    export type RuleName = string;    // pattern: &quot;[\.\-_A-Za-z0-9]+&quot;, max: 64, min: 1
    export type RuleNameList = RuleName[];
    export type RuleResponseList = Rule[];
    export type RuleState = string;
    export type ScheduleExpression = string;    // max: 256
    export type String = string;
    export type TargetArn = string;    // max: 1600, min: 1
    export type TargetId = string;    // pattern: &quot;[\.\-_A-Za-z0-9]+&quot;, max: 64, min: 1
    export type TargetIdList = TargetId[];    // max: 100, min: 1
    export type TargetInput = string;    // max: 8192
    export type TargetInputPath = string;    // max: 256
    export type TargetList = Target[];

    export interface ConcurrentModificationException {
    }
    export interface DeleteRuleRequest {
        Name: RuleName;
    }
    export interface DescribeRuleRequest {
        Name: RuleName;
    }
    export interface DescribeRuleResponse {
        Name?: RuleName;
        Arn?: RuleArn;
        EventPattern?: EventPattern;
        ScheduleExpression?: ScheduleExpression;
        State?: RuleState;
        Description?: RuleDescription;
        RoleArn?: RoleArn;
    }
    export interface DisableRuleRequest {
        Name: RuleName;
    }
    export interface EnableRuleRequest {
        Name: RuleName;
    }
    export interface InternalException {
    }
    export interface InvalidEventPatternException {
    }
    export interface LimitExceededException {
    }
    export interface ListRuleNamesByTargetRequest {
        TargetArn: TargetArn;
        NextToken?: NextToken;
        Limit?: LimitMax100;
    }
    export interface ListRuleNamesByTargetResponse {
        RuleNames?: RuleNameList;
        NextToken?: NextToken;
    }
    export interface ListRulesRequest {
        NamePrefix?: RuleName;
        NextToken?: NextToken;
        Limit?: LimitMax100;
    }
    export interface ListRulesResponse {
        Rules?: RuleResponseList;
        NextToken?: NextToken;
    }
    export interface ListTargetsByRuleRequest {
        Rule: RuleName;
        NextToken?: NextToken;
        Limit?: LimitMax100;
    }
    export interface ListTargetsByRuleResponse {
        Targets?: TargetList;
        NextToken?: NextToken;
    }
    export interface PutEventsRequest {
        Entries: PutEventsRequestEntryList;
    }
    export interface PutEventsRequestEntry {
        Time?: EventTime;
        Source?: String;
        Resources?: EventResourceList;
        DetailType?: String;
        Detail?: String;
    }
    export interface PutEventsResponse {
        FailedEntryCount?: Integer;
        Entries?: PutEventsResultEntryList;
    }
    export interface PutEventsResultEntry {
        EventId?: EventId;
        ErrorCode?: ErrorCode;
        ErrorMessage?: ErrorMessage;
    }
    export interface PutRuleRequest {
        Name: RuleName;
        ScheduleExpression?: ScheduleExpression;
        EventPattern?: EventPattern;
        State?: RuleState;
        Description?: RuleDescription;
        RoleArn?: RoleArn;
    }
    export interface PutRuleResponse {
        RuleArn?: RuleArn;
    }
    export interface PutTargetsRequest {
        Rule: RuleName;
        Targets: TargetList;
    }
    export interface PutTargetsResponse {
        FailedEntryCount?: Integer;
        FailedEntries?: PutTargetsResultEntryList;
    }
    export interface PutTargetsResultEntry {
        TargetId?: TargetId;
        ErrorCode?: ErrorCode;
        ErrorMessage?: ErrorMessage;
    }
    export interface RemoveTargetsRequest {
        Rule: RuleName;
        Ids: TargetIdList;
    }
    export interface RemoveTargetsResponse {
        FailedEntryCount?: Integer;
        FailedEntries?: RemoveTargetsResultEntryList;
    }
    export interface RemoveTargetsResultEntry {
        TargetId?: TargetId;
        ErrorCode?: ErrorCode;
        ErrorMessage?: ErrorMessage;
    }
    export interface ResourceNotFoundException {
    }
    export interface Rule {
        Name?: RuleName;
        Arn?: RuleArn;
        EventPattern?: EventPattern;
        State?: RuleState;
        Description?: RuleDescription;
        ScheduleExpression?: ScheduleExpression;
        RoleArn?: RoleArn;
    }
    export interface Target {
        Id: TargetId;
        Arn: TargetArn;
        Input?: TargetInput;
        InputPath?: TargetInputPath;
    }
    export interface TestEventPatternRequest {
        EventPattern: EventPattern;
        Event: String;
    }
    export interface TestEventPatternResponse {
        Result?: Boolean;
    }
  }

  /*
   * apiVersion: 2014-03-28
   * endpointPrefix: logs
   * serviceAbbreviation: 
   * signatureVersion: v4
   * protocol: json
   */
  export class CloudWatchLogs extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    cancelExportTask(params: CloudWatchLogs.CancelExportTaskRequest, callback?: (err: CloudWatchLogs.InvalidParameterException|CloudWatchLogs.ResourceNotFoundException|CloudWatchLogs.InvalidOperationException|CloudWatchLogs.ServiceUnavailableException|any, data: any) => void): Request;
    createExportTask(params: CloudWatchLogs.CreateExportTaskRequest, callback?: (err: CloudWatchLogs.InvalidParameterException|CloudWatchLogs.LimitExceededException|CloudWatchLogs.OperationAbortedException|CloudWatchLogs.ServiceUnavailableException|CloudWatchLogs.ResourceNotFoundException|CloudWatchLogs.ResourceAlreadyExistsException|any, data: CloudWatchLogs.CreateExportTaskResponse|any) => void): Request;
    createLogGroup(params: CloudWatchLogs.CreateLogGroupRequest, callback?: (err: CloudWatchLogs.InvalidParameterException|CloudWatchLogs.ResourceAlreadyExistsException|CloudWatchLogs.LimitExceededException|CloudWatchLogs.OperationAbortedException|CloudWatchLogs.ServiceUnavailableException|any, data: any) => void): Request;
    createLogStream(params: CloudWatchLogs.CreateLogStreamRequest, callback?: (err: CloudWatchLogs.InvalidParameterException|CloudWatchLogs.ResourceAlreadyExistsException|CloudWatchLogs.ResourceNotFoundException|CloudWatchLogs.ServiceUnavailableException|any, data: any) => void): Request;
    deleteDestination(params: CloudWatchLogs.DeleteDestinationRequest, callback?: (err: CloudWatchLogs.InvalidParameterException|CloudWatchLogs.ResourceNotFoundException|CloudWatchLogs.OperationAbortedException|CloudWatchLogs.ServiceUnavailableException|any, data: any) => void): Request;
    deleteLogGroup(params: CloudWatchLogs.DeleteLogGroupRequest, callback?: (err: CloudWatchLogs.InvalidParameterException|CloudWatchLogs.ResourceNotFoundException|CloudWatchLogs.OperationAbortedException|CloudWatchLogs.ServiceUnavailableException|any, data: any) => void): Request;
    deleteLogStream(params: CloudWatchLogs.DeleteLogStreamRequest, callback?: (err: CloudWatchLogs.InvalidParameterException|CloudWatchLogs.ResourceNotFoundException|CloudWatchLogs.OperationAbortedException|CloudWatchLogs.ServiceUnavailableException|any, data: any) => void): Request;
    deleteMetricFilter(params: CloudWatchLogs.DeleteMetricFilterRequest, callback?: (err: CloudWatchLogs.InvalidParameterException|CloudWatchLogs.ResourceNotFoundException|CloudWatchLogs.OperationAbortedException|CloudWatchLogs.ServiceUnavailableException|any, data: any) => void): Request;
    deleteRetentionPolicy(params: CloudWatchLogs.DeleteRetentionPolicyRequest, callback?: (err: CloudWatchLogs.InvalidParameterException|CloudWatchLogs.ResourceNotFoundException|CloudWatchLogs.OperationAbortedException|CloudWatchLogs.ServiceUnavailableException|any, data: any) => void): Request;
    deleteSubscriptionFilter(params: CloudWatchLogs.DeleteSubscriptionFilterRequest, callback?: (err: CloudWatchLogs.InvalidParameterException|CloudWatchLogs.ResourceNotFoundException|CloudWatchLogs.OperationAbortedException|CloudWatchLogs.ServiceUnavailableException|any, data: any) => void): Request;
    describeDestinations(params: CloudWatchLogs.DescribeDestinationsRequest, callback?: (err: CloudWatchLogs.InvalidParameterException|CloudWatchLogs.ServiceUnavailableException|any, data: CloudWatchLogs.DescribeDestinationsResponse|any) => void): Request;
    describeExportTasks(params: CloudWatchLogs.DescribeExportTasksRequest, callback?: (err: CloudWatchLogs.InvalidParameterException|CloudWatchLogs.ServiceUnavailableException|any, data: CloudWatchLogs.DescribeExportTasksResponse|any) => void): Request;
    describeLogGroups(params: CloudWatchLogs.DescribeLogGroupsRequest, callback?: (err: CloudWatchLogs.InvalidParameterException|CloudWatchLogs.ServiceUnavailableException|any, data: CloudWatchLogs.DescribeLogGroupsResponse|any) => void): Request;
    describeLogStreams(params: CloudWatchLogs.DescribeLogStreamsRequest, callback?: (err: CloudWatchLogs.InvalidParameterException|CloudWatchLogs.ResourceNotFoundException|CloudWatchLogs.ServiceUnavailableException|any, data: CloudWatchLogs.DescribeLogStreamsResponse|any) => void): Request;
    describeMetricFilters(params: CloudWatchLogs.DescribeMetricFiltersRequest, callback?: (err: CloudWatchLogs.InvalidParameterException|CloudWatchLogs.ResourceNotFoundException|CloudWatchLogs.ServiceUnavailableException|any, data: CloudWatchLogs.DescribeMetricFiltersResponse|any) => void): Request;
    describeSubscriptionFilters(params: CloudWatchLogs.DescribeSubscriptionFiltersRequest, callback?: (err: CloudWatchLogs.InvalidParameterException|CloudWatchLogs.ResourceNotFoundException|CloudWatchLogs.ServiceUnavailableException|any, data: CloudWatchLogs.DescribeSubscriptionFiltersResponse|any) => void): Request;
    filterLogEvents(params: CloudWatchLogs.FilterLogEventsRequest, callback?: (err: CloudWatchLogs.InvalidParameterException|CloudWatchLogs.ResourceNotFoundException|CloudWatchLogs.ServiceUnavailableException|any, data: CloudWatchLogs.FilterLogEventsResponse|any) => void): Request;
    getLogEvents(params: CloudWatchLogs.GetLogEventsRequest, callback?: (err: CloudWatchLogs.InvalidParameterException|CloudWatchLogs.ResourceNotFoundException|CloudWatchLogs.ServiceUnavailableException|any, data: CloudWatchLogs.GetLogEventsResponse|any) => void): Request;
    putDestination(params: CloudWatchLogs.PutDestinationRequest, callback?: (err: CloudWatchLogs.InvalidParameterException|CloudWatchLogs.OperationAbortedException|CloudWatchLogs.ServiceUnavailableException|any, data: CloudWatchLogs.PutDestinationResponse|any) => void): Request;
    putDestinationPolicy(params: CloudWatchLogs.PutDestinationPolicyRequest, callback?: (err: CloudWatchLogs.InvalidParameterException|CloudWatchLogs.OperationAbortedException|CloudWatchLogs.ServiceUnavailableException|any, data: any) => void): Request;
    putLogEvents(params: CloudWatchLogs.PutLogEventsRequest, callback?: (err: CloudWatchLogs.InvalidParameterException|CloudWatchLogs.InvalidSequenceTokenException|CloudWatchLogs.DataAlreadyAcceptedException|CloudWatchLogs.ResourceNotFoundException|CloudWatchLogs.OperationAbortedException|CloudWatchLogs.ServiceUnavailableException|any, data: CloudWatchLogs.PutLogEventsResponse|any) => void): Request;
    putMetricFilter(params: CloudWatchLogs.PutMetricFilterRequest, callback?: (err: CloudWatchLogs.InvalidParameterException|CloudWatchLogs.ResourceNotFoundException|CloudWatchLogs.OperationAbortedException|CloudWatchLogs.LimitExceededException|CloudWatchLogs.ServiceUnavailableException|any, data: any) => void): Request;
    putRetentionPolicy(params: CloudWatchLogs.PutRetentionPolicyRequest, callback?: (err: CloudWatchLogs.InvalidParameterException|CloudWatchLogs.ResourceNotFoundException|CloudWatchLogs.OperationAbortedException|CloudWatchLogs.ServiceUnavailableException|any, data: any) => void): Request;
    putSubscriptionFilter(params: CloudWatchLogs.PutSubscriptionFilterRequest, callback?: (err: CloudWatchLogs.InvalidParameterException|CloudWatchLogs.ResourceNotFoundException|CloudWatchLogs.OperationAbortedException|CloudWatchLogs.LimitExceededException|CloudWatchLogs.ServiceUnavailableException|any, data: any) => void): Request;
    testMetricFilter(params: CloudWatchLogs.TestMetricFilterRequest, callback?: (err: CloudWatchLogs.InvalidParameterException|CloudWatchLogs.ServiceUnavailableException|any, data: CloudWatchLogs.TestMetricFilterResponse|any) => void): Request;

  }

  export module CloudWatchLogs {
    export type AccessPolicy = string;    // min: 1
    export type Arn = string;
    export type Days = number;
    export type Descending = boolean;
    export type DescribeLimit = number;    // max: 50, min: 1
    export type DestinationArn = string;    // min: 1
    export type DestinationName = string;    // pattern: &quot;[^:*]*&quot;, max: 512, min: 1
    export type Destinations = Destination[];
    export type EventId = string;
    export type EventMessage = string;    // min: 1
    export type EventNumber = number;
    export type EventsLimit = number;    // max: 10000, min: 1
    export type ExportDestinationBucket = string;    // max: 512, min: 1
    export type ExportDestinationPrefix = string;
    export type ExportTaskId = string;    // max: 512, min: 1
    export type ExportTaskName = string;    // max: 512, min: 1
    export type ExportTaskStatusCode = string;
    export type ExportTaskStatusMessage = string;
    export type ExportTasks = ExportTask[];
    export type ExtractedValues = {[key:string]: Value};
    export type FilterCount = number;
    export type FilterName = string;    // pattern: &quot;[^:*]*&quot;, max: 512, min: 1
    export type FilterPattern = string;    // max: 1024
    export type FilteredLogEvents = FilteredLogEvent[];
    export type InputLogEvents = InputLogEvent[];    // max: 10000, min: 1
    export type InputLogStreamNames = LogStreamName[];    // max: 100, min: 1
    export type Interleaved = boolean;
    export type LogEventIndex = number;
    export type LogGroupName = string;    // pattern: &quot;[\.\-_/#A-Za-z0-9]+&quot;, max: 512, min: 1
    export type LogGroups = LogGroup[];
    export type LogStreamName = string;    // pattern: &quot;[^:*]*&quot;, max: 512, min: 1
    export type LogStreamSearchedCompletely = boolean;
    export type LogStreams = LogStream[];
    export type MetricFilterMatches = MetricFilterMatchRecord[];
    export type MetricFilters = MetricFilter[];
    export type MetricName = string;    // pattern: &quot;[^:*$]*&quot;, max: 255
    export type MetricNamespace = string;    // pattern: &quot;[^:*$]*&quot;, max: 255
    export type MetricTransformations = MetricTransformation[];    // max: 1, min: 1
    export type MetricValue = string;    // max: 100
    export type NextToken = string;    // min: 1
    export type OrderBy = string;
    export type OutputLogEvents = OutputLogEvent[];
    export type RoleArn = string;    // min: 1
    export type SearchedLogStreams = SearchedLogStream[];
    export type SequenceToken = string;    // min: 1
    export type StartFromHead = boolean;
    export type StoredBytes = number;
    export type SubscriptionFilters = SubscriptionFilter[];
    export type TargetArn = string;    // min: 1
    export type TestEventMessages = EventMessage[];    // max: 50, min: 1
    export type Timestamp = number;
    export type Token = string;
    export type Value = string;

    export interface CancelExportTaskRequest {
        taskId: ExportTaskId;
    }
    export interface CreateExportTaskRequest {
        taskName?: ExportTaskName;
        logGroupName: LogGroupName;
        logStreamNamePrefix?: LogStreamName;
        from: Timestamp;
        to: Timestamp;
        destination: ExportDestinationBucket;
        destinationPrefix?: ExportDestinationPrefix;
    }
    export interface CreateExportTaskResponse {
        taskId?: ExportTaskId;
    }
    export interface CreateLogGroupRequest {
        logGroupName: LogGroupName;
    }
    export interface CreateLogStreamRequest {
        logGroupName: LogGroupName;
        logStreamName: LogStreamName;
    }
    export interface DataAlreadyAcceptedException {
        expectedSequenceToken?: SequenceToken;
    }
    export interface DeleteDestinationRequest {
        destinationName: DestinationName;
    }
    export interface DeleteLogGroupRequest {
        logGroupName: LogGroupName;
    }
    export interface DeleteLogStreamRequest {
        logGroupName: LogGroupName;
        logStreamName: LogStreamName;
    }
    export interface DeleteMetricFilterRequest {
        logGroupName: LogGroupName;
        filterName: FilterName;
    }
    export interface DeleteRetentionPolicyRequest {
        logGroupName: LogGroupName;
    }
    export interface DeleteSubscriptionFilterRequest {
        logGroupName: LogGroupName;
        filterName: FilterName;
    }
    export interface DescribeDestinationsRequest {
        DestinationNamePrefix?: DestinationName;
        nextToken?: NextToken;
        limit?: DescribeLimit;
    }
    export interface DescribeDestinationsResponse {
        destinations?: Destinations;
        nextToken?: NextToken;
    }
    export interface DescribeExportTasksRequest {
        taskId?: ExportTaskId;
        statusCode?: ExportTaskStatusCode;
        nextToken?: NextToken;
        limit?: DescribeLimit;
    }
    export interface DescribeExportTasksResponse {
        exportTasks?: ExportTasks;
        nextToken?: NextToken;
    }
    export interface DescribeLogGroupsRequest {
        logGroupNamePrefix?: LogGroupName;
        nextToken?: NextToken;
        limit?: DescribeLimit;
    }
    export interface DescribeLogGroupsResponse {
        logGroups?: LogGroups;
        nextToken?: NextToken;
    }
    export interface DescribeLogStreamsRequest {
        logGroupName: LogGroupName;
        logStreamNamePrefix?: LogStreamName;
        orderBy?: OrderBy;
        descending?: Descending;
        nextToken?: NextToken;
        limit?: DescribeLimit;
    }
    export interface DescribeLogStreamsResponse {
        logStreams?: LogStreams;
        nextToken?: NextToken;
    }
    export interface DescribeMetricFiltersRequest {
        logGroupName: LogGroupName;
        filterNamePrefix?: FilterName;
        nextToken?: NextToken;
        limit?: DescribeLimit;
    }
    export interface DescribeMetricFiltersResponse {
        metricFilters?: MetricFilters;
        nextToken?: NextToken;
    }
    export interface DescribeSubscriptionFiltersRequest {
        logGroupName: LogGroupName;
        filterNamePrefix?: FilterName;
        nextToken?: NextToken;
        limit?: DescribeLimit;
    }
    export interface DescribeSubscriptionFiltersResponse {
        subscriptionFilters?: SubscriptionFilters;
        nextToken?: NextToken;
    }
    export interface Destination {
        destinationName?: DestinationName;
        targetArn?: TargetArn;
        roleArn?: RoleArn;
        accessPolicy?: AccessPolicy;
        arn?: Arn;
        creationTime?: Timestamp;
    }
    export interface ExportTask {
        taskId?: ExportTaskId;
        taskName?: ExportTaskName;
        logGroupName?: LogGroupName;
        from?: Timestamp;
        to?: Timestamp;
        destination?: ExportDestinationBucket;
        destinationPrefix?: ExportDestinationPrefix;
        status?: ExportTaskStatus;
        executionInfo?: ExportTaskExecutionInfo;
    }
    export interface ExportTaskExecutionInfo {
        creationTime?: Timestamp;
        completionTime?: Timestamp;
    }
    export interface ExportTaskStatus {
        code?: ExportTaskStatusCode;
        message?: ExportTaskStatusMessage;
    }
    export interface FilterLogEventsRequest {
        logGroupName: LogGroupName;
        logStreamNames?: InputLogStreamNames;
        startTime?: Timestamp;
        endTime?: Timestamp;
        filterPattern?: FilterPattern;
        nextToken?: NextToken;
        limit?: EventsLimit;
        interleaved?: Interleaved;
    }
    export interface FilterLogEventsResponse {
        events?: FilteredLogEvents;
        searchedLogStreams?: SearchedLogStreams;
        nextToken?: NextToken;
    }
    export interface FilteredLogEvent {
        logStreamName?: LogStreamName;
        timestamp?: Timestamp;
        message?: EventMessage;
        ingestionTime?: Timestamp;
        eventId?: EventId;
    }
    export interface GetLogEventsRequest {
        logGroupName: LogGroupName;
        logStreamName: LogStreamName;
        startTime?: Timestamp;
        endTime?: Timestamp;
        nextToken?: NextToken;
        limit?: EventsLimit;
        startFromHead?: StartFromHead;
    }
    export interface GetLogEventsResponse {
        events?: OutputLogEvents;
        nextForwardToken?: NextToken;
        nextBackwardToken?: NextToken;
    }
    export interface InputLogEvent {
        timestamp: Timestamp;
        message: EventMessage;
    }
    export interface InvalidOperationException {
    }
    export interface InvalidParameterException {
    }
    export interface InvalidSequenceTokenException {
        expectedSequenceToken?: SequenceToken;
    }
    export interface LimitExceededException {
    }
    export interface LogGroup {
        logGroupName?: LogGroupName;
        creationTime?: Timestamp;
        retentionInDays?: Days;
        metricFilterCount?: FilterCount;
        arn?: Arn;
        storedBytes?: StoredBytes;
    }
    export interface LogStream {
        logStreamName?: LogStreamName;
        creationTime?: Timestamp;
        firstEventTimestamp?: Timestamp;
        lastEventTimestamp?: Timestamp;
        lastIngestionTime?: Timestamp;
        uploadSequenceToken?: SequenceToken;
        arn?: Arn;
        storedBytes?: StoredBytes;
    }
    export interface MetricFilter {
        filterName?: FilterName;
        filterPattern?: FilterPattern;
        metricTransformations?: MetricTransformations;
        creationTime?: Timestamp;
    }
    export interface MetricFilterMatchRecord {
        eventNumber?: EventNumber;
        eventMessage?: EventMessage;
        extractedValues?: ExtractedValues;
    }
    export interface MetricTransformation {
        metricName: MetricName;
        metricNamespace: MetricNamespace;
        metricValue: MetricValue;
    }
    export interface OperationAbortedException {
    }
    export interface OutputLogEvent {
        timestamp?: Timestamp;
        message?: EventMessage;
        ingestionTime?: Timestamp;
    }
    export interface PutDestinationPolicyRequest {
        destinationName: DestinationName;
        accessPolicy: AccessPolicy;
    }
    export interface PutDestinationRequest {
        destinationName: DestinationName;
        targetArn: TargetArn;
        roleArn: RoleArn;
    }
    export interface PutDestinationResponse {
        destination?: Destination;
    }
    export interface PutLogEventsRequest {
        logGroupName: LogGroupName;
        logStreamName: LogStreamName;
        logEvents: InputLogEvents;
        sequenceToken?: SequenceToken;
    }
    export interface PutLogEventsResponse {
        nextSequenceToken?: SequenceToken;
        rejectedLogEventsInfo?: RejectedLogEventsInfo;
    }
    export interface PutMetricFilterRequest {
        logGroupName: LogGroupName;
        filterName: FilterName;
        filterPattern: FilterPattern;
        metricTransformations: MetricTransformations;
    }
    export interface PutRetentionPolicyRequest {
        logGroupName: LogGroupName;
        retentionInDays: Days;
    }
    export interface PutSubscriptionFilterRequest {
        logGroupName: LogGroupName;
        filterName: FilterName;
        filterPattern: FilterPattern;
        destinationArn: DestinationArn;
        roleArn?: RoleArn;
    }
    export interface RejectedLogEventsInfo {
        tooNewLogEventStartIndex?: LogEventIndex;
        tooOldLogEventEndIndex?: LogEventIndex;
        expiredLogEventEndIndex?: LogEventIndex;
    }
    export interface ResourceAlreadyExistsException {
    }
    export interface ResourceNotFoundException {
    }
    export interface SearchedLogStream {
        logStreamName?: LogStreamName;
        searchedCompletely?: LogStreamSearchedCompletely;
    }
    export interface ServiceUnavailableException {
    }
    export interface SubscriptionFilter {
        filterName?: FilterName;
        logGroupName?: LogGroupName;
        filterPattern?: FilterPattern;
        destinationArn?: DestinationArn;
        roleArn?: RoleArn;
        creationTime?: Timestamp;
    }
    export interface TestMetricFilterRequest {
        filterPattern: FilterPattern;
        logEventMessages: TestEventMessages;
    }
    export interface TestMetricFilterResponse {
        matches?: MetricFilterMatches;
    }
  }

  /*
   * apiVersion: 2015-04-13
   * endpointPrefix: codecommit
   * serviceAbbreviation: CodeCommit
   * signatureVersion: v4
   * protocol: json
   */
  export class CodeCommit extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    batchGetRepositories(params: CodeCommit.BatchGetRepositoriesInput, callback?: (err: CodeCommit.RepositoryNamesRequiredException|CodeCommit.MaximumRepositoryNamesExceededException|CodeCommit.InvalidRepositoryNameException|CodeCommit.EncryptionIntegrityChecksFailedException|CodeCommit.EncryptionKeyAccessDeniedException|CodeCommit.EncryptionKeyDisabledException|CodeCommit.EncryptionKeyNotFoundException|CodeCommit.EncryptionKeyUnavailableException|any, data: CodeCommit.BatchGetRepositoriesOutput|any) => void): Request;
    createBranch(params: CodeCommit.CreateBranchInput, callback?: (err: CodeCommit.RepositoryNameRequiredException|CodeCommit.InvalidRepositoryNameException|CodeCommit.RepositoryDoesNotExistException|CodeCommit.BranchNameRequiredException|CodeCommit.BranchNameExistsException|CodeCommit.InvalidBranchNameException|CodeCommit.CommitIdRequiredException|CodeCommit.CommitDoesNotExistException|CodeCommit.InvalidCommitIdException|CodeCommit.EncryptionIntegrityChecksFailedException|CodeCommit.EncryptionKeyAccessDeniedException|CodeCommit.EncryptionKeyDisabledException|CodeCommit.EncryptionKeyNotFoundException|CodeCommit.EncryptionKeyUnavailableException|any, data: any) => void): Request;
    createRepository(params: CodeCommit.CreateRepositoryInput, callback?: (err: CodeCommit.RepositoryNameExistsException|CodeCommit.RepositoryNameRequiredException|CodeCommit.InvalidRepositoryNameException|CodeCommit.InvalidRepositoryDescriptionException|CodeCommit.RepositoryLimitExceededException|CodeCommit.EncryptionIntegrityChecksFailedException|CodeCommit.EncryptionKeyAccessDeniedException|CodeCommit.EncryptionKeyDisabledException|CodeCommit.EncryptionKeyNotFoundException|CodeCommit.EncryptionKeyUnavailableException|any, data: CodeCommit.CreateRepositoryOutput|any) => void): Request;
    deleteRepository(params: CodeCommit.DeleteRepositoryInput, callback?: (err: CodeCommit.RepositoryNameRequiredException|CodeCommit.InvalidRepositoryNameException|CodeCommit.EncryptionIntegrityChecksFailedException|CodeCommit.EncryptionKeyAccessDeniedException|CodeCommit.EncryptionKeyDisabledException|CodeCommit.EncryptionKeyNotFoundException|CodeCommit.EncryptionKeyUnavailableException|any, data: CodeCommit.DeleteRepositoryOutput|any) => void): Request;
    getBranch(params: CodeCommit.GetBranchInput, callback?: (err: CodeCommit.RepositoryNameRequiredException|CodeCommit.RepositoryDoesNotExistException|CodeCommit.InvalidRepositoryNameException|CodeCommit.BranchNameRequiredException|CodeCommit.InvalidBranchNameException|CodeCommit.BranchDoesNotExistException|CodeCommit.EncryptionIntegrityChecksFailedException|CodeCommit.EncryptionKeyAccessDeniedException|CodeCommit.EncryptionKeyDisabledException|CodeCommit.EncryptionKeyNotFoundException|CodeCommit.EncryptionKeyUnavailableException|any, data: CodeCommit.GetBranchOutput|any) => void): Request;
    getCommit(params: CodeCommit.GetCommitInput, callback?: (err: CodeCommit.RepositoryNameRequiredException|CodeCommit.InvalidRepositoryNameException|CodeCommit.RepositoryDoesNotExistException|CodeCommit.CommitIdRequiredException|CodeCommit.InvalidCommitIdException|CodeCommit.CommitIdDoesNotExistException|CodeCommit.EncryptionIntegrityChecksFailedException|CodeCommit.EncryptionKeyAccessDeniedException|CodeCommit.EncryptionKeyDisabledException|CodeCommit.EncryptionKeyNotFoundException|CodeCommit.EncryptionKeyUnavailableException|any, data: CodeCommit.GetCommitOutput|any) => void): Request;
    getRepository(params: CodeCommit.GetRepositoryInput, callback?: (err: CodeCommit.RepositoryNameRequiredException|CodeCommit.RepositoryDoesNotExistException|CodeCommit.InvalidRepositoryNameException|CodeCommit.EncryptionIntegrityChecksFailedException|CodeCommit.EncryptionKeyAccessDeniedException|CodeCommit.EncryptionKeyDisabledException|CodeCommit.EncryptionKeyNotFoundException|CodeCommit.EncryptionKeyUnavailableException|any, data: CodeCommit.GetRepositoryOutput|any) => void): Request;
    getRepositoryTriggers(params: CodeCommit.GetRepositoryTriggersInput, callback?: (err: CodeCommit.RepositoryNameRequiredException|CodeCommit.InvalidRepositoryNameException|CodeCommit.RepositoryDoesNotExistException|CodeCommit.EncryptionIntegrityChecksFailedException|CodeCommit.EncryptionKeyAccessDeniedException|CodeCommit.EncryptionKeyDisabledException|CodeCommit.EncryptionKeyNotFoundException|CodeCommit.EncryptionKeyUnavailableException|any, data: CodeCommit.GetRepositoryTriggersOutput|any) => void): Request;
    listBranches(params: CodeCommit.ListBranchesInput, callback?: (err: CodeCommit.RepositoryNameRequiredException|CodeCommit.RepositoryDoesNotExistException|CodeCommit.InvalidRepositoryNameException|CodeCommit.EncryptionIntegrityChecksFailedException|CodeCommit.EncryptionKeyAccessDeniedException|CodeCommit.EncryptionKeyDisabledException|CodeCommit.EncryptionKeyNotFoundException|CodeCommit.EncryptionKeyUnavailableException|CodeCommit.InvalidContinuationTokenException|any, data: CodeCommit.ListBranchesOutput|any) => void): Request;
    listRepositories(params: CodeCommit.ListRepositoriesInput, callback?: (err: CodeCommit.InvalidSortByException|CodeCommit.InvalidOrderException|CodeCommit.InvalidContinuationTokenException|any, data: CodeCommit.ListRepositoriesOutput|any) => void): Request;
    putRepositoryTriggers(params: CodeCommit.PutRepositoryTriggersInput, callback?: (err: CodeCommit.RepositoryDoesNotExistException|CodeCommit.RepositoryNameRequiredException|CodeCommit.InvalidRepositoryNameException|CodeCommit.RepositoryTriggersListRequiredException|CodeCommit.MaximumRepositoryTriggersExceededException|CodeCommit.InvalidRepositoryTriggerNameException|CodeCommit.InvalidRepositoryTriggerDestinationArnException|CodeCommit.InvalidRepositoryTriggerRegionException|CodeCommit.InvalidRepositoryTriggerCustomDataException|CodeCommit.MaximumBranchesExceededException|CodeCommit.InvalidRepositoryTriggerBranchNameException|CodeCommit.InvalidRepositoryTriggerEventsException|CodeCommit.RepositoryTriggerNameRequiredException|CodeCommit.RepositoryTriggerDestinationArnRequiredException|CodeCommit.RepositoryTriggerBranchNameListRequiredException|CodeCommit.RepositoryTriggerEventsListRequiredException|CodeCommit.EncryptionIntegrityChecksFailedException|CodeCommit.EncryptionKeyAccessDeniedException|CodeCommit.EncryptionKeyDisabledException|CodeCommit.EncryptionKeyNotFoundException|CodeCommit.EncryptionKeyUnavailableException|any, data: CodeCommit.PutRepositoryTriggersOutput|any) => void): Request;
    testRepositoryTriggers(params: CodeCommit.TestRepositoryTriggersInput, callback?: (err: CodeCommit.RepositoryDoesNotExistException|CodeCommit.RepositoryNameRequiredException|CodeCommit.InvalidRepositoryNameException|CodeCommit.RepositoryTriggersListRequiredException|CodeCommit.MaximumRepositoryTriggersExceededException|CodeCommit.InvalidRepositoryTriggerNameException|CodeCommit.InvalidRepositoryTriggerDestinationArnException|CodeCommit.InvalidRepositoryTriggerRegionException|CodeCommit.InvalidRepositoryTriggerCustomDataException|CodeCommit.MaximumBranchesExceededException|CodeCommit.InvalidRepositoryTriggerBranchNameException|CodeCommit.InvalidRepositoryTriggerEventsException|CodeCommit.RepositoryTriggerNameRequiredException|CodeCommit.RepositoryTriggerDestinationArnRequiredException|CodeCommit.RepositoryTriggerBranchNameListRequiredException|CodeCommit.RepositoryTriggerEventsListRequiredException|CodeCommit.EncryptionIntegrityChecksFailedException|CodeCommit.EncryptionKeyAccessDeniedException|CodeCommit.EncryptionKeyDisabledException|CodeCommit.EncryptionKeyNotFoundException|CodeCommit.EncryptionKeyUnavailableException|any, data: CodeCommit.TestRepositoryTriggersOutput|any) => void): Request;
    updateDefaultBranch(params: CodeCommit.UpdateDefaultBranchInput, callback?: (err: CodeCommit.RepositoryNameRequiredException|CodeCommit.RepositoryDoesNotExistException|CodeCommit.InvalidRepositoryNameException|CodeCommit.BranchNameRequiredException|CodeCommit.InvalidBranchNameException|CodeCommit.BranchDoesNotExistException|CodeCommit.EncryptionIntegrityChecksFailedException|CodeCommit.EncryptionKeyAccessDeniedException|CodeCommit.EncryptionKeyDisabledException|CodeCommit.EncryptionKeyNotFoundException|CodeCommit.EncryptionKeyUnavailableException|any, data: any) => void): Request;
    updateRepositoryDescription(params: CodeCommit.UpdateRepositoryDescriptionInput, callback?: (err: CodeCommit.RepositoryNameRequiredException|CodeCommit.RepositoryDoesNotExistException|CodeCommit.InvalidRepositoryNameException|CodeCommit.InvalidRepositoryDescriptionException|CodeCommit.EncryptionIntegrityChecksFailedException|CodeCommit.EncryptionKeyAccessDeniedException|CodeCommit.EncryptionKeyDisabledException|CodeCommit.EncryptionKeyNotFoundException|CodeCommit.EncryptionKeyUnavailableException|any, data: any) => void): Request;
    updateRepositoryName(params: CodeCommit.UpdateRepositoryNameInput, callback?: (err: CodeCommit.RepositoryDoesNotExistException|CodeCommit.RepositoryNameExistsException|CodeCommit.RepositoryNameRequiredException|CodeCommit.InvalidRepositoryNameException|any, data: any) => void): Request;

  }

  export module CodeCommit {
    export type AccountId = string;
    export type AdditionalData = string;
    export type Arn = string;
    export type BranchName = string;    // max: 100, min: 1
    export type BranchNameList = BranchName[];
    export type CloneUrlHttp = string;
    export type CloneUrlSsh = string;
    export type CommitId = string;
    export type CreationDate = number;
    export type Date = string;
    export type Email = string;
    export type LastModifiedDate = number;
    export type Message = string;
    export type Name = string;
    export type NextToken = string;
    export type ObjectId = string;
    export type OrderEnum = string;
    export type ParentList = ObjectId[];
    export type RepositoryDescription = string;    // max: 1000
    export type RepositoryId = string;
    export type RepositoryMetadataList = RepositoryMetadata[];
    export type RepositoryName = string;    // pattern: &quot;[\\w\\.-]+&quot;, max: 100, min: 1
    export type RepositoryNameIdPairList = RepositoryNameIdPair[];
    export type RepositoryNameList = RepositoryName[];
    export type RepositoryNotFoundList = RepositoryName[];
    export type RepositoryTriggerCustomData = string;
    export type RepositoryTriggerEventEnum = string;
    export type RepositoryTriggerEventList = RepositoryTriggerEventEnum[];
    export type RepositoryTriggerExecutionFailureList = RepositoryTriggerExecutionFailure[];
    export type RepositoryTriggerExecutionFailureMessage = string;
    export type RepositoryTriggerName = string;
    export type RepositoryTriggerNameList = RepositoryTriggerName[];
    export type RepositoryTriggersConfigurationId = string;
    export type RepositoryTriggersList = RepositoryTrigger[];
    export type SortByEnum = string;

    export interface BatchGetRepositoriesInput {
        repositoryNames: RepositoryNameList;
    }
    export interface BatchGetRepositoriesOutput {
        repositories?: RepositoryMetadataList;
        repositoriesNotFound?: RepositoryNotFoundList;
    }
    export interface BranchDoesNotExistException {
    }
    export interface BranchInfo {
        branchName?: BranchName;
        commitId?: CommitId;
    }
    export interface BranchNameExistsException {
    }
    export interface BranchNameRequiredException {
    }
    export interface Commit {
        treeId?: ObjectId;
        parents?: ParentList;
        message?: Message;
        author?: UserInfo;
        committer?: UserInfo;
        additionalData?: AdditionalData;
    }
    export interface CommitDoesNotExistException {
    }
    export interface CommitIdDoesNotExistException {
    }
    export interface CommitIdRequiredException {
    }
    export interface CreateBranchInput {
        repositoryName: RepositoryName;
        branchName: BranchName;
        commitId: CommitId;
    }
    export interface CreateRepositoryInput {
        repositoryName: RepositoryName;
        repositoryDescription?: RepositoryDescription;
    }
    export interface CreateRepositoryOutput {
        repositoryMetadata?: RepositoryMetadata;
    }
    export interface DeleteRepositoryInput {
        repositoryName: RepositoryName;
    }
    export interface DeleteRepositoryOutput {
        repositoryId?: RepositoryId;
    }
    export interface EncryptionIntegrityChecksFailedException {
    }
    export interface EncryptionKeyAccessDeniedException {
    }
    export interface EncryptionKeyDisabledException {
    }
    export interface EncryptionKeyNotFoundException {
    }
    export interface EncryptionKeyUnavailableException {
    }
    export interface GetBranchInput {
        repositoryName?: RepositoryName;
        branchName?: BranchName;
    }
    export interface GetBranchOutput {
        branch?: BranchInfo;
    }
    export interface GetCommitInput {
        repositoryName: RepositoryName;
        commitId: ObjectId;
    }
    export interface GetCommitOutput {
        commit: Commit;
    }
    export interface GetRepositoryInput {
        repositoryName: RepositoryName;
    }
    export interface GetRepositoryOutput {
        repositoryMetadata?: RepositoryMetadata;
    }
    export interface GetRepositoryTriggersInput {
        repositoryName?: RepositoryName;
    }
    export interface GetRepositoryTriggersOutput {
        configurationId?: RepositoryTriggersConfigurationId;
        triggers?: RepositoryTriggersList;
    }
    export interface InvalidBranchNameException {
    }
    export interface InvalidCommitIdException {
    }
    export interface InvalidContinuationTokenException {
    }
    export interface InvalidOrderException {
    }
    export interface InvalidRepositoryDescriptionException {
    }
    export interface InvalidRepositoryNameException {
    }
    export interface InvalidRepositoryTriggerBranchNameException {
    }
    export interface InvalidRepositoryTriggerCustomDataException {
    }
    export interface InvalidRepositoryTriggerDestinationArnException {
    }
    export interface InvalidRepositoryTriggerEventsException {
    }
    export interface InvalidRepositoryTriggerNameException {
    }
    export interface InvalidRepositoryTriggerRegionException {
    }
    export interface InvalidSortByException {
    }
    export interface ListBranchesInput {
        repositoryName: RepositoryName;
        nextToken?: NextToken;
    }
    export interface ListBranchesOutput {
        branches?: BranchNameList;
        nextToken?: NextToken;
    }
    export interface ListRepositoriesInput {
        nextToken?: NextToken;
        sortBy?: SortByEnum;
        order?: OrderEnum;
    }
    export interface ListRepositoriesOutput {
        repositories?: RepositoryNameIdPairList;
        nextToken?: NextToken;
    }
    export interface MaximumBranchesExceededException {
    }
    export interface MaximumRepositoryNamesExceededException {
    }
    export interface MaximumRepositoryTriggersExceededException {
    }
    export interface PutRepositoryTriggersInput {
        repositoryName?: RepositoryName;
        triggers?: RepositoryTriggersList;
    }
    export interface PutRepositoryTriggersOutput {
        configurationId?: RepositoryTriggersConfigurationId;
    }
    export interface RepositoryDoesNotExistException {
    }
    export interface RepositoryLimitExceededException {
    }
    export interface RepositoryMetadata {
        accountId?: AccountId;
        repositoryId?: RepositoryId;
        repositoryName?: RepositoryName;
        repositoryDescription?: RepositoryDescription;
        defaultBranch?: BranchName;
        lastModifiedDate?: LastModifiedDate;
        creationDate?: CreationDate;
        cloneUrlHttp?: CloneUrlHttp;
        cloneUrlSsh?: CloneUrlSsh;
        Arn?: Arn;
    }
    export interface RepositoryNameExistsException {
    }
    export interface RepositoryNameIdPair {
        repositoryName?: RepositoryName;
        repositoryId?: RepositoryId;
    }
    export interface RepositoryNameRequiredException {
    }
    export interface RepositoryNamesRequiredException {
    }
    export interface RepositoryTrigger {
        name?: RepositoryTriggerName;
        destinationArn?: Arn;
        customData?: RepositoryTriggerCustomData;
        branches?: BranchNameList;
        events?: RepositoryTriggerEventList;
    }
    export interface RepositoryTriggerBranchNameListRequiredException {
    }
    export interface RepositoryTriggerDestinationArnRequiredException {
    }
    export interface RepositoryTriggerEventsListRequiredException {
    }
    export interface RepositoryTriggerExecutionFailure {
        trigger?: RepositoryTriggerName;
        failureMessage?: RepositoryTriggerExecutionFailureMessage;
    }
    export interface RepositoryTriggerNameRequiredException {
    }
    export interface RepositoryTriggersListRequiredException {
    }
    export interface TestRepositoryTriggersInput {
        repositoryName?: RepositoryName;
        triggers?: RepositoryTriggersList;
    }
    export interface TestRepositoryTriggersOutput {
        successfulExecutions?: RepositoryTriggerNameList;
        failedExecutions?: RepositoryTriggerExecutionFailureList;
    }
    export interface UpdateDefaultBranchInput {
        repositoryName: RepositoryName;
        defaultBranchName: BranchName;
    }
    export interface UpdateRepositoryDescriptionInput {
        repositoryName: RepositoryName;
        repositoryDescription?: RepositoryDescription;
    }
    export interface UpdateRepositoryNameInput {
        oldName: RepositoryName;
        newName: RepositoryName;
    }
    export interface UserInfo {
        name?: Name;
        email?: Email;
        date?: Date;
    }
  }

  /*
   * apiVersion: 2014-10-06
   * endpointPrefix: codedeploy
   * serviceAbbreviation: CodeDeploy
   * signatureVersion: v4
   * protocol: json
   */
  export class CodeDeploy extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    addTagsToOnPremisesInstances(params: CodeDeploy.AddTagsToOnPremisesInstancesInput, callback?: (err: CodeDeploy.InstanceNameRequiredException|CodeDeploy.TagRequiredException|CodeDeploy.InvalidTagException|CodeDeploy.TagLimitExceededException|CodeDeploy.InstanceLimitExceededException|CodeDeploy.InstanceNotRegisteredException|any, data: any) => void): Request;
    batchGetApplicationRevisions(params: CodeDeploy.BatchGetApplicationRevisionsInput, callback?: (err: CodeDeploy.ApplicationDoesNotExistException|CodeDeploy.ApplicationNameRequiredException|CodeDeploy.InvalidApplicationNameException|CodeDeploy.RevisionRequiredException|CodeDeploy.InvalidRevisionException|CodeDeploy.BatchLimitExceededException|any, data: CodeDeploy.BatchGetApplicationRevisionsOutput|any) => void): Request;
    batchGetApplications(params: CodeDeploy.BatchGetApplicationsInput, callback?: (err: CodeDeploy.ApplicationNameRequiredException|CodeDeploy.InvalidApplicationNameException|CodeDeploy.ApplicationDoesNotExistException|CodeDeploy.BatchLimitExceededException|any, data: CodeDeploy.BatchGetApplicationsOutput|any) => void): Request;
    batchGetDeploymentGroups(params: CodeDeploy.BatchGetDeploymentGroupsInput, callback?: (err: CodeDeploy.ApplicationNameRequiredException|CodeDeploy.InvalidApplicationNameException|CodeDeploy.ApplicationDoesNotExistException|CodeDeploy.DeploymentGroupNameRequiredException|CodeDeploy.InvalidDeploymentGroupNameException|CodeDeploy.BatchLimitExceededException|any, data: CodeDeploy.BatchGetDeploymentGroupsOutput|any) => void): Request;
    batchGetDeploymentInstances(params: CodeDeploy.BatchGetDeploymentInstancesInput, callback?: (err: CodeDeploy.DeploymentIdRequiredException|CodeDeploy.DeploymentDoesNotExistException|CodeDeploy.InstanceIdRequiredException|CodeDeploy.InvalidDeploymentIdException|CodeDeploy.InvalidInstanceNameException|CodeDeploy.BatchLimitExceededException|any, data: CodeDeploy.BatchGetDeploymentInstancesOutput|any) => void): Request;
    batchGetDeployments(params: CodeDeploy.BatchGetDeploymentsInput, callback?: (err: CodeDeploy.DeploymentIdRequiredException|CodeDeploy.InvalidDeploymentIdException|CodeDeploy.BatchLimitExceededException|any, data: CodeDeploy.BatchGetDeploymentsOutput|any) => void): Request;
    batchGetOnPremisesInstances(params: CodeDeploy.BatchGetOnPremisesInstancesInput, callback?: (err: CodeDeploy.InstanceNameRequiredException|CodeDeploy.InvalidInstanceNameException|CodeDeploy.BatchLimitExceededException|any, data: CodeDeploy.BatchGetOnPremisesInstancesOutput|any) => void): Request;
    createApplication(params: CodeDeploy.CreateApplicationInput, callback?: (err: CodeDeploy.ApplicationNameRequiredException|CodeDeploy.InvalidApplicationNameException|CodeDeploy.ApplicationAlreadyExistsException|CodeDeploy.ApplicationLimitExceededException|any, data: CodeDeploy.CreateApplicationOutput|any) => void): Request;
    createDeployment(params: CodeDeploy.CreateDeploymentInput, callback?: (err: CodeDeploy.ApplicationNameRequiredException|CodeDeploy.InvalidApplicationNameException|CodeDeploy.ApplicationDoesNotExistException|CodeDeploy.DeploymentGroupNameRequiredException|CodeDeploy.InvalidDeploymentGroupNameException|CodeDeploy.DeploymentGroupDoesNotExistException|CodeDeploy.RevisionRequiredException|CodeDeploy.InvalidRevisionException|CodeDeploy.InvalidDeploymentConfigNameException|CodeDeploy.DeploymentConfigDoesNotExistException|CodeDeploy.DescriptionTooLongException|CodeDeploy.DeploymentLimitExceededException|any, data: CodeDeploy.CreateDeploymentOutput|any) => void): Request;
    createDeploymentConfig(params: CodeDeploy.CreateDeploymentConfigInput, callback?: (err: CodeDeploy.InvalidDeploymentConfigNameException|CodeDeploy.DeploymentConfigNameRequiredException|CodeDeploy.DeploymentConfigAlreadyExistsException|CodeDeploy.InvalidMinimumHealthyHostValueException|CodeDeploy.DeploymentConfigLimitExceededException|any, data: CodeDeploy.CreateDeploymentConfigOutput|any) => void): Request;
    createDeploymentGroup(params: CodeDeploy.CreateDeploymentGroupInput, callback?: (err: CodeDeploy.ApplicationNameRequiredException|CodeDeploy.InvalidApplicationNameException|CodeDeploy.ApplicationDoesNotExistException|CodeDeploy.DeploymentGroupNameRequiredException|CodeDeploy.InvalidDeploymentGroupNameException|CodeDeploy.DeploymentGroupAlreadyExistsException|CodeDeploy.InvalidEC2TagException|CodeDeploy.InvalidTagException|CodeDeploy.InvalidAutoScalingGroupException|CodeDeploy.InvalidDeploymentConfigNameException|CodeDeploy.DeploymentConfigDoesNotExistException|CodeDeploy.RoleRequiredException|CodeDeploy.InvalidRoleException|CodeDeploy.DeploymentGroupLimitExceededException|CodeDeploy.LifecycleHookLimitExceededException|CodeDeploy.InvalidTriggerConfigException|CodeDeploy.TriggerTargetsLimitExceededException|any, data: CodeDeploy.CreateDeploymentGroupOutput|any) => void): Request;
    deleteApplication(params: CodeDeploy.DeleteApplicationInput, callback?: (err: CodeDeploy.ApplicationNameRequiredException|CodeDeploy.InvalidApplicationNameException|any, data: any) => void): Request;
    deleteDeploymentConfig(params: CodeDeploy.DeleteDeploymentConfigInput, callback?: (err: CodeDeploy.InvalidDeploymentConfigNameException|CodeDeploy.DeploymentConfigNameRequiredException|CodeDeploy.DeploymentConfigInUseException|CodeDeploy.InvalidOperationException|any, data: any) => void): Request;
    deleteDeploymentGroup(params: CodeDeploy.DeleteDeploymentGroupInput, callback?: (err: CodeDeploy.ApplicationNameRequiredException|CodeDeploy.InvalidApplicationNameException|CodeDeploy.DeploymentGroupNameRequiredException|CodeDeploy.InvalidDeploymentGroupNameException|CodeDeploy.InvalidRoleException|any, data: CodeDeploy.DeleteDeploymentGroupOutput|any) => void): Request;
    deregisterOnPremisesInstance(params: CodeDeploy.DeregisterOnPremisesInstanceInput, callback?: (err: CodeDeploy.InstanceNameRequiredException|CodeDeploy.InvalidInstanceNameException|any, data: any) => void): Request;
    getApplication(params: CodeDeploy.GetApplicationInput, callback?: (err: CodeDeploy.ApplicationNameRequiredException|CodeDeploy.InvalidApplicationNameException|CodeDeploy.ApplicationDoesNotExistException|any, data: CodeDeploy.GetApplicationOutput|any) => void): Request;
    getApplicationRevision(params: CodeDeploy.GetApplicationRevisionInput, callback?: (err: CodeDeploy.ApplicationDoesNotExistException|CodeDeploy.ApplicationNameRequiredException|CodeDeploy.InvalidApplicationNameException|CodeDeploy.RevisionDoesNotExistException|CodeDeploy.RevisionRequiredException|CodeDeploy.InvalidRevisionException|any, data: CodeDeploy.GetApplicationRevisionOutput|any) => void): Request;
    getDeployment(params: CodeDeploy.GetDeploymentInput, callback?: (err: CodeDeploy.DeploymentIdRequiredException|CodeDeploy.InvalidDeploymentIdException|CodeDeploy.DeploymentDoesNotExistException|any, data: CodeDeploy.GetDeploymentOutput|any) => void): Request;
    getDeploymentConfig(params: CodeDeploy.GetDeploymentConfigInput, callback?: (err: CodeDeploy.InvalidDeploymentConfigNameException|CodeDeploy.DeploymentConfigNameRequiredException|CodeDeploy.DeploymentConfigDoesNotExistException|any, data: CodeDeploy.GetDeploymentConfigOutput|any) => void): Request;
    getDeploymentGroup(params: CodeDeploy.GetDeploymentGroupInput, callback?: (err: CodeDeploy.ApplicationNameRequiredException|CodeDeploy.InvalidApplicationNameException|CodeDeploy.ApplicationDoesNotExistException|CodeDeploy.DeploymentGroupNameRequiredException|CodeDeploy.InvalidDeploymentGroupNameException|CodeDeploy.DeploymentGroupDoesNotExistException|any, data: CodeDeploy.GetDeploymentGroupOutput|any) => void): Request;
    getDeploymentInstance(params: CodeDeploy.GetDeploymentInstanceInput, callback?: (err: CodeDeploy.DeploymentIdRequiredException|CodeDeploy.DeploymentDoesNotExistException|CodeDeploy.InstanceIdRequiredException|CodeDeploy.InvalidDeploymentIdException|CodeDeploy.InstanceDoesNotExistException|CodeDeploy.InvalidInstanceNameException|any, data: CodeDeploy.GetDeploymentInstanceOutput|any) => void): Request;
    getOnPremisesInstance(params: CodeDeploy.GetOnPremisesInstanceInput, callback?: (err: CodeDeploy.InstanceNameRequiredException|CodeDeploy.InstanceNotRegisteredException|CodeDeploy.InvalidInstanceNameException|any, data: CodeDeploy.GetOnPremisesInstanceOutput|any) => void): Request;
    listApplicationRevisions(params: CodeDeploy.ListApplicationRevisionsInput, callback?: (err: CodeDeploy.ApplicationDoesNotExistException|CodeDeploy.ApplicationNameRequiredException|CodeDeploy.InvalidApplicationNameException|CodeDeploy.InvalidSortByException|CodeDeploy.InvalidSortOrderException|CodeDeploy.InvalidBucketNameFilterException|CodeDeploy.InvalidKeyPrefixFilterException|CodeDeploy.BucketNameFilterRequiredException|CodeDeploy.InvalidDeployedStateFilterException|CodeDeploy.InvalidNextTokenException|any, data: CodeDeploy.ListApplicationRevisionsOutput|any) => void): Request;
    listApplications(params: CodeDeploy.ListApplicationsInput, callback?: (err: CodeDeploy.InvalidNextTokenException|any, data: CodeDeploy.ListApplicationsOutput|any) => void): Request;
    listDeploymentConfigs(params: CodeDeploy.ListDeploymentConfigsInput, callback?: (err: CodeDeploy.InvalidNextTokenException|any, data: CodeDeploy.ListDeploymentConfigsOutput|any) => void): Request;
    listDeploymentGroups(params: CodeDeploy.ListDeploymentGroupsInput, callback?: (err: CodeDeploy.ApplicationNameRequiredException|CodeDeploy.InvalidApplicationNameException|CodeDeploy.ApplicationDoesNotExistException|CodeDeploy.InvalidNextTokenException|any, data: CodeDeploy.ListDeploymentGroupsOutput|any) => void): Request;
    listDeploymentInstances(params: CodeDeploy.ListDeploymentInstancesInput, callback?: (err: CodeDeploy.DeploymentIdRequiredException|CodeDeploy.DeploymentDoesNotExistException|CodeDeploy.DeploymentNotStartedException|CodeDeploy.InvalidNextTokenException|CodeDeploy.InvalidDeploymentIdException|CodeDeploy.InvalidInstanceStatusException|any, data: CodeDeploy.ListDeploymentInstancesOutput|any) => void): Request;
    listDeployments(params: CodeDeploy.ListDeploymentsInput, callback?: (err: CodeDeploy.ApplicationNameRequiredException|CodeDeploy.InvalidApplicationNameException|CodeDeploy.ApplicationDoesNotExistException|CodeDeploy.InvalidDeploymentGroupNameException|CodeDeploy.DeploymentGroupDoesNotExistException|CodeDeploy.DeploymentGroupNameRequiredException|CodeDeploy.InvalidTimeRangeException|CodeDeploy.InvalidDeploymentStatusException|CodeDeploy.InvalidNextTokenException|any, data: CodeDeploy.ListDeploymentsOutput|any) => void): Request;
    listOnPremisesInstances(params: CodeDeploy.ListOnPremisesInstancesInput, callback?: (err: CodeDeploy.InvalidRegistrationStatusException|CodeDeploy.InvalidTagFilterException|CodeDeploy.InvalidNextTokenException|any, data: CodeDeploy.ListOnPremisesInstancesOutput|any) => void): Request;
    registerApplicationRevision(params: CodeDeploy.RegisterApplicationRevisionInput, callback?: (err: CodeDeploy.ApplicationDoesNotExistException|CodeDeploy.ApplicationNameRequiredException|CodeDeploy.InvalidApplicationNameException|CodeDeploy.DescriptionTooLongException|CodeDeploy.RevisionRequiredException|CodeDeploy.InvalidRevisionException|any, data: any) => void): Request;
    registerOnPremisesInstance(params: CodeDeploy.RegisterOnPremisesInstanceInput, callback?: (err: CodeDeploy.InstanceNameAlreadyRegisteredException|CodeDeploy.IamUserArnAlreadyRegisteredException|CodeDeploy.InstanceNameRequiredException|CodeDeploy.IamUserArnRequiredException|CodeDeploy.InvalidInstanceNameException|CodeDeploy.InvalidIamUserArnException|any, data: any) => void): Request;
    removeTagsFromOnPremisesInstances(params: CodeDeploy.RemoveTagsFromOnPremisesInstancesInput, callback?: (err: CodeDeploy.InstanceNameRequiredException|CodeDeploy.TagRequiredException|CodeDeploy.InvalidTagException|CodeDeploy.TagLimitExceededException|CodeDeploy.InstanceLimitExceededException|CodeDeploy.InstanceNotRegisteredException|any, data: any) => void): Request;
    stopDeployment(params: CodeDeploy.StopDeploymentInput, callback?: (err: CodeDeploy.DeploymentIdRequiredException|CodeDeploy.DeploymentDoesNotExistException|CodeDeploy.DeploymentAlreadyCompletedException|CodeDeploy.InvalidDeploymentIdException|any, data: CodeDeploy.StopDeploymentOutput|any) => void): Request;
    updateApplication(params: CodeDeploy.UpdateApplicationInput, callback?: (err: CodeDeploy.ApplicationNameRequiredException|CodeDeploy.InvalidApplicationNameException|CodeDeploy.ApplicationAlreadyExistsException|CodeDeploy.ApplicationDoesNotExistException|any, data: any) => void): Request;
    updateDeploymentGroup(params: CodeDeploy.UpdateDeploymentGroupInput, callback?: (err: CodeDeploy.ApplicationNameRequiredException|CodeDeploy.InvalidApplicationNameException|CodeDeploy.ApplicationDoesNotExistException|CodeDeploy.InvalidDeploymentGroupNameException|CodeDeploy.DeploymentGroupAlreadyExistsException|CodeDeploy.DeploymentGroupNameRequiredException|CodeDeploy.DeploymentGroupDoesNotExistException|CodeDeploy.InvalidEC2TagException|CodeDeploy.InvalidTagException|CodeDeploy.InvalidAutoScalingGroupException|CodeDeploy.InvalidDeploymentConfigNameException|CodeDeploy.DeploymentConfigDoesNotExistException|CodeDeploy.InvalidRoleException|CodeDeploy.LifecycleHookLimitExceededException|CodeDeploy.InvalidTriggerConfigException|CodeDeploy.TriggerTargetsLimitExceededException|any, data: CodeDeploy.UpdateDeploymentGroupOutput|any) => void): Request;

  }

  export module CodeDeploy {
    export type ApplicationId = string;
    export type ApplicationName = string;    // max: 100, min: 1
    export type ApplicationRevisionSortBy = string;
    export type ApplicationsInfoList = ApplicationInfo[];
    export type ApplicationsList = ApplicationName[];
    export type AutoScalingGroupHook = string;
    export type AutoScalingGroupList = AutoScalingGroup[];
    export type AutoScalingGroupName = string;
    export type AutoScalingGroupNameList = AutoScalingGroupName[];
    export type Boolean = boolean;
    export type BundleType = string;
    export type CommitId = string;
    export type DeploymentConfigId = string;
    export type DeploymentConfigName = string;    // max: 100, min: 1
    export type DeploymentConfigsList = DeploymentConfigName[];
    export type DeploymentCreator = string;
    export type DeploymentGroupId = string;
    export type DeploymentGroupInfoList = DeploymentGroupInfo[];
    export type DeploymentGroupName = string;    // max: 100, min: 1
    export type DeploymentGroupsList = DeploymentGroupName[];
    export type DeploymentId = string;
    export type DeploymentStatus = string;
    export type DeploymentStatusList = DeploymentStatus[];
    export type DeploymentsInfoList = DeploymentInfo[];
    export type DeploymentsList = DeploymentId[];
    export type Description = string;
    export type EC2TagFilterList = EC2TagFilter[];
    export type EC2TagFilterType = string;
    export type ETag = string;
    export type ErrorCode = string;
    export type ErrorMessage = string;
    export type IamUserArn = string;
    export type InstanceArn = string;
    export type InstanceCount = number;
    export type InstanceId = string;
    export type InstanceInfoList = InstanceInfo[];
    export type InstanceName = string;
    export type InstanceNameList = InstanceName[];
    export type InstanceStatus = string;
    export type InstanceStatusList = InstanceStatus[];
    export type InstanceSummaryList = InstanceSummary[];
    export type InstancesList = InstanceId[];
    export type Key = string;
    export type LifecycleErrorCode = string;
    export type LifecycleEventList = LifecycleEvent[];
    export type LifecycleEventName = string;
    export type LifecycleEventStatus = string;
    export type LifecycleMessage = string;
    export type ListStateFilterAction = string;
    export type LogTail = string;
    export type Message = string;
    export type MinimumHealthyHostsType = string;
    export type MinimumHealthyHostsValue = number;
    export type NextToken = string;
    export type RegistrationStatus = string;
    export type Repository = string;
    export type RevisionInfoList = RevisionInfo[];
    export type RevisionLocationList = RevisionLocation[];
    export type RevisionLocationType = string;
    export type Role = string;
    export type S3Bucket = string;
    export type S3Key = string;
    export type ScriptName = string;
    export type SortOrder = string;
    export type StopStatus = string;
    export type TagFilterList = TagFilter[];
    export type TagFilterType = string;
    export type TagList = Tag[];
    export type Timestamp = number;
    export type TriggerConfigList = TriggerConfig[];
    export type TriggerEventType = string;
    export type TriggerEventTypeList = TriggerEventType[];
    export type TriggerName = string;
    export type TriggerTargetArn = string;
    export type Value = string;
    export type VersionId = string;

    export interface AddTagsToOnPremisesInstancesInput {
        tags: TagList;
        instanceNames: InstanceNameList;
    }
    export interface ApplicationAlreadyExistsException {
    }
    export interface ApplicationDoesNotExistException {
    }
    export interface ApplicationInfo {
        applicationId?: ApplicationId;
        applicationName?: ApplicationName;
        createTime?: Timestamp;
        linkedToGitHub?: Boolean;
    }
    export interface ApplicationLimitExceededException {
    }
    export interface ApplicationNameRequiredException {
    }
    export interface AutoScalingGroup {
        name?: AutoScalingGroupName;
        hook?: AutoScalingGroupHook;
    }
    export interface BatchGetApplicationRevisionsInput {
        applicationName: ApplicationName;
        revisions: RevisionLocationList;
    }
    export interface BatchGetApplicationRevisionsOutput {
        applicationName?: ApplicationName;
        errorMessage?: ErrorMessage;
        revisions?: RevisionInfoList;
    }
    export interface BatchGetApplicationsInput {
        applicationNames?: ApplicationsList;
    }
    export interface BatchGetApplicationsOutput {
        applicationsInfo?: ApplicationsInfoList;
    }
    export interface BatchGetDeploymentGroupsInput {
        applicationName: ApplicationName;
        deploymentGroupNames: DeploymentGroupsList;
    }
    export interface BatchGetDeploymentGroupsOutput {
        deploymentGroupsInfo?: DeploymentGroupInfoList;
        errorMessage?: ErrorMessage;
    }
    export interface BatchGetDeploymentInstancesInput {
        deploymentId: DeploymentId;
        instanceIds: InstancesList;
    }
    export interface BatchGetDeploymentInstancesOutput {
        instancesSummary?: InstanceSummaryList;
        errorMessage?: ErrorMessage;
    }
    export interface BatchGetDeploymentsInput {
        deploymentIds?: DeploymentsList;
    }
    export interface BatchGetDeploymentsOutput {
        deploymentsInfo?: DeploymentsInfoList;
    }
    export interface BatchGetOnPremisesInstancesInput {
        instanceNames?: InstanceNameList;
    }
    export interface BatchGetOnPremisesInstancesOutput {
        instanceInfos?: InstanceInfoList;
    }
    export interface BatchLimitExceededException {
    }
    export interface BucketNameFilterRequiredException {
    }
    export interface CreateApplicationInput {
        applicationName: ApplicationName;
    }
    export interface CreateApplicationOutput {
        applicationId?: ApplicationId;
    }
    export interface CreateDeploymentConfigInput {
        deploymentConfigName: DeploymentConfigName;
        minimumHealthyHosts?: MinimumHealthyHosts;
    }
    export interface CreateDeploymentConfigOutput {
        deploymentConfigId?: DeploymentConfigId;
    }
    export interface CreateDeploymentGroupInput {
        applicationName: ApplicationName;
        deploymentGroupName: DeploymentGroupName;
        deploymentConfigName?: DeploymentConfigName;
        ec2TagFilters?: EC2TagFilterList;
        onPremisesInstanceTagFilters?: TagFilterList;
        autoScalingGroups?: AutoScalingGroupNameList;
        serviceRoleArn: Role;
        triggerConfigurations?: TriggerConfigList;
    }
    export interface CreateDeploymentGroupOutput {
        deploymentGroupId?: DeploymentGroupId;
    }
    export interface CreateDeploymentInput {
        applicationName: ApplicationName;
        deploymentGroupName?: DeploymentGroupName;
        revision?: RevisionLocation;
        deploymentConfigName?: DeploymentConfigName;
        description?: Description;
        ignoreApplicationStopFailures?: Boolean;
    }
    export interface CreateDeploymentOutput {
        deploymentId?: DeploymentId;
    }
    export interface DeleteApplicationInput {
        applicationName: ApplicationName;
    }
    export interface DeleteDeploymentConfigInput {
        deploymentConfigName: DeploymentConfigName;
    }
    export interface DeleteDeploymentGroupInput {
        applicationName: ApplicationName;
        deploymentGroupName: DeploymentGroupName;
    }
    export interface DeleteDeploymentGroupOutput {
        hooksNotCleanedUp?: AutoScalingGroupList;
    }
    export interface DeploymentAlreadyCompletedException {
    }
    export interface DeploymentConfigAlreadyExistsException {
    }
    export interface DeploymentConfigDoesNotExistException {
    }
    export interface DeploymentConfigInUseException {
    }
    export interface DeploymentConfigInfo {
        deploymentConfigId?: DeploymentConfigId;
        deploymentConfigName?: DeploymentConfigName;
        minimumHealthyHosts?: MinimumHealthyHosts;
        createTime?: Timestamp;
    }
    export interface DeploymentConfigLimitExceededException {
    }
    export interface DeploymentConfigNameRequiredException {
    }
    export interface DeploymentDoesNotExistException {
    }
    export interface DeploymentGroupAlreadyExistsException {
    }
    export interface DeploymentGroupDoesNotExistException {
    }
    export interface DeploymentGroupInfo {
        applicationName?: ApplicationName;
        deploymentGroupId?: DeploymentGroupId;
        deploymentGroupName?: DeploymentGroupName;
        deploymentConfigName?: DeploymentConfigName;
        ec2TagFilters?: EC2TagFilterList;
        onPremisesInstanceTagFilters?: TagFilterList;
        autoScalingGroups?: AutoScalingGroupList;
        serviceRoleArn?: Role;
        targetRevision?: RevisionLocation;
        triggerConfigurations?: TriggerConfigList;
    }
    export interface DeploymentGroupLimitExceededException {
    }
    export interface DeploymentGroupNameRequiredException {
    }
    export interface DeploymentIdRequiredException {
    }
    export interface DeploymentInfo {
        applicationName?: ApplicationName;
        deploymentGroupName?: DeploymentGroupName;
        deploymentConfigName?: DeploymentConfigName;
        deploymentId?: DeploymentId;
        revision?: RevisionLocation;
        status?: DeploymentStatus;
        errorInformation?: ErrorInformation;
        createTime?: Timestamp;
        startTime?: Timestamp;
        completeTime?: Timestamp;
        deploymentOverview?: DeploymentOverview;
        description?: Description;
        creator?: DeploymentCreator;
        ignoreApplicationStopFailures?: Boolean;
    }
    export interface DeploymentLimitExceededException {
    }
    export interface DeploymentNotStartedException {
    }
    export interface DeploymentOverview {
        Pending?: InstanceCount;
        InProgress?: InstanceCount;
        Succeeded?: InstanceCount;
        Failed?: InstanceCount;
        Skipped?: InstanceCount;
    }
    export interface DeregisterOnPremisesInstanceInput {
        instanceName: InstanceName;
    }
    export interface DescriptionTooLongException {
    }
    export interface Diagnostics {
        errorCode?: LifecycleErrorCode;
        scriptName?: ScriptName;
        message?: LifecycleMessage;
        logTail?: LogTail;
    }
    export interface EC2TagFilter {
        Key?: Key;
        Value?: Value;
        Type?: EC2TagFilterType;
    }
    export interface ErrorInformation {
        code?: ErrorCode;
        message?: ErrorMessage;
    }
    export interface GenericRevisionInfo {
        description?: Description;
        deploymentGroups?: DeploymentGroupsList;
        firstUsedTime?: Timestamp;
        lastUsedTime?: Timestamp;
        registerTime?: Timestamp;
    }
    export interface GetApplicationInput {
        applicationName: ApplicationName;
    }
    export interface GetApplicationOutput {
        application?: ApplicationInfo;
    }
    export interface GetApplicationRevisionInput {
        applicationName: ApplicationName;
        revision: RevisionLocation;
    }
    export interface GetApplicationRevisionOutput {
        applicationName?: ApplicationName;
        revision?: RevisionLocation;
        revisionInfo?: GenericRevisionInfo;
    }
    export interface GetDeploymentConfigInput {
        deploymentConfigName: DeploymentConfigName;
    }
    export interface GetDeploymentConfigOutput {
        deploymentConfigInfo?: DeploymentConfigInfo;
    }
    export interface GetDeploymentGroupInput {
        applicationName: ApplicationName;
        deploymentGroupName: DeploymentGroupName;
    }
    export interface GetDeploymentGroupOutput {
        deploymentGroupInfo?: DeploymentGroupInfo;
    }
    export interface GetDeploymentInput {
        deploymentId: DeploymentId;
    }
    export interface GetDeploymentInstanceInput {
        deploymentId: DeploymentId;
        instanceId: InstanceId;
    }
    export interface GetDeploymentInstanceOutput {
        instanceSummary?: InstanceSummary;
    }
    export interface GetDeploymentOutput {
        deploymentInfo?: DeploymentInfo;
    }
    export interface GetOnPremisesInstanceInput {
        instanceName: InstanceName;
    }
    export interface GetOnPremisesInstanceOutput {
        instanceInfo?: InstanceInfo;
    }
    export interface GitHubLocation {
        repository?: Repository;
        commitId?: CommitId;
    }
    export interface IamUserArnAlreadyRegisteredException {
    }
    export interface IamUserArnRequiredException {
    }
    export interface InstanceDoesNotExistException {
    }
    export interface InstanceIdRequiredException {
    }
    export interface InstanceInfo {
        instanceName?: InstanceName;
        iamUserArn?: IamUserArn;
        instanceArn?: InstanceArn;
        registerTime?: Timestamp;
        deregisterTime?: Timestamp;
        tags?: TagList;
    }
    export interface InstanceLimitExceededException {
    }
    export interface InstanceNameAlreadyRegisteredException {
    }
    export interface InstanceNameRequiredException {
    }
    export interface InstanceNotRegisteredException {
    }
    export interface InstanceSummary {
        deploymentId?: DeploymentId;
        instanceId?: InstanceId;
        status?: InstanceStatus;
        lastUpdatedAt?: Timestamp;
        lifecycleEvents?: LifecycleEventList;
    }
    export interface InvalidApplicationNameException {
    }
    export interface InvalidAutoScalingGroupException {
    }
    export interface InvalidBucketNameFilterException {
    }
    export interface InvalidDeployedStateFilterException {
    }
    export interface InvalidDeploymentConfigNameException {
    }
    export interface InvalidDeploymentGroupNameException {
    }
    export interface InvalidDeploymentIdException {
    }
    export interface InvalidDeploymentStatusException {
    }
    export interface InvalidEC2TagException {
    }
    export interface InvalidIamUserArnException {
    }
    export interface InvalidInstanceNameException {
    }
    export interface InvalidInstanceStatusException {
    }
    export interface InvalidKeyPrefixFilterException {
    }
    export interface InvalidMinimumHealthyHostValueException {
    }
    export interface InvalidNextTokenException {
    }
    export interface InvalidOperationException {
    }
    export interface InvalidRegistrationStatusException {
    }
    export interface InvalidRevisionException {
    }
    export interface InvalidRoleException {
    }
    export interface InvalidSortByException {
    }
    export interface InvalidSortOrderException {
    }
    export interface InvalidTagException {
    }
    export interface InvalidTagFilterException {
    }
    export interface InvalidTimeRangeException {
    }
    export interface InvalidTriggerConfigException {
    }
    export interface LifecycleEvent {
        lifecycleEventName?: LifecycleEventName;
        diagnostics?: Diagnostics;
        startTime?: Timestamp;
        endTime?: Timestamp;
        status?: LifecycleEventStatus;
    }
    export interface LifecycleHookLimitExceededException {
    }
    export interface ListApplicationRevisionsInput {
        applicationName: ApplicationName;
        sortBy?: ApplicationRevisionSortBy;
        sortOrder?: SortOrder;
        s3Bucket?: S3Bucket;
        s3KeyPrefix?: S3Key;
        deployed?: ListStateFilterAction;
        nextToken?: NextToken;
    }
    export interface ListApplicationRevisionsOutput {
        revisions?: RevisionLocationList;
        nextToken?: NextToken;
    }
    export interface ListApplicationsInput {
        nextToken?: NextToken;
    }
    export interface ListApplicationsOutput {
        applications?: ApplicationsList;
        nextToken?: NextToken;
    }
    export interface ListDeploymentConfigsInput {
        nextToken?: NextToken;
    }
    export interface ListDeploymentConfigsOutput {
        deploymentConfigsList?: DeploymentConfigsList;
        nextToken?: NextToken;
    }
    export interface ListDeploymentGroupsInput {
        applicationName: ApplicationName;
        nextToken?: NextToken;
    }
    export interface ListDeploymentGroupsOutput {
        applicationName?: ApplicationName;
        deploymentGroups?: DeploymentGroupsList;
        nextToken?: NextToken;
    }
    export interface ListDeploymentInstancesInput {
        deploymentId: DeploymentId;
        nextToken?: NextToken;
        instanceStatusFilter?: InstanceStatusList;
    }
    export interface ListDeploymentInstancesOutput {
        instancesList?: InstancesList;
        nextToken?: NextToken;
    }
    export interface ListDeploymentsInput {
        applicationName?: ApplicationName;
        deploymentGroupName?: DeploymentGroupName;
        includeOnlyStatuses?: DeploymentStatusList;
        createTimeRange?: TimeRange;
        nextToken?: NextToken;
    }
    export interface ListDeploymentsOutput {
        deployments?: DeploymentsList;
        nextToken?: NextToken;
    }
    export interface ListOnPremisesInstancesInput {
        registrationStatus?: RegistrationStatus;
        tagFilters?: TagFilterList;
        nextToken?: NextToken;
    }
    export interface ListOnPremisesInstancesOutput {
        instanceNames?: InstanceNameList;
        nextToken?: NextToken;
    }
    export interface MinimumHealthyHosts {
        value?: MinimumHealthyHostsValue;
        type?: MinimumHealthyHostsType;
    }
    export interface RegisterApplicationRevisionInput {
        applicationName: ApplicationName;
        description?: Description;
        revision: RevisionLocation;
    }
    export interface RegisterOnPremisesInstanceInput {
        instanceName: InstanceName;
        iamUserArn: IamUserArn;
    }
    export interface RemoveTagsFromOnPremisesInstancesInput {
        tags: TagList;
        instanceNames: InstanceNameList;
    }
    export interface RevisionDoesNotExistException {
    }
    export interface RevisionInfo {
        revisionLocation?: RevisionLocation;
        genericRevisionInfo?: GenericRevisionInfo;
    }
    export interface RevisionLocation {
        revisionType?: RevisionLocationType;
        s3Location?: S3Location;
        gitHubLocation?: GitHubLocation;
    }
    export interface RevisionRequiredException {
    }
    export interface RoleRequiredException {
    }
    export interface S3Location {
        bucket?: S3Bucket;
        key?: S3Key;
        bundleType?: BundleType;
        version?: VersionId;
        eTag?: ETag;
    }
    export interface StopDeploymentInput {
        deploymentId: DeploymentId;
    }
    export interface StopDeploymentOutput {
        status?: StopStatus;
        statusMessage?: Message;
    }
    export interface Tag {
        Key?: Key;
        Value?: Value;
    }
    export interface TagFilter {
        Key?: Key;
        Value?: Value;
        Type?: TagFilterType;
    }
    export interface TagLimitExceededException {
    }
    export interface TagRequiredException {
    }
    export interface TimeRange {
        start?: Timestamp;
        end?: Timestamp;
    }
    export interface TriggerConfig {
        triggerName?: TriggerName;
        triggerTargetArn?: TriggerTargetArn;
        triggerEvents?: TriggerEventTypeList;
    }
    export interface TriggerTargetsLimitExceededException {
    }
    export interface UpdateApplicationInput {
        applicationName?: ApplicationName;
        newApplicationName?: ApplicationName;
    }
    export interface UpdateDeploymentGroupInput {
        applicationName: ApplicationName;
        currentDeploymentGroupName: DeploymentGroupName;
        newDeploymentGroupName?: DeploymentGroupName;
        deploymentConfigName?: DeploymentConfigName;
        ec2TagFilters?: EC2TagFilterList;
        onPremisesInstanceTagFilters?: TagFilterList;
        autoScalingGroups?: AutoScalingGroupNameList;
        serviceRoleArn?: Role;
        triggerConfigurations?: TriggerConfigList;
    }
    export interface UpdateDeploymentGroupOutput {
        hooksNotCleanedUp?: AutoScalingGroupList;
    }
  }

  /*
   * apiVersion: 2015-07-09
   * endpointPrefix: codepipeline
   * serviceAbbreviation: CodePipeline
   * signatureVersion: v4
   * protocol: json
   */
  export class CodePipeline extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    acknowledgeJob(params: CodePipeline.AcknowledgeJobInput, callback?: (err: CodePipeline.ValidationException|CodePipeline.InvalidNonceException|CodePipeline.JobNotFoundException|any, data: CodePipeline.AcknowledgeJobOutput|any) => void): Request;
    acknowledgeThirdPartyJob(params: CodePipeline.AcknowledgeThirdPartyJobInput, callback?: (err: CodePipeline.ValidationException|CodePipeline.InvalidNonceException|CodePipeline.JobNotFoundException|CodePipeline.InvalidClientTokenException|any, data: CodePipeline.AcknowledgeThirdPartyJobOutput|any) => void): Request;
    createCustomActionType(params: CodePipeline.CreateCustomActionTypeInput, callback?: (err: CodePipeline.ValidationException|CodePipeline.LimitExceededException|any, data: CodePipeline.CreateCustomActionTypeOutput|any) => void): Request;
    createPipeline(params: CodePipeline.CreatePipelineInput, callback?: (err: CodePipeline.ValidationException|CodePipeline.PipelineNameInUseException|CodePipeline.InvalidStageDeclarationException|CodePipeline.InvalidActionDeclarationException|CodePipeline.InvalidBlockerDeclarationException|CodePipeline.InvalidStructureException|CodePipeline.LimitExceededException|any, data: CodePipeline.CreatePipelineOutput|any) => void): Request;
    deleteCustomActionType(params: CodePipeline.DeleteCustomActionTypeInput, callback?: (err: CodePipeline.ValidationException|any, data: any) => void): Request;
    deletePipeline(params: CodePipeline.DeletePipelineInput, callback?: (err: CodePipeline.ValidationException|any, data: any) => void): Request;
    disableStageTransition(params: CodePipeline.DisableStageTransitionInput, callback?: (err: CodePipeline.ValidationException|CodePipeline.PipelineNotFoundException|CodePipeline.StageNotFoundException|any, data: any) => void): Request;
    enableStageTransition(params: CodePipeline.EnableStageTransitionInput, callback?: (err: CodePipeline.ValidationException|CodePipeline.PipelineNotFoundException|CodePipeline.StageNotFoundException|any, data: any) => void): Request;
    getJobDetails(params: CodePipeline.GetJobDetailsInput, callback?: (err: CodePipeline.ValidationException|CodePipeline.JobNotFoundException|any, data: CodePipeline.GetJobDetailsOutput|any) => void): Request;
    getPipeline(params: CodePipeline.GetPipelineInput, callback?: (err: CodePipeline.ValidationException|CodePipeline.PipelineNotFoundException|CodePipeline.PipelineVersionNotFoundException|any, data: CodePipeline.GetPipelineOutput|any) => void): Request;
    getPipelineState(params: CodePipeline.GetPipelineStateInput, callback?: (err: CodePipeline.ValidationException|CodePipeline.PipelineNotFoundException|any, data: CodePipeline.GetPipelineStateOutput|any) => void): Request;
    getThirdPartyJobDetails(params: CodePipeline.GetThirdPartyJobDetailsInput, callback?: (err: CodePipeline.JobNotFoundException|CodePipeline.ValidationException|CodePipeline.InvalidClientTokenException|CodePipeline.InvalidJobException|any, data: CodePipeline.GetThirdPartyJobDetailsOutput|any) => void): Request;
    listActionTypes(params: CodePipeline.ListActionTypesInput, callback?: (err: CodePipeline.ValidationException|CodePipeline.InvalidNextTokenException|any, data: CodePipeline.ListActionTypesOutput|any) => void): Request;
    listPipelines(params: CodePipeline.ListPipelinesInput, callback?: (err: CodePipeline.InvalidNextTokenException|any, data: CodePipeline.ListPipelinesOutput|any) => void): Request;
    pollForJobs(params: CodePipeline.PollForJobsInput, callback?: (err: CodePipeline.ValidationException|CodePipeline.ActionTypeNotFoundException|any, data: CodePipeline.PollForJobsOutput|any) => void): Request;
    pollForThirdPartyJobs(params: CodePipeline.PollForThirdPartyJobsInput, callback?: (err: CodePipeline.ActionTypeNotFoundException|CodePipeline.ValidationException|any, data: CodePipeline.PollForThirdPartyJobsOutput|any) => void): Request;
    putActionRevision(params: CodePipeline.PutActionRevisionInput, callback?: (err: CodePipeline.PipelineNotFoundException|CodePipeline.StageNotFoundException|CodePipeline.ActionNotFoundException|CodePipeline.ValidationException|any, data: CodePipeline.PutActionRevisionOutput|any) => void): Request;
    putJobFailureResult(params: CodePipeline.PutJobFailureResultInput, callback?: (err: CodePipeline.ValidationException|CodePipeline.JobNotFoundException|CodePipeline.InvalidJobStateException|any, data: any) => void): Request;
    putJobSuccessResult(params: CodePipeline.PutJobSuccessResultInput, callback?: (err: CodePipeline.ValidationException|CodePipeline.JobNotFoundException|CodePipeline.InvalidJobStateException|any, data: any) => void): Request;
    putThirdPartyJobFailureResult(params: CodePipeline.PutThirdPartyJobFailureResultInput, callback?: (err: CodePipeline.ValidationException|CodePipeline.JobNotFoundException|CodePipeline.InvalidJobStateException|CodePipeline.InvalidClientTokenException|any, data: any) => void): Request;
    putThirdPartyJobSuccessResult(params: CodePipeline.PutThirdPartyJobSuccessResultInput, callback?: (err: CodePipeline.ValidationException|CodePipeline.JobNotFoundException|CodePipeline.InvalidJobStateException|CodePipeline.InvalidClientTokenException|any, data: any) => void): Request;
    startPipelineExecution(params: CodePipeline.StartPipelineExecutionInput, callback?: (err: CodePipeline.ValidationException|CodePipeline.PipelineNotFoundException|any, data: CodePipeline.StartPipelineExecutionOutput|any) => void): Request;
    updatePipeline(params: CodePipeline.UpdatePipelineInput, callback?: (err: CodePipeline.ValidationException|CodePipeline.InvalidStageDeclarationException|CodePipeline.InvalidActionDeclarationException|CodePipeline.InvalidBlockerDeclarationException|CodePipeline.InvalidStructureException|any, data: CodePipeline.UpdatePipelineOutput|any) => void): Request;

  }

  export module CodePipeline {
    export type AccessKeyId = string;
    export type AccountId = string;    // pattern: &quot;[0-9]{12}&quot;
    export type ActionCategory = string;
    export type ActionConfigurationKey = string;    // max: 50, min: 1
    export type ActionConfigurationMap = {[key:string]: ActionConfigurationValue};
    export type ActionConfigurationPropertyList = ActionConfigurationProperty[];    // max: 10
    export type ActionConfigurationPropertyType = string;
    export type ActionConfigurationQueryableValue = string;    // pattern: &quot;[a-zA-Z0-9_-]+&quot;, max: 20, min: 1
    export type ActionConfigurationValue = string;    // max: 250, min: 1
    export type ActionExecutionStatus = string;
    export type ActionName = string;    // pattern: &quot;[A-Za-z0-9.@\-_]+&quot;, max: 100, min: 1
    export type ActionOwner = string;
    export type ActionProvider = string;    // pattern: &quot;[0-9A-Za-z_-]+&quot;, max: 25, min: 1
    export type ActionRunOrder = number;    // max: 999, min: 1
    export type ActionStateList = ActionState[];
    export type ActionTypeList = ActionType[];
    export type ArtifactList = Artifact[];
    export type ArtifactLocationType = string;
    export type ArtifactName = string;    // pattern: &quot;[a-zA-Z0-9_\-]+&quot;, max: 100, min: 1
    export type ArtifactStoreLocation = string;    // pattern: &quot;[a-zA-Z0-9\-\.]+&quot;, max: 63, min: 3
    export type ArtifactStoreType = string;
    export type BlockerName = string;    // max: 100, min: 1
    export type BlockerType = string;
    export type Boolean = boolean;
    export type ClientId = string;    // pattern: &quot;[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}&quot;
    export type ClientToken = string;
    export type Code = string;
    export type ContinuationToken = string;
    export type Description = string;    // max: 2048, min: 1
    export type DisabledReason = string;    // pattern: &quot;[a-zA-Z0-9!@ \(\)\.\*\?\-]+&quot;, max: 300, min: 1
    export type Enabled = boolean;
    export type EncryptionKeyId = string;    // max: 100, min: 1
    export type EncryptionKeyType = string;
    export type ExecutionId = string;
    export type ExecutionSummary = string;
    export type FailureType = string;
    export type InputArtifactList = InputArtifact[];
    export type JobId = string;    // pattern: &quot;[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}&quot;
    export type JobList = Job[];
    export type JobStatus = string;
    export type LastChangedAt = number;
    export type LastChangedBy = string;
    export type MaxBatchSize = number;    // min: 1
    export type MaximumArtifactCount = number;    // max: 5
    export type Message = string;
    export type MinimumArtifactCount = number;    // max: 5
    export type NextToken = string;
    export type Nonce = string;
    export type OutputArtifactList = OutputArtifact[];
    export type Percentage = number;    // max: 100
    export type PipelineExecutionId = string;    // pattern: &quot;[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}&quot;
    export type PipelineList = PipelineSummary[];
    export type PipelineName = string;    // pattern: &quot;[A-Za-z0-9.@\-_]+&quot;, max: 100, min: 1
    export type PipelineStageDeclarationList = StageDeclaration[];
    export type PipelineVersion = number;    // min: 1
    export type QueryParamMap = {[key:string]: ActionConfigurationQueryableValue};    // max: 1
    export type Revision = string;
    export type RevisionChangeId = string;
    export type RevisionChangeIdentifier = string;
    export type RevisionId = string;
    export type RoleArn = string;    // pattern: &quot;arn:[^:]+:iam::[0-9]{12}:role/.*&quot;
    export type S3BucketName = string;
    export type S3ObjectKey = string;
    export type SecretAccessKey = string;
    export type SessionToken = string;
    export type StageActionDeclarationList = ActionDeclaration[];
    export type StageBlockerDeclarationList = BlockerDeclaration[];
    export type StageName = string;    // pattern: &quot;[A-Za-z0-9.@\-_]+&quot;, max: 100, min: 1
    export type StageStateList = StageState[];
    export type StageTransitionType = string;
    export type ThirdPartyJobId = string;    // max: 512, min: 1
    export type ThirdPartyJobList = ThirdPartyJob[];
    export type Timestamp = number;
    export type Url = string;    // max: 2048, min: 1
    export type UrlTemplate = string;    // max: 2048, min: 1
    export type Version = string;    // pattern: &quot;[0-9A-Za-z_-]+&quot;, max: 9, min: 1

    export interface AWSSessionCredentials {
        accessKeyId: AccessKeyId;
        secretAccessKey: SecretAccessKey;
        sessionToken: SessionToken;
    }
    export interface AcknowledgeJobInput {
        jobId: JobId;
        nonce: Nonce;
    }
    export interface AcknowledgeJobOutput {
        status?: JobStatus;
    }
    export interface AcknowledgeThirdPartyJobInput {
        jobId: ThirdPartyJobId;
        nonce: Nonce;
        clientToken: ClientToken;
    }
    export interface AcknowledgeThirdPartyJobOutput {
        status?: JobStatus;
    }
    export interface ActionConfiguration {
        configuration?: ActionConfigurationMap;
    }
    export interface ActionConfigurationProperty {
        name: ActionConfigurationKey;
        required: Boolean;
        key: Boolean;
        secret: Boolean;
        queryable?: Boolean;
        description?: Description;
        type?: ActionConfigurationPropertyType;
    }
    export interface ActionContext {
        name?: ActionName;
    }
    export interface ActionDeclaration {
        name: ActionName;
        actionTypeId: ActionTypeId;
        runOrder?: ActionRunOrder;
        configuration?: ActionConfigurationMap;
        outputArtifacts?: OutputArtifactList;
        inputArtifacts?: InputArtifactList;
        roleArn?: RoleArn;
    }
    export interface ActionExecution {
        status?: ActionExecutionStatus;
        summary?: ExecutionSummary;
        lastStatusChange?: Timestamp;
        externalExecutionId?: ExecutionId;
        externalExecutionUrl?: Url;
        percentComplete?: Percentage;
        errorDetails?: ErrorDetails;
    }
    export interface ActionNotFoundException {
    }
    export interface ActionRevision {
        revisionId: RevisionId;
        revisionChangeId?: RevisionChangeId;
        created: Timestamp;
    }
    export interface ActionState {
        actionName?: ActionName;
        currentRevision?: ActionRevision;
        latestExecution?: ActionExecution;
        entityUrl?: Url;
        revisionUrl?: Url;
    }
    export interface ActionType {
        id: ActionTypeId;
        settings?: ActionTypeSettings;
        actionConfigurationProperties?: ActionConfigurationPropertyList;
        inputArtifactDetails: ArtifactDetails;
        outputArtifactDetails: ArtifactDetails;
    }
    export interface ActionTypeId {
        category: ActionCategory;
        owner: ActionOwner;
        provider: ActionProvider;
        version: Version;
    }
    export interface ActionTypeNotFoundException {
    }
    export interface ActionTypeSettings {
        thirdPartyConfigurationUrl?: Url;
        entityUrlTemplate?: UrlTemplate;
        executionUrlTemplate?: UrlTemplate;
        revisionUrlTemplate?: UrlTemplate;
    }
    export interface Artifact {
        name?: ArtifactName;
        revision?: Revision;
        location?: ArtifactLocation;
    }
    export interface ArtifactDetails {
        minimumCount: MinimumArtifactCount;
        maximumCount: MaximumArtifactCount;
    }
    export interface ArtifactLocation {
        type?: ArtifactLocationType;
        s3Location?: S3ArtifactLocation;
    }
    export interface ArtifactStore {
        type: ArtifactStoreType;
        location: ArtifactStoreLocation;
        encryptionKey?: EncryptionKey;
    }
    export interface BlockerDeclaration {
        name: BlockerName;
        type: BlockerType;
    }
    export interface CreateCustomActionTypeInput {
        category: ActionCategory;
        provider: ActionProvider;
        version: Version;
        settings?: ActionTypeSettings;
        configurationProperties?: ActionConfigurationPropertyList;
        inputArtifactDetails: ArtifactDetails;
        outputArtifactDetails: ArtifactDetails;
    }
    export interface CreateCustomActionTypeOutput {
        actionType: ActionType;
    }
    export interface CreatePipelineInput {
        pipeline: PipelineDeclaration;
    }
    export interface CreatePipelineOutput {
        pipeline?: PipelineDeclaration;
    }
    export interface CurrentRevision {
        revision: Revision;
        changeIdentifier: RevisionChangeIdentifier;
    }
    export interface DeleteCustomActionTypeInput {
        category: ActionCategory;
        provider: ActionProvider;
        version: Version;
    }
    export interface DeletePipelineInput {
        name: PipelineName;
    }
    export interface DisableStageTransitionInput {
        pipelineName: PipelineName;
        stageName: StageName;
        transitionType: StageTransitionType;
        reason: DisabledReason;
    }
    export interface EnableStageTransitionInput {
        pipelineName: PipelineName;
        stageName: StageName;
        transitionType: StageTransitionType;
    }
    export interface EncryptionKey {
        id: EncryptionKeyId;
        type: EncryptionKeyType;
    }
    export interface ErrorDetails {
        code?: Code;
        message?: Message;
    }
    export interface ExecutionDetails {
        summary?: ExecutionSummary;
        externalExecutionId?: ExecutionId;
        percentComplete?: Percentage;
    }
    export interface FailureDetails {
        type: FailureType;
        message: Message;
        externalExecutionId?: ExecutionId;
    }
    export interface GetJobDetailsInput {
        jobId: JobId;
    }
    export interface GetJobDetailsOutput {
        jobDetails?: JobDetails;
    }
    export interface GetPipelineInput {
        name: PipelineName;
        version?: PipelineVersion;
    }
    export interface GetPipelineOutput {
        pipeline?: PipelineDeclaration;
    }
    export interface GetPipelineStateInput {
        name: PipelineName;
    }
    export interface GetPipelineStateOutput {
        pipelineName?: PipelineName;
        pipelineVersion?: PipelineVersion;
        stageStates?: StageStateList;
        created?: Timestamp;
        updated?: Timestamp;
    }
    export interface GetThirdPartyJobDetailsInput {
        jobId: ThirdPartyJobId;
        clientToken: ClientToken;
    }
    export interface GetThirdPartyJobDetailsOutput {
        jobDetails?: ThirdPartyJobDetails;
    }
    export interface InputArtifact {
        name: ArtifactName;
    }
    export interface InvalidActionDeclarationException {
    }
    export interface InvalidBlockerDeclarationException {
    }
    export interface InvalidClientTokenException {
    }
    export interface InvalidJobException {
    }
    export interface InvalidJobStateException {
    }
    export interface InvalidNextTokenException {
    }
    export interface InvalidNonceException {
    }
    export interface InvalidStageDeclarationException {
    }
    export interface InvalidStructureException {
    }
    export interface Job {
        id?: JobId;
        data?: JobData;
        nonce?: Nonce;
        accountId?: AccountId;
    }
    export interface JobData {
        actionTypeId?: ActionTypeId;
        actionConfiguration?: ActionConfiguration;
        pipelineContext?: PipelineContext;
        inputArtifacts?: ArtifactList;
        outputArtifacts?: ArtifactList;
        artifactCredentials?: AWSSessionCredentials;
        continuationToken?: ContinuationToken;
        encryptionKey?: EncryptionKey;
    }
    export interface JobDetails {
        id?: JobId;
        data?: JobData;
        accountId?: AccountId;
    }
    export interface JobNotFoundException {
    }
    export interface LimitExceededException {
    }
    export interface ListActionTypesInput {
        actionOwnerFilter?: ActionOwner;
        nextToken?: NextToken;
    }
    export interface ListActionTypesOutput {
        actionTypes: ActionTypeList;
        nextToken?: NextToken;
    }
    export interface ListPipelinesInput {
        nextToken?: NextToken;
    }
    export interface ListPipelinesOutput {
        pipelines?: PipelineList;
        nextToken?: NextToken;
    }
    export interface OutputArtifact {
        name: ArtifactName;
    }
    export interface PipelineContext {
        pipelineName?: PipelineName;
        stage?: StageContext;
        action?: ActionContext;
    }
    export interface PipelineDeclaration {
        name: PipelineName;
        roleArn: RoleArn;
        artifactStore: ArtifactStore;
        stages: PipelineStageDeclarationList;
        version?: PipelineVersion;
    }
    export interface PipelineNameInUseException {
    }
    export interface PipelineNotFoundException {
    }
    export interface PipelineSummary {
        name?: PipelineName;
        version?: PipelineVersion;
        created?: Timestamp;
        updated?: Timestamp;
    }
    export interface PipelineVersionNotFoundException {
    }
    export interface PollForJobsInput {
        actionTypeId: ActionTypeId;
        maxBatchSize?: MaxBatchSize;
        queryParam?: QueryParamMap;
    }
    export interface PollForJobsOutput {
        jobs?: JobList;
    }
    export interface PollForThirdPartyJobsInput {
        actionTypeId: ActionTypeId;
        maxBatchSize?: MaxBatchSize;
    }
    export interface PollForThirdPartyJobsOutput {
        jobs?: ThirdPartyJobList;
    }
    export interface PutActionRevisionInput {
        pipelineName: PipelineName;
        stageName: StageName;
        actionName: ActionName;
        actionRevision: ActionRevision;
    }
    export interface PutActionRevisionOutput {
        newRevision?: Boolean;
        pipelineExecutionId?: PipelineExecutionId;
    }
    export interface PutJobFailureResultInput {
        jobId: JobId;
        failureDetails: FailureDetails;
    }
    export interface PutJobSuccessResultInput {
        jobId: JobId;
        currentRevision?: CurrentRevision;
        continuationToken?: ContinuationToken;
        executionDetails?: ExecutionDetails;
    }
    export interface PutThirdPartyJobFailureResultInput {
        jobId: ThirdPartyJobId;
        clientToken: ClientToken;
        failureDetails: FailureDetails;
    }
    export interface PutThirdPartyJobSuccessResultInput {
        jobId: ThirdPartyJobId;
        clientToken: ClientToken;
        currentRevision?: CurrentRevision;
        continuationToken?: ContinuationToken;
        executionDetails?: ExecutionDetails;
    }
    export interface S3ArtifactLocation {
        bucketName: S3BucketName;
        objectKey: S3ObjectKey;
    }
    export interface StageContext {
        name?: StageName;
    }
    export interface StageDeclaration {
        name: StageName;
        blockers?: StageBlockerDeclarationList;
        actions: StageActionDeclarationList;
    }
    export interface StageNotFoundException {
    }
    export interface StageState {
        stageName?: StageName;
        inboundTransitionState?: TransitionState;
        actionStates?: ActionStateList;
    }
    export interface StartPipelineExecutionInput {
        name: PipelineName;
    }
    export interface StartPipelineExecutionOutput {
        pipelineExecutionId?: PipelineExecutionId;
    }
    export interface ThirdPartyJob {
        clientId?: ClientId;
        jobId?: JobId;
    }
    export interface ThirdPartyJobData {
        actionTypeId?: ActionTypeId;
        actionConfiguration?: ActionConfiguration;
        pipelineContext?: PipelineContext;
        inputArtifacts?: ArtifactList;
        outputArtifacts?: ArtifactList;
        artifactCredentials?: AWSSessionCredentials;
        continuationToken?: ContinuationToken;
        encryptionKey?: EncryptionKey;
    }
    export interface ThirdPartyJobDetails {
        id?: ThirdPartyJobId;
        data?: ThirdPartyJobData;
        nonce?: Nonce;
    }
    export interface TransitionState {
        enabled?: Enabled;
        lastChangedBy?: LastChangedBy;
        lastChangedAt?: LastChangedAt;
        disabledReason?: DisabledReason;
    }
    export interface UpdatePipelineInput {
        pipeline: PipelineDeclaration;
    }
    export interface UpdatePipelineOutput {
        pipeline?: PipelineDeclaration;
    }
    export interface ValidationException {
    }
  }

  /*
   * apiVersion: 2014-06-30
   * endpointPrefix: cognito-identity
   * serviceAbbreviation: 
   * signatureVersion: v4
   * protocol: json
   */
  export class CognitoIdentity extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    createIdentityPool(params: CognitoIdentity.CreateIdentityPoolInput, callback?: (err: CognitoIdentity.InvalidParameterException|CognitoIdentity.NotAuthorizedException|CognitoIdentity.ResourceConflictException|CognitoIdentity.TooManyRequestsException|CognitoIdentity.InternalErrorException|CognitoIdentity.LimitExceededException|any, data: CognitoIdentity.IdentityPool|any) => void): Request;
    deleteIdentities(params: CognitoIdentity.DeleteIdentitiesInput, callback?: (err: CognitoIdentity.InvalidParameterException|CognitoIdentity.TooManyRequestsException|CognitoIdentity.InternalErrorException|any, data: CognitoIdentity.DeleteIdentitiesResponse|any) => void): Request;
    deleteIdentityPool(params: CognitoIdentity.DeleteIdentityPoolInput, callback?: (err: CognitoIdentity.InvalidParameterException|CognitoIdentity.ResourceNotFoundException|CognitoIdentity.NotAuthorizedException|CognitoIdentity.TooManyRequestsException|CognitoIdentity.InternalErrorException|any, data: any) => void): Request;
    describeIdentity(params: CognitoIdentity.DescribeIdentityInput, callback?: (err: CognitoIdentity.InvalidParameterException|CognitoIdentity.ResourceNotFoundException|CognitoIdentity.NotAuthorizedException|CognitoIdentity.TooManyRequestsException|CognitoIdentity.InternalErrorException|any, data: CognitoIdentity.IdentityDescription|any) => void): Request;
    describeIdentityPool(params: CognitoIdentity.DescribeIdentityPoolInput, callback?: (err: CognitoIdentity.InvalidParameterException|CognitoIdentity.ResourceNotFoundException|CognitoIdentity.NotAuthorizedException|CognitoIdentity.TooManyRequestsException|CognitoIdentity.InternalErrorException|any, data: CognitoIdentity.IdentityPool|any) => void): Request;
    getCredentialsForIdentity(params: CognitoIdentity.GetCredentialsForIdentityInput, callback?: (err: CognitoIdentity.InvalidParameterException|CognitoIdentity.ResourceNotFoundException|CognitoIdentity.NotAuthorizedException|CognitoIdentity.ResourceConflictException|CognitoIdentity.TooManyRequestsException|CognitoIdentity.InvalidIdentityPoolConfigurationException|CognitoIdentity.InternalErrorException|CognitoIdentity.ExternalServiceException|any, data: CognitoIdentity.GetCredentialsForIdentityResponse|any) => void): Request;
    getId(params: CognitoIdentity.GetIdInput, callback?: (err: CognitoIdentity.InvalidParameterException|CognitoIdentity.ResourceNotFoundException|CognitoIdentity.NotAuthorizedException|CognitoIdentity.ResourceConflictException|CognitoIdentity.TooManyRequestsException|CognitoIdentity.InternalErrorException|CognitoIdentity.LimitExceededException|CognitoIdentity.ExternalServiceException|any, data: CognitoIdentity.GetIdResponse|any) => void): Request;
    getIdentityPoolRoles(params: CognitoIdentity.GetIdentityPoolRolesInput, callback?: (err: CognitoIdentity.InvalidParameterException|CognitoIdentity.ResourceNotFoundException|CognitoIdentity.NotAuthorizedException|CognitoIdentity.ResourceConflictException|CognitoIdentity.TooManyRequestsException|CognitoIdentity.InternalErrorException|any, data: CognitoIdentity.GetIdentityPoolRolesResponse|any) => void): Request;
    getOpenIdToken(params: CognitoIdentity.GetOpenIdTokenInput, callback?: (err: CognitoIdentity.InvalidParameterException|CognitoIdentity.ResourceNotFoundException|CognitoIdentity.NotAuthorizedException|CognitoIdentity.ResourceConflictException|CognitoIdentity.TooManyRequestsException|CognitoIdentity.InternalErrorException|CognitoIdentity.ExternalServiceException|any, data: CognitoIdentity.GetOpenIdTokenResponse|any) => void): Request;
    getOpenIdTokenForDeveloperIdentity(params: CognitoIdentity.GetOpenIdTokenForDeveloperIdentityInput, callback?: (err: CognitoIdentity.InvalidParameterException|CognitoIdentity.ResourceNotFoundException|CognitoIdentity.NotAuthorizedException|CognitoIdentity.ResourceConflictException|CognitoIdentity.TooManyRequestsException|CognitoIdentity.InternalErrorException|CognitoIdentity.DeveloperUserAlreadyRegisteredException|any, data: CognitoIdentity.GetOpenIdTokenForDeveloperIdentityResponse|any) => void): Request;
    listIdentities(params: CognitoIdentity.ListIdentitiesInput, callback?: (err: CognitoIdentity.InvalidParameterException|CognitoIdentity.ResourceNotFoundException|CognitoIdentity.NotAuthorizedException|CognitoIdentity.TooManyRequestsException|CognitoIdentity.InternalErrorException|any, data: CognitoIdentity.ListIdentitiesResponse|any) => void): Request;
    listIdentityPools(params: CognitoIdentity.ListIdentityPoolsInput, callback?: (err: CognitoIdentity.InvalidParameterException|CognitoIdentity.NotAuthorizedException|CognitoIdentity.TooManyRequestsException|CognitoIdentity.InternalErrorException|any, data: CognitoIdentity.ListIdentityPoolsResponse|any) => void): Request;
    lookupDeveloperIdentity(params: CognitoIdentity.LookupDeveloperIdentityInput, callback?: (err: CognitoIdentity.InvalidParameterException|CognitoIdentity.ResourceNotFoundException|CognitoIdentity.NotAuthorizedException|CognitoIdentity.ResourceConflictException|CognitoIdentity.TooManyRequestsException|CognitoIdentity.InternalErrorException|any, data: CognitoIdentity.LookupDeveloperIdentityResponse|any) => void): Request;
    mergeDeveloperIdentities(params: CognitoIdentity.MergeDeveloperIdentitiesInput, callback?: (err: CognitoIdentity.InvalidParameterException|CognitoIdentity.ResourceNotFoundException|CognitoIdentity.NotAuthorizedException|CognitoIdentity.ResourceConflictException|CognitoIdentity.TooManyRequestsException|CognitoIdentity.InternalErrorException|any, data: CognitoIdentity.MergeDeveloperIdentitiesResponse|any) => void): Request;
    setIdentityPoolRoles(params: CognitoIdentity.SetIdentityPoolRolesInput, callback?: (err: CognitoIdentity.InvalidParameterException|CognitoIdentity.ResourceNotFoundException|CognitoIdentity.NotAuthorizedException|CognitoIdentity.ResourceConflictException|CognitoIdentity.TooManyRequestsException|CognitoIdentity.InternalErrorException|CognitoIdentity.ConcurrentModificationException|any, data: any) => void): Request;
    unlinkDeveloperIdentity(params: CognitoIdentity.UnlinkDeveloperIdentityInput, callback?: (err: CognitoIdentity.InvalidParameterException|CognitoIdentity.ResourceNotFoundException|CognitoIdentity.NotAuthorizedException|CognitoIdentity.ResourceConflictException|CognitoIdentity.TooManyRequestsException|CognitoIdentity.InternalErrorException|any, data: any) => void): Request;
    unlinkIdentity(params: CognitoIdentity.UnlinkIdentityInput, callback?: (err: CognitoIdentity.InvalidParameterException|CognitoIdentity.ResourceNotFoundException|CognitoIdentity.NotAuthorizedException|CognitoIdentity.ResourceConflictException|CognitoIdentity.TooManyRequestsException|CognitoIdentity.InternalErrorException|CognitoIdentity.ExternalServiceException|any, data: any) => void): Request;
    updateIdentityPool(params: CognitoIdentity.IdentityPool, callback?: (err: CognitoIdentity.InvalidParameterException|CognitoIdentity.ResourceNotFoundException|CognitoIdentity.NotAuthorizedException|CognitoIdentity.ResourceConflictException|CognitoIdentity.TooManyRequestsException|CognitoIdentity.InternalErrorException|CognitoIdentity.ConcurrentModificationException|any, data: CognitoIdentity.IdentityPool|any) => void): Request;

    /***
     * Found on JS Sources - Sorry for the inconvenience :)
     * 
     **/
    getOpenIdToken(...args: any[]): any
    /***
     * Found on JS Sources - Sorry for the inconvenience :)
     * 
     **/
    getId(...args: any[]): any
    /***
     * Found on JS Sources - Sorry for the inconvenience :)
     * 
     **/
    getCredentialsForIdentity(...args: any[]): any
  }

  export module CognitoIdentity {
    export type ARNString = string;    // max: 2048, min: 20
    export type AccessKeyString = string;
    export type AccountId = string;    // pattern: &quot;\d+&quot;, max: 15, min: 1
    export type DateType = number;
    export type DeveloperProviderName = string;    // pattern: &quot;[\w._-]+&quot;, max: 128, min: 1
    export type DeveloperUserIdentifier = string;    // pattern: &quot;[\w.@_-]+&quot;, max: 1024, min: 1
    export type DeveloperUserIdentifierList = DeveloperUserIdentifier[];
    export type ErrorCode = string;
    export type HideDisabled = boolean;
    export type IdentitiesList = IdentityDescription[];
    export type IdentityId = string;    // pattern: &quot;[\w-]+:[0-9a-f-]+&quot;, max: 55, min: 1
    export type IdentityIdList = IdentityId[];    // max: 60, min: 1
    export type IdentityPoolId = string;    // pattern: &quot;[\w-]+:[0-9a-f-]+&quot;, max: 55, min: 1
    export type IdentityPoolName = string;    // pattern: &quot;[\w ]+&quot;, max: 128, min: 1
    export type IdentityPoolUnauthenticated = boolean;
    export type IdentityPoolsList = IdentityPoolShortDescription[];
    export type IdentityProviderId = string;    // pattern: &quot;[\w.;_-]+&quot;, max: 128, min: 1
    export type IdentityProviderName = string;    // pattern: &quot;[\w._/-]+&quot;, max: 128, min: 1
    export type IdentityProviderToken = string;    // pattern: &quot;[\S]+&quot;, max: 2048, min: 1
    export type IdentityProviders = {[key:string]: IdentityProviderId};    // max: 10
    export type LoginsList = IdentityProviderName[];
    export type LoginsMap = {[key:string]: IdentityProviderToken};    // max: 10
    export type OIDCProviderList = ARNString[];
    export type OIDCToken = string;
    export type PaginationKey = string;    // pattern: &quot;[\S]+&quot;, min: 1
    export type QueryLimit = number;    // max: 60, min: 1
    export type RoleType = string;    // pattern: &quot;(un)?authenticated&quot;
    export type RolesMap = {[key:string]: ARNString};    // max: 2
    export type SecretKeyString = string;
    export type SessionTokenString = string;
    export type String = string;
    export type TokenDuration = number;    // max: 86400, min: 1
    export type UnprocessedIdentityIdList = UnprocessedIdentityId[];    // max: 60

    export interface ConcurrentModificationException {
        message?: String;
    }
    export interface CreateIdentityPoolInput {
        IdentityPoolName: IdentityPoolName;
        AllowUnauthenticatedIdentities: IdentityPoolUnauthenticated;
        SupportedLoginProviders?: IdentityProviders;
        DeveloperProviderName?: DeveloperProviderName;
        OpenIdConnectProviderARNs?: OIDCProviderList;
    }
    export interface Credentials {
        AccessKeyId?: AccessKeyString;
        SecretKey?: SecretKeyString;
        SessionToken?: SessionTokenString;
        Expiration?: DateType;
    }
    export interface DeleteIdentitiesInput {
        IdentityIdsToDelete: IdentityIdList;
    }
    export interface DeleteIdentitiesResponse {
        UnprocessedIdentityIds?: UnprocessedIdentityIdList;
    }
    export interface DeleteIdentityPoolInput {
        IdentityPoolId: IdentityPoolId;
    }
    export interface DescribeIdentityInput {
        IdentityId: IdentityId;
    }
    export interface DescribeIdentityPoolInput {
        IdentityPoolId: IdentityPoolId;
    }
    export interface DeveloperUserAlreadyRegisteredException {
        message?: String;
    }
    export interface ExternalServiceException {
        message?: String;
    }
    export interface GetCredentialsForIdentityInput {
        IdentityId: IdentityId;
        Logins?: LoginsMap;
    }
    export interface GetCredentialsForIdentityResponse {
        IdentityId?: IdentityId;
        Credentials?: Credentials;
    }
    export interface GetIdInput {
        AccountId?: AccountId;
        IdentityPoolId: IdentityPoolId;
        Logins?: LoginsMap;
    }
    export interface GetIdResponse {
        IdentityId?: IdentityId;
    }
    export interface GetIdentityPoolRolesInput {
        IdentityPoolId: IdentityPoolId;
    }
    export interface GetIdentityPoolRolesResponse {
        IdentityPoolId?: IdentityPoolId;
        Roles?: RolesMap;
    }
    export interface GetOpenIdTokenForDeveloperIdentityInput {
        IdentityPoolId: IdentityPoolId;
        IdentityId?: IdentityId;
        Logins: LoginsMap;
        TokenDuration?: TokenDuration;
    }
    export interface GetOpenIdTokenForDeveloperIdentityResponse {
        IdentityId?: IdentityId;
        Token?: OIDCToken;
    }
    export interface GetOpenIdTokenInput {
        IdentityId: IdentityId;
        Logins?: LoginsMap;
    }
    export interface GetOpenIdTokenResponse {
        IdentityId?: IdentityId;
        Token?: OIDCToken;
    }
    export interface IdentityDescription {
        IdentityId?: IdentityId;
        Logins?: LoginsList;
        CreationDate?: DateType;
        LastModifiedDate?: DateType;
    }
    export interface IdentityPool {
        IdentityPoolId: IdentityPoolId;
        IdentityPoolName: IdentityPoolName;
        AllowUnauthenticatedIdentities: IdentityPoolUnauthenticated;
        SupportedLoginProviders?: IdentityProviders;
        DeveloperProviderName?: DeveloperProviderName;
        OpenIdConnectProviderARNs?: OIDCProviderList;
    }
    export interface IdentityPoolShortDescription {
        IdentityPoolId?: IdentityPoolId;
        IdentityPoolName?: IdentityPoolName;
    }
    export interface InternalErrorException {
        message?: String;
    }
    export interface InvalidIdentityPoolConfigurationException {
        message?: String;
    }
    export interface InvalidParameterException {
        message?: String;
    }
    export interface LimitExceededException {
        message?: String;
    }
    export interface ListIdentitiesInput {
        IdentityPoolId: IdentityPoolId;
        MaxResults: QueryLimit;
        NextToken?: PaginationKey;
        HideDisabled?: HideDisabled;
    }
    export interface ListIdentitiesResponse {
        IdentityPoolId?: IdentityPoolId;
        Identities?: IdentitiesList;
        NextToken?: PaginationKey;
    }
    export interface ListIdentityPoolsInput {
        MaxResults: QueryLimit;
        NextToken?: PaginationKey;
    }
    export interface ListIdentityPoolsResponse {
        IdentityPools?: IdentityPoolsList;
        NextToken?: PaginationKey;
    }
    export interface LookupDeveloperIdentityInput {
        IdentityPoolId: IdentityPoolId;
        IdentityId?: IdentityId;
        DeveloperUserIdentifier?: DeveloperUserIdentifier;
        MaxResults?: QueryLimit;
        NextToken?: PaginationKey;
    }
    export interface LookupDeveloperIdentityResponse {
        IdentityId?: IdentityId;
        DeveloperUserIdentifierList?: DeveloperUserIdentifierList;
        NextToken?: PaginationKey;
    }
    export interface MergeDeveloperIdentitiesInput {
        SourceUserIdentifier: DeveloperUserIdentifier;
        DestinationUserIdentifier: DeveloperUserIdentifier;
        DeveloperProviderName: DeveloperProviderName;
        IdentityPoolId: IdentityPoolId;
    }
    export interface MergeDeveloperIdentitiesResponse {
        IdentityId?: IdentityId;
    }
    export interface NotAuthorizedException {
        message?: String;
    }
    export interface ResourceConflictException {
        message?: String;
    }
    export interface ResourceNotFoundException {
        message?: String;
    }
    export interface SetIdentityPoolRolesInput {
        IdentityPoolId: IdentityPoolId;
        Roles: RolesMap;
    }
    export interface TooManyRequestsException {
        message?: String;
    }
    export interface UnlinkDeveloperIdentityInput {
        IdentityId: IdentityId;
        IdentityPoolId: IdentityPoolId;
        DeveloperProviderName: DeveloperProviderName;
        DeveloperUserIdentifier: DeveloperUserIdentifier;
    }
    export interface UnlinkIdentityInput {
        IdentityId: IdentityId;
        Logins: LoginsMap;
        LoginsToRemove: LoginsList;
    }
    export interface UnprocessedIdentityId {
        IdentityId?: IdentityId;
        ErrorCode?: ErrorCode;
    }
  }

  /*
   * apiVersion: 2014-06-30
   * endpointPrefix: cognito-sync
   * serviceAbbreviation: 
   * signatureVersion: v4
   * protocol: rest-json
   */
  export class CognitoSync extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    bulkPublish(params: CognitoSync.BulkPublishRequest, callback?: (err: CognitoSync.NotAuthorizedException|CognitoSync.InvalidParameterException|CognitoSync.ResourceNotFoundException|CognitoSync.InternalErrorException|CognitoSync.DuplicateRequestException|CognitoSync.AlreadyStreamedException|any, data: CognitoSync.BulkPublishResponse|any) => void): Request;
    deleteDataset(params: CognitoSync.DeleteDatasetRequest, callback?: (err: CognitoSync.NotAuthorizedException|CognitoSync.InvalidParameterException|CognitoSync.ResourceNotFoundException|CognitoSync.InternalErrorException|CognitoSync.TooManyRequestsException|CognitoSync.ResourceConflictException|any, data: CognitoSync.DeleteDatasetResponse|any) => void): Request;
    describeDataset(params: CognitoSync.DescribeDatasetRequest, callback?: (err: CognitoSync.NotAuthorizedException|CognitoSync.InvalidParameterException|CognitoSync.ResourceNotFoundException|CognitoSync.InternalErrorException|CognitoSync.TooManyRequestsException|any, data: CognitoSync.DescribeDatasetResponse|any) => void): Request;
    describeIdentityPoolUsage(params: CognitoSync.DescribeIdentityPoolUsageRequest, callback?: (err: CognitoSync.NotAuthorizedException|CognitoSync.InvalidParameterException|CognitoSync.ResourceNotFoundException|CognitoSync.InternalErrorException|CognitoSync.TooManyRequestsException|any, data: CognitoSync.DescribeIdentityPoolUsageResponse|any) => void): Request;
    describeIdentityUsage(params: CognitoSync.DescribeIdentityUsageRequest, callback?: (err: CognitoSync.NotAuthorizedException|CognitoSync.InvalidParameterException|CognitoSync.ResourceNotFoundException|CognitoSync.InternalErrorException|CognitoSync.TooManyRequestsException|any, data: CognitoSync.DescribeIdentityUsageResponse|any) => void): Request;
    getBulkPublishDetails(params: CognitoSync.GetBulkPublishDetailsRequest, callback?: (err: CognitoSync.NotAuthorizedException|CognitoSync.InvalidParameterException|CognitoSync.ResourceNotFoundException|CognitoSync.InternalErrorException|any, data: CognitoSync.GetBulkPublishDetailsResponse|any) => void): Request;
    getCognitoEvents(params: CognitoSync.GetCognitoEventsRequest, callback?: (err: CognitoSync.InvalidParameterException|CognitoSync.ResourceNotFoundException|CognitoSync.NotAuthorizedException|CognitoSync.InternalErrorException|CognitoSync.TooManyRequestsException|any, data: CognitoSync.GetCognitoEventsResponse|any) => void): Request;
    getIdentityPoolConfiguration(params: CognitoSync.GetIdentityPoolConfigurationRequest, callback?: (err: CognitoSync.NotAuthorizedException|CognitoSync.InvalidParameterException|CognitoSync.ResourceNotFoundException|CognitoSync.InternalErrorException|CognitoSync.TooManyRequestsException|any, data: CognitoSync.GetIdentityPoolConfigurationResponse|any) => void): Request;
    listDatasets(params: CognitoSync.ListDatasetsRequest, callback?: (err: CognitoSync.NotAuthorizedException|CognitoSync.InvalidParameterException|CognitoSync.InternalErrorException|CognitoSync.TooManyRequestsException|any, data: CognitoSync.ListDatasetsResponse|any) => void): Request;
    listIdentityPoolUsage(params: CognitoSync.ListIdentityPoolUsageRequest, callback?: (err: CognitoSync.NotAuthorizedException|CognitoSync.InvalidParameterException|CognitoSync.InternalErrorException|CognitoSync.TooManyRequestsException|any, data: CognitoSync.ListIdentityPoolUsageResponse|any) => void): Request;
    listRecords(params: CognitoSync.ListRecordsRequest, callback?: (err: CognitoSync.InvalidParameterException|CognitoSync.NotAuthorizedException|CognitoSync.TooManyRequestsException|CognitoSync.InternalErrorException|any, data: CognitoSync.ListRecordsResponse|any) => void): Request;
    registerDevice(params: CognitoSync.RegisterDeviceRequest, callback?: (err: CognitoSync.NotAuthorizedException|CognitoSync.InvalidParameterException|CognitoSync.ResourceNotFoundException|CognitoSync.InternalErrorException|CognitoSync.InvalidConfigurationException|CognitoSync.TooManyRequestsException|any, data: CognitoSync.RegisterDeviceResponse|any) => void): Request;
    setCognitoEvents(params: CognitoSync.SetCognitoEventsRequest, callback?: (err: CognitoSync.InvalidParameterException|CognitoSync.ResourceNotFoundException|CognitoSync.NotAuthorizedException|CognitoSync.InternalErrorException|CognitoSync.TooManyRequestsException|any, data: any) => void): Request;
    setIdentityPoolConfiguration(params: CognitoSync.SetIdentityPoolConfigurationRequest, callback?: (err: CognitoSync.NotAuthorizedException|CognitoSync.InvalidParameterException|CognitoSync.ResourceNotFoundException|CognitoSync.InternalErrorException|CognitoSync.TooManyRequestsException|CognitoSync.ConcurrentModificationException|any, data: CognitoSync.SetIdentityPoolConfigurationResponse|any) => void): Request;
    subscribeToDataset(params: CognitoSync.SubscribeToDatasetRequest, callback?: (err: CognitoSync.NotAuthorizedException|CognitoSync.InvalidParameterException|CognitoSync.ResourceNotFoundException|CognitoSync.InternalErrorException|CognitoSync.InvalidConfigurationException|CognitoSync.TooManyRequestsException|any, data: CognitoSync.SubscribeToDatasetResponse|any) => void): Request;
    unsubscribeFromDataset(params: CognitoSync.UnsubscribeFromDatasetRequest, callback?: (err: CognitoSync.NotAuthorizedException|CognitoSync.InvalidParameterException|CognitoSync.ResourceNotFoundException|CognitoSync.InternalErrorException|CognitoSync.InvalidConfigurationException|CognitoSync.TooManyRequestsException|any, data: CognitoSync.UnsubscribeFromDatasetResponse|any) => void): Request;
    updateRecords(params: CognitoSync.UpdateRecordsRequest, callback?: (err: CognitoSync.InvalidParameterException|CognitoSync.LimitExceededException|CognitoSync.NotAuthorizedException|CognitoSync.ResourceNotFoundException|CognitoSync.ResourceConflictException|CognitoSync.InvalidLambdaFunctionOutputException|CognitoSync.LambdaThrottledException|CognitoSync.TooManyRequestsException|CognitoSync.InternalErrorException|any, data: CognitoSync.UpdateRecordsResponse|any) => void): Request;

  }

  export module CognitoSync {
    export type ApplicationArn = string;    // pattern: &quot;arn:aws:sns:[-0-9a-z]+:\d+:app/[A-Z_]+/[a-zA-Z0-9_.-]+&quot;
    export type ApplicationArnList = ApplicationArn[];
    export type AssumeRoleArn = string;    // pattern: &quot;arn:aws:iam::\d+:role/.*&quot;, max: 2048, min: 20
    export type Boolean = boolean;
    export type BulkPublishStatus = string;
    export type ClientContext = string;
    export type CognitoEventType = string;
    export type DatasetList = Dataset[];
    export type DatasetName = string;    // pattern: &quot;[a-zA-Z0-9_.:-]+&quot;, max: 128, min: 1
    export type Date = number;
    export type DeviceId = string;    // max: 256, min: 1
    export type Events = {[key:string]: LambdaFunctionArn};    // max: 1
    export type ExceptionMessage = string;
    export type IdentityId = string;    // pattern: &quot;[\w-]+:[0-9a-f-]+&quot;, max: 55, min: 1
    export type IdentityPoolId = string;    // pattern: &quot;[\w-]+:[0-9a-f-]+&quot;, max: 55, min: 1
    export type IdentityPoolUsageList = IdentityPoolUsage[];
    export type Integer = number;
    export type IntegerString = number;
    export type LambdaFunctionArn = string;
    export type Long = number;
    export type MergedDatasetNameList = String[];
    export type Operation = string;
    export type Platform = string;
    export type PushToken = string;
    export type RecordKey = string;    // max: 1024, min: 1
    export type RecordList = Record[];
    export type RecordPatchList = RecordPatch[];
    export type RecordValue = string;    // max: 1048575
    export type StreamName = string;    // max: 128, min: 1
    export type StreamingStatus = string;
    export type String = string;
    export type SyncSessionToken = string;

    export interface AlreadyStreamedException {
        message: ExceptionMessage;
    }
    export interface BulkPublishRequest {
        IdentityPoolId: IdentityPoolId;
    }
    export interface BulkPublishResponse {
        IdentityPoolId?: IdentityPoolId;
    }
    export interface CognitoStreams {
        StreamName?: StreamName;
        RoleArn?: AssumeRoleArn;
        StreamingStatus?: StreamingStatus;
    }
    export interface ConcurrentModificationException {
        message: String;
    }
    export interface Dataset {
        IdentityId?: IdentityId;
        DatasetName?: DatasetName;
        CreationDate?: Date;
        LastModifiedDate?: Date;
        LastModifiedBy?: String;
        DataStorage?: Long;
        NumRecords?: Long;
    }
    export interface DeleteDatasetRequest {
        IdentityPoolId: IdentityPoolId;
        IdentityId: IdentityId;
        DatasetName: DatasetName;
    }
    export interface DeleteDatasetResponse {
        Dataset?: Dataset;
    }
    export interface DescribeDatasetRequest {
        IdentityPoolId: IdentityPoolId;
        IdentityId: IdentityId;
        DatasetName: DatasetName;
    }
    export interface DescribeDatasetResponse {
        Dataset?: Dataset;
    }
    export interface DescribeIdentityPoolUsageRequest {
        IdentityPoolId: IdentityPoolId;
    }
    export interface DescribeIdentityPoolUsageResponse {
        IdentityPoolUsage?: IdentityPoolUsage;
    }
    export interface DescribeIdentityUsageRequest {
        IdentityPoolId: IdentityPoolId;
        IdentityId: IdentityId;
    }
    export interface DescribeIdentityUsageResponse {
        IdentityUsage?: IdentityUsage;
    }
    export interface DuplicateRequestException {
        message: ExceptionMessage;
    }
    export interface GetBulkPublishDetailsRequest {
        IdentityPoolId: IdentityPoolId;
    }
    export interface GetBulkPublishDetailsResponse {
        IdentityPoolId?: IdentityPoolId;
        BulkPublishStartTime?: Date;
        BulkPublishCompleteTime?: Date;
        BulkPublishStatus?: BulkPublishStatus;
        FailureMessage?: String;
    }
    export interface GetCognitoEventsRequest {
        IdentityPoolId: IdentityPoolId;
    }
    export interface GetCognitoEventsResponse {
        Events?: Events;
    }
    export interface GetIdentityPoolConfigurationRequest {
        IdentityPoolId: IdentityPoolId;
    }
    export interface GetIdentityPoolConfigurationResponse {
        IdentityPoolId?: IdentityPoolId;
        PushSync?: PushSync;
        CognitoStreams?: CognitoStreams;
    }
    export interface IdentityPoolUsage {
        IdentityPoolId?: IdentityPoolId;
        SyncSessionsCount?: Long;
        DataStorage?: Long;
        LastModifiedDate?: Date;
    }
    export interface IdentityUsage {
        IdentityId?: IdentityId;
        IdentityPoolId?: IdentityPoolId;
        LastModifiedDate?: Date;
        DatasetCount?: Integer;
        DataStorage?: Long;
    }
    export interface InternalErrorException {
        message: ExceptionMessage;
    }
    export interface InvalidConfigurationException {
        message: ExceptionMessage;
    }
    export interface InvalidLambdaFunctionOutputException {
        message: ExceptionMessage;
    }
    export interface InvalidParameterException {
        message: ExceptionMessage;
    }
    export interface LambdaThrottledException {
        message: ExceptionMessage;
    }
    export interface LimitExceededException {
        message: ExceptionMessage;
    }
    export interface ListDatasetsRequest {
        IdentityPoolId: IdentityPoolId;
        IdentityId: IdentityId;
        NextToken?: String;
        MaxResults?: IntegerString;
    }
    export interface ListDatasetsResponse {
        Datasets?: DatasetList;
        Count?: Integer;
        NextToken?: String;
    }
    export interface ListIdentityPoolUsageRequest {
        NextToken?: String;
        MaxResults?: IntegerString;
    }
    export interface ListIdentityPoolUsageResponse {
        IdentityPoolUsages?: IdentityPoolUsageList;
        MaxResults?: Integer;
        Count?: Integer;
        NextToken?: String;
    }
    export interface ListRecordsRequest {
        IdentityPoolId: IdentityPoolId;
        IdentityId: IdentityId;
        DatasetName: DatasetName;
        LastSyncCount?: Long;
        NextToken?: String;
        MaxResults?: IntegerString;
        SyncSessionToken?: SyncSessionToken;
    }
    export interface ListRecordsResponse {
        Records?: RecordList;
        NextToken?: String;
        Count?: Integer;
        DatasetSyncCount?: Long;
        LastModifiedBy?: String;
        MergedDatasetNames?: MergedDatasetNameList;
        DatasetExists?: Boolean;
        DatasetDeletedAfterRequestedSyncCount?: Boolean;
        SyncSessionToken?: String;
    }
    export interface NotAuthorizedException {
        message: ExceptionMessage;
    }
    export interface PushSync {
        ApplicationArns?: ApplicationArnList;
        RoleArn?: AssumeRoleArn;
    }
    export interface Record {
        Key?: RecordKey;
        Value?: RecordValue;
        SyncCount?: Long;
        LastModifiedDate?: Date;
        LastModifiedBy?: String;
        DeviceLastModifiedDate?: Date;
    }
    export interface RecordPatch {
        Op: Operation;
        Key: RecordKey;
        Value?: RecordValue;
        SyncCount: Long;
        DeviceLastModifiedDate?: Date;
    }
    export interface RegisterDeviceRequest {
        IdentityPoolId: IdentityPoolId;
        IdentityId: IdentityId;
        Platform: Platform;
        Token: PushToken;
    }
    export interface RegisterDeviceResponse {
        DeviceId?: DeviceId;
    }
    export interface ResourceConflictException {
        message: ExceptionMessage;
    }
    export interface ResourceNotFoundException {
        message: ExceptionMessage;
    }
    export interface SetCognitoEventsRequest {
        IdentityPoolId: IdentityPoolId;
        Events: Events;
    }
    export interface SetIdentityPoolConfigurationRequest {
        IdentityPoolId: IdentityPoolId;
        PushSync?: PushSync;
        CognitoStreams?: CognitoStreams;
    }
    export interface SetIdentityPoolConfigurationResponse {
        IdentityPoolId?: IdentityPoolId;
        PushSync?: PushSync;
        CognitoStreams?: CognitoStreams;
    }
    export interface SubscribeToDatasetRequest {
        IdentityPoolId: IdentityPoolId;
        IdentityId: IdentityId;
        DatasetName: DatasetName;
        DeviceId: DeviceId;
    }
    export interface SubscribeToDatasetResponse {
    }
    export interface TooManyRequestsException {
        message: ExceptionMessage;
    }
    export interface UnsubscribeFromDatasetRequest {
        IdentityPoolId: IdentityPoolId;
        IdentityId: IdentityId;
        DatasetName: DatasetName;
        DeviceId: DeviceId;
    }
    export interface UnsubscribeFromDatasetResponse {
    }
    export interface UpdateRecordsRequest {
        IdentityPoolId: IdentityPoolId;
        IdentityId: IdentityId;
        DatasetName: DatasetName;
        DeviceId?: DeviceId;
        RecordPatches?: RecordPatchList;
        SyncSessionToken: SyncSessionToken;
        ClientContext?: ClientContext;
    }
    export interface UpdateRecordsResponse {
        Records?: RecordList;
    }
  }

  /*
   * apiVersion: 2014-11-12
   * endpointPrefix: config
   * serviceAbbreviation: Config Service
   * signatureVersion: v4
   * protocol: json
   */
  export class ConfigService extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    deleteConfigRule(params: ConfigService.DeleteConfigRuleRequest, callback?: (err: ConfigService.NoSuchConfigRuleException|ConfigService.ResourceInUseException|any, data: any) => void): Request;
    deleteDeliveryChannel(params: ConfigService.DeleteDeliveryChannelRequest, callback?: (err: ConfigService.NoSuchDeliveryChannelException|ConfigService.LastDeliveryChannelDeleteFailedException|any, data: any) => void): Request;
    deliverConfigSnapshot(params: ConfigService.DeliverConfigSnapshotRequest, callback?: (err: ConfigService.NoSuchDeliveryChannelException|ConfigService.NoAvailableConfigurationRecorderException|ConfigService.NoRunningConfigurationRecorderException|any, data: ConfigService.DeliverConfigSnapshotResponse|any) => void): Request;
    describeComplianceByConfigRule(params: ConfigService.DescribeComplianceByConfigRuleRequest, callback?: (err: ConfigService.InvalidParameterValueException|ConfigService.NoSuchConfigRuleException|any, data: ConfigService.DescribeComplianceByConfigRuleResponse|any) => void): Request;
    describeComplianceByResource(params: ConfigService.DescribeComplianceByResourceRequest, callback?: (err: ConfigService.InvalidParameterValueException|ConfigService.InvalidNextTokenException|any, data: ConfigService.DescribeComplianceByResourceResponse|any) => void): Request;
    describeConfigRuleEvaluationStatus(params: ConfigService.DescribeConfigRuleEvaluationStatusRequest, callback?: (err: ConfigService.NoSuchConfigRuleException|any, data: ConfigService.DescribeConfigRuleEvaluationStatusResponse|any) => void): Request;
    describeConfigRules(params: ConfigService.DescribeConfigRulesRequest, callback?: (err: ConfigService.NoSuchConfigRuleException|any, data: ConfigService.DescribeConfigRulesResponse|any) => void): Request;
    describeConfigurationRecorderStatus(params: ConfigService.DescribeConfigurationRecorderStatusRequest, callback?: (err: ConfigService.NoSuchConfigurationRecorderException|any, data: ConfigService.DescribeConfigurationRecorderStatusResponse|any) => void): Request;
    describeConfigurationRecorders(params: ConfigService.DescribeConfigurationRecordersRequest, callback?: (err: ConfigService.NoSuchConfigurationRecorderException|any, data: ConfigService.DescribeConfigurationRecordersResponse|any) => void): Request;
    describeDeliveryChannelStatus(params: ConfigService.DescribeDeliveryChannelStatusRequest, callback?: (err: ConfigService.NoSuchDeliveryChannelException|any, data: ConfigService.DescribeDeliveryChannelStatusResponse|any) => void): Request;
    describeDeliveryChannels(params: ConfigService.DescribeDeliveryChannelsRequest, callback?: (err: ConfigService.NoSuchDeliveryChannelException|any, data: ConfigService.DescribeDeliveryChannelsResponse|any) => void): Request;
    getComplianceDetailsByConfigRule(params: ConfigService.GetComplianceDetailsByConfigRuleRequest, callback?: (err: ConfigService.InvalidParameterValueException|ConfigService.InvalidNextTokenException|ConfigService.NoSuchConfigRuleException|any, data: ConfigService.GetComplianceDetailsByConfigRuleResponse|any) => void): Request;
    getComplianceDetailsByResource(params: ConfigService.GetComplianceDetailsByResourceRequest, callback?: (err: ConfigService.InvalidParameterValueException|any, data: ConfigService.GetComplianceDetailsByResourceResponse|any) => void): Request;
    getComplianceSummaryByConfigRule(callback?: (err: any, data: ConfigService.GetComplianceSummaryByConfigRuleResponse|any) => void): Request;
    getComplianceSummaryByResourceType(params: ConfigService.GetComplianceSummaryByResourceTypeRequest, callback?: (err: ConfigService.InvalidParameterValueException|any, data: ConfigService.GetComplianceSummaryByResourceTypeResponse|any) => void): Request;
    getResourceConfigHistory(params: ConfigService.GetResourceConfigHistoryRequest, callback?: (err: ConfigService.ValidationException|ConfigService.InvalidTimeRangeException|ConfigService.InvalidLimitException|ConfigService.InvalidNextTokenException|ConfigService.NoAvailableConfigurationRecorderException|ConfigService.ResourceNotDiscoveredException|any, data: ConfigService.GetResourceConfigHistoryResponse|any) => void): Request;
    listDiscoveredResources(params: ConfigService.ListDiscoveredResourcesRequest, callback?: (err: ConfigService.ValidationException|ConfigService.InvalidLimitException|ConfigService.InvalidNextTokenException|ConfigService.NoAvailableConfigurationRecorderException|any, data: ConfigService.ListDiscoveredResourcesResponse|any) => void): Request;
    putConfigRule(params: ConfigService.PutConfigRuleRequest, callback?: (err: ConfigService.InvalidParameterValueException|ConfigService.MaxNumberOfConfigRulesExceededException|ConfigService.ResourceInUseException|ConfigService.InsufficientPermissionsException|any, data: any) => void): Request;
    putConfigurationRecorder(params: ConfigService.PutConfigurationRecorderRequest, callback?: (err: ConfigService.MaxNumberOfConfigurationRecordersExceededException|ConfigService.InvalidConfigurationRecorderNameException|ConfigService.InvalidRoleException|ConfigService.InvalidRecordingGroupException|any, data: any) => void): Request;
    putDeliveryChannel(params: ConfigService.PutDeliveryChannelRequest, callback?: (err: ConfigService.MaxNumberOfDeliveryChannelsExceededException|ConfigService.NoAvailableConfigurationRecorderException|ConfigService.InvalidDeliveryChannelNameException|ConfigService.NoSuchBucketException|ConfigService.InvalidS3KeyPrefixException|ConfigService.InvalidSNSTopicARNException|ConfigService.InsufficientDeliveryPolicyException|any, data: any) => void): Request;
    putEvaluations(params: ConfigService.PutEvaluationsRequest, callback?: (err: ConfigService.InvalidParameterValueException|ConfigService.InvalidResultTokenException|ConfigService.NoSuchConfigRuleException|any, data: ConfigService.PutEvaluationsResponse|any) => void): Request;
    startConfigurationRecorder(params: ConfigService.StartConfigurationRecorderRequest, callback?: (err: ConfigService.NoSuchConfigurationRecorderException|ConfigService.NoAvailableDeliveryChannelException|any, data: any) => void): Request;
    stopConfigurationRecorder(params: ConfigService.StopConfigurationRecorderRequest, callback?: (err: ConfigService.NoSuchConfigurationRecorderException|any, data: any) => void): Request;

  }

  export module ConfigService {
    export type ARN = string;
    export type AccountId = string;
    export type AllSupported = boolean;
    export type AvailabilityZone = string;
    export type AwsRegion = string;
    export type Boolean = boolean;
    export type ChannelName = string;    // max: 256, min: 1
    export type ChronologicalOrder = string;
    export type ComplianceByConfigRules = ComplianceByConfigRule[];
    export type ComplianceByResources = ComplianceByResource[];
    export type ComplianceResourceTypes = StringWithCharLimit256[];    // max: 100
    export type ComplianceSummariesByResourceType = ComplianceSummaryByResourceType[];
    export type ComplianceType = string;
    export type ComplianceTypes = ComplianceType[];    // max: 3
    export type ConfigRuleEvaluationStatusList = ConfigRuleEvaluationStatus[];
    export type ConfigRuleNames = StringWithCharLimit64[];    // max: 25
    export type ConfigRuleState = string;
    export type ConfigRules = ConfigRule[];
    export type Configuration = string;
    export type ConfigurationItemCaptureTime = number;
    export type ConfigurationItemList = ConfigurationItem[];
    export type ConfigurationItemMD5Hash = string;
    export type ConfigurationItemStatus = string;
    export type ConfigurationRecorderList = ConfigurationRecorder[];
    export type ConfigurationRecorderNameList = RecorderName[];
    export type ConfigurationRecorderStatusList = ConfigurationRecorderStatus[];
    export type ConfigurationStateId = string;
    export type Date = number;
    export type DeliveryChannelList = DeliveryChannel[];
    export type DeliveryChannelNameList = ChannelName[];
    export type DeliveryChannelStatusList = DeliveryChannelStatus[];
    export type DeliveryStatus = string;
    export type EarlierTime = number;
    export type EmptiableStringWithCharLimit256 = string;    // max: 256
    export type EvaluationResults = EvaluationResult[];
    export type Evaluations = Evaluation[];    // max: 100
    export type EventSource = string;
    export type IncludeGlobalResourceTypes = boolean;
    export type Integer = number;
    export type LaterTime = number;
    export type Limit = number;    // max: 100
    export type MaximumExecutionFrequency = string;
    export type MessageType = string;
    export type Name = string;
    export type NextToken = string;
    export type OrderingTimestamp = number;
    export type Owner = string;
    export type RecorderName = string;    // max: 256, min: 1
    export type RecorderStatus = string;
    export type RelatedEvent = string;
    export type RelatedEventList = RelatedEvent[];
    export type RelationshipList = Relationship[];
    export type RelationshipName = string;
    export type ResourceCreationTime = number;
    export type ResourceDeletionTime = number;
    export type ResourceId = string;
    export type ResourceIdList = ResourceId[];
    export type ResourceIdentifierList = ResourceIdentifier[];
    export type ResourceName = string;
    export type ResourceType = string;
    export type ResourceTypeList = ResourceType[];
    export type ResourceTypes = StringWithCharLimit256[];    // max: 20
    export type SourceDetails = SourceDetail[];    // max: 25
    export type String = string;
    export type StringWithCharLimit128 = string;    // max: 128, min: 1
    export type StringWithCharLimit256 = string;    // max: 256, min: 1
    export type StringWithCharLimit64 = string;    // max: 64, min: 1
    export type Tags = {[key:string]: Value};
    export type Value = string;
    export type Version = string;

    export interface Compliance {
        ComplianceType?: ComplianceType;
        ComplianceContributorCount?: ComplianceContributorCount;
    }
    export interface ComplianceByConfigRule {
        ConfigRuleName?: StringWithCharLimit64;
        Compliance?: Compliance;
    }
    export interface ComplianceByResource {
        ResourceType?: StringWithCharLimit256;
        ResourceId?: StringWithCharLimit256;
        Compliance?: Compliance;
    }
    export interface ComplianceContributorCount {
        CappedCount?: Integer;
        CapExceeded?: Boolean;
    }
    export interface ComplianceSummary {
        CompliantResourceCount?: ComplianceContributorCount;
        NonCompliantResourceCount?: ComplianceContributorCount;
        ComplianceSummaryTimestamp?: Date;
    }
    export interface ComplianceSummaryByResourceType {
        ResourceType?: StringWithCharLimit256;
        ComplianceSummary?: ComplianceSummary;
    }
    export interface ConfigExportDeliveryInfo {
        lastStatus?: DeliveryStatus;
        lastErrorCode?: String;
        lastErrorMessage?: String;
        lastAttemptTime?: Date;
        lastSuccessfulTime?: Date;
        nextDeliveryTime?: Date;
    }
    export interface ConfigRule {
        ConfigRuleName?: StringWithCharLimit64;
        ConfigRuleArn?: String;
        ConfigRuleId?: String;
        Description?: EmptiableStringWithCharLimit256;
        Scope?: Scope;
        Source: Source;
        InputParameters?: StringWithCharLimit256;
        MaximumExecutionFrequency?: MaximumExecutionFrequency;
        ConfigRuleState?: ConfigRuleState;
    }
    export interface ConfigRuleEvaluationStatus {
        ConfigRuleName?: StringWithCharLimit64;
        ConfigRuleArn?: String;
        ConfigRuleId?: String;
        LastSuccessfulInvocationTime?: Date;
        LastFailedInvocationTime?: Date;
        LastSuccessfulEvaluationTime?: Date;
        LastFailedEvaluationTime?: Date;
        FirstActivatedTime?: Date;
        LastErrorCode?: String;
        LastErrorMessage?: String;
        FirstEvaluationStarted?: Boolean;
    }
    export interface ConfigSnapshotDeliveryProperties {
        deliveryFrequency?: MaximumExecutionFrequency;
    }
    export interface ConfigStreamDeliveryInfo {
        lastStatus?: DeliveryStatus;
        lastErrorCode?: String;
        lastErrorMessage?: String;
        lastStatusChangeTime?: Date;
    }
    export interface ConfigurationItem {
        version?: Version;
        accountId?: AccountId;
        configurationItemCaptureTime?: ConfigurationItemCaptureTime;
        configurationItemStatus?: ConfigurationItemStatus;
        configurationStateId?: ConfigurationStateId;
        configurationItemMD5Hash?: ConfigurationItemMD5Hash;
        arn?: ARN;
        resourceType?: ResourceType;
        resourceId?: ResourceId;
        resourceName?: ResourceName;
        awsRegion?: AwsRegion;
        availabilityZone?: AvailabilityZone;
        resourceCreationTime?: ResourceCreationTime;
        tags?: Tags;
        relatedEvents?: RelatedEventList;
        relationships?: RelationshipList;
        configuration?: Configuration;
    }
    export interface ConfigurationRecorder {
        name?: RecorderName;
        roleARN?: String;
        recordingGroup?: RecordingGroup;
    }
    export interface ConfigurationRecorderStatus {
        name?: String;
        lastStartTime?: Date;
        lastStopTime?: Date;
        recording?: Boolean;
        lastStatus?: RecorderStatus;
        lastErrorCode?: String;
        lastErrorMessage?: String;
        lastStatusChangeTime?: Date;
    }
    export interface DeleteConfigRuleRequest {
        ConfigRuleName: StringWithCharLimit64;
    }
    export interface DeleteDeliveryChannelRequest {
        DeliveryChannelName: ChannelName;
    }
    export interface DeliverConfigSnapshotRequest {
        deliveryChannelName: ChannelName;
    }
    export interface DeliverConfigSnapshotResponse {
        configSnapshotId?: String;
    }
    export interface DeliveryChannel {
        name?: ChannelName;
        s3BucketName?: String;
        s3KeyPrefix?: String;
        snsTopicARN?: String;
        configSnapshotDeliveryProperties?: ConfigSnapshotDeliveryProperties;
    }
    export interface DeliveryChannelStatus {
        name?: String;
        configSnapshotDeliveryInfo?: ConfigExportDeliveryInfo;
        configHistoryDeliveryInfo?: ConfigExportDeliveryInfo;
        configStreamDeliveryInfo?: ConfigStreamDeliveryInfo;
    }
    export interface DescribeComplianceByConfigRuleRequest {
        ConfigRuleNames?: ConfigRuleNames;
        ComplianceTypes?: ComplianceTypes;
        NextToken?: String;
    }
    export interface DescribeComplianceByConfigRuleResponse {
        ComplianceByConfigRules?: ComplianceByConfigRules;
        NextToken?: String;
    }
    export interface DescribeComplianceByResourceRequest {
        ResourceType?: StringWithCharLimit256;
        ResourceId?: StringWithCharLimit256;
        ComplianceTypes?: ComplianceTypes;
        Limit?: Limit;
        NextToken?: NextToken;
    }
    export interface DescribeComplianceByResourceResponse {
        ComplianceByResources?: ComplianceByResources;
        NextToken?: NextToken;
    }
    export interface DescribeConfigRuleEvaluationStatusRequest {
        ConfigRuleNames?: ConfigRuleNames;
    }
    export interface DescribeConfigRuleEvaluationStatusResponse {
        ConfigRulesEvaluationStatus?: ConfigRuleEvaluationStatusList;
    }
    export interface DescribeConfigRulesRequest {
        ConfigRuleNames?: ConfigRuleNames;
        NextToken?: String;
    }
    export interface DescribeConfigRulesResponse {
        ConfigRules?: ConfigRules;
        NextToken?: String;
    }
    export interface DescribeConfigurationRecorderStatusRequest {
        ConfigurationRecorderNames?: ConfigurationRecorderNameList;
    }
    export interface DescribeConfigurationRecorderStatusResponse {
        ConfigurationRecordersStatus?: ConfigurationRecorderStatusList;
    }
    export interface DescribeConfigurationRecordersRequest {
        ConfigurationRecorderNames?: ConfigurationRecorderNameList;
    }
    export interface DescribeConfigurationRecordersResponse {
        ConfigurationRecorders?: ConfigurationRecorderList;
    }
    export interface DescribeDeliveryChannelStatusRequest {
        DeliveryChannelNames?: DeliveryChannelNameList;
    }
    export interface DescribeDeliveryChannelStatusResponse {
        DeliveryChannelsStatus?: DeliveryChannelStatusList;
    }
    export interface DescribeDeliveryChannelsRequest {
        DeliveryChannelNames?: DeliveryChannelNameList;
    }
    export interface DescribeDeliveryChannelsResponse {
        DeliveryChannels?: DeliveryChannelList;
    }
    export interface Evaluation {
        ComplianceResourceType: StringWithCharLimit256;
        ComplianceResourceId: StringWithCharLimit256;
        ComplianceType: ComplianceType;
        Annotation?: StringWithCharLimit256;
        OrderingTimestamp: OrderingTimestamp;
    }
    export interface EvaluationResult {
        EvaluationResultIdentifier?: EvaluationResultIdentifier;
        ComplianceType?: ComplianceType;
        ResultRecordedTime?: Date;
        ConfigRuleInvokedTime?: Date;
        Annotation?: StringWithCharLimit256;
        ResultToken?: String;
    }
    export interface EvaluationResultIdentifier {
        EvaluationResultQualifier?: EvaluationResultQualifier;
        OrderingTimestamp?: Date;
    }
    export interface EvaluationResultQualifier {
        ConfigRuleName?: StringWithCharLimit64;
        ResourceType?: StringWithCharLimit256;
        ResourceId?: StringWithCharLimit256;
    }
    export interface GetComplianceDetailsByConfigRuleRequest {
        ConfigRuleName: StringWithCharLimit64;
        ComplianceTypes?: ComplianceTypes;
        Limit?: Limit;
        NextToken?: NextToken;
    }
    export interface GetComplianceDetailsByConfigRuleResponse {
        EvaluationResults?: EvaluationResults;
        NextToken?: NextToken;
    }
    export interface GetComplianceDetailsByResourceRequest {
        ResourceType: StringWithCharLimit256;
        ResourceId: StringWithCharLimit256;
        ComplianceTypes?: ComplianceTypes;
        NextToken?: String;
    }
    export interface GetComplianceDetailsByResourceResponse {
        EvaluationResults?: EvaluationResults;
        NextToken?: String;
    }
    export interface GetComplianceSummaryByConfigRuleResponse {
        ComplianceSummary?: ComplianceSummary;
    }
    export interface GetComplianceSummaryByResourceTypeRequest {
        ResourceTypes?: ResourceTypes;
    }
    export interface GetComplianceSummaryByResourceTypeResponse {
        ComplianceSummariesByResourceType?: ComplianceSummariesByResourceType;
    }
    export interface GetResourceConfigHistoryRequest {
        resourceType: ResourceType;
        resourceId: ResourceId;
        laterTime?: LaterTime;
        earlierTime?: EarlierTime;
        chronologicalOrder?: ChronologicalOrder;
        limit?: Limit;
        nextToken?: NextToken;
    }
    export interface GetResourceConfigHistoryResponse {
        configurationItems?: ConfigurationItemList;
        nextToken?: NextToken;
    }
    export interface InsufficientDeliveryPolicyException {
    }
    export interface InsufficientPermissionsException {
    }
    export interface InvalidConfigurationRecorderNameException {
    }
    export interface InvalidDeliveryChannelNameException {
    }
    export interface InvalidLimitException {
    }
    export interface InvalidNextTokenException {
    }
    export interface InvalidParameterValueException {
    }
    export interface InvalidRecordingGroupException {
    }
    export interface InvalidResultTokenException {
    }
    export interface InvalidRoleException {
    }
    export interface InvalidS3KeyPrefixException {
    }
    export interface InvalidSNSTopicARNException {
    }
    export interface InvalidTimeRangeException {
    }
    export interface LastDeliveryChannelDeleteFailedException {
    }
    export interface ListDiscoveredResourcesRequest {
        resourceType: ResourceType;
        resourceIds?: ResourceIdList;
        resourceName?: ResourceName;
        limit?: Limit;
        includeDeletedResources?: Boolean;
        nextToken?: NextToken;
    }
    export interface ListDiscoveredResourcesResponse {
        resourceIdentifiers?: ResourceIdentifierList;
        nextToken?: NextToken;
    }
    export interface MaxNumberOfConfigRulesExceededException {
    }
    export interface MaxNumberOfConfigurationRecordersExceededException {
    }
    export interface MaxNumberOfDeliveryChannelsExceededException {
    }
    export interface NoAvailableConfigurationRecorderException {
    }
    export interface NoAvailableDeliveryChannelException {
    }
    export interface NoRunningConfigurationRecorderException {
    }
    export interface NoSuchBucketException {
    }
    export interface NoSuchConfigRuleException {
    }
    export interface NoSuchConfigurationRecorderException {
    }
    export interface NoSuchDeliveryChannelException {
    }
    export interface PutConfigRuleRequest {
        ConfigRule: ConfigRule;
    }
    export interface PutConfigurationRecorderRequest {
        ConfigurationRecorder: ConfigurationRecorder;
    }
    export interface PutDeliveryChannelRequest {
        DeliveryChannel: DeliveryChannel;
    }
    export interface PutEvaluationsRequest {
        Evaluations?: Evaluations;
        ResultToken: String;
    }
    export interface PutEvaluationsResponse {
        FailedEvaluations?: Evaluations;
    }
    export interface RecordingGroup {
        allSupported?: AllSupported;
        includeGlobalResourceTypes?: IncludeGlobalResourceTypes;
        resourceTypes?: ResourceTypeList;
    }
    export interface Relationship {
        resourceType?: ResourceType;
        resourceId?: ResourceId;
        resourceName?: ResourceName;
        relationshipName?: RelationshipName;
    }
    export interface ResourceIdentifier {
        resourceType?: ResourceType;
        resourceId?: ResourceId;
        resourceName?: ResourceName;
        resourceDeletionTime?: ResourceDeletionTime;
    }
    export interface ResourceInUseException {
    }
    export interface ResourceNotDiscoveredException {
    }
    export interface Scope {
        ComplianceResourceTypes?: ComplianceResourceTypes;
        TagKey?: StringWithCharLimit128;
        TagValue?: StringWithCharLimit256;
        ComplianceResourceId?: StringWithCharLimit256;
    }
    export interface Source {
        Owner?: Owner;
        SourceIdentifier?: StringWithCharLimit256;
        SourceDetails?: SourceDetails;
    }
    export interface SourceDetail {
        EventSource?: EventSource;
        MessageType?: MessageType;
    }
    export interface StartConfigurationRecorderRequest {
        ConfigurationRecorderName: RecorderName;
    }
    export interface StopConfigurationRecorderRequest {
        ConfigurationRecorderName: RecorderName;
    }
    export interface ValidationException {
    }
  }

  /*
   * apiVersion: 2012-10-29
   * endpointPrefix: datapipeline
   * serviceAbbreviation: 
   * signatureVersion: v4
   * protocol: json
   */
  export class DataPipeline extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    activatePipeline(params: DataPipeline.ActivatePipelineInput, callback?: (err: DataPipeline.PipelineNotFoundException|DataPipeline.PipelineDeletedException|DataPipeline.InternalServiceError|DataPipeline.InvalidRequestException|any, data: DataPipeline.ActivatePipelineOutput|any) => void): Request;
    addTags(params: DataPipeline.AddTagsInput, callback?: (err: DataPipeline.InternalServiceError|DataPipeline.InvalidRequestException|DataPipeline.PipelineNotFoundException|DataPipeline.PipelineDeletedException|any, data: DataPipeline.AddTagsOutput|any) => void): Request;
    createPipeline(params: DataPipeline.CreatePipelineInput, callback?: (err: DataPipeline.InternalServiceError|DataPipeline.InvalidRequestException|any, data: DataPipeline.CreatePipelineOutput|any) => void): Request;
    deactivatePipeline(params: DataPipeline.DeactivatePipelineInput, callback?: (err: DataPipeline.PipelineNotFoundException|DataPipeline.PipelineDeletedException|DataPipeline.InternalServiceError|DataPipeline.InvalidRequestException|any, data: DataPipeline.DeactivatePipelineOutput|any) => void): Request;
    deletePipeline(params: DataPipeline.DeletePipelineInput, callback?: (err: DataPipeline.PipelineNotFoundException|DataPipeline.InternalServiceError|DataPipeline.InvalidRequestException|any, data: any) => void): Request;
    describeObjects(params: DataPipeline.DescribeObjectsInput, callback?: (err: DataPipeline.InternalServiceError|DataPipeline.InvalidRequestException|DataPipeline.PipelineNotFoundException|DataPipeline.PipelineDeletedException|any, data: DataPipeline.DescribeObjectsOutput|any) => void): Request;
    describePipelines(params: DataPipeline.DescribePipelinesInput, callback?: (err: DataPipeline.PipelineNotFoundException|DataPipeline.PipelineDeletedException|DataPipeline.InternalServiceError|DataPipeline.InvalidRequestException|any, data: DataPipeline.DescribePipelinesOutput|any) => void): Request;
    evaluateExpression(params: DataPipeline.EvaluateExpressionInput, callback?: (err: DataPipeline.InternalServiceError|DataPipeline.TaskNotFoundException|DataPipeline.InvalidRequestException|DataPipeline.PipelineNotFoundException|DataPipeline.PipelineDeletedException|any, data: DataPipeline.EvaluateExpressionOutput|any) => void): Request;
    getPipelineDefinition(params: DataPipeline.GetPipelineDefinitionInput, callback?: (err: DataPipeline.InternalServiceError|DataPipeline.InvalidRequestException|DataPipeline.PipelineNotFoundException|DataPipeline.PipelineDeletedException|any, data: DataPipeline.GetPipelineDefinitionOutput|any) => void): Request;
    listPipelines(params: DataPipeline.ListPipelinesInput, callback?: (err: DataPipeline.InternalServiceError|DataPipeline.InvalidRequestException|any, data: DataPipeline.ListPipelinesOutput|any) => void): Request;
    pollForTask(params: DataPipeline.PollForTaskInput, callback?: (err: DataPipeline.InternalServiceError|DataPipeline.InvalidRequestException|DataPipeline.TaskNotFoundException|any, data: DataPipeline.PollForTaskOutput|any) => void): Request;
    putPipelineDefinition(params: DataPipeline.PutPipelineDefinitionInput, callback?: (err: DataPipeline.InternalServiceError|DataPipeline.InvalidRequestException|DataPipeline.PipelineNotFoundException|DataPipeline.PipelineDeletedException|any, data: DataPipeline.PutPipelineDefinitionOutput|any) => void): Request;
    queryObjects(params: DataPipeline.QueryObjectsInput, callback?: (err: DataPipeline.PipelineNotFoundException|DataPipeline.PipelineDeletedException|DataPipeline.InternalServiceError|DataPipeline.InvalidRequestException|any, data: DataPipeline.QueryObjectsOutput|any) => void): Request;
    removeTags(params: DataPipeline.RemoveTagsInput, callback?: (err: DataPipeline.InternalServiceError|DataPipeline.InvalidRequestException|DataPipeline.PipelineNotFoundException|DataPipeline.PipelineDeletedException|any, data: DataPipeline.RemoveTagsOutput|any) => void): Request;
    reportTaskProgress(params: DataPipeline.ReportTaskProgressInput, callback?: (err: DataPipeline.InternalServiceError|DataPipeline.InvalidRequestException|DataPipeline.TaskNotFoundException|DataPipeline.PipelineNotFoundException|DataPipeline.PipelineDeletedException|any, data: DataPipeline.ReportTaskProgressOutput|any) => void): Request;
    reportTaskRunnerHeartbeat(params: DataPipeline.ReportTaskRunnerHeartbeatInput, callback?: (err: DataPipeline.InternalServiceError|DataPipeline.InvalidRequestException|any, data: DataPipeline.ReportTaskRunnerHeartbeatOutput|any) => void): Request;
    setStatus(params: DataPipeline.SetStatusInput, callback?: (err: DataPipeline.PipelineNotFoundException|DataPipeline.PipelineDeletedException|DataPipeline.InternalServiceError|DataPipeline.InvalidRequestException|any, data: any) => void): Request;
    setTaskStatus(params: DataPipeline.SetTaskStatusInput, callback?: (err: DataPipeline.InternalServiceError|DataPipeline.TaskNotFoundException|DataPipeline.InvalidRequestException|DataPipeline.PipelineNotFoundException|DataPipeline.PipelineDeletedException|any, data: DataPipeline.SetTaskStatusOutput|any) => void): Request;
    validatePipelineDefinition(params: DataPipeline.ValidatePipelineDefinitionInput, callback?: (err: DataPipeline.InternalServiceError|DataPipeline.InvalidRequestException|DataPipeline.PipelineNotFoundException|DataPipeline.PipelineDeletedException|any, data: DataPipeline.ValidatePipelineDefinitionOutput|any) => void): Request;

  }

  export module DataPipeline {
    export type OperatorType = string;
    export type ParameterAttributeList = ParameterAttribute[];
    export type ParameterObjectList = ParameterObject[];
    export type ParameterValueList = ParameterValue[];
    export type PipelineDescriptionList = PipelineDescription[];
    export type PipelineObjectList = PipelineObject[];
    export type PipelineObjectMap = {[key:string]: PipelineObject};
    export type SelectorList = Selector[];
    export type TaskStatus = string;
    export type ValidationErrors = ValidationError[];
    export type ValidationWarnings = ValidationWarning[];
    export type attributeNameString = string;    // pattern: &quot;[\u0020-\uD7FF\uE000-\uFFFD\uD800\uDC00-\uDBFF\uDFFF\r\n\t]*&quot;, max: 256, min: 1
    export type attributeValueString = string;    // pattern: &quot;[\u0020-\uD7FF\uE000-\uFFFD\uD800\uDC00-\uDBFF\uDFFF\r\n\t]*&quot;, max: 10240
    export type cancelActive = boolean;
    export type errorMessage = string;
    export type fieldList = Field[];
    export type fieldNameString = string;    // pattern: &quot;[\u0020-\uD7FF\uE000-\uFFFD\uD800\uDC00-\uDBFF\uDFFF\r\n\t]*&quot;, max: 256, min: 1
    export type fieldStringValue = string;    // pattern: &quot;[\u0020-\uD7FF\uE000-\uFFFD\uD800\uDC00-\uDBFF\uDFFF\r\n\t]*&quot;, max: 10240
    export type id = string;    // pattern: &quot;[\u0020-\uD7FF\uE000-\uFFFD\uD800\uDC00-\uDBFF\uDFFF\r\n\t]*&quot;, max: 1024, min: 1
    export type idList = id[];
    export type int = number;
    export type longString = string;    // pattern: &quot;[\u0020-\uD7FF\uE000-\uFFFD\uD800\uDC00-\uDBFF\uDFFF\r\n\t]*&quot;, max: 20971520
    export type pipelineList = PipelineIdName[];
    export type stringList = string[];
    export type tagKey = string;    // max: 128, min: 1
    export type tagList = Tag[];    // max: 10
    export type tagValue = string;    // max: 256
    export type taskId = string;    // pattern: &quot;[\u0020-\uD7FF\uE000-\uFFFD\uD800\uDC00-\uDBFF\uDFFF\r\n\t]*&quot;, max: 2048, min: 1
    export type timestamp = number;
    export type validationMessage = string;    // pattern: &quot;[\u0020-\uD7FF\uE000-\uFFFD\uD800\uDC00-\uDBFF\uDFFF\r\n\t]*&quot;, max: 10000
    export type validationMessages = validationMessage[];

    export interface ActivatePipelineInput {
        pipelineId: id;
        parameterValues?: ParameterValueList;
        startTimestamp?: timestamp;
    }
    export interface ActivatePipelineOutput {
    }
    export interface AddTagsInput {
        pipelineId: id;
        tags: tagList;
    }
    export interface AddTagsOutput {
    }
    export interface CreatePipelineInput {
        name: id;
        uniqueId: id;
        description?: string;
        tags?: tagList;
    }
    export interface CreatePipelineOutput {
        pipelineId: id;
    }
    export interface DeactivatePipelineInput {
        pipelineId: id;
        cancelActive?: cancelActive;
    }
    export interface DeactivatePipelineOutput {
    }
    export interface DeletePipelineInput {
        pipelineId: id;
    }
    export interface DescribeObjectsInput {
        pipelineId: id;
        objectIds: idList;
        evaluateExpressions?: boolean;
        marker?: string;
    }
    export interface DescribeObjectsOutput {
        pipelineObjects: PipelineObjectList;
        marker?: string;
        hasMoreResults?: boolean;
    }
    export interface DescribePipelinesInput {
        pipelineIds: idList;
    }
    export interface DescribePipelinesOutput {
        pipelineDescriptionList: PipelineDescriptionList;
    }
    export interface EvaluateExpressionInput {
        pipelineId: id;
        objectId: id;
        expression: longString;
    }
    export interface EvaluateExpressionOutput {
        evaluatedExpression: longString;
    }
    export interface Field {
        key: fieldNameString;
        stringValue?: fieldStringValue;
        refValue?: fieldNameString;
    }
    export interface GetPipelineDefinitionInput {
        pipelineId: id;
        version?: string;
    }
    export interface GetPipelineDefinitionOutput {
        pipelineObjects?: PipelineObjectList;
        parameterObjects?: ParameterObjectList;
        parameterValues?: ParameterValueList;
    }
    export interface InstanceIdentity {
        document?: string;
        signature?: string;
    }
    export interface InternalServiceError {
        message?: errorMessage;
    }
    export interface InvalidRequestException {
        message?: errorMessage;
    }
    export interface ListPipelinesInput {
        marker?: string;
    }
    export interface ListPipelinesOutput {
        pipelineIdList: pipelineList;
        marker?: string;
        hasMoreResults?: boolean;
    }
    export interface Operator {
        type?: OperatorType;
        values?: stringList;
    }
    export interface ParameterAttribute {
        key: attributeNameString;
        stringValue: attributeValueString;
    }
    export interface ParameterObject {
        id: fieldNameString;
        attributes: ParameterAttributeList;
    }
    export interface ParameterValue {
        id: fieldNameString;
        stringValue: fieldStringValue;
    }
    export interface PipelineDeletedException {
        message?: errorMessage;
    }
    export interface PipelineDescription {
        pipelineId: id;
        name: id;
        fields: fieldList;
        description?: string;
        tags?: tagList;
    }
    export interface PipelineIdName {
        id?: id;
        name?: id;
    }
    export interface PipelineNotFoundException {
        message?: errorMessage;
    }
    export interface PipelineObject {
        id: id;
        name: id;
        fields: fieldList;
    }
    export interface PollForTaskInput {
        workerGroup: string;
        hostname?: id;
        instanceIdentity?: InstanceIdentity;
    }
    export interface PollForTaskOutput {
        taskObject?: TaskObject;
    }
    export interface PutPipelineDefinitionInput {
        pipelineId: id;
        pipelineObjects: PipelineObjectList;
        parameterObjects?: ParameterObjectList;
        parameterValues?: ParameterValueList;
    }
    export interface PutPipelineDefinitionOutput {
        validationErrors?: ValidationErrors;
        validationWarnings?: ValidationWarnings;
        errored: boolean;
    }
    export interface Query {
        selectors?: SelectorList;
    }
    export interface QueryObjectsInput {
        pipelineId: id;
        query?: Query;
        sphere: string;
        marker?: string;
        limit?: int;
    }
    export interface QueryObjectsOutput {
        ids?: idList;
        marker?: string;
        hasMoreResults?: boolean;
    }
    export interface RemoveTagsInput {
        pipelineId: id;
        tagKeys: stringList;
    }
    export interface RemoveTagsOutput {
    }
    export interface ReportTaskProgressInput {
        taskId: taskId;
        fields?: fieldList;
    }
    export interface ReportTaskProgressOutput {
        canceled: boolean;
    }
    export interface ReportTaskRunnerHeartbeatInput {
        taskrunnerId: id;
        workerGroup?: string;
        hostname?: id;
    }
    export interface ReportTaskRunnerHeartbeatOutput {
        terminate: boolean;
    }
    export interface Selector {
        fieldName?: string;
        operator?: Operator;
    }
    export interface SetStatusInput {
        pipelineId: id;
        objectIds: idList;
        status: string;
    }
    export interface SetTaskStatusInput {
        taskId: taskId;
        taskStatus: TaskStatus;
        errorId?: string;
        errorMessage?: errorMessage;
        errorStackTrace?: string;
    }
    export interface SetTaskStatusOutput {
    }
    export interface Tag {
        key: tagKey;
        value: tagValue;
    }
    export interface TaskNotFoundException {
        message?: errorMessage;
    }
    export interface TaskObject {
        taskId?: taskId;
        pipelineId?: id;
        attemptId?: id;
        objects?: PipelineObjectMap;
    }
    export interface ValidatePipelineDefinitionInput {
        pipelineId: id;
        pipelineObjects: PipelineObjectList;
        parameterObjects?: ParameterObjectList;
        parameterValues?: ParameterValueList;
    }
    export interface ValidatePipelineDefinitionOutput {
        validationErrors?: ValidationErrors;
        validationWarnings?: ValidationWarnings;
        errored: boolean;
    }
    export interface ValidationError {
        id?: id;
        errors?: validationMessages;
    }
    export interface ValidationWarning {
        id?: id;
        warnings?: validationMessages;
    }
  }

  /*
   * apiVersion: 2015-06-23
   * endpointPrefix: devicefarm
   * serviceAbbreviation: 
   * signatureVersion: v4
   * protocol: json
   */
  export class DeviceFarm extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    createDevicePool(params: DeviceFarm.CreateDevicePoolRequest, callback?: (err: DeviceFarm.ArgumentException|DeviceFarm.NotFoundException|DeviceFarm.LimitExceededException|DeviceFarm.ServiceAccountException|any, data: DeviceFarm.CreateDevicePoolResult|any) => void): Request;
    createProject(params: DeviceFarm.CreateProjectRequest, callback?: (err: DeviceFarm.ArgumentException|DeviceFarm.NotFoundException|DeviceFarm.LimitExceededException|DeviceFarm.ServiceAccountException|any, data: DeviceFarm.CreateProjectResult|any) => void): Request;
    createUpload(params: DeviceFarm.CreateUploadRequest, callback?: (err: DeviceFarm.ArgumentException|DeviceFarm.NotFoundException|DeviceFarm.LimitExceededException|DeviceFarm.ServiceAccountException|any, data: DeviceFarm.CreateUploadResult|any) => void): Request;
    deleteDevicePool(params: DeviceFarm.DeleteDevicePoolRequest, callback?: (err: DeviceFarm.ArgumentException|DeviceFarm.NotFoundException|DeviceFarm.LimitExceededException|DeviceFarm.ServiceAccountException|any, data: DeviceFarm.DeleteDevicePoolResult|any) => void): Request;
    deleteProject(params: DeviceFarm.DeleteProjectRequest, callback?: (err: DeviceFarm.ArgumentException|DeviceFarm.NotFoundException|DeviceFarm.LimitExceededException|DeviceFarm.ServiceAccountException|any, data: DeviceFarm.DeleteProjectResult|any) => void): Request;
    deleteRun(params: DeviceFarm.DeleteRunRequest, callback?: (err: DeviceFarm.ArgumentException|DeviceFarm.NotFoundException|DeviceFarm.LimitExceededException|DeviceFarm.ServiceAccountException|any, data: DeviceFarm.DeleteRunResult|any) => void): Request;
    deleteUpload(params: DeviceFarm.DeleteUploadRequest, callback?: (err: DeviceFarm.ArgumentException|DeviceFarm.NotFoundException|DeviceFarm.LimitExceededException|DeviceFarm.ServiceAccountException|any, data: DeviceFarm.DeleteUploadResult|any) => void): Request;
    getAccountSettings(params: DeviceFarm.GetAccountSettingsRequest, callback?: (err: DeviceFarm.ArgumentException|DeviceFarm.NotFoundException|DeviceFarm.LimitExceededException|DeviceFarm.ServiceAccountException|any, data: DeviceFarm.GetAccountSettingsResult|any) => void): Request;
    getDevice(params: DeviceFarm.GetDeviceRequest, callback?: (err: DeviceFarm.ArgumentException|DeviceFarm.NotFoundException|DeviceFarm.LimitExceededException|DeviceFarm.ServiceAccountException|any, data: DeviceFarm.GetDeviceResult|any) => void): Request;
    getDevicePool(params: DeviceFarm.GetDevicePoolRequest, callback?: (err: DeviceFarm.ArgumentException|DeviceFarm.NotFoundException|DeviceFarm.LimitExceededException|DeviceFarm.ServiceAccountException|any, data: DeviceFarm.GetDevicePoolResult|any) => void): Request;
    getDevicePoolCompatibility(params: DeviceFarm.GetDevicePoolCompatibilityRequest, callback?: (err: DeviceFarm.ArgumentException|DeviceFarm.NotFoundException|DeviceFarm.LimitExceededException|DeviceFarm.ServiceAccountException|any, data: DeviceFarm.GetDevicePoolCompatibilityResult|any) => void): Request;
    getJob(params: DeviceFarm.GetJobRequest, callback?: (err: DeviceFarm.ArgumentException|DeviceFarm.NotFoundException|DeviceFarm.LimitExceededException|DeviceFarm.ServiceAccountException|any, data: DeviceFarm.GetJobResult|any) => void): Request;
    getOfferingStatus(params: DeviceFarm.GetOfferingStatusRequest, callback?: (err: DeviceFarm.ArgumentException|DeviceFarm.NotFoundException|DeviceFarm.NotEligibleException|DeviceFarm.LimitExceededException|DeviceFarm.ServiceAccountException|any, data: DeviceFarm.GetOfferingStatusResult|any) => void): Request;
    getProject(params: DeviceFarm.GetProjectRequest, callback?: (err: DeviceFarm.ArgumentException|DeviceFarm.NotFoundException|DeviceFarm.LimitExceededException|DeviceFarm.ServiceAccountException|any, data: DeviceFarm.GetProjectResult|any) => void): Request;
    getRun(params: DeviceFarm.GetRunRequest, callback?: (err: DeviceFarm.ArgumentException|DeviceFarm.NotFoundException|DeviceFarm.LimitExceededException|DeviceFarm.ServiceAccountException|any, data: DeviceFarm.GetRunResult|any) => void): Request;
    getSuite(params: DeviceFarm.GetSuiteRequest, callback?: (err: DeviceFarm.ArgumentException|DeviceFarm.NotFoundException|DeviceFarm.LimitExceededException|DeviceFarm.ServiceAccountException|any, data: DeviceFarm.GetSuiteResult|any) => void): Request;
    getTest(params: DeviceFarm.GetTestRequest, callback?: (err: DeviceFarm.ArgumentException|DeviceFarm.NotFoundException|DeviceFarm.LimitExceededException|DeviceFarm.ServiceAccountException|any, data: DeviceFarm.GetTestResult|any) => void): Request;
    getUpload(params: DeviceFarm.GetUploadRequest, callback?: (err: DeviceFarm.ArgumentException|DeviceFarm.NotFoundException|DeviceFarm.LimitExceededException|DeviceFarm.ServiceAccountException|any, data: DeviceFarm.GetUploadResult|any) => void): Request;
    listArtifacts(params: DeviceFarm.ListArtifactsRequest, callback?: (err: DeviceFarm.ArgumentException|DeviceFarm.NotFoundException|DeviceFarm.LimitExceededException|DeviceFarm.ServiceAccountException|any, data: DeviceFarm.ListArtifactsResult|any) => void): Request;
    listDevicePools(params: DeviceFarm.ListDevicePoolsRequest, callback?: (err: DeviceFarm.ArgumentException|DeviceFarm.NotFoundException|DeviceFarm.LimitExceededException|DeviceFarm.ServiceAccountException|any, data: DeviceFarm.ListDevicePoolsResult|any) => void): Request;
    listDevices(params: DeviceFarm.ListDevicesRequest, callback?: (err: DeviceFarm.ArgumentException|DeviceFarm.NotFoundException|DeviceFarm.LimitExceededException|DeviceFarm.ServiceAccountException|any, data: DeviceFarm.ListDevicesResult|any) => void): Request;
    listJobs(params: DeviceFarm.ListJobsRequest, callback?: (err: DeviceFarm.ArgumentException|DeviceFarm.NotFoundException|DeviceFarm.LimitExceededException|DeviceFarm.ServiceAccountException|any, data: DeviceFarm.ListJobsResult|any) => void): Request;
    listOfferingTransactions(params: DeviceFarm.ListOfferingTransactionsRequest, callback?: (err: DeviceFarm.ArgumentException|DeviceFarm.NotFoundException|DeviceFarm.NotEligibleException|DeviceFarm.LimitExceededException|DeviceFarm.ServiceAccountException|any, data: DeviceFarm.ListOfferingTransactionsResult|any) => void): Request;
    listOfferings(params: DeviceFarm.ListOfferingsRequest, callback?: (err: DeviceFarm.ArgumentException|DeviceFarm.NotFoundException|DeviceFarm.NotEligibleException|DeviceFarm.LimitExceededException|DeviceFarm.ServiceAccountException|any, data: DeviceFarm.ListOfferingsResult|any) => void): Request;
    listProjects(params: DeviceFarm.ListProjectsRequest, callback?: (err: DeviceFarm.ArgumentException|DeviceFarm.NotFoundException|DeviceFarm.LimitExceededException|DeviceFarm.ServiceAccountException|any, data: DeviceFarm.ListProjectsResult|any) => void): Request;
    listRuns(params: DeviceFarm.ListRunsRequest, callback?: (err: DeviceFarm.ArgumentException|DeviceFarm.NotFoundException|DeviceFarm.LimitExceededException|DeviceFarm.ServiceAccountException|any, data: DeviceFarm.ListRunsResult|any) => void): Request;
    listSamples(params: DeviceFarm.ListSamplesRequest, callback?: (err: DeviceFarm.ArgumentException|DeviceFarm.NotFoundException|DeviceFarm.LimitExceededException|DeviceFarm.ServiceAccountException|any, data: DeviceFarm.ListSamplesResult|any) => void): Request;
    listSuites(params: DeviceFarm.ListSuitesRequest, callback?: (err: DeviceFarm.ArgumentException|DeviceFarm.NotFoundException|DeviceFarm.LimitExceededException|DeviceFarm.ServiceAccountException|any, data: DeviceFarm.ListSuitesResult|any) => void): Request;
    listTests(params: DeviceFarm.ListTestsRequest, callback?: (err: DeviceFarm.ArgumentException|DeviceFarm.NotFoundException|DeviceFarm.LimitExceededException|DeviceFarm.ServiceAccountException|any, data: DeviceFarm.ListTestsResult|any) => void): Request;
    listUniqueProblems(params: DeviceFarm.ListUniqueProblemsRequest, callback?: (err: DeviceFarm.ArgumentException|DeviceFarm.NotFoundException|DeviceFarm.LimitExceededException|DeviceFarm.ServiceAccountException|any, data: DeviceFarm.ListUniqueProblemsResult|any) => void): Request;
    listUploads(params: DeviceFarm.ListUploadsRequest, callback?: (err: DeviceFarm.ArgumentException|DeviceFarm.NotFoundException|DeviceFarm.LimitExceededException|DeviceFarm.ServiceAccountException|any, data: DeviceFarm.ListUploadsResult|any) => void): Request;
    purchaseOffering(params: DeviceFarm.PurchaseOfferingRequest, callback?: (err: DeviceFarm.ArgumentException|DeviceFarm.NotFoundException|DeviceFarm.NotEligibleException|DeviceFarm.LimitExceededException|DeviceFarm.ServiceAccountException|any, data: DeviceFarm.PurchaseOfferingResult|any) => void): Request;
    renewOffering(params: DeviceFarm.RenewOfferingRequest, callback?: (err: DeviceFarm.ArgumentException|DeviceFarm.NotFoundException|DeviceFarm.NotEligibleException|DeviceFarm.LimitExceededException|DeviceFarm.ServiceAccountException|any, data: DeviceFarm.RenewOfferingResult|any) => void): Request;
    scheduleRun(params: DeviceFarm.ScheduleRunRequest, callback?: (err: DeviceFarm.ArgumentException|DeviceFarm.NotFoundException|DeviceFarm.LimitExceededException|DeviceFarm.IdempotencyException|DeviceFarm.ServiceAccountException|any, data: DeviceFarm.ScheduleRunResult|any) => void): Request;
    stopRun(params: DeviceFarm.StopRunRequest, callback?: (err: DeviceFarm.ArgumentException|DeviceFarm.NotFoundException|DeviceFarm.LimitExceededException|DeviceFarm.ServiceAccountException|any, data: DeviceFarm.StopRunResult|any) => void): Request;
    updateDevicePool(params: DeviceFarm.UpdateDevicePoolRequest, callback?: (err: DeviceFarm.ArgumentException|DeviceFarm.NotFoundException|DeviceFarm.LimitExceededException|DeviceFarm.ServiceAccountException|any, data: DeviceFarm.UpdateDevicePoolResult|any) => void): Request;
    updateProject(params: DeviceFarm.UpdateProjectRequest, callback?: (err: DeviceFarm.ArgumentException|DeviceFarm.NotFoundException|DeviceFarm.LimitExceededException|DeviceFarm.ServiceAccountException|any, data: DeviceFarm.UpdateProjectResult|any) => void): Request;

  }

  export module DeviceFarm {
    export type AWSAccountNumber = string;    // max: 16, min: 2
    export type AmazonResourceName = string;    // min: 32
    export type AmazonResourceNames = AmazonResourceName[];
    export type ArtifactCategory = string;
    export type ArtifactType = string;
    export type Artifacts = Artifact[];
    export type BillingMethod = string;
    export type Boolean = boolean;
    export type ContentType = string;    // max: 64
    export type CurrencyCode = string;
    export type DateTime = number;
    export type DeviceAttribute = string;
    export type DeviceFormFactor = string;
    export type DevicePlatform = string;
    export type DevicePoolCompatibilityResults = DevicePoolCompatibilityResult[];
    export type DevicePoolType = string;
    export type DevicePools = DevicePool[];
    export type Devices = Device[];
    export type Double = number;
    export type ExecutionResult = string;
    export type ExecutionStatus = string;
    export type Filter = string;    // max: 8192
    export type IncompatibilityMessages = IncompatibilityMessage[];
    export type Integer = number;
    export type Jobs = Job[];
    export type Long = number;
    export type Message = string;    // max: 16384
    export type Metadata = string;    // max: 8192
    export type Name = string;    // max: 256
    export type OfferingIdentifier = string;    // min: 32
    export type OfferingStatusMap = {[key:string]: OfferingStatus};
    export type OfferingTransactionType = string;
    export type OfferingTransactions = OfferingTransaction[];
    export type OfferingType = string;
    export type Offerings = Offering[];
    export type PaginationToken = string;    // max: 1024, min: 4
    export type Problems = Problem[];
    export type Projects = Project[];
    export type PurchasedDevicesMap = {[key:string]: Integer};
    export type RecurringChargeFrequency = string;
    export type RecurringCharges = RecurringCharge[];
    export type RuleOperator = string;
    export type Rules = Rule[];
    export type Runs = Run[];
    export type SampleType = string;
    export type Samples = Sample[];
    export type String = string;
    export type Suites = Suite[];
    export type TestParameters = {[key:string]: String};
    export type TestType = string;
    export type Tests = Test[];
    export type TransactionIdentifier = string;    // min: 32
    export type URL = string;    // max: 2048
    export type UniqueProblems = UniqueProblem[];
    export type UniqueProblemsByExecutionResultMap = {[key:string]: UniqueProblems};
    export type UploadStatus = string;
    export type UploadType = string;
    export type Uploads = Upload[];

    export interface AccountSettings {
        awsAccountNumber?: AWSAccountNumber;
        unmeteredDevices?: PurchasedDevicesMap;
    }
    export interface ArgumentException {
        message?: Message;
    }
    export interface Artifact {
        arn?: AmazonResourceName;
        name?: Name;
        type?: ArtifactType;
        extension?: String;
        url?: URL;
    }
    export interface CPU {
        frequency?: String;
        architecture?: String;
        clock?: Double;
    }
    export interface Counters {
        total?: Integer;
        passed?: Integer;
        failed?: Integer;
        warned?: Integer;
        errored?: Integer;
        stopped?: Integer;
        skipped?: Integer;
    }
    export interface CreateDevicePoolRequest {
        projectArn: AmazonResourceName;
        name: Name;
        description?: Message;
        rules: Rules;
    }
    export interface CreateDevicePoolResult {
        devicePool?: DevicePool;
    }
    export interface CreateProjectRequest {
        name: Name;
    }
    export interface CreateProjectResult {
        project?: Project;
    }
    export interface CreateUploadRequest {
        projectArn: AmazonResourceName;
        name: Name;
        type: UploadType;
        contentType?: ContentType;
    }
    export interface CreateUploadResult {
        upload?: Upload;
    }
    export interface DeleteDevicePoolRequest {
        arn: AmazonResourceName;
    }
    export interface DeleteDevicePoolResult {
    }
    export interface DeleteProjectRequest {
        arn: AmazonResourceName;
    }
    export interface DeleteProjectResult {
    }
    export interface DeleteRunRequest {
        arn: AmazonResourceName;
    }
    export interface DeleteRunResult {
    }
    export interface DeleteUploadRequest {
        arn: AmazonResourceName;
    }
    export interface DeleteUploadResult {
    }
    export interface Device {
        arn?: AmazonResourceName;
        name?: Name;
        manufacturer?: String;
        model?: String;
        formFactor?: DeviceFormFactor;
        platform?: DevicePlatform;
        os?: String;
        cpu?: CPU;
        resolution?: Resolution;
        heapSize?: Long;
        memory?: Long;
        image?: String;
        carrier?: String;
        radio?: String;
    }
    export interface DeviceMinutes {
        total?: Double;
        metered?: Double;
        unmetered?: Double;
    }
    export interface DevicePool {
        arn?: AmazonResourceName;
        name?: Name;
        description?: Message;
        type?: DevicePoolType;
        rules?: Rules;
    }
    export interface DevicePoolCompatibilityResult {
        device?: Device;
        compatible?: Boolean;
        incompatibilityMessages?: IncompatibilityMessages;
    }
    export interface GetAccountSettingsRequest {
    }
    export interface GetAccountSettingsResult {
        accountSettings?: AccountSettings;
    }
    export interface GetDevicePoolCompatibilityRequest {
        devicePoolArn: AmazonResourceName;
        appArn?: AmazonResourceName;
        testType?: TestType;
    }
    export interface GetDevicePoolCompatibilityResult {
        compatibleDevices?: DevicePoolCompatibilityResults;
        incompatibleDevices?: DevicePoolCompatibilityResults;
    }
    export interface GetDevicePoolRequest {
        arn: AmazonResourceName;
    }
    export interface GetDevicePoolResult {
        devicePool?: DevicePool;
    }
    export interface GetDeviceRequest {
        arn: AmazonResourceName;
    }
    export interface GetDeviceResult {
        device?: Device;
    }
    export interface GetJobRequest {
        arn: AmazonResourceName;
    }
    export interface GetJobResult {
        job?: Job;
    }
    export interface GetOfferingStatusRequest {
        nextToken?: PaginationToken;
    }
    export interface GetOfferingStatusResult {
        current?: OfferingStatusMap;
        nextPeriod?: OfferingStatusMap;
        nextToken?: PaginationToken;
    }
    export interface GetProjectRequest {
        arn: AmazonResourceName;
    }
    export interface GetProjectResult {
        project?: Project;
    }
    export interface GetRunRequest {
        arn: AmazonResourceName;
    }
    export interface GetRunResult {
        run?: Run;
    }
    export interface GetSuiteRequest {
        arn: AmazonResourceName;
    }
    export interface GetSuiteResult {
        suite?: Suite;
    }
    export interface GetTestRequest {
        arn: AmazonResourceName;
    }
    export interface GetTestResult {
        test?: Test;
    }
    export interface GetUploadRequest {
        arn: AmazonResourceName;
    }
    export interface GetUploadResult {
        upload?: Upload;
    }
    export interface IdempotencyException {
        message?: Message;
    }
    export interface IncompatibilityMessage {
        message?: Message;
        type?: DeviceAttribute;
    }
    export interface Job {
        arn?: AmazonResourceName;
        name?: Name;
        type?: TestType;
        created?: DateTime;
        status?: ExecutionStatus;
        result?: ExecutionResult;
        started?: DateTime;
        stopped?: DateTime;
        counters?: Counters;
        message?: Message;
        device?: Device;
        deviceMinutes?: DeviceMinutes;
    }
    export interface LimitExceededException {
        message?: Message;
    }
    export interface ListArtifactsRequest {
        arn: AmazonResourceName;
        type: ArtifactCategory;
        nextToken?: PaginationToken;
    }
    export interface ListArtifactsResult {
        artifacts?: Artifacts;
        nextToken?: PaginationToken;
    }
    export interface ListDevicePoolsRequest {
        arn: AmazonResourceName;
        type?: DevicePoolType;
        nextToken?: PaginationToken;
    }
    export interface ListDevicePoolsResult {
        devicePools?: DevicePools;
        nextToken?: PaginationToken;
    }
    export interface ListDevicesRequest {
        arn?: AmazonResourceName;
        nextToken?: PaginationToken;
    }
    export interface ListDevicesResult {
        devices?: Devices;
        nextToken?: PaginationToken;
    }
    export interface ListJobsRequest {
        arn: AmazonResourceName;
        nextToken?: PaginationToken;
    }
    export interface ListJobsResult {
        jobs?: Jobs;
        nextToken?: PaginationToken;
    }
    export interface ListOfferingTransactionsRequest {
        nextToken?: PaginationToken;
    }
    export interface ListOfferingTransactionsResult {
        offeringTransactions?: OfferingTransactions;
        nextToken?: PaginationToken;
    }
    export interface ListOfferingsRequest {
        nextToken?: PaginationToken;
    }
    export interface ListOfferingsResult {
        offerings?: Offerings;
        nextToken?: PaginationToken;
    }
    export interface ListProjectsRequest {
        arn?: AmazonResourceName;
        nextToken?: PaginationToken;
    }
    export interface ListProjectsResult {
        projects?: Projects;
        nextToken?: PaginationToken;
    }
    export interface ListRunsRequest {
        arn: AmazonResourceName;
        nextToken?: PaginationToken;
    }
    export interface ListRunsResult {
        runs?: Runs;
        nextToken?: PaginationToken;
    }
    export interface ListSamplesRequest {
        arn: AmazonResourceName;
        nextToken?: PaginationToken;
    }
    export interface ListSamplesResult {
        samples?: Samples;
        nextToken?: PaginationToken;
    }
    export interface ListSuitesRequest {
        arn: AmazonResourceName;
        nextToken?: PaginationToken;
    }
    export interface ListSuitesResult {
        suites?: Suites;
        nextToken?: PaginationToken;
    }
    export interface ListTestsRequest {
        arn: AmazonResourceName;
        nextToken?: PaginationToken;
    }
    export interface ListTestsResult {
        tests?: Tests;
        nextToken?: PaginationToken;
    }
    export interface ListUniqueProblemsRequest {
        arn: AmazonResourceName;
        nextToken?: PaginationToken;
    }
    export interface ListUniqueProblemsResult {
        uniqueProblems?: UniqueProblemsByExecutionResultMap;
        nextToken?: PaginationToken;
    }
    export interface ListUploadsRequest {
        arn: AmazonResourceName;
        nextToken?: PaginationToken;
    }
    export interface ListUploadsResult {
        uploads?: Uploads;
        nextToken?: PaginationToken;
    }
    export interface Location {
        latitude: Double;
        longitude: Double;
    }
    export interface MonetaryAmount {
        amount?: Double;
        currencyCode?: CurrencyCode;
    }
    export interface NotEligibleException {
        message?: Message;
    }
    export interface NotFoundException {
        message?: Message;
    }
    export interface Offering {
        id?: OfferingIdentifier;
        description?: Message;
        type?: OfferingType;
        platform?: DevicePlatform;
        recurringCharges?: RecurringCharges;
    }
    export interface OfferingStatus {
        type?: OfferingTransactionType;
        offering?: Offering;
        quantity?: Integer;
        effectiveOn?: DateTime;
    }
    export interface OfferingTransaction {
        offeringStatus?: OfferingStatus;
        transactionId?: TransactionIdentifier;
        createdOn?: DateTime;
        cost?: MonetaryAmount;
    }
    export interface Problem {
        run?: ProblemDetail;
        job?: ProblemDetail;
        suite?: ProblemDetail;
        test?: ProblemDetail;
        device?: Device;
        result?: ExecutionResult;
        message?: Message;
    }
    export interface ProblemDetail {
        arn?: AmazonResourceName;
        name?: Name;
    }
    export interface Project {
        arn?: AmazonResourceName;
        name?: Name;
        created?: DateTime;
    }
    export interface PurchaseOfferingRequest {
        offeringId?: OfferingIdentifier;
        quantity?: Integer;
    }
    export interface PurchaseOfferingResult {
        offeringTransaction?: OfferingTransaction;
    }
    export interface Radios {
        wifi?: Boolean;
        bluetooth?: Boolean;
        nfc?: Boolean;
        gps?: Boolean;
    }
    export interface RecurringCharge {
        cost?: MonetaryAmount;
        frequency?: RecurringChargeFrequency;
    }
    export interface RenewOfferingRequest {
        offeringId?: OfferingIdentifier;
        quantity?: Integer;
    }
    export interface RenewOfferingResult {
        offeringTransaction?: OfferingTransaction;
    }
    export interface Resolution {
        width?: Integer;
        height?: Integer;
    }
    export interface Rule {
        attribute?: DeviceAttribute;
        operator?: RuleOperator;
        value?: String;
    }
    export interface Run {
        arn?: AmazonResourceName;
        name?: Name;
        type?: TestType;
        platform?: DevicePlatform;
        created?: DateTime;
        status?: ExecutionStatus;
        result?: ExecutionResult;
        started?: DateTime;
        stopped?: DateTime;
        counters?: Counters;
        message?: Message;
        totalJobs?: Integer;
        completedJobs?: Integer;
        billingMethod?: BillingMethod;
        deviceMinutes?: DeviceMinutes;
    }
    export interface Sample {
        arn?: AmazonResourceName;
        type?: SampleType;
        url?: URL;
    }
    export interface ScheduleRunConfiguration {
        extraDataPackageArn?: AmazonResourceName;
        networkProfileArn?: AmazonResourceName;
        locale?: String;
        location?: Location;
        radios?: Radios;
        auxiliaryApps?: AmazonResourceNames;
        billingMethod?: BillingMethod;
    }
    export interface ScheduleRunRequest {
        projectArn: AmazonResourceName;
        appArn?: AmazonResourceName;
        devicePoolArn: AmazonResourceName;
        name?: Name;
        test: ScheduleRunTest;
        configuration?: ScheduleRunConfiguration;
    }
    export interface ScheduleRunResult {
        run?: Run;
    }
    export interface ScheduleRunTest {
        type: TestType;
        testPackageArn?: AmazonResourceName;
        filter?: Filter;
        parameters?: TestParameters;
    }
    export interface ServiceAccountException {
        message?: Message;
    }
    export interface StopRunRequest {
        arn: AmazonResourceName;
    }
    export interface StopRunResult {
        run?: Run;
    }
    export interface Suite {
        arn?: AmazonResourceName;
        name?: Name;
        type?: TestType;
        created?: DateTime;
        status?: ExecutionStatus;
        result?: ExecutionResult;
        started?: DateTime;
        stopped?: DateTime;
        counters?: Counters;
        message?: Message;
        deviceMinutes?: DeviceMinutes;
    }
    export interface Test {
        arn?: AmazonResourceName;
        name?: Name;
        type?: TestType;
        created?: DateTime;
        status?: ExecutionStatus;
        result?: ExecutionResult;
        started?: DateTime;
        stopped?: DateTime;
        counters?: Counters;
        message?: Message;
        deviceMinutes?: DeviceMinutes;
    }
    export interface UniqueProblem {
        message?: Message;
        problems?: Problems;
    }
    export interface UpdateDevicePoolRequest {
        arn: AmazonResourceName;
        name?: Name;
        description?: Message;
        rules?: Rules;
    }
    export interface UpdateDevicePoolResult {
        devicePool?: DevicePool;
    }
    export interface UpdateProjectRequest {
        arn: AmazonResourceName;
        name?: Name;
    }
    export interface UpdateProjectResult {
        project?: Project;
    }
    export interface Upload {
        arn?: AmazonResourceName;
        name?: Name;
        created?: DateTime;
        type?: UploadType;
        status?: UploadStatus;
        url?: URL;
        metadata?: Metadata;
        contentType?: ContentType;
        message?: Message;
    }
  }

  /*
   * apiVersion: 2012-10-25
   * endpointPrefix: directconnect
   * serviceAbbreviation: 
   * signatureVersion: v4
   * protocol: json
   */
  export class DirectConnect extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    allocateConnectionOnInterconnect(params: DirectConnect.AllocateConnectionOnInterconnectRequest, callback?: (err: DirectConnect.DirectConnectServerException|DirectConnect.DirectConnectClientException|any, data: DirectConnect.Connection|any) => void): Request;
    allocatePrivateVirtualInterface(params: DirectConnect.AllocatePrivateVirtualInterfaceRequest, callback?: (err: DirectConnect.DirectConnectServerException|DirectConnect.DirectConnectClientException|any, data: DirectConnect.VirtualInterface|any) => void): Request;
    allocatePublicVirtualInterface(params: DirectConnect.AllocatePublicVirtualInterfaceRequest, callback?: (err: DirectConnect.DirectConnectServerException|DirectConnect.DirectConnectClientException|any, data: DirectConnect.VirtualInterface|any) => void): Request;
    confirmConnection(params: DirectConnect.ConfirmConnectionRequest, callback?: (err: DirectConnect.DirectConnectServerException|DirectConnect.DirectConnectClientException|any, data: DirectConnect.ConfirmConnectionResponse|any) => void): Request;
    confirmPrivateVirtualInterface(params: DirectConnect.ConfirmPrivateVirtualInterfaceRequest, callback?: (err: DirectConnect.DirectConnectServerException|DirectConnect.DirectConnectClientException|any, data: DirectConnect.ConfirmPrivateVirtualInterfaceResponse|any) => void): Request;
    confirmPublicVirtualInterface(params: DirectConnect.ConfirmPublicVirtualInterfaceRequest, callback?: (err: DirectConnect.DirectConnectServerException|DirectConnect.DirectConnectClientException|any, data: DirectConnect.ConfirmPublicVirtualInterfaceResponse|any) => void): Request;
    createConnection(params: DirectConnect.CreateConnectionRequest, callback?: (err: DirectConnect.DirectConnectServerException|DirectConnect.DirectConnectClientException|any, data: DirectConnect.Connection|any) => void): Request;
    createInterconnect(params: DirectConnect.CreateInterconnectRequest, callback?: (err: DirectConnect.DirectConnectServerException|DirectConnect.DirectConnectClientException|any, data: DirectConnect.Interconnect|any) => void): Request;
    createPrivateVirtualInterface(params: DirectConnect.CreatePrivateVirtualInterfaceRequest, callback?: (err: DirectConnect.DirectConnectServerException|DirectConnect.DirectConnectClientException|any, data: DirectConnect.VirtualInterface|any) => void): Request;
    createPublicVirtualInterface(params: DirectConnect.CreatePublicVirtualInterfaceRequest, callback?: (err: DirectConnect.DirectConnectServerException|DirectConnect.DirectConnectClientException|any, data: DirectConnect.VirtualInterface|any) => void): Request;
    deleteConnection(params: DirectConnect.DeleteConnectionRequest, callback?: (err: DirectConnect.DirectConnectServerException|DirectConnect.DirectConnectClientException|any, data: DirectConnect.Connection|any) => void): Request;
    deleteInterconnect(params: DirectConnect.DeleteInterconnectRequest, callback?: (err: DirectConnect.DirectConnectServerException|DirectConnect.DirectConnectClientException|any, data: DirectConnect.DeleteInterconnectResponse|any) => void): Request;
    deleteVirtualInterface(params: DirectConnect.DeleteVirtualInterfaceRequest, callback?: (err: DirectConnect.DirectConnectServerException|DirectConnect.DirectConnectClientException|any, data: DirectConnect.DeleteVirtualInterfaceResponse|any) => void): Request;
    describeConnections(params: DirectConnect.DescribeConnectionsRequest, callback?: (err: DirectConnect.DirectConnectServerException|DirectConnect.DirectConnectClientException|any, data: DirectConnect.Connections|any) => void): Request;
    describeConnectionsOnInterconnect(params: DirectConnect.DescribeConnectionsOnInterconnectRequest, callback?: (err: DirectConnect.DirectConnectServerException|DirectConnect.DirectConnectClientException|any, data: DirectConnect.Connections|any) => void): Request;
    describeInterconnects(params: DirectConnect.DescribeInterconnectsRequest, callback?: (err: DirectConnect.DirectConnectServerException|DirectConnect.DirectConnectClientException|any, data: DirectConnect.Interconnects|any) => void): Request;
    describeLocations(callback?: (err: DirectConnect.DirectConnectServerException|DirectConnect.DirectConnectClientException|any, data: DirectConnect.Locations|any) => void): Request;
    describeVirtualGateways(callback?: (err: DirectConnect.DirectConnectServerException|DirectConnect.DirectConnectClientException|any, data: DirectConnect.VirtualGateways|any) => void): Request;
    describeVirtualInterfaces(params: DirectConnect.DescribeVirtualInterfacesRequest, callback?: (err: DirectConnect.DirectConnectServerException|DirectConnect.DirectConnectClientException|any, data: DirectConnect.VirtualInterfaces|any) => void): Request;

  }

  export module DirectConnect {
    export type ASN = number;
    export type AmazonAddress = string;
    export type BGPAuthKey = string;
    export type Bandwidth = string;
    export type CIDR = string;
    export type ConnectionId = string;
    export type ConnectionList = Connection[];
    export type ConnectionName = string;
    export type ConnectionState = string;
    export type CustomerAddress = string;
    export type ErrorMessage = string;
    export type InterconnectId = string;
    export type InterconnectList = Interconnect[];
    export type InterconnectName = string;
    export type InterconnectState = string;
    export type LocationCode = string;
    export type LocationList = Location[];
    export type LocationName = string;
    export type OwnerAccount = string;
    export type PartnerName = string;
    export type Region = string;
    export type RouteFilterPrefixList = RouteFilterPrefix[];
    export type RouterConfig = string;
    export type VLAN = number;
    export type VirtualGatewayId = string;
    export type VirtualGatewayList = VirtualGateway[];
    export type VirtualGatewayState = string;
    export type VirtualInterfaceId = string;
    export type VirtualInterfaceList = VirtualInterface[];
    export type VirtualInterfaceName = string;
    export type VirtualInterfaceState = string;
    export type VirtualInterfaceType = string;

    export interface AllocateConnectionOnInterconnectRequest {
        bandwidth: Bandwidth;
        connectionName: ConnectionName;
        ownerAccount: OwnerAccount;
        interconnectId: InterconnectId;
        vlan: VLAN;
    }
    export interface AllocatePrivateVirtualInterfaceRequest {
        connectionId: ConnectionId;
        ownerAccount: OwnerAccount;
        newPrivateVirtualInterfaceAllocation: NewPrivateVirtualInterfaceAllocation;
    }
    export interface AllocatePublicVirtualInterfaceRequest {
        connectionId: ConnectionId;
        ownerAccount: OwnerAccount;
        newPublicVirtualInterfaceAllocation: NewPublicVirtualInterfaceAllocation;
    }
    export interface ConfirmConnectionRequest {
        connectionId: ConnectionId;
    }
    export interface ConfirmConnectionResponse {
        connectionState?: ConnectionState;
    }
    export interface ConfirmPrivateVirtualInterfaceRequest {
        virtualInterfaceId: VirtualInterfaceId;
        virtualGatewayId: VirtualGatewayId;
    }
    export interface ConfirmPrivateVirtualInterfaceResponse {
        virtualInterfaceState?: VirtualInterfaceState;
    }
    export interface ConfirmPublicVirtualInterfaceRequest {
        virtualInterfaceId: VirtualInterfaceId;
    }
    export interface ConfirmPublicVirtualInterfaceResponse {
        virtualInterfaceState?: VirtualInterfaceState;
    }
    export interface Connection {
        ownerAccount?: OwnerAccount;
        connectionId?: ConnectionId;
        connectionName?: ConnectionName;
        connectionState?: ConnectionState;
        region?: Region;
        location?: LocationCode;
        bandwidth?: Bandwidth;
        vlan?: VLAN;
        partnerName?: PartnerName;
    }
    export interface Connections {
        connections?: ConnectionList;
    }
    export interface CreateConnectionRequest {
        location: LocationCode;
        bandwidth: Bandwidth;
        connectionName: ConnectionName;
    }
    export interface CreateInterconnectRequest {
        interconnectName: InterconnectName;
        bandwidth: Bandwidth;
        location: LocationCode;
    }
    export interface CreatePrivateVirtualInterfaceRequest {
        connectionId: ConnectionId;
        newPrivateVirtualInterface: NewPrivateVirtualInterface;
    }
    export interface CreatePublicVirtualInterfaceRequest {
        connectionId: ConnectionId;
        newPublicVirtualInterface: NewPublicVirtualInterface;
    }
    export interface DeleteConnectionRequest {
        connectionId: ConnectionId;
    }
    export interface DeleteInterconnectRequest {
        interconnectId: InterconnectId;
    }
    export interface DeleteInterconnectResponse {
        interconnectState?: InterconnectState;
    }
    export interface DeleteVirtualInterfaceRequest {
        virtualInterfaceId: VirtualInterfaceId;
    }
    export interface DeleteVirtualInterfaceResponse {
        virtualInterfaceState?: VirtualInterfaceState;
    }
    export interface DescribeConnectionsOnInterconnectRequest {
        interconnectId: InterconnectId;
    }
    export interface DescribeConnectionsRequest {
        connectionId?: ConnectionId;
    }
    export interface DescribeInterconnectsRequest {
        interconnectId?: InterconnectId;
    }
    export interface DescribeVirtualInterfacesRequest {
        connectionId?: ConnectionId;
        virtualInterfaceId?: VirtualInterfaceId;
    }
    export interface DirectConnectClientException {
        message?: ErrorMessage;
    }
    export interface DirectConnectServerException {
        message?: ErrorMessage;
    }
    export interface Interconnect {
        interconnectId?: InterconnectId;
        interconnectName?: InterconnectName;
        interconnectState?: InterconnectState;
        region?: Region;
        location?: LocationCode;
        bandwidth?: Bandwidth;
    }
    export interface Interconnects {
        interconnects?: InterconnectList;
    }
    export interface Location {
        locationCode?: LocationCode;
        locationName?: LocationName;
    }
    export interface Locations {
        locations?: LocationList;
    }
    export interface NewPrivateVirtualInterface {
        virtualInterfaceName: VirtualInterfaceName;
        vlan: VLAN;
        asn: ASN;
        authKey?: BGPAuthKey;
        amazonAddress?: AmazonAddress;
        customerAddress?: CustomerAddress;
        virtualGatewayId: VirtualGatewayId;
    }
    export interface NewPrivateVirtualInterfaceAllocation {
        virtualInterfaceName: VirtualInterfaceName;
        vlan: VLAN;
        asn: ASN;
        authKey?: BGPAuthKey;
        amazonAddress?: AmazonAddress;
        customerAddress?: CustomerAddress;
    }
    export interface NewPublicVirtualInterface {
        virtualInterfaceName: VirtualInterfaceName;
        vlan: VLAN;
        asn: ASN;
        authKey?: BGPAuthKey;
        amazonAddress: AmazonAddress;
        customerAddress: CustomerAddress;
        routeFilterPrefixes: RouteFilterPrefixList;
    }
    export interface NewPublicVirtualInterfaceAllocation {
        virtualInterfaceName: VirtualInterfaceName;
        vlan: VLAN;
        asn: ASN;
        authKey?: BGPAuthKey;
        amazonAddress: AmazonAddress;
        customerAddress: CustomerAddress;
        routeFilterPrefixes: RouteFilterPrefixList;
    }
    export interface RouteFilterPrefix {
        cidr?: CIDR;
    }
    export interface VirtualGateway {
        virtualGatewayId?: VirtualGatewayId;
        virtualGatewayState?: VirtualGatewayState;
    }
    export interface VirtualGateways {
        virtualGateways?: VirtualGatewayList;
    }
    export interface VirtualInterface {
        ownerAccount?: OwnerAccount;
        virtualInterfaceId?: VirtualInterfaceId;
        location?: LocationCode;
        connectionId?: ConnectionId;
        virtualInterfaceType?: VirtualInterfaceType;
        virtualInterfaceName?: VirtualInterfaceName;
        vlan?: VLAN;
        asn?: ASN;
        authKey?: BGPAuthKey;
        amazonAddress?: AmazonAddress;
        customerAddress?: CustomerAddress;
        virtualInterfaceState?: VirtualInterfaceState;
        customerRouterConfig?: RouterConfig;
        virtualGatewayId?: VirtualGatewayId;
        routeFilterPrefixes?: RouteFilterPrefixList;
    }
    export interface VirtualInterfaces {
        virtualInterfaces?: VirtualInterfaceList;
    }
  }

  /*
   * apiVersion: 2015-04-16
   * endpointPrefix: ds
   * serviceAbbreviation: Directory Service
   * signatureVersion: v4
   * protocol: json
   */
  export class DirectoryService extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    connectDirectory(params: DirectoryService.ConnectDirectoryRequest, callback?: (err: DirectoryService.DirectoryLimitExceededException|DirectoryService.InvalidParameterException|DirectoryService.ClientException|DirectoryService.ServiceException|any, data: DirectoryService.ConnectDirectoryResult|any) => void): Request;
    createAlias(params: DirectoryService.CreateAliasRequest, callback?: (err: DirectoryService.EntityAlreadyExistsException|DirectoryService.EntityDoesNotExistException|DirectoryService.InvalidParameterException|DirectoryService.ClientException|DirectoryService.ServiceException|any, data: DirectoryService.CreateAliasResult|any) => void): Request;
    createComputer(params: DirectoryService.CreateComputerRequest, callback?: (err: DirectoryService.AuthenticationFailedException|DirectoryService.DirectoryUnavailableException|DirectoryService.EntityAlreadyExistsException|DirectoryService.EntityDoesNotExistException|DirectoryService.InvalidParameterException|DirectoryService.UnsupportedOperationException|DirectoryService.ClientException|DirectoryService.ServiceException|any, data: DirectoryService.CreateComputerResult|any) => void): Request;
    createDirectory(params: DirectoryService.CreateDirectoryRequest, callback?: (err: DirectoryService.DirectoryLimitExceededException|DirectoryService.InvalidParameterException|DirectoryService.ClientException|DirectoryService.ServiceException|any, data: DirectoryService.CreateDirectoryResult|any) => void): Request;
    createMicrosoftAD(params: DirectoryService.CreateMicrosoftADRequest, callback?: (err: DirectoryService.DirectoryLimitExceededException|DirectoryService.InvalidParameterException|DirectoryService.ClientException|DirectoryService.ServiceException|DirectoryService.UnsupportedOperationException|any, data: DirectoryService.CreateMicrosoftADResult|any) => void): Request;
    createSnapshot(params: DirectoryService.CreateSnapshotRequest, callback?: (err: DirectoryService.EntityDoesNotExistException|DirectoryService.InvalidParameterException|DirectoryService.SnapshotLimitExceededException|DirectoryService.ClientException|DirectoryService.ServiceException|any, data: DirectoryService.CreateSnapshotResult|any) => void): Request;
    createTrust(params: DirectoryService.CreateTrustRequest, callback?: (err: DirectoryService.EntityAlreadyExistsException|DirectoryService.EntityDoesNotExistException|DirectoryService.InvalidParameterException|DirectoryService.ClientException|DirectoryService.ServiceException|DirectoryService.UnsupportedOperationException|any, data: DirectoryService.CreateTrustResult|any) => void): Request;
    deleteDirectory(params: DirectoryService.DeleteDirectoryRequest, callback?: (err: DirectoryService.EntityDoesNotExistException|DirectoryService.ClientException|DirectoryService.ServiceException|any, data: DirectoryService.DeleteDirectoryResult|any) => void): Request;
    deleteSnapshot(params: DirectoryService.DeleteSnapshotRequest, callback?: (err: DirectoryService.EntityDoesNotExistException|DirectoryService.InvalidParameterException|DirectoryService.ClientException|DirectoryService.ServiceException|any, data: DirectoryService.DeleteSnapshotResult|any) => void): Request;
    deleteTrust(params: DirectoryService.DeleteTrustRequest, callback?: (err: DirectoryService.EntityDoesNotExistException|DirectoryService.InvalidParameterException|DirectoryService.ClientException|DirectoryService.ServiceException|DirectoryService.UnsupportedOperationException|any, data: DirectoryService.DeleteTrustResult|any) => void): Request;
    deregisterEventTopic(params: DirectoryService.DeregisterEventTopicRequest, callback?: (err: DirectoryService.EntityDoesNotExistException|DirectoryService.InvalidParameterException|DirectoryService.ClientException|DirectoryService.ServiceException|any, data: DirectoryService.DeregisterEventTopicResult|any) => void): Request;
    describeDirectories(params: DirectoryService.DescribeDirectoriesRequest, callback?: (err: DirectoryService.EntityDoesNotExistException|DirectoryService.InvalidParameterException|DirectoryService.InvalidNextTokenException|DirectoryService.ClientException|DirectoryService.ServiceException|any, data: DirectoryService.DescribeDirectoriesResult|any) => void): Request;
    describeEventTopics(params: DirectoryService.DescribeEventTopicsRequest, callback?: (err: DirectoryService.EntityDoesNotExistException|DirectoryService.InvalidParameterException|DirectoryService.ClientException|DirectoryService.ServiceException|any, data: DirectoryService.DescribeEventTopicsResult|any) => void): Request;
    describeSnapshots(params: DirectoryService.DescribeSnapshotsRequest, callback?: (err: DirectoryService.EntityDoesNotExistException|DirectoryService.InvalidParameterException|DirectoryService.InvalidNextTokenException|DirectoryService.ClientException|DirectoryService.ServiceException|any, data: DirectoryService.DescribeSnapshotsResult|any) => void): Request;
    describeTrusts(params: DirectoryService.DescribeTrustsRequest, callback?: (err: DirectoryService.EntityDoesNotExistException|DirectoryService.InvalidNextTokenException|DirectoryService.InvalidParameterException|DirectoryService.ClientException|DirectoryService.ServiceException|DirectoryService.UnsupportedOperationException|any, data: DirectoryService.DescribeTrustsResult|any) => void): Request;
    disableRadius(params: DirectoryService.DisableRadiusRequest, callback?: (err: DirectoryService.EntityDoesNotExistException|DirectoryService.ClientException|DirectoryService.ServiceException|any, data: DirectoryService.DisableRadiusResult|any) => void): Request;
    disableSso(params: DirectoryService.DisableSsoRequest, callback?: (err: DirectoryService.EntityDoesNotExistException|DirectoryService.InsufficientPermissionsException|DirectoryService.AuthenticationFailedException|DirectoryService.ClientException|DirectoryService.ServiceException|any, data: DirectoryService.DisableSsoResult|any) => void): Request;
    enableRadius(params: DirectoryService.EnableRadiusRequest, callback?: (err: DirectoryService.InvalidParameterException|DirectoryService.EntityAlreadyExistsException|DirectoryService.EntityDoesNotExistException|DirectoryService.ClientException|DirectoryService.ServiceException|any, data: DirectoryService.EnableRadiusResult|any) => void): Request;
    enableSso(params: DirectoryService.EnableSsoRequest, callback?: (err: DirectoryService.EntityDoesNotExistException|DirectoryService.InsufficientPermissionsException|DirectoryService.AuthenticationFailedException|DirectoryService.ClientException|DirectoryService.ServiceException|any, data: DirectoryService.EnableSsoResult|any) => void): Request;
    getDirectoryLimits(params: DirectoryService.GetDirectoryLimitsRequest, callback?: (err: DirectoryService.EntityDoesNotExistException|DirectoryService.ClientException|DirectoryService.ServiceException|any, data: DirectoryService.GetDirectoryLimitsResult|any) => void): Request;
    getSnapshotLimits(params: DirectoryService.GetSnapshotLimitsRequest, callback?: (err: DirectoryService.EntityDoesNotExistException|DirectoryService.ClientException|DirectoryService.ServiceException|any, data: DirectoryService.GetSnapshotLimitsResult|any) => void): Request;
    registerEventTopic(params: DirectoryService.RegisterEventTopicRequest, callback?: (err: DirectoryService.EntityDoesNotExistException|DirectoryService.InvalidParameterException|DirectoryService.ClientException|DirectoryService.ServiceException|any, data: DirectoryService.RegisterEventTopicResult|any) => void): Request;
    restoreFromSnapshot(params: DirectoryService.RestoreFromSnapshotRequest, callback?: (err: DirectoryService.EntityDoesNotExistException|DirectoryService.InvalidParameterException|DirectoryService.ClientException|DirectoryService.ServiceException|any, data: DirectoryService.RestoreFromSnapshotResult|any) => void): Request;
    updateRadius(params: DirectoryService.UpdateRadiusRequest, callback?: (err: DirectoryService.InvalidParameterException|DirectoryService.EntityDoesNotExistException|DirectoryService.ClientException|DirectoryService.ServiceException|any, data: DirectoryService.UpdateRadiusResult|any) => void): Request;
    verifyTrust(params: DirectoryService.VerifyTrustRequest, callback?: (err: DirectoryService.EntityDoesNotExistException|DirectoryService.InvalidParameterException|DirectoryService.ClientException|DirectoryService.ServiceException|DirectoryService.UnsupportedOperationException|any, data: DirectoryService.VerifyTrustResult|any) => void): Request;

  }

  export module DirectoryService {
    export type AccessUrl = string;    // max: 128, min: 1
    export type AliasName = string;    // pattern: &quot;^(?!d-)([\da-zA-Z]+)([-]*[\da-zA-Z])*&quot;, max: 62, min: 1
    export type AttributeName = string;    // min: 1
    export type AttributeValue = string;
    export type Attributes = Attribute[];
    export type AvailabilityZone = string;
    export type AvailabilityZones = AvailabilityZone[];
    export type CloudOnlyDirectoriesLimitReached = boolean;
    export type ComputerName = string;    // max: 15, min: 1
    export type ComputerPassword = string;    // pattern: &quot;[\u0020-\u00FF]+&quot;, max: 64, min: 8
    export type ConnectPassword = string;    // max: 128, min: 1
    export type ConnectedDirectoriesLimitReached = boolean;
    export type CreatedDateTime = number;
    export type Description = string;    // pattern: &quot;^([a-zA-Z0-9_])[\\a-zA-Z0-9_@#%*+=:?./!\s-]*$&quot;, max: 128
    export type DirectoryDescriptions = DirectoryDescription[];
    export type DirectoryId = string;    // pattern: &quot;^d-[0-9a-f]{10}$&quot;
    export type DirectoryIds = DirectoryId[];
    export type DirectoryName = string;    // pattern: &quot;^([a-zA-Z0-9]+[\\.-])+([a-zA-Z0-9])+$&quot;
    export type DirectoryShortName = string;    // pattern: &quot;^[^\\/:*?\&quot;\&lt;\&gt;|.]+[^\\/:*?\&quot;&lt;&gt;|]*$&quot;
    export type DirectorySize = string;
    export type DirectoryStage = string;
    export type DirectoryType = string;
    export type DnsIpAddrs = IpAddr[];
    export type EventTopics = EventTopic[];
    export type ExceptionMessage = string;
    export type IpAddr = string;    // pattern: &quot;^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$&quot;
    export type IpAddrs = IpAddr[];
    export type LastUpdatedDateTime = number;
    export type LaunchTime = number;
    export type Limit = number;
    export type ManualSnapshotsLimitReached = boolean;
    export type NextToken = string;
    export type OrganizationalUnitDN = string;    // max: 2000, min: 1
    export type Password = string;    // pattern: &quot;(?=^.{8,64}$)((?=.*\d)(?=.*[A-Z])(?=.*[a-z])|(?=.*\d)(?=.*[^A-Za-z0-9\s])(?=.*[a-z])|(?=.*[^A-Za-z0-9\s])(?=.*[A-Z])(?=.*[a-z])|(?=.*\d)(?=.*[A-Z])(?=.*[^A-Za-z0-9\s]))^.*&quot;
    export type PortNumber = number;    // max: 65535, min: 1025
    export type RadiusAuthenticationProtocol = string;
    export type RadiusDisplayLabel = string;    // max: 64, min: 1
    export type RadiusRetries = number;    // max: 10
    export type RadiusSharedSecret = string;    // max: 512, min: 8
    export type RadiusStatus = string;
    export type RadiusTimeout = number;    // max: 20, min: 1
    export type RemoteDomainName = string;    // pattern: &quot;^([a-zA-Z0-9]+[\\.-])+([a-zA-Z0-9])+[.]?$&quot;
    export type RequestId = string;    // pattern: &quot;^([A-Fa-f0-9]{8}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{12})$&quot;
    export type SID = string;    // pattern: &quot;[&amp;\w+-.@]+&quot;, max: 256, min: 1
    export type SecurityGroupId = string;    // pattern: &quot;^(sg-[0-9a-f]{8})$&quot;
    export type Server = string;    // max: 256, min: 1
    export type Servers = Server[];
    export type SnapshotId = string;    // pattern: &quot;^s-[0-9a-f]{10}$&quot;
    export type SnapshotIds = SnapshotId[];
    export type SnapshotName = string;    // pattern: &quot;^([a-zA-Z0-9_])[\\a-zA-Z0-9_@#%*+=:?./!\s-]*$&quot;, max: 128
    export type SnapshotStatus = string;
    export type SnapshotType = string;
    export type Snapshots = Snapshot[];
    export type SsoEnabled = boolean;
    export type StageReason = string;
    export type StartTime = number;
    export type StateLastUpdatedDateTime = number;
    export type SubnetId = string;    // pattern: &quot;^(subnet-[0-9a-f]{8})$&quot;
    export type SubnetIds = SubnetId[];
    export type TopicArn = string;
    export type TopicName = string;    // pattern: &quot;[a-zA-Z0-9_-]+&quot;, max: 256, min: 1
    export type TopicNames = TopicName[];
    export type TopicStatus = string;
    export type TrustDirection = string;
    export type TrustId = string;    // pattern: &quot;^t-[0-9a-f]{10}$&quot;
    export type TrustIds = TrustId[];
    export type TrustPassword = string;    // max: 128, min: 1
    export type TrustState = string;
    export type TrustType = string;
    export type Trusts = Trust[];
    export type UseSameUsername = boolean;
    export type UserName = string;    // pattern: &quot;[a-zA-Z0-9._-]+&quot;, min: 1
    export type VpcId = string;    // pattern: &quot;^(vpc-[0-9a-f]{8})$&quot;

    export interface Attribute {
        Name?: AttributeName;
        Value?: AttributeValue;
    }
    export interface AuthenticationFailedException {
        Message?: ExceptionMessage;
        RequestId?: RequestId;
    }
    export interface ClientException {
        Message?: ExceptionMessage;
        RequestId?: RequestId;
    }
    export interface Computer {
        ComputerId?: SID;
        ComputerName?: ComputerName;
        ComputerAttributes?: Attributes;
    }
    export interface ConnectDirectoryRequest {
        Name: DirectoryName;
        ShortName?: DirectoryShortName;
        Password: ConnectPassword;
        Description?: Description;
        Size: DirectorySize;
        ConnectSettings: DirectoryConnectSettings;
    }
    export interface ConnectDirectoryResult {
        DirectoryId?: DirectoryId;
    }
    export interface CreateAliasRequest {
        DirectoryId: DirectoryId;
        Alias: AliasName;
    }
    export interface CreateAliasResult {
        DirectoryId?: DirectoryId;
        Alias?: AliasName;
    }
    export interface CreateComputerRequest {
        DirectoryId: DirectoryId;
        ComputerName: ComputerName;
        Password: ComputerPassword;
        OrganizationalUnitDistinguishedName?: OrganizationalUnitDN;
        ComputerAttributes?: Attributes;
    }
    export interface CreateComputerResult {
        Computer?: Computer;
    }
    export interface CreateDirectoryRequest {
        Name: DirectoryName;
        ShortName?: DirectoryShortName;
        Password: Password;
        Description?: Description;
        Size: DirectorySize;
        VpcSettings?: DirectoryVpcSettings;
    }
    export interface CreateDirectoryResult {
        DirectoryId?: DirectoryId;
    }
    export interface CreateMicrosoftADRequest {
        Name: DirectoryName;
        ShortName?: DirectoryShortName;
        Password: Password;
        Description?: Description;
        VpcSettings: DirectoryVpcSettings;
    }
    export interface CreateMicrosoftADResult {
        DirectoryId?: DirectoryId;
    }
    export interface CreateSnapshotRequest {
        DirectoryId: DirectoryId;
        Name?: SnapshotName;
    }
    export interface CreateSnapshotResult {
        SnapshotId?: SnapshotId;
    }
    export interface CreateTrustRequest {
        DirectoryId: DirectoryId;
        RemoteDomainName: RemoteDomainName;
        TrustPassword: TrustPassword;
        TrustDirection: TrustDirection;
        TrustType?: TrustType;
    }
    export interface CreateTrustResult {
        TrustId?: TrustId;
    }
    export interface DeleteDirectoryRequest {
        DirectoryId: DirectoryId;
    }
    export interface DeleteDirectoryResult {
        DirectoryId?: DirectoryId;
    }
    export interface DeleteSnapshotRequest {
        SnapshotId: SnapshotId;
    }
    export interface DeleteSnapshotResult {
        SnapshotId?: SnapshotId;
    }
    export interface DeleteTrustRequest {
        TrustId: TrustId;
    }
    export interface DeleteTrustResult {
        TrustId?: TrustId;
    }
    export interface DeregisterEventTopicRequest {
        DirectoryId: DirectoryId;
        TopicName: TopicName;
    }
    export interface DeregisterEventTopicResult {
    }
    export interface DescribeDirectoriesRequest {
        DirectoryIds?: DirectoryIds;
        NextToken?: NextToken;
        Limit?: Limit;
    }
    export interface DescribeDirectoriesResult {
        DirectoryDescriptions?: DirectoryDescriptions;
        NextToken?: NextToken;
    }
    export interface DescribeEventTopicsRequest {
        DirectoryId?: DirectoryId;
        TopicNames?: TopicNames;
    }
    export interface DescribeEventTopicsResult {
        EventTopics?: EventTopics;
    }
    export interface DescribeSnapshotsRequest {
        DirectoryId?: DirectoryId;
        SnapshotIds?: SnapshotIds;
        NextToken?: NextToken;
        Limit?: Limit;
    }
    export interface DescribeSnapshotsResult {
        Snapshots?: Snapshots;
        NextToken?: NextToken;
    }
    export interface DescribeTrustsRequest {
        DirectoryId?: DirectoryId;
        TrustIds?: TrustIds;
        NextToken?: NextToken;
        Limit?: Limit;
    }
    export interface DescribeTrustsResult {
        Trusts?: Trusts;
        NextToken?: NextToken;
    }
    export interface DirectoryConnectSettings {
        VpcId: VpcId;
        SubnetIds: SubnetIds;
        CustomerDnsIps: DnsIpAddrs;
        CustomerUserName: UserName;
    }
    export interface DirectoryConnectSettingsDescription {
        VpcId?: VpcId;
        SubnetIds?: SubnetIds;
        CustomerUserName?: UserName;
        SecurityGroupId?: SecurityGroupId;
        AvailabilityZones?: AvailabilityZones;
        ConnectIps?: IpAddrs;
    }
    export interface DirectoryDescription {
        DirectoryId?: DirectoryId;
        Name?: DirectoryName;
        ShortName?: DirectoryShortName;
        Size?: DirectorySize;
        Alias?: AliasName;
        AccessUrl?: AccessUrl;
        Description?: Description;
        DnsIpAddrs?: DnsIpAddrs;
        Stage?: DirectoryStage;
        LaunchTime?: LaunchTime;
        StageLastUpdatedDateTime?: LastUpdatedDateTime;
        Type?: DirectoryType;
        VpcSettings?: DirectoryVpcSettingsDescription;
        ConnectSettings?: DirectoryConnectSettingsDescription;
        RadiusSettings?: RadiusSettings;
        RadiusStatus?: RadiusStatus;
        StageReason?: StageReason;
        SsoEnabled?: SsoEnabled;
    }
    export interface DirectoryLimitExceededException {
        Message?: ExceptionMessage;
        RequestId?: RequestId;
    }
    export interface DirectoryLimits {
        CloudOnlyDirectoriesLimit?: Limit;
        CloudOnlyDirectoriesCurrentCount?: Limit;
        CloudOnlyDirectoriesLimitReached?: CloudOnlyDirectoriesLimitReached;
        CloudOnlyMicrosoftADLimit?: Limit;
        CloudOnlyMicrosoftADCurrentCount?: Limit;
        CloudOnlyMicrosoftADLimitReached?: CloudOnlyDirectoriesLimitReached;
        ConnectedDirectoriesLimit?: Limit;
        ConnectedDirectoriesCurrentCount?: Limit;
        ConnectedDirectoriesLimitReached?: ConnectedDirectoriesLimitReached;
    }
    export interface DirectoryUnavailableException {
        Message?: ExceptionMessage;
        RequestId?: RequestId;
    }
    export interface DirectoryVpcSettings {
        VpcId: VpcId;
        SubnetIds: SubnetIds;
    }
    export interface DirectoryVpcSettingsDescription {
        VpcId?: VpcId;
        SubnetIds?: SubnetIds;
        SecurityGroupId?: SecurityGroupId;
        AvailabilityZones?: AvailabilityZones;
    }
    export interface DisableRadiusRequest {
        DirectoryId: DirectoryId;
    }
    export interface DisableRadiusResult {
    }
    export interface DisableSsoRequest {
        DirectoryId: DirectoryId;
        UserName?: UserName;
        Password?: ConnectPassword;
    }
    export interface DisableSsoResult {
    }
    export interface EnableRadiusRequest {
        DirectoryId: DirectoryId;
        RadiusSettings: RadiusSettings;
    }
    export interface EnableRadiusResult {
    }
    export interface EnableSsoRequest {
        DirectoryId: DirectoryId;
        UserName?: UserName;
        Password?: ConnectPassword;
    }
    export interface EnableSsoResult {
    }
    export interface EntityAlreadyExistsException {
        Message?: ExceptionMessage;
        RequestId?: RequestId;
    }
    export interface EntityDoesNotExistException {
        Message?: ExceptionMessage;
        RequestId?: RequestId;
    }
    export interface EventTopic {
        DirectoryId?: DirectoryId;
        TopicName?: TopicName;
        TopicArn?: TopicArn;
        CreatedDateTime?: CreatedDateTime;
        Status?: TopicStatus;
    }
    export interface GetDirectoryLimitsRequest {
    }
    export interface GetDirectoryLimitsResult {
        DirectoryLimits?: DirectoryLimits;
    }
    export interface GetSnapshotLimitsRequest {
        DirectoryId: DirectoryId;
    }
    export interface GetSnapshotLimitsResult {
        SnapshotLimits?: SnapshotLimits;
    }
    export interface InsufficientPermissionsException {
        Message?: ExceptionMessage;
        RequestId?: RequestId;
    }
    export interface InvalidNextTokenException {
        Message?: ExceptionMessage;
        RequestId?: RequestId;
    }
    export interface InvalidParameterException {
        Message?: ExceptionMessage;
        RequestId?: RequestId;
    }
    export interface RadiusSettings {
        RadiusServers?: Servers;
        RadiusPort?: PortNumber;
        RadiusTimeout?: RadiusTimeout;
        RadiusRetries?: RadiusRetries;
        SharedSecret?: RadiusSharedSecret;
        AuthenticationProtocol?: RadiusAuthenticationProtocol;
        DisplayLabel?: RadiusDisplayLabel;
        UseSameUsername?: UseSameUsername;
    }
    export interface RegisterEventTopicRequest {
        DirectoryId: DirectoryId;
        TopicName: TopicName;
    }
    export interface RegisterEventTopicResult {
    }
    export interface RestoreFromSnapshotRequest {
        SnapshotId: SnapshotId;
    }
    export interface RestoreFromSnapshotResult {
    }
    export interface ServiceException {
        Message?: ExceptionMessage;
        RequestId?: RequestId;
    }
    export interface Snapshot {
        DirectoryId?: DirectoryId;
        SnapshotId?: SnapshotId;
        Type?: SnapshotType;
        Name?: SnapshotName;
        Status?: SnapshotStatus;
        StartTime?: StartTime;
    }
    export interface SnapshotLimitExceededException {
        Message?: ExceptionMessage;
        RequestId?: RequestId;
    }
    export interface SnapshotLimits {
        ManualSnapshotsLimit?: Limit;
        ManualSnapshotsCurrentCount?: Limit;
        ManualSnapshotsLimitReached?: ManualSnapshotsLimitReached;
    }
    export interface Trust {
        DirectoryId?: DirectoryId;
        TrustId?: TrustId;
        RemoteDomainName?: RemoteDomainName;
        TrustType?: TrustType;
        TrustDirection?: TrustDirection;
        TrustState?: TrustState;
        CreatedDateTime?: CreatedDateTime;
        LastUpdatedDateTime?: LastUpdatedDateTime;
        StateLastUpdatedDateTime?: StateLastUpdatedDateTime;
    }
    export interface UnsupportedOperationException {
        Message?: ExceptionMessage;
        RequestId?: RequestId;
    }
    export interface UpdateRadiusRequest {
        DirectoryId: DirectoryId;
        RadiusSettings: RadiusSettings;
    }
    export interface UpdateRadiusResult {
    }
    export interface VerifyTrustRequest {
        TrustId: TrustId;
    }
    export interface VerifyTrustResult {
        TrustId?: TrustId;
    }
  }

  /*
   * apiVersion: 2016-01-01
   * endpointPrefix: dms
   * serviceAbbreviation: 
   * signatureVersion: v4
   * protocol: json
   */
  export class DMS extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    addTagsToResource(params: DMS.AddTagsToResourceMessage, callback?: (err: DMS.ResourceNotFoundFault|any, data: DMS.AddTagsToResourceResponse|any) => void): Request;
    createEndpoint(params: DMS.CreateEndpointMessage, callback?: (err: DMS.KMSKeyNotAccessibleFault|DMS.ResourceAlreadyExistsFault|DMS.ResourceQuotaExceededFault|any, data: DMS.CreateEndpointResponse|any) => void): Request;
    createReplicationInstance(params: DMS.CreateReplicationInstanceMessage, callback?: (err: DMS.AccessDeniedFault|DMS.ResourceAlreadyExistsFault|DMS.InsufficientResourceCapacityFault|DMS.ResourceQuotaExceededFault|DMS.StorageQuotaExceededFault|DMS.ResourceNotFoundFault|DMS.ReplicationSubnetGroupDoesNotCoverEnoughAZs|DMS.InvalidResourceStateFault|DMS.InvalidSubnet|DMS.KMSKeyNotAccessibleFault|any, data: DMS.CreateReplicationInstanceResponse|any) => void): Request;
    createReplicationSubnetGroup(params: DMS.CreateReplicationSubnetGroupMessage, callback?: (err: DMS.AccessDeniedFault|DMS.ResourceAlreadyExistsFault|DMS.ResourceNotFoundFault|DMS.ResourceQuotaExceededFault|DMS.ReplicationSubnetGroupDoesNotCoverEnoughAZs|DMS.InvalidSubnet|any, data: DMS.CreateReplicationSubnetGroupResponse|any) => void): Request;
    createReplicationTask(params: DMS.CreateReplicationTaskMessage, callback?: (err: DMS.InvalidResourceStateFault|DMS.ResourceAlreadyExistsFault|DMS.ResourceNotFoundFault|DMS.KMSKeyNotAccessibleFault|DMS.ResourceQuotaExceededFault|any, data: DMS.CreateReplicationTaskResponse|any) => void): Request;
    deleteEndpoint(params: DMS.DeleteEndpointMessage, callback?: (err: DMS.ResourceNotFoundFault|DMS.InvalidResourceStateFault|any, data: DMS.DeleteEndpointResponse|any) => void): Request;
    deleteReplicationInstance(params: DMS.DeleteReplicationInstanceMessage, callback?: (err: DMS.InvalidResourceStateFault|DMS.ResourceNotFoundFault|any, data: DMS.DeleteReplicationInstanceResponse|any) => void): Request;
    deleteReplicationSubnetGroup(params: DMS.DeleteReplicationSubnetGroupMessage, callback?: (err: DMS.InvalidResourceStateFault|DMS.ResourceNotFoundFault|any, data: DMS.DeleteReplicationSubnetGroupResponse|any) => void): Request;
    deleteReplicationTask(params: DMS.DeleteReplicationTaskMessage, callback?: (err: DMS.ResourceNotFoundFault|DMS.InvalidResourceStateFault|any, data: DMS.DeleteReplicationTaskResponse|any) => void): Request;
    describeAccountAttributes(params: DMS.DescribeAccountAttributesMessage, callback?: (err: any, data: DMS.DescribeAccountAttributesResponse|any) => void): Request;
    describeConnections(params: DMS.DescribeConnectionsMessage, callback?: (err: DMS.ResourceNotFoundFault|any, data: DMS.DescribeConnectionsResponse|any) => void): Request;
    describeEndpointTypes(params: DMS.DescribeEndpointTypesMessage, callback?: (err: any, data: DMS.DescribeEndpointTypesResponse|any) => void): Request;
    describeEndpoints(params: DMS.DescribeEndpointsMessage, callback?: (err: DMS.ResourceNotFoundFault|any, data: DMS.DescribeEndpointsResponse|any) => void): Request;
    describeOrderableReplicationInstances(params: DMS.DescribeOrderableReplicationInstancesMessage, callback?: (err: any, data: DMS.DescribeOrderableReplicationInstancesResponse|any) => void): Request;
    describeRefreshSchemasStatus(params: DMS.DescribeRefreshSchemasStatusMessage, callback?: (err: DMS.InvalidResourceStateFault|DMS.ResourceNotFoundFault|any, data: DMS.DescribeRefreshSchemasStatusResponse|any) => void): Request;
    describeReplicationInstances(params: DMS.DescribeReplicationInstancesMessage, callback?: (err: DMS.ResourceNotFoundFault|any, data: DMS.DescribeReplicationInstancesResponse|any) => void): Request;
    describeReplicationSubnetGroups(params: DMS.DescribeReplicationSubnetGroupsMessage, callback?: (err: DMS.ResourceNotFoundFault|any, data: DMS.DescribeReplicationSubnetGroupsResponse|any) => void): Request;
    describeReplicationTasks(params: DMS.DescribeReplicationTasksMessage, callback?: (err: DMS.ResourceNotFoundFault|any, data: DMS.DescribeReplicationTasksResponse|any) => void): Request;
    describeSchemas(params: DMS.DescribeSchemasMessage, callback?: (err: DMS.InvalidResourceStateFault|DMS.ResourceNotFoundFault|any, data: DMS.DescribeSchemasResponse|any) => void): Request;
    describeTableStatistics(params: DMS.DescribeTableStatisticsMessage, callback?: (err: DMS.ResourceNotFoundFault|DMS.InvalidResourceStateFault|any, data: DMS.DescribeTableStatisticsResponse|any) => void): Request;
    listTagsForResource(params: DMS.ListTagsForResourceMessage, callback?: (err: DMS.ResourceNotFoundFault|any, data: DMS.ListTagsForResourceResponse|any) => void): Request;
    modifyEndpoint(params: DMS.ModifyEndpointMessage, callback?: (err: DMS.InvalidResourceStateFault|DMS.ResourceNotFoundFault|DMS.ResourceAlreadyExistsFault|DMS.KMSKeyNotAccessibleFault|any, data: DMS.ModifyEndpointResponse|any) => void): Request;
    modifyReplicationInstance(params: DMS.ModifyReplicationInstanceMessage, callback?: (err: DMS.InvalidResourceStateFault|DMS.ResourceAlreadyExistsFault|DMS.ResourceNotFoundFault|DMS.InsufficientResourceCapacityFault|DMS.StorageQuotaExceededFault|DMS.UpgradeDependencyFailureFault|any, data: DMS.ModifyReplicationInstanceResponse|any) => void): Request;
    modifyReplicationSubnetGroup(params: DMS.ModifyReplicationSubnetGroupMessage, callback?: (err: DMS.ResourceNotFoundFault|DMS.ResourceQuotaExceededFault|DMS.SubnetAlreadyInUse|DMS.ReplicationSubnetGroupDoesNotCoverEnoughAZs|DMS.InvalidSubnet|any, data: DMS.ModifyReplicationSubnetGroupResponse|any) => void): Request;
    refreshSchemas(params: DMS.RefreshSchemasMessage, callback?: (err: DMS.InvalidResourceStateFault|DMS.ResourceNotFoundFault|DMS.KMSKeyNotAccessibleFault|DMS.ResourceQuotaExceededFault|any, data: DMS.RefreshSchemasResponse|any) => void): Request;
    removeTagsFromResource(params: DMS.RemoveTagsFromResourceMessage, callback?: (err: DMS.ResourceNotFoundFault|any, data: DMS.RemoveTagsFromResourceResponse|any) => void): Request;
    startReplicationTask(params: DMS.StartReplicationTaskMessage, callback?: (err: DMS.ResourceNotFoundFault|DMS.InvalidResourceStateFault|any, data: DMS.StartReplicationTaskResponse|any) => void): Request;
    stopReplicationTask(params: DMS.StopReplicationTaskMessage, callback?: (err: DMS.ResourceNotFoundFault|DMS.InvalidResourceStateFault|any, data: DMS.StopReplicationTaskResponse|any) => void): Request;
    testConnection(params: DMS.TestConnectionMessage, callback?: (err: DMS.ResourceNotFoundFault|DMS.InvalidResourceStateFault|DMS.KMSKeyNotAccessibleFault|DMS.ResourceQuotaExceededFault|any, data: DMS.TestConnectionResponse|any) => void): Request;

  }

  export module DMS {
    export type AccountQuotaList = AccountQuota[];
    export type Boolean = boolean;
    export type BooleanOptional = boolean;
    export type ConnectionList = Connection[];
    export type EndpointList = Endpoint[];
    export type ExceptionMessage = string;
    export type FilterList = Filter[];
    export type FilterValueList = String[];
    export type Integer = number;
    export type IntegerOptional = number;
    export type KeyList = String[];
    export type Long = number;
    export type MigrationTypeValue = string;
    export type OrderableReplicationInstanceList = OrderableReplicationInstance[];
    export type RefreshSchemasStatusTypeValue = string;
    export type ReplicationEndpointTypeValue = string;
    export type ReplicationInstanceList = ReplicationInstance[];
    export type ReplicationSubnetGroups = ReplicationSubnetGroup[];
    export type ReplicationTaskList = ReplicationTask[];
    export type SchemaList = String[];
    export type SecretString = string;
    export type StartReplicationTaskTypeValue = string;
    export type String = string;
    export type SubnetIdentifierList = String[];
    export type SubnetList = Subnet[];
    export type SupportedEndpointTypeList = SupportedEndpointType[];
    export type TStamp = number;
    export type TableStatisticsList = TableStatistics[];
    export type TagList = Tag[];

    export interface AccessDeniedFault {
        message?: ExceptionMessage;
    }
    export interface AccountQuota {
        AccountQuotaName?: String;
        Used?: Long;
        Max?: Long;
    }
    export interface AddTagsToResourceMessage {
        ResourceArn: String;
        Tags: TagList;
    }
    export interface AddTagsToResourceResponse {
    }
    export interface AvailabilityZone {
        Name?: String;
    }
    export interface Connection {
        ReplicationInstanceArn?: String;
        EndpointArn?: String;
        Status?: String;
        LastFailureMessage?: String;
        EndpointIdentifier?: String;
        ReplicationInstanceIdentifier?: String;
    }
    export interface CreateEndpointMessage {
        EndpointIdentifier: String;
        EndpointType: ReplicationEndpointTypeValue;
        EngineName: String;
        Username: String;
        Password: SecretString;
        ServerName: String;
        Port: IntegerOptional;
        DatabaseName?: String;
        ExtraConnectionAttributes?: String;
        KmsKeyId?: String;
        Tags?: TagList;
    }
    export interface CreateEndpointResponse {
        Endpoint?: Endpoint;
    }
    export interface CreateReplicationInstanceMessage {
        ReplicationInstanceIdentifier: String;
        AllocatedStorage?: IntegerOptional;
        ReplicationInstanceClass: String;
        AvailabilityZone?: String;
        ReplicationSubnetGroupIdentifier?: String;
        PreferredMaintenanceWindow?: String;
        EngineVersion?: String;
        AutoMinorVersionUpgrade?: BooleanOptional;
        Tags?: TagList;
        KmsKeyId?: String;
        PubliclyAccessible?: BooleanOptional;
    }
    export interface CreateReplicationInstanceResponse {
        ReplicationInstance?: ReplicationInstance;
    }
    export interface CreateReplicationSubnetGroupMessage {
        ReplicationSubnetGroupIdentifier: String;
        ReplicationSubnetGroupDescription: String;
        SubnetIds: SubnetIdentifierList;
        Tags?: TagList;
    }
    export interface CreateReplicationSubnetGroupResponse {
        ReplicationSubnetGroup?: ReplicationSubnetGroup;
    }
    export interface CreateReplicationTaskMessage {
        ReplicationTaskIdentifier: String;
        SourceEndpointArn: String;
        TargetEndpointArn: String;
        ReplicationInstanceArn: String;
        MigrationType: MigrationTypeValue;
        TableMappings: String;
        ReplicationTaskSettings?: String;
        CdcStartTime?: TStamp;
        Tags?: TagList;
    }
    export interface CreateReplicationTaskResponse {
        ReplicationTask?: ReplicationTask;
    }
    export interface DeleteEndpointMessage {
        EndpointArn: String;
    }
    export interface DeleteEndpointResponse {
        Endpoint?: Endpoint;
    }
    export interface DeleteReplicationInstanceMessage {
        ReplicationInstanceArn: String;
    }
    export interface DeleteReplicationInstanceResponse {
        ReplicationInstance?: ReplicationInstance;
    }
    export interface DeleteReplicationSubnetGroupMessage {
        ReplicationSubnetGroupIdentifier: String;
    }
    export interface DeleteReplicationSubnetGroupResponse {
    }
    export interface DeleteReplicationTaskMessage {
        ReplicationTaskArn: String;
    }
    export interface DeleteReplicationTaskResponse {
        ReplicationTask?: ReplicationTask;
    }
    export interface DescribeAccountAttributesMessage {
    }
    export interface DescribeAccountAttributesResponse {
        AccountQuotas?: AccountQuotaList;
    }
    export interface DescribeConnectionsMessage {
        Filters?: FilterList;
        MaxRecords?: IntegerOptional;
        Marker?: String;
    }
    export interface DescribeConnectionsResponse {
        Marker?: String;
        Connections?: ConnectionList;
    }
    export interface DescribeEndpointTypesMessage {
        Filters?: FilterList;
        MaxRecords?: IntegerOptional;
        Marker?: String;
    }
    export interface DescribeEndpointTypesResponse {
        Marker?: String;
        SupportedEndpointTypes?: SupportedEndpointTypeList;
    }
    export interface DescribeEndpointsMessage {
        Filters?: FilterList;
        MaxRecords?: IntegerOptional;
        Marker?: String;
    }
    export interface DescribeEndpointsResponse {
        Marker?: String;
        Endpoints?: EndpointList;
    }
    export interface DescribeOrderableReplicationInstancesMessage {
        MaxRecords?: IntegerOptional;
        Marker?: String;
    }
    export interface DescribeOrderableReplicationInstancesResponse {
        OrderableReplicationInstances?: OrderableReplicationInstanceList;
        Marker?: String;
    }
    export interface DescribeRefreshSchemasStatusMessage {
        EndpointArn: String;
    }
    export interface DescribeRefreshSchemasStatusResponse {
        RefreshSchemasStatus?: RefreshSchemasStatus;
    }
    export interface DescribeReplicationInstancesMessage {
        Filters?: FilterList;
        MaxRecords?: IntegerOptional;
        Marker?: String;
    }
    export interface DescribeReplicationInstancesResponse {
        Marker?: String;
        ReplicationInstances?: ReplicationInstanceList;
    }
    export interface DescribeReplicationSubnetGroupsMessage {
        Filters?: FilterList;
        MaxRecords?: IntegerOptional;
        Marker?: String;
    }
    export interface DescribeReplicationSubnetGroupsResponse {
        Marker?: String;
        ReplicationSubnetGroups?: ReplicationSubnetGroups;
    }
    export interface DescribeReplicationTasksMessage {
        Filters?: FilterList;
        MaxRecords?: IntegerOptional;
        Marker?: String;
    }
    export interface DescribeReplicationTasksResponse {
        Marker?: String;
        ReplicationTasks?: ReplicationTaskList;
    }
    export interface DescribeSchemasMessage {
        EndpointArn: String;
        MaxRecords?: IntegerOptional;
        Marker?: String;
    }
    export interface DescribeSchemasResponse {
        Marker?: String;
        Schemas?: SchemaList;
    }
    export interface DescribeTableStatisticsMessage {
        ReplicationTaskArn: String;
        MaxRecords?: IntegerOptional;
        Marker?: String;
    }
    export interface DescribeTableStatisticsResponse {
        ReplicationTaskArn?: String;
        TableStatistics?: TableStatisticsList;
        Marker?: String;
    }
    export interface Endpoint {
        EndpointIdentifier?: String;
        EndpointType?: ReplicationEndpointTypeValue;
        EngineName?: String;
        Username?: String;
        ServerName?: String;
        Port?: IntegerOptional;
        DatabaseName?: String;
        ExtraConnectionAttributes?: String;
        Status?: String;
        KmsKeyId?: String;
        EndpointArn?: String;
    }
    export interface Filter {
        Name: String;
        Values: FilterValueList;
    }
    export interface InsufficientResourceCapacityFault {
        message?: ExceptionMessage;
    }
    export interface InvalidResourceStateFault {
        message?: ExceptionMessage;
    }
    export interface InvalidSubnet {
        message?: ExceptionMessage;
    }
    export interface KMSKeyNotAccessibleFault {
        message?: ExceptionMessage;
    }
    export interface ListTagsForResourceMessage {
        ResourceArn: String;
    }
    export interface ListTagsForResourceResponse {
        TagList?: TagList;
    }
    export interface ModifyEndpointMessage {
        EndpointArn: String;
        EndpointIdentifier?: String;
        EndpointType?: ReplicationEndpointTypeValue;
        EngineName?: String;
        Username?: String;
        Password?: SecretString;
        ServerName?: String;
        Port?: IntegerOptional;
        DatabaseName?: String;
        ExtraConnectionAttributes?: String;
    }
    export interface ModifyEndpointResponse {
        Endpoint?: Endpoint;
    }
    export interface ModifyReplicationInstanceMessage {
        ReplicationInstanceArn: String;
        AllocatedStorage?: IntegerOptional;
        ApplyImmediately?: Boolean;
        ReplicationInstanceClass?: String;
        PreferredMaintenanceWindow?: String;
        EngineVersion?: String;
        AllowMajorVersionUpgrade?: Boolean;
        AutoMinorVersionUpgrade?: BooleanOptional;
        ReplicationInstanceIdentifier?: String;
    }
    export interface ModifyReplicationInstanceResponse {
        ReplicationInstance?: ReplicationInstance;
    }
    export interface ModifyReplicationSubnetGroupMessage {
        ReplicationSubnetGroupIdentifier: String;
        ReplicationSubnetGroupDescription?: String;
        SubnetIds: SubnetIdentifierList;
    }
    export interface ModifyReplicationSubnetGroupResponse {
        ReplicationSubnetGroup?: ReplicationSubnetGroup;
    }
    export interface OrderableReplicationInstance {
        EngineVersion?: String;
        ReplicationInstanceClass?: String;
        StorageType?: String;
        MinAllocatedStorage?: Integer;
        MaxAllocatedStorage?: Integer;
        DefaultAllocatedStorage?: Integer;
        IncludedAllocatedStorage?: Integer;
    }
    export interface RefreshSchemasMessage {
        EndpointArn: String;
        ReplicationInstanceArn: String;
    }
    export interface RefreshSchemasResponse {
        RefreshSchemasStatus?: RefreshSchemasStatus;
    }
    export interface RefreshSchemasStatus {
        EndpointArn?: String;
        ReplicationInstanceArn?: String;
        Status?: RefreshSchemasStatusTypeValue;
        LastRefreshDate?: TStamp;
        LastFailureMessage?: String;
    }
    export interface RemoveTagsFromResourceMessage {
        ResourceArn: String;
        TagKeys: KeyList;
    }
    export interface RemoveTagsFromResourceResponse {
    }
    export interface ReplicationInstance {
        ReplicationInstanceIdentifier?: String;
        ReplicationInstanceClass?: String;
        ReplicationInstanceStatus?: String;
        AllocatedStorage?: Integer;
        InstanceCreateTime?: TStamp;
        AvailabilityZone?: String;
        ReplicationSubnetGroup?: ReplicationSubnetGroup;
        PreferredMaintenanceWindow?: String;
        PendingModifiedValues?: ReplicationPendingModifiedValues;
        EngineVersion?: String;
        AutoMinorVersionUpgrade?: Boolean;
        KmsKeyId?: String;
        ReplicationInstanceArn?: String;
        ReplicationInstancePublicIpAddress?: String;
        ReplicationInstancePrivateIpAddress?: String;
        PubliclyAccessible?: Boolean;
    }
    export interface ReplicationPendingModifiedValues {
        ReplicationInstanceClass?: String;
        AllocatedStorage?: IntegerOptional;
        EngineVersion?: String;
    }
    export interface ReplicationSubnetGroup {
        ReplicationSubnetGroupIdentifier?: String;
        ReplicationSubnetGroupDescription?: String;
        VpcId?: String;
        SubnetGroupStatus?: String;
        Subnets?: SubnetList;
    }
    export interface ReplicationSubnetGroupDoesNotCoverEnoughAZs {
        message?: ExceptionMessage;
    }
    export interface ReplicationTask {
        ReplicationTaskIdentifier?: String;
        SourceEndpointArn?: String;
        TargetEndpointArn?: String;
        ReplicationInstanceArn?: String;
        MigrationType?: MigrationTypeValue;
        TableMappings?: String;
        ReplicationTaskSettings?: String;
        Status?: String;
        LastFailureMessage?: String;
        ReplicationTaskCreationDate?: TStamp;
        ReplicationTaskStartDate?: TStamp;
        ReplicationTaskArn?: String;
        ReplicationTaskStats?: ReplicationTaskStats;
    }
    export interface ReplicationTaskStats {
        FullLoadProgressPercent?: Integer;
        ElapsedTimeMillis?: Long;
        TablesLoaded?: Integer;
        TablesLoading?: Integer;
        TablesQueued?: Integer;
        TablesErrored?: Integer;
    }
    export interface ResourceAlreadyExistsFault {
        message?: ExceptionMessage;
    }
    export interface ResourceNotFoundFault {
        message?: ExceptionMessage;
    }
    export interface ResourceQuotaExceededFault {
        message?: ExceptionMessage;
    }
    export interface StartReplicationTaskMessage {
        ReplicationTaskArn: String;
        StartReplicationTaskType: StartReplicationTaskTypeValue;
        CdcStartTime?: TStamp;
    }
    export interface StartReplicationTaskResponse {
        ReplicationTask?: ReplicationTask;
    }
    export interface StopReplicationTaskMessage {
        ReplicationTaskArn: String;
    }
    export interface StopReplicationTaskResponse {
        ReplicationTask?: ReplicationTask;
    }
    export interface StorageQuotaExceededFault {
        message?: ExceptionMessage;
    }
    export interface Subnet {
        SubnetIdentifier?: String;
        SubnetAvailabilityZone?: AvailabilityZone;
        SubnetStatus?: String;
    }
    export interface SubnetAlreadyInUse {
        message?: ExceptionMessage;
    }
    export interface SupportedEndpointType {
        EngineName?: String;
        SupportsCDC?: Boolean;
        EndpointType?: ReplicationEndpointTypeValue;
    }
    export interface TableStatistics {
        SchemaName?: String;
        TableName?: String;
        Inserts?: Long;
        Deletes?: Long;
        Updates?: Long;
        Ddls?: Long;
        FullLoadRows?: Long;
        LastUpdateTime?: TStamp;
        TableState?: String;
    }
    export interface Tag {
        Key?: String;
        Value?: String;
    }
    export interface TestConnectionMessage {
        ReplicationInstanceArn: String;
        EndpointArn: String;
    }
    export interface TestConnectionResponse {
        Connection?: Connection;
    }
    export interface UpgradeDependencyFailureFault {
        message?: ExceptionMessage;
    }
  }

  /*
   * apiVersion: 2012-08-10
   * endpointPrefix: dynamodb
   * serviceAbbreviation: DynamoDB
   * signatureVersion: v4
   * protocol: json
   */
  export class DynamoDB extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    batchGetItem(params: DynamoDB.BatchGetItemInput, callback?: (err: DynamoDB.ProvisionedThroughputExceededException|DynamoDB.ResourceNotFoundException|DynamoDB.InternalServerError|any, data: DynamoDB.BatchGetItemOutput|any) => void): Request;
    batchWriteItem(params: DynamoDB.BatchWriteItemInput, callback?: (err: DynamoDB.ProvisionedThroughputExceededException|DynamoDB.ResourceNotFoundException|DynamoDB.ItemCollectionSizeLimitExceededException|DynamoDB.InternalServerError|any, data: DynamoDB.BatchWriteItemOutput|any) => void): Request;
    createTable(params: DynamoDB.CreateTableInput, callback?: (err: DynamoDB.ResourceInUseException|DynamoDB.LimitExceededException|DynamoDB.InternalServerError|any, data: DynamoDB.CreateTableOutput|any) => void): Request;
    deleteItem(params: DynamoDB.DeleteItemInput, callback?: (err: DynamoDB.ConditionalCheckFailedException|DynamoDB.ProvisionedThroughputExceededException|DynamoDB.ResourceNotFoundException|DynamoDB.ItemCollectionSizeLimitExceededException|DynamoDB.InternalServerError|any, data: DynamoDB.DeleteItemOutput|any) => void): Request;
    deleteTable(params: DynamoDB.DeleteTableInput, callback?: (err: DynamoDB.ResourceInUseException|DynamoDB.ResourceNotFoundException|DynamoDB.LimitExceededException|DynamoDB.InternalServerError|any, data: DynamoDB.DeleteTableOutput|any) => void): Request;
    describeLimits(params: DynamoDB.DescribeLimitsInput, callback?: (err: DynamoDB.InternalServerError|any, data: DynamoDB.DescribeLimitsOutput|any) => void): Request;
    describeTable(params: DynamoDB.DescribeTableInput, callback?: (err: DynamoDB.ResourceNotFoundException|DynamoDB.InternalServerError|any, data: DynamoDB.DescribeTableOutput|any) => void): Request;
    getItem(params: DynamoDB.GetItemInput, callback?: (err: DynamoDB.ProvisionedThroughputExceededException|DynamoDB.ResourceNotFoundException|DynamoDB.InternalServerError|any, data: DynamoDB.GetItemOutput|any) => void): Request;
    listTables(params: DynamoDB.ListTablesInput, callback?: (err: DynamoDB.InternalServerError|any, data: DynamoDB.ListTablesOutput|any) => void): Request;
    putItem(params: DynamoDB.PutItemInput, callback?: (err: DynamoDB.ConditionalCheckFailedException|DynamoDB.ProvisionedThroughputExceededException|DynamoDB.ResourceNotFoundException|DynamoDB.ItemCollectionSizeLimitExceededException|DynamoDB.InternalServerError|any, data: DynamoDB.PutItemOutput|any) => void): Request;
    query(params: DynamoDB.QueryInput, callback?: (err: DynamoDB.ProvisionedThroughputExceededException|DynamoDB.ResourceNotFoundException|DynamoDB.InternalServerError|any, data: DynamoDB.QueryOutput|any) => void): Request;
    scan(params: DynamoDB.ScanInput, callback?: (err: DynamoDB.ProvisionedThroughputExceededException|DynamoDB.ResourceNotFoundException|DynamoDB.InternalServerError|any, data: DynamoDB.ScanOutput|any) => void): Request;
    updateItem(params: DynamoDB.UpdateItemInput, callback?: (err: DynamoDB.ConditionalCheckFailedException|DynamoDB.ProvisionedThroughputExceededException|DynamoDB.ResourceNotFoundException|DynamoDB.ItemCollectionSizeLimitExceededException|DynamoDB.InternalServerError|any, data: DynamoDB.UpdateItemOutput|any) => void): Request;
    updateTable(params: DynamoDB.UpdateTableInput, callback?: (err: DynamoDB.ResourceInUseException|DynamoDB.ResourceNotFoundException|DynamoDB.LimitExceededException|DynamoDB.InternalServerError|any, data: DynamoDB.UpdateTableOutput|any) => void): Request;

  }

  export module DynamoDB {
    export type AttributeAction = string;
    export type AttributeDefinitions = AttributeDefinition[];
    export type AttributeMap = {[key:string]: AttributeValue};
    export type AttributeName = string;    // max: 65535
    export type AttributeNameList = AttributeName[];    // min: 1
    export type AttributeUpdates = {[key:string]: AttributeValueUpdate};
    export type AttributeValueList = AttributeValue[];
    export type Backfilling = boolean;
    export type BatchGetRequestMap = {[key:string]: KeysAndAttributes};    // max: 100, min: 1
    export type BatchGetResponseMap = {[key:string]: ItemList};
    export type BatchWriteItemRequestMap = {[key:string]: WriteRequests};    // max: 25, min: 1
    export type BinaryAttributeValue = any;    // type: blob
    export type BinarySetAttributeValue = BinaryAttributeValue[];
    export type BooleanAttributeValue = boolean;
    export type BooleanObject = boolean;
    export type ComparisonOperator = string;
    export type ConditionExpression = string;
    export type ConditionalOperator = string;
    export type ConsistentRead = boolean;
    export type ConsumedCapacityMultiple = ConsumedCapacity[];
    export type ConsumedCapacityUnits = number;
    export type Date = number;
    export type ErrorMessage = string;
    export type ExpectedAttributeMap = {[key:string]: ExpectedAttributeValue};
    export type ExpressionAttributeNameMap = {[key:string]: AttributeName};
    export type ExpressionAttributeNameVariable = string;
    export type ExpressionAttributeValueMap = {[key:string]: AttributeValue};
    export type ExpressionAttributeValueVariable = string;
    export type FilterConditionMap = {[key:string]: Condition};
    export type GlobalSecondaryIndexDescriptionList = GlobalSecondaryIndexDescription[];
    export type GlobalSecondaryIndexList = GlobalSecondaryIndex[];
    export type GlobalSecondaryIndexUpdateList = GlobalSecondaryIndexUpdate[];
    export type IndexName = string;    // pattern: &quot;[a-zA-Z0-9_.-]+&quot;, max: 255, min: 3
    export type IndexStatus = string;
    export type Integer = number;
    export type ItemCollectionKeyAttributeMap = {[key:string]: AttributeValue};
    export type ItemCollectionMetricsMultiple = ItemCollectionMetrics[];
    export type ItemCollectionMetricsPerTable = {[key:string]: ItemCollectionMetricsMultiple};
    export type ItemCollectionSizeEstimateBound = number;
    export type ItemCollectionSizeEstimateRange = ItemCollectionSizeEstimateBound[];
    export type ItemList = AttributeMap[];
    export type Key = {[key:string]: AttributeValue};
    export type KeyConditions = {[key:string]: Condition};
    export type KeyExpression = string;
    export type KeyList = Key[];    // max: 100, min: 1
    export type KeySchema = KeySchemaElement[];    // max: 2, min: 1
    export type KeySchemaAttributeName = string;    // max: 255, min: 1
    export type KeyType = string;
    export type ListAttributeValue = AttributeValue[];
    export type ListTablesInputLimit = number;    // max: 100, min: 1
    export type LocalSecondaryIndexDescriptionList = LocalSecondaryIndexDescription[];
    export type LocalSecondaryIndexList = LocalSecondaryIndex[];
    export type Long = number;
    export type MapAttributeValue = {[key:string]: AttributeValue};
    export type NonKeyAttributeName = string;    // max: 255, min: 1
    export type NonKeyAttributeNameList = NonKeyAttributeName[];    // max: 20, min: 1
    export type NullAttributeValue = boolean;
    export type NumberAttributeValue = string;
    export type NumberSetAttributeValue = NumberAttributeValue[];
    export type PositiveIntegerObject = number;    // min: 1
    export type PositiveLongObject = number;    // min: 1
    export type ProjectionExpression = string;
    export type ProjectionType = string;
    export type PutItemInputAttributeMap = {[key:string]: AttributeValue};
    export type ReturnConsumedCapacity = string;
    export type ReturnItemCollectionMetrics = string;
    export type ReturnValue = string;
    export type ScalarAttributeType = string;
    export type ScanSegment = number;    // max: 999999
    export type ScanTotalSegments = number;    // max: 1000000, min: 1
    export type SecondaryIndexesCapacityMap = {[key:string]: Capacity};
    export type Select = string;
    export type StreamArn = string;    // max: 1024, min: 37
    export type StreamEnabled = boolean;
    export type StreamViewType = string;
    export type String = string;
    export type StringAttributeValue = string;
    export type StringSetAttributeValue = StringAttributeValue[];
    export type TableName = string;    // pattern: &quot;[a-zA-Z0-9_.-]+&quot;, max: 255, min: 3
    export type TableNameList = TableName[];
    export type TableStatus = string;
    export type UpdateExpression = string;
    export type WriteRequests = WriteRequest[];    // max: 25, min: 1

    export interface AttributeDefinition {
        AttributeName: KeySchemaAttributeName;
        AttributeType: ScalarAttributeType;
    }
    export interface AttributeValue {
        S?: StringAttributeValue;
        N?: NumberAttributeValue;
        B?: BinaryAttributeValue;
        SS?: StringSetAttributeValue;
        NS?: NumberSetAttributeValue;
        BS?: BinarySetAttributeValue;
        M?: MapAttributeValue;
        L?: ListAttributeValue;
        NULL?: NullAttributeValue;
        BOOL?: BooleanAttributeValue;
    }
    export interface AttributeValueUpdate {
        Value?: AttributeValue;
        Action?: AttributeAction;
    }
    export interface BatchGetItemInput {
        RequestItems: BatchGetRequestMap;
        ReturnConsumedCapacity?: ReturnConsumedCapacity;
    }
    export interface BatchGetItemOutput {
        Responses?: BatchGetResponseMap;
        UnprocessedKeys?: BatchGetRequestMap;
        ConsumedCapacity?: ConsumedCapacityMultiple;
    }
    export interface BatchWriteItemInput {
        RequestItems: BatchWriteItemRequestMap;
        ReturnConsumedCapacity?: ReturnConsumedCapacity;
        ReturnItemCollectionMetrics?: ReturnItemCollectionMetrics;
    }
    export interface BatchWriteItemOutput {
        UnprocessedItems?: BatchWriteItemRequestMap;
        ItemCollectionMetrics?: ItemCollectionMetricsPerTable;
        ConsumedCapacity?: ConsumedCapacityMultiple;
    }
    export interface Capacity {
        CapacityUnits?: ConsumedCapacityUnits;
    }
    export interface Condition {
        AttributeValueList?: AttributeValueList;
        ComparisonOperator: ComparisonOperator;
    }
    export interface ConditionalCheckFailedException {
        message?: ErrorMessage;
    }
    export interface ConsumedCapacity {
        TableName?: TableName;
        CapacityUnits?: ConsumedCapacityUnits;
        Table?: Capacity;
        LocalSecondaryIndexes?: SecondaryIndexesCapacityMap;
        GlobalSecondaryIndexes?: SecondaryIndexesCapacityMap;
    }
    export interface CreateGlobalSecondaryIndexAction {
        IndexName: IndexName;
        KeySchema: KeySchema;
        Projection: Projection;
        ProvisionedThroughput: ProvisionedThroughput;
    }
    export interface CreateTableInput {
        AttributeDefinitions: AttributeDefinitions;
        TableName: TableName;
        KeySchema: KeySchema;
        LocalSecondaryIndexes?: LocalSecondaryIndexList;
        GlobalSecondaryIndexes?: GlobalSecondaryIndexList;
        ProvisionedThroughput: ProvisionedThroughput;
        StreamSpecification?: StreamSpecification;
    }
    export interface CreateTableOutput {
        TableDescription?: TableDescription;
    }
    export interface DeleteGlobalSecondaryIndexAction {
        IndexName: IndexName;
    }
    export interface DeleteItemInput {
        TableName: TableName;
        Key: Key;
        Expected?: ExpectedAttributeMap;
        ConditionalOperator?: ConditionalOperator;
        ReturnValues?: ReturnValue;
        ReturnConsumedCapacity?: ReturnConsumedCapacity;
        ReturnItemCollectionMetrics?: ReturnItemCollectionMetrics;
        ConditionExpression?: ConditionExpression;
        ExpressionAttributeNames?: ExpressionAttributeNameMap;
        ExpressionAttributeValues?: ExpressionAttributeValueMap;
    }
    export interface DeleteItemOutput {
        Attributes?: AttributeMap;
        ConsumedCapacity?: ConsumedCapacity;
        ItemCollectionMetrics?: ItemCollectionMetrics;
    }
    export interface DeleteRequest {
        Key: Key;
    }
    export interface DeleteTableInput {
        TableName: TableName;
    }
    export interface DeleteTableOutput {
        TableDescription?: TableDescription;
    }
    export interface DescribeLimitsInput {
    }
    export interface DescribeLimitsOutput {
        AccountMaxReadCapacityUnits?: PositiveLongObject;
        AccountMaxWriteCapacityUnits?: PositiveLongObject;
        TableMaxReadCapacityUnits?: PositiveLongObject;
        TableMaxWriteCapacityUnits?: PositiveLongObject;
    }
    export interface DescribeTableInput {
        TableName: TableName;
    }
    export interface DescribeTableOutput {
        Table?: TableDescription;
    }
    export interface ExpectedAttributeValue {
        Value?: AttributeValue;
        Exists?: BooleanObject;
        ComparisonOperator?: ComparisonOperator;
        AttributeValueList?: AttributeValueList;
    }
    export interface GetItemInput {
        TableName: TableName;
        Key: Key;
        AttributesToGet?: AttributeNameList;
        ConsistentRead?: ConsistentRead;
        ReturnConsumedCapacity?: ReturnConsumedCapacity;
        ProjectionExpression?: ProjectionExpression;
        ExpressionAttributeNames?: ExpressionAttributeNameMap;
    }
    export interface GetItemOutput {
        Item?: AttributeMap;
        ConsumedCapacity?: ConsumedCapacity;
    }
    export interface GlobalSecondaryIndex {
        IndexName: IndexName;
        KeySchema: KeySchema;
        Projection: Projection;
        ProvisionedThroughput: ProvisionedThroughput;
    }
    export interface GlobalSecondaryIndexDescription {
        IndexName?: IndexName;
        KeySchema?: KeySchema;
        Projection?: Projection;
        IndexStatus?: IndexStatus;
        Backfilling?: Backfilling;
        ProvisionedThroughput?: ProvisionedThroughputDescription;
        IndexSizeBytes?: Long;
        ItemCount?: Long;
        IndexArn?: String;
    }
    export interface GlobalSecondaryIndexUpdate {
        Update?: UpdateGlobalSecondaryIndexAction;
        Create?: CreateGlobalSecondaryIndexAction;
        Delete?: DeleteGlobalSecondaryIndexAction;
    }
    export interface InternalServerError {
        message?: ErrorMessage;
    }
    export interface ItemCollectionMetrics {
        ItemCollectionKey?: ItemCollectionKeyAttributeMap;
        SizeEstimateRangeGB?: ItemCollectionSizeEstimateRange;
    }
    export interface ItemCollectionSizeLimitExceededException {
        message?: ErrorMessage;
    }
    export interface KeySchemaElement {
        AttributeName: KeySchemaAttributeName;
        KeyType: KeyType;
    }
    export interface KeysAndAttributes {
        Keys: KeyList;
        AttributesToGet?: AttributeNameList;
        ConsistentRead?: ConsistentRead;
        ProjectionExpression?: ProjectionExpression;
        ExpressionAttributeNames?: ExpressionAttributeNameMap;
    }
    export interface LimitExceededException {
        message?: ErrorMessage;
    }
    export interface ListTablesInput {
        ExclusiveStartTableName?: TableName;
        Limit?: ListTablesInputLimit;
    }
    export interface ListTablesOutput {
        TableNames?: TableNameList;
        LastEvaluatedTableName?: TableName;
    }
    export interface LocalSecondaryIndex {
        IndexName: IndexName;
        KeySchema: KeySchema;
        Projection: Projection;
    }
    export interface LocalSecondaryIndexDescription {
        IndexName?: IndexName;
        KeySchema?: KeySchema;
        Projection?: Projection;
        IndexSizeBytes?: Long;
        ItemCount?: Long;
        IndexArn?: String;
    }
    export interface Projection {
        ProjectionType?: ProjectionType;
        NonKeyAttributes?: NonKeyAttributeNameList;
    }
    export interface ProvisionedThroughput {
        ReadCapacityUnits: PositiveLongObject;
        WriteCapacityUnits: PositiveLongObject;
    }
    export interface ProvisionedThroughputDescription {
        LastIncreaseDateTime?: Date;
        LastDecreaseDateTime?: Date;
        NumberOfDecreasesToday?: PositiveLongObject;
        ReadCapacityUnits?: PositiveLongObject;
        WriteCapacityUnits?: PositiveLongObject;
    }
    export interface ProvisionedThroughputExceededException {
        message?: ErrorMessage;
    }
    export interface PutItemInput {
        TableName: TableName;
        Item: PutItemInputAttributeMap;
        Expected?: ExpectedAttributeMap;
        ReturnValues?: ReturnValue;
        ReturnConsumedCapacity?: ReturnConsumedCapacity;
        ReturnItemCollectionMetrics?: ReturnItemCollectionMetrics;
        ConditionalOperator?: ConditionalOperator;
        ConditionExpression?: ConditionExpression;
        ExpressionAttributeNames?: ExpressionAttributeNameMap;
        ExpressionAttributeValues?: ExpressionAttributeValueMap;
    }
    export interface PutItemOutput {
        Attributes?: AttributeMap;
        ConsumedCapacity?: ConsumedCapacity;
        ItemCollectionMetrics?: ItemCollectionMetrics;
    }
    export interface PutRequest {
        Item: PutItemInputAttributeMap;
    }
    export interface QueryInput {
        TableName: TableName;
        IndexName?: IndexName;
        Select?: Select;
        AttributesToGet?: AttributeNameList;
        Limit?: PositiveIntegerObject;
        ConsistentRead?: ConsistentRead;
        KeyConditions?: KeyConditions;
        QueryFilter?: FilterConditionMap;
        ConditionalOperator?: ConditionalOperator;
        ScanIndexForward?: BooleanObject;
        ExclusiveStartKey?: Key;
        ReturnConsumedCapacity?: ReturnConsumedCapacity;
        ProjectionExpression?: ProjectionExpression;
        FilterExpression?: ConditionExpression;
        KeyConditionExpression?: KeyExpression;
        ExpressionAttributeNames?: ExpressionAttributeNameMap;
        ExpressionAttributeValues?: ExpressionAttributeValueMap;
    }
    export interface QueryOutput {
        Items?: ItemList;
        Count?: Integer;
        ScannedCount?: Integer;
        LastEvaluatedKey?: Key;
        ConsumedCapacity?: ConsumedCapacity;
    }
    export interface ResourceInUseException {
        message?: ErrorMessage;
    }
    export interface ResourceNotFoundException {
        message?: ErrorMessage;
    }
    export interface ScanInput {
        TableName: TableName;
        IndexName?: IndexName;
        AttributesToGet?: AttributeNameList;
        Limit?: PositiveIntegerObject;
        Select?: Select;
        ScanFilter?: FilterConditionMap;
        ConditionalOperator?: ConditionalOperator;
        ExclusiveStartKey?: Key;
        ReturnConsumedCapacity?: ReturnConsumedCapacity;
        TotalSegments?: ScanTotalSegments;
        Segment?: ScanSegment;
        ProjectionExpression?: ProjectionExpression;
        FilterExpression?: ConditionExpression;
        ExpressionAttributeNames?: ExpressionAttributeNameMap;
        ExpressionAttributeValues?: ExpressionAttributeValueMap;
        ConsistentRead?: ConsistentRead;
    }
    export interface ScanOutput {
        Items?: ItemList;
        Count?: Integer;
        ScannedCount?: Integer;
        LastEvaluatedKey?: Key;
        ConsumedCapacity?: ConsumedCapacity;
    }
    export interface StreamSpecification {
        StreamEnabled?: StreamEnabled;
        StreamViewType?: StreamViewType;
    }
    export interface TableDescription {
        AttributeDefinitions?: AttributeDefinitions;
        TableName?: TableName;
        KeySchema?: KeySchema;
        TableStatus?: TableStatus;
        CreationDateTime?: Date;
        ProvisionedThroughput?: ProvisionedThroughputDescription;
        TableSizeBytes?: Long;
        ItemCount?: Long;
        TableArn?: String;
        LocalSecondaryIndexes?: LocalSecondaryIndexDescriptionList;
        GlobalSecondaryIndexes?: GlobalSecondaryIndexDescriptionList;
        StreamSpecification?: StreamSpecification;
        LatestStreamLabel?: String;
        LatestStreamArn?: StreamArn;
    }
    export interface UpdateGlobalSecondaryIndexAction {
        IndexName: IndexName;
        ProvisionedThroughput: ProvisionedThroughput;
    }
    export interface UpdateItemInput {
        TableName: TableName;
        Key: Key;
        AttributeUpdates?: AttributeUpdates;
        Expected?: ExpectedAttributeMap;
        ConditionalOperator?: ConditionalOperator;
        ReturnValues?: ReturnValue;
        ReturnConsumedCapacity?: ReturnConsumedCapacity;
        ReturnItemCollectionMetrics?: ReturnItemCollectionMetrics;
        UpdateExpression?: UpdateExpression;
        ConditionExpression?: ConditionExpression;
        ExpressionAttributeNames?: ExpressionAttributeNameMap;
        ExpressionAttributeValues?: ExpressionAttributeValueMap;
    }
    export interface UpdateItemOutput {
        Attributes?: AttributeMap;
        ConsumedCapacity?: ConsumedCapacity;
        ItemCollectionMetrics?: ItemCollectionMetrics;
    }
    export interface UpdateTableInput {
        AttributeDefinitions?: AttributeDefinitions;
        TableName: TableName;
        ProvisionedThroughput?: ProvisionedThroughput;
        GlobalSecondaryIndexUpdates?: GlobalSecondaryIndexUpdateList;
        StreamSpecification?: StreamSpecification;
    }
    export interface UpdateTableOutput {
        TableDescription?: TableDescription;
    }
    export interface WriteRequest {
        PutRequest?: PutRequest;
        DeleteRequest?: DeleteRequest;
    }
  }

  /*
   * apiVersion: 2012-08-10
   * endpointPrefix: streams.dynamodb
   * serviceAbbreviation: 
   * signatureVersion: v4
   * protocol: json
   */
  export class DynamoDBStreams extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    describeStream(params: DynamoDBStreams.DescribeStreamInput, callback?: (err: DynamoDBStreams.ResourceNotFoundException|DynamoDBStreams.InternalServerError|any, data: DynamoDBStreams.DescribeStreamOutput|any) => void): Request;
    getRecords(params: DynamoDBStreams.GetRecordsInput, callback?: (err: DynamoDBStreams.ResourceNotFoundException|DynamoDBStreams.LimitExceededException|DynamoDBStreams.InternalServerError|DynamoDBStreams.ExpiredIteratorException|DynamoDBStreams.TrimmedDataAccessException|any, data: DynamoDBStreams.GetRecordsOutput|any) => void): Request;
    getShardIterator(params: DynamoDBStreams.GetShardIteratorInput, callback?: (err: DynamoDBStreams.ResourceNotFoundException|DynamoDBStreams.InternalServerError|DynamoDBStreams.TrimmedDataAccessException|any, data: DynamoDBStreams.GetShardIteratorOutput|any) => void): Request;
    listStreams(params: DynamoDBStreams.ListStreamsInput, callback?: (err: DynamoDBStreams.ResourceNotFoundException|DynamoDBStreams.InternalServerError|any, data: DynamoDBStreams.ListStreamsOutput|any) => void): Request;

  }

  export module DynamoDBStreams {
    export type AttributeMap = {[key:string]: AttributeValue};
    export type AttributeName = string;    // max: 65535
    export type BinaryAttributeValue = any;    // type: blob
    export type BinarySetAttributeValue = BinaryAttributeValue[];
    export type BooleanAttributeValue = boolean;
    export type Date = number;
    export type ErrorMessage = string;
    export type KeySchema = KeySchemaElement[];    // max: 2, min: 1
    export type KeySchemaAttributeName = string;    // max: 255, min: 1
    export type KeyType = string;
    export type ListAttributeValue = AttributeValue[];
    export type MapAttributeValue = {[key:string]: AttributeValue};
    export type NullAttributeValue = boolean;
    export type NumberAttributeValue = string;
    export type NumberSetAttributeValue = NumberAttributeValue[];
    export type OperationType = string;
    export type PositiveIntegerObject = number;    // min: 1
    export type PositiveLongObject = number;    // min: 1
    export type RecordList = Record[];
    export type SequenceNumber = string;    // max: 40, min: 21
    export type ShardDescriptionList = Shard[];
    export type ShardId = string;    // max: 65, min: 28
    export type ShardIterator = string;    // max: 2048, min: 1
    export type ShardIteratorType = string;
    export type StreamArn = string;    // max: 1024, min: 37
    export type StreamList = Stream[];
    export type StreamStatus = string;
    export type StreamViewType = string;
    export type String = string;
    export type StringAttributeValue = string;
    export type StringSetAttributeValue = StringAttributeValue[];
    export type TableName = string;    // pattern: &quot;[a-zA-Z0-9_.-]+&quot;, max: 255, min: 3

    export interface AttributeValue {
        S?: StringAttributeValue;
        N?: NumberAttributeValue;
        B?: BinaryAttributeValue;
        SS?: StringSetAttributeValue;
        NS?: NumberSetAttributeValue;
        BS?: BinarySetAttributeValue;
        M?: MapAttributeValue;
        L?: ListAttributeValue;
        NULL?: NullAttributeValue;
        BOOL?: BooleanAttributeValue;
    }
    export interface DescribeStreamInput {
        StreamArn: StreamArn;
        Limit?: PositiveIntegerObject;
        ExclusiveStartShardId?: ShardId;
    }
    export interface DescribeStreamOutput {
        StreamDescription?: StreamDescription;
    }
    export interface ExpiredIteratorException {
        message?: ErrorMessage;
    }
    export interface GetRecordsInput {
        ShardIterator: ShardIterator;
        Limit?: PositiveIntegerObject;
    }
    export interface GetRecordsOutput {
        Records?: RecordList;
        NextShardIterator?: ShardIterator;
    }
    export interface GetShardIteratorInput {
        StreamArn: StreamArn;
        ShardId: ShardId;
        ShardIteratorType: ShardIteratorType;
        SequenceNumber?: SequenceNumber;
    }
    export interface GetShardIteratorOutput {
        ShardIterator?: ShardIterator;
    }
    export interface InternalServerError {
        message?: ErrorMessage;
    }
    export interface KeySchemaElement {
        AttributeName: KeySchemaAttributeName;
        KeyType: KeyType;
    }
    export interface LimitExceededException {
        message?: ErrorMessage;
    }
    export interface ListStreamsInput {
        TableName?: TableName;
        Limit?: PositiveIntegerObject;
        ExclusiveStartStreamArn?: StreamArn;
    }
    export interface ListStreamsOutput {
        Streams?: StreamList;
        LastEvaluatedStreamArn?: StreamArn;
    }
    export interface Record {
        eventID?: String;
        eventName?: OperationType;
        eventVersion?: String;
        eventSource?: String;
        awsRegion?: String;
        dynamodb?: StreamRecord;
    }
    export interface ResourceNotFoundException {
        message?: ErrorMessage;
    }
    export interface SequenceNumberRange {
        StartingSequenceNumber?: SequenceNumber;
        EndingSequenceNumber?: SequenceNumber;
    }
    export interface Shard {
        ShardId?: ShardId;
        SequenceNumberRange?: SequenceNumberRange;
        ParentShardId?: ShardId;
    }
    export interface Stream {
        StreamArn?: StreamArn;
        TableName?: TableName;
        StreamLabel?: String;
    }
    export interface StreamDescription {
        StreamArn?: StreamArn;
        StreamLabel?: String;
        StreamStatus?: StreamStatus;
        StreamViewType?: StreamViewType;
        CreationRequestDateTime?: Date;
        TableName?: TableName;
        KeySchema?: KeySchema;
        Shards?: ShardDescriptionList;
        LastEvaluatedShardId?: ShardId;
    }
    export interface StreamRecord {
        Keys?: AttributeMap;
        NewImage?: AttributeMap;
        OldImage?: AttributeMap;
        SequenceNumber?: SequenceNumber;
        SizeBytes?: PositiveLongObject;
        StreamViewType?: StreamViewType;
    }
    export interface TrimmedDataAccessException {
        message?: ErrorMessage;
    }
  }

  /*
   * apiVersion: 2015-10-01
   * endpointPrefix: ec2
   * serviceAbbreviation: Amazon EC2
   * signatureVersion: v4
   * protocol: ec2
   */
  export class EC2 extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    acceptVpcPeeringConnection(params: EC2.AcceptVpcPeeringConnectionRequest, callback?: (err: any, data: EC2.AcceptVpcPeeringConnectionResult|any) => void): Request;
    allocateAddress(params: EC2.AllocateAddressRequest, callback?: (err: any, data: EC2.AllocateAddressResult|any) => void): Request;
    allocateHosts(params: EC2.AllocateHostsRequest, callback?: (err: any, data: EC2.AllocateHostsResult|any) => void): Request;
    assignPrivateIpAddresses(params: EC2.AssignPrivateIpAddressesRequest, callback?: (err: any, data: any) => void): Request;
    associateAddress(params: EC2.AssociateAddressRequest, callback?: (err: any, data: EC2.AssociateAddressResult|any) => void): Request;
    associateDhcpOptions(params: EC2.AssociateDhcpOptionsRequest, callback?: (err: any, data: any) => void): Request;
    associateRouteTable(params: EC2.AssociateRouteTableRequest, callback?: (err: any, data: EC2.AssociateRouteTableResult|any) => void): Request;
    attachClassicLinkVpc(params: EC2.AttachClassicLinkVpcRequest, callback?: (err: any, data: EC2.AttachClassicLinkVpcResult|any) => void): Request;
    attachInternetGateway(params: EC2.AttachInternetGatewayRequest, callback?: (err: any, data: any) => void): Request;
    attachNetworkInterface(params: EC2.AttachNetworkInterfaceRequest, callback?: (err: any, data: EC2.AttachNetworkInterfaceResult|any) => void): Request;
    attachVolume(params: EC2.AttachVolumeRequest, callback?: (err: any, data: EC2.VolumeAttachment|any) => void): Request;
    attachVpnGateway(params: EC2.AttachVpnGatewayRequest, callback?: (err: any, data: EC2.AttachVpnGatewayResult|any) => void): Request;
    authorizeSecurityGroupEgress(params: EC2.AuthorizeSecurityGroupEgressRequest, callback?: (err: any, data: any) => void): Request;
    authorizeSecurityGroupIngress(params: EC2.AuthorizeSecurityGroupIngressRequest, callback?: (err: any, data: any) => void): Request;
    bundleInstance(params: EC2.BundleInstanceRequest, callback?: (err: any, data: EC2.BundleInstanceResult|any) => void): Request;
    cancelBundleTask(params: EC2.CancelBundleTaskRequest, callback?: (err: any, data: EC2.CancelBundleTaskResult|any) => void): Request;
    cancelConversionTask(params: EC2.CancelConversionRequest, callback?: (err: any, data: any) => void): Request;
    cancelExportTask(params: EC2.CancelExportTaskRequest, callback?: (err: any, data: any) => void): Request;
    cancelImportTask(params: EC2.CancelImportTaskRequest, callback?: (err: any, data: EC2.CancelImportTaskResult|any) => void): Request;
    cancelReservedInstancesListing(params: EC2.CancelReservedInstancesListingRequest, callback?: (err: any, data: EC2.CancelReservedInstancesListingResult|any) => void): Request;
    cancelSpotFleetRequests(params: EC2.CancelSpotFleetRequestsRequest, callback?: (err: any, data: EC2.CancelSpotFleetRequestsResponse|any) => void): Request;
    cancelSpotInstanceRequests(params: EC2.CancelSpotInstanceRequestsRequest, callback?: (err: any, data: EC2.CancelSpotInstanceRequestsResult|any) => void): Request;
    confirmProductInstance(params: EC2.ConfirmProductInstanceRequest, callback?: (err: any, data: EC2.ConfirmProductInstanceResult|any) => void): Request;
    copyImage(params: EC2.CopyImageRequest, callback?: (err: any, data: EC2.CopyImageResult|any) => void): Request;
    copySnapshot(params: EC2.CopySnapshotRequest, callback?: (err: any, data: EC2.CopySnapshotResult|any) => void): Request;
    createCustomerGateway(params: EC2.CreateCustomerGatewayRequest, callback?: (err: any, data: EC2.CreateCustomerGatewayResult|any) => void): Request;
    createDhcpOptions(params: EC2.CreateDhcpOptionsRequest, callback?: (err: any, data: EC2.CreateDhcpOptionsResult|any) => void): Request;
    createFlowLogs(params: EC2.CreateFlowLogsRequest, callback?: (err: any, data: EC2.CreateFlowLogsResult|any) => void): Request;
    createImage(params: EC2.CreateImageRequest, callback?: (err: any, data: EC2.CreateImageResult|any) => void): Request;
    createInstanceExportTask(params: EC2.CreateInstanceExportTaskRequest, callback?: (err: any, data: EC2.CreateInstanceExportTaskResult|any) => void): Request;
    createInternetGateway(params: EC2.CreateInternetGatewayRequest, callback?: (err: any, data: EC2.CreateInternetGatewayResult|any) => void): Request;
    createKeyPair(params: EC2.CreateKeyPairRequest, callback?: (err: any, data: EC2.KeyPair|any) => void): Request;
    createNatGateway(params: EC2.CreateNatGatewayRequest, callback?: (err: any, data: EC2.CreateNatGatewayResult|any) => void): Request;
    createNetworkAcl(params: EC2.CreateNetworkAclRequest, callback?: (err: any, data: EC2.CreateNetworkAclResult|any) => void): Request;
    createNetworkAclEntry(params: EC2.CreateNetworkAclEntryRequest, callback?: (err: any, data: any) => void): Request;
    createNetworkInterface(params: EC2.CreateNetworkInterfaceRequest, callback?: (err: any, data: EC2.CreateNetworkInterfaceResult|any) => void): Request;
    createPlacementGroup(params: EC2.CreatePlacementGroupRequest, callback?: (err: any, data: any) => void): Request;
    createReservedInstancesListing(params: EC2.CreateReservedInstancesListingRequest, callback?: (err: any, data: EC2.CreateReservedInstancesListingResult|any) => void): Request;
    createRoute(params: EC2.CreateRouteRequest, callback?: (err: any, data: EC2.CreateRouteResult|any) => void): Request;
    createRouteTable(params: EC2.CreateRouteTableRequest, callback?: (err: any, data: EC2.CreateRouteTableResult|any) => void): Request;
    createSecurityGroup(params: EC2.CreateSecurityGroupRequest, callback?: (err: any, data: EC2.CreateSecurityGroupResult|any) => void): Request;
    createSnapshot(params: EC2.CreateSnapshotRequest, callback?: (err: any, data: EC2.Snapshot|any) => void): Request;
    createSpotDatafeedSubscription(params: EC2.CreateSpotDatafeedSubscriptionRequest, callback?: (err: any, data: EC2.CreateSpotDatafeedSubscriptionResult|any) => void): Request;
    createSubnet(params: EC2.CreateSubnetRequest, callback?: (err: any, data: EC2.CreateSubnetResult|any) => void): Request;
    createTags(params: EC2.CreateTagsRequest, callback?: (err: any, data: any) => void): Request;
    createVolume(params: EC2.CreateVolumeRequest, callback?: (err: any, data: EC2.Volume|any) => void): Request;
    createVpc(params: EC2.CreateVpcRequest, callback?: (err: any, data: EC2.CreateVpcResult|any) => void): Request;
    createVpcEndpoint(params: EC2.CreateVpcEndpointRequest, callback?: (err: any, data: EC2.CreateVpcEndpointResult|any) => void): Request;
    createVpcPeeringConnection(params: EC2.CreateVpcPeeringConnectionRequest, callback?: (err: any, data: EC2.CreateVpcPeeringConnectionResult|any) => void): Request;
    createVpnConnection(params: EC2.CreateVpnConnectionRequest, callback?: (err: any, data: EC2.CreateVpnConnectionResult|any) => void): Request;
    createVpnConnectionRoute(params: EC2.CreateVpnConnectionRouteRequest, callback?: (err: any, data: any) => void): Request;
    createVpnGateway(params: EC2.CreateVpnGatewayRequest, callback?: (err: any, data: EC2.CreateVpnGatewayResult|any) => void): Request;
    deleteCustomerGateway(params: EC2.DeleteCustomerGatewayRequest, callback?: (err: any, data: any) => void): Request;
    deleteDhcpOptions(params: EC2.DeleteDhcpOptionsRequest, callback?: (err: any, data: any) => void): Request;
    deleteFlowLogs(params: EC2.DeleteFlowLogsRequest, callback?: (err: any, data: EC2.DeleteFlowLogsResult|any) => void): Request;
    deleteInternetGateway(params: EC2.DeleteInternetGatewayRequest, callback?: (err: any, data: any) => void): Request;
    deleteKeyPair(params: EC2.DeleteKeyPairRequest, callback?: (err: any, data: any) => void): Request;
    deleteNatGateway(params: EC2.DeleteNatGatewayRequest, callback?: (err: any, data: EC2.DeleteNatGatewayResult|any) => void): Request;
    deleteNetworkAcl(params: EC2.DeleteNetworkAclRequest, callback?: (err: any, data: any) => void): Request;
    deleteNetworkAclEntry(params: EC2.DeleteNetworkAclEntryRequest, callback?: (err: any, data: any) => void): Request;
    deleteNetworkInterface(params: EC2.DeleteNetworkInterfaceRequest, callback?: (err: any, data: any) => void): Request;
    deletePlacementGroup(params: EC2.DeletePlacementGroupRequest, callback?: (err: any, data: any) => void): Request;
    deleteRoute(params: EC2.DeleteRouteRequest, callback?: (err: any, data: any) => void): Request;
    deleteRouteTable(params: EC2.DeleteRouteTableRequest, callback?: (err: any, data: any) => void): Request;
    deleteSecurityGroup(params: EC2.DeleteSecurityGroupRequest, callback?: (err: any, data: any) => void): Request;
    deleteSnapshot(params: EC2.DeleteSnapshotRequest, callback?: (err: any, data: any) => void): Request;
    deleteSpotDatafeedSubscription(params: EC2.DeleteSpotDatafeedSubscriptionRequest, callback?: (err: any, data: any) => void): Request;
    deleteSubnet(params: EC2.DeleteSubnetRequest, callback?: (err: any, data: any) => void): Request;
    deleteTags(params: EC2.DeleteTagsRequest, callback?: (err: any, data: any) => void): Request;
    deleteVolume(params: EC2.DeleteVolumeRequest, callback?: (err: any, data: any) => void): Request;
    deleteVpc(params: EC2.DeleteVpcRequest, callback?: (err: any, data: any) => void): Request;
    deleteVpcEndpoints(params: EC2.DeleteVpcEndpointsRequest, callback?: (err: any, data: EC2.DeleteVpcEndpointsResult|any) => void): Request;
    deleteVpcPeeringConnection(params: EC2.DeleteVpcPeeringConnectionRequest, callback?: (err: any, data: EC2.DeleteVpcPeeringConnectionResult|any) => void): Request;
    deleteVpnConnection(params: EC2.DeleteVpnConnectionRequest, callback?: (err: any, data: any) => void): Request;
    deleteVpnConnectionRoute(params: EC2.DeleteVpnConnectionRouteRequest, callback?: (err: any, data: any) => void): Request;
    deleteVpnGateway(params: EC2.DeleteVpnGatewayRequest, callback?: (err: any, data: any) => void): Request;
    deregisterImage(params: EC2.DeregisterImageRequest, callback?: (err: any, data: any) => void): Request;
    describeAccountAttributes(params: EC2.DescribeAccountAttributesRequest, callback?: (err: any, data: EC2.DescribeAccountAttributesResult|any) => void): Request;
    describeAddresses(params: EC2.DescribeAddressesRequest, callback?: (err: any, data: EC2.DescribeAddressesResult|any) => void): Request;
    describeAvailabilityZones(params: EC2.DescribeAvailabilityZonesRequest, callback?: (err: any, data: EC2.DescribeAvailabilityZonesResult|any) => void): Request;
    describeBundleTasks(params: EC2.DescribeBundleTasksRequest, callback?: (err: any, data: EC2.DescribeBundleTasksResult|any) => void): Request;
    describeClassicLinkInstances(params: EC2.DescribeClassicLinkInstancesRequest, callback?: (err: any, data: EC2.DescribeClassicLinkInstancesResult|any) => void): Request;
    describeConversionTasks(params: EC2.DescribeConversionTasksRequest, callback?: (err: any, data: EC2.DescribeConversionTasksResult|any) => void): Request;
    describeCustomerGateways(params: EC2.DescribeCustomerGatewaysRequest, callback?: (err: any, data: EC2.DescribeCustomerGatewaysResult|any) => void): Request;
    describeDhcpOptions(params: EC2.DescribeDhcpOptionsRequest, callback?: (err: any, data: EC2.DescribeDhcpOptionsResult|any) => void): Request;
    describeExportTasks(params: EC2.DescribeExportTasksRequest, callback?: (err: any, data: EC2.DescribeExportTasksResult|any) => void): Request;
    describeFlowLogs(params: EC2.DescribeFlowLogsRequest, callback?: (err: any, data: EC2.DescribeFlowLogsResult|any) => void): Request;
    describeHosts(params: EC2.DescribeHostsRequest, callback?: (err: any, data: EC2.DescribeHostsResult|any) => void): Request;
    describeIdFormat(params: EC2.DescribeIdFormatRequest, callback?: (err: any, data: EC2.DescribeIdFormatResult|any) => void): Request;
    describeImageAttribute(params: EC2.DescribeImageAttributeRequest, callback?: (err: any, data: EC2.ImageAttribute|any) => void): Request;
    describeImages(params: EC2.DescribeImagesRequest, callback?: (err: any, data: EC2.DescribeImagesResult|any) => void): Request;
    describeImportImageTasks(params: EC2.DescribeImportImageTasksRequest, callback?: (err: any, data: EC2.DescribeImportImageTasksResult|any) => void): Request;
    describeImportSnapshotTasks(params: EC2.DescribeImportSnapshotTasksRequest, callback?: (err: any, data: EC2.DescribeImportSnapshotTasksResult|any) => void): Request;
    describeInstanceAttribute(params: EC2.DescribeInstanceAttributeRequest, callback?: (err: any, data: EC2.InstanceAttribute|any) => void): Request;
    describeInstanceStatus(params: EC2.DescribeInstanceStatusRequest, callback?: (err: any, data: EC2.DescribeInstanceStatusResult|any) => void): Request;
    describeInstances(params: EC2.DescribeInstancesRequest, callback?: (err: any, data: EC2.DescribeInstancesResult|any) => void): Request;
    describeInternetGateways(params: EC2.DescribeInternetGatewaysRequest, callback?: (err: any, data: EC2.DescribeInternetGatewaysResult|any) => void): Request;
    describeKeyPairs(params: EC2.DescribeKeyPairsRequest, callback?: (err: any, data: EC2.DescribeKeyPairsResult|any) => void): Request;
    describeMovingAddresses(params: EC2.DescribeMovingAddressesRequest, callback?: (err: any, data: EC2.DescribeMovingAddressesResult|any) => void): Request;
    describeNatGateways(params: EC2.DescribeNatGatewaysRequest, callback?: (err: any, data: EC2.DescribeNatGatewaysResult|any) => void): Request;
    describeNetworkAcls(params: EC2.DescribeNetworkAclsRequest, callback?: (err: any, data: EC2.DescribeNetworkAclsResult|any) => void): Request;
    describeNetworkInterfaceAttribute(params: EC2.DescribeNetworkInterfaceAttributeRequest, callback?: (err: any, data: EC2.DescribeNetworkInterfaceAttributeResult|any) => void): Request;
    describeNetworkInterfaces(params: EC2.DescribeNetworkInterfacesRequest, callback?: (err: any, data: EC2.DescribeNetworkInterfacesResult|any) => void): Request;
    describePlacementGroups(params: EC2.DescribePlacementGroupsRequest, callback?: (err: any, data: EC2.DescribePlacementGroupsResult|any) => void): Request;
    describePrefixLists(params: EC2.DescribePrefixListsRequest, callback?: (err: any, data: EC2.DescribePrefixListsResult|any) => void): Request;
    describeRegions(params: EC2.DescribeRegionsRequest, callback?: (err: any, data: EC2.DescribeRegionsResult|any) => void): Request;
    describeReservedInstances(params: EC2.DescribeReservedInstancesRequest, callback?: (err: any, data: EC2.DescribeReservedInstancesResult|any) => void): Request;
    describeReservedInstancesListings(params: EC2.DescribeReservedInstancesListingsRequest, callback?: (err: any, data: EC2.DescribeReservedInstancesListingsResult|any) => void): Request;
    describeReservedInstancesModifications(params: EC2.DescribeReservedInstancesModificationsRequest, callback?: (err: any, data: EC2.DescribeReservedInstancesModificationsResult|any) => void): Request;
    describeReservedInstancesOfferings(params: EC2.DescribeReservedInstancesOfferingsRequest, callback?: (err: any, data: EC2.DescribeReservedInstancesOfferingsResult|any) => void): Request;
    describeRouteTables(params: EC2.DescribeRouteTablesRequest, callback?: (err: any, data: EC2.DescribeRouteTablesResult|any) => void): Request;
    describeScheduledInstanceAvailability(params: EC2.DescribeScheduledInstanceAvailabilityRequest, callback?: (err: any, data: EC2.DescribeScheduledInstanceAvailabilityResult|any) => void): Request;
    describeScheduledInstances(params: EC2.DescribeScheduledInstancesRequest, callback?: (err: any, data: EC2.DescribeScheduledInstancesResult|any) => void): Request;
    describeSecurityGroups(params: EC2.DescribeSecurityGroupsRequest, callback?: (err: any, data: EC2.DescribeSecurityGroupsResult|any) => void): Request;
    describeSnapshotAttribute(params: EC2.DescribeSnapshotAttributeRequest, callback?: (err: any, data: EC2.DescribeSnapshotAttributeResult|any) => void): Request;
    describeSnapshots(params: EC2.DescribeSnapshotsRequest, callback?: (err: any, data: EC2.DescribeSnapshotsResult|any) => void): Request;
    describeSpotDatafeedSubscription(params: EC2.DescribeSpotDatafeedSubscriptionRequest, callback?: (err: any, data: EC2.DescribeSpotDatafeedSubscriptionResult|any) => void): Request;
    describeSpotFleetInstances(params: EC2.DescribeSpotFleetInstancesRequest, callback?: (err: any, data: EC2.DescribeSpotFleetInstancesResponse|any) => void): Request;
    describeSpotFleetRequestHistory(params: EC2.DescribeSpotFleetRequestHistoryRequest, callback?: (err: any, data: EC2.DescribeSpotFleetRequestHistoryResponse|any) => void): Request;
    describeSpotFleetRequests(params: EC2.DescribeSpotFleetRequestsRequest, callback?: (err: any, data: EC2.DescribeSpotFleetRequestsResponse|any) => void): Request;
    describeSpotInstanceRequests(params: EC2.DescribeSpotInstanceRequestsRequest, callback?: (err: any, data: EC2.DescribeSpotInstanceRequestsResult|any) => void): Request;
    describeSpotPriceHistory(params: EC2.DescribeSpotPriceHistoryRequest, callback?: (err: any, data: EC2.DescribeSpotPriceHistoryResult|any) => void): Request;
    describeSubnets(params: EC2.DescribeSubnetsRequest, callback?: (err: any, data: EC2.DescribeSubnetsResult|any) => void): Request;
    describeTags(params: EC2.DescribeTagsRequest, callback?: (err: any, data: EC2.DescribeTagsResult|any) => void): Request;
    describeVolumeAttribute(params: EC2.DescribeVolumeAttributeRequest, callback?: (err: any, data: EC2.DescribeVolumeAttributeResult|any) => void): Request;
    describeVolumeStatus(params: EC2.DescribeVolumeStatusRequest, callback?: (err: any, data: EC2.DescribeVolumeStatusResult|any) => void): Request;
    describeVolumes(params: EC2.DescribeVolumesRequest, callback?: (err: any, data: EC2.DescribeVolumesResult|any) => void): Request;
    describeVpcAttribute(params: EC2.DescribeVpcAttributeRequest, callback?: (err: any, data: EC2.DescribeVpcAttributeResult|any) => void): Request;
    describeVpcClassicLink(params: EC2.DescribeVpcClassicLinkRequest, callback?: (err: any, data: EC2.DescribeVpcClassicLinkResult|any) => void): Request;
    describeVpcClassicLinkDnsSupport(params: EC2.DescribeVpcClassicLinkDnsSupportRequest, callback?: (err: any, data: EC2.DescribeVpcClassicLinkDnsSupportResult|any) => void): Request;
    describeVpcEndpointServices(params: EC2.DescribeVpcEndpointServicesRequest, callback?: (err: any, data: EC2.DescribeVpcEndpointServicesResult|any) => void): Request;
    describeVpcEndpoints(params: EC2.DescribeVpcEndpointsRequest, callback?: (err: any, data: EC2.DescribeVpcEndpointsResult|any) => void): Request;
    describeVpcPeeringConnections(params: EC2.DescribeVpcPeeringConnectionsRequest, callback?: (err: any, data: EC2.DescribeVpcPeeringConnectionsResult|any) => void): Request;
    describeVpcs(params: EC2.DescribeVpcsRequest, callback?: (err: any, data: EC2.DescribeVpcsResult|any) => void): Request;
    describeVpnConnections(params: EC2.DescribeVpnConnectionsRequest, callback?: (err: any, data: EC2.DescribeVpnConnectionsResult|any) => void): Request;
    describeVpnGateways(params: EC2.DescribeVpnGatewaysRequest, callback?: (err: any, data: EC2.DescribeVpnGatewaysResult|any) => void): Request;
    detachClassicLinkVpc(params: EC2.DetachClassicLinkVpcRequest, callback?: (err: any, data: EC2.DetachClassicLinkVpcResult|any) => void): Request;
    detachInternetGateway(params: EC2.DetachInternetGatewayRequest, callback?: (err: any, data: any) => void): Request;
    detachNetworkInterface(params: EC2.DetachNetworkInterfaceRequest, callback?: (err: any, data: any) => void): Request;
    detachVolume(params: EC2.DetachVolumeRequest, callback?: (err: any, data: EC2.VolumeAttachment|any) => void): Request;
    detachVpnGateway(params: EC2.DetachVpnGatewayRequest, callback?: (err: any, data: any) => void): Request;
    disableVgwRoutePropagation(params: EC2.DisableVgwRoutePropagationRequest, callback?: (err: any, data: any) => void): Request;
    disableVpcClassicLink(params: EC2.DisableVpcClassicLinkRequest, callback?: (err: any, data: EC2.DisableVpcClassicLinkResult|any) => void): Request;
    disableVpcClassicLinkDnsSupport(params: EC2.DisableVpcClassicLinkDnsSupportRequest, callback?: (err: any, data: EC2.DisableVpcClassicLinkDnsSupportResult|any) => void): Request;
    disassociateAddress(params: EC2.DisassociateAddressRequest, callback?: (err: any, data: any) => void): Request;
    disassociateRouteTable(params: EC2.DisassociateRouteTableRequest, callback?: (err: any, data: any) => void): Request;
    enableVgwRoutePropagation(params: EC2.EnableVgwRoutePropagationRequest, callback?: (err: any, data: any) => void): Request;
    enableVolumeIO(params: EC2.EnableVolumeIORequest, callback?: (err: any, data: any) => void): Request;
    enableVpcClassicLink(params: EC2.EnableVpcClassicLinkRequest, callback?: (err: any, data: EC2.EnableVpcClassicLinkResult|any) => void): Request;
    enableVpcClassicLinkDnsSupport(params: EC2.EnableVpcClassicLinkDnsSupportRequest, callback?: (err: any, data: EC2.EnableVpcClassicLinkDnsSupportResult|any) => void): Request;
    getConsoleOutput(params: EC2.GetConsoleOutputRequest, callback?: (err: any, data: EC2.GetConsoleOutputResult|any) => void): Request;
    getPasswordData(params: EC2.GetPasswordDataRequest, callback?: (err: any, data: EC2.GetPasswordDataResult|any) => void): Request;
    importImage(params: EC2.ImportImageRequest, callback?: (err: any, data: EC2.ImportImageResult|any) => void): Request;
    importInstance(params: EC2.ImportInstanceRequest, callback?: (err: any, data: EC2.ImportInstanceResult|any) => void): Request;
    importKeyPair(params: EC2.ImportKeyPairRequest, callback?: (err: any, data: EC2.ImportKeyPairResult|any) => void): Request;
    importSnapshot(params: EC2.ImportSnapshotRequest, callback?: (err: any, data: EC2.ImportSnapshotResult|any) => void): Request;
    importVolume(params: EC2.ImportVolumeRequest, callback?: (err: any, data: EC2.ImportVolumeResult|any) => void): Request;
    modifyHosts(params: EC2.ModifyHostsRequest, callback?: (err: any, data: EC2.ModifyHostsResult|any) => void): Request;
    modifyIdFormat(params: EC2.ModifyIdFormatRequest, callback?: (err: any, data: any) => void): Request;
    modifyImageAttribute(params: EC2.ModifyImageAttributeRequest, callback?: (err: any, data: any) => void): Request;
    modifyInstanceAttribute(params: EC2.ModifyInstanceAttributeRequest, callback?: (err: any, data: any) => void): Request;
    modifyInstancePlacement(params: EC2.ModifyInstancePlacementRequest, callback?: (err: any, data: EC2.ModifyInstancePlacementResult|any) => void): Request;
    modifyNetworkInterfaceAttribute(params: EC2.ModifyNetworkInterfaceAttributeRequest, callback?: (err: any, data: any) => void): Request;
    modifyReservedInstances(params: EC2.ModifyReservedInstancesRequest, callback?: (err: any, data: EC2.ModifyReservedInstancesResult|any) => void): Request;
    modifySnapshotAttribute(params: EC2.ModifySnapshotAttributeRequest, callback?: (err: any, data: any) => void): Request;
    modifySpotFleetRequest(params: EC2.ModifySpotFleetRequestRequest, callback?: (err: any, data: EC2.ModifySpotFleetRequestResponse|any) => void): Request;
    modifySubnetAttribute(params: EC2.ModifySubnetAttributeRequest, callback?: (err: any, data: any) => void): Request;
    modifyVolumeAttribute(params: EC2.ModifyVolumeAttributeRequest, callback?: (err: any, data: any) => void): Request;
    modifyVpcAttribute(params: EC2.ModifyVpcAttributeRequest, callback?: (err: any, data: any) => void): Request;
    modifyVpcEndpoint(params: EC2.ModifyVpcEndpointRequest, callback?: (err: any, data: EC2.ModifyVpcEndpointResult|any) => void): Request;
    monitorInstances(params: EC2.MonitorInstancesRequest, callback?: (err: any, data: EC2.MonitorInstancesResult|any) => void): Request;
    moveAddressToVpc(params: EC2.MoveAddressToVpcRequest, callback?: (err: any, data: EC2.MoveAddressToVpcResult|any) => void): Request;
    purchaseReservedInstancesOffering(params: EC2.PurchaseReservedInstancesOfferingRequest, callback?: (err: any, data: EC2.PurchaseReservedInstancesOfferingResult|any) => void): Request;
    purchaseScheduledInstances(params: EC2.PurchaseScheduledInstancesRequest, callback?: (err: any, data: EC2.PurchaseScheduledInstancesResult|any) => void): Request;
    rebootInstances(params: EC2.RebootInstancesRequest, callback?: (err: any, data: any) => void): Request;
    registerImage(params: EC2.RegisterImageRequest, callback?: (err: any, data: EC2.RegisterImageResult|any) => void): Request;
    rejectVpcPeeringConnection(params: EC2.RejectVpcPeeringConnectionRequest, callback?: (err: any, data: EC2.RejectVpcPeeringConnectionResult|any) => void): Request;
    releaseAddress(params: EC2.ReleaseAddressRequest, callback?: (err: any, data: any) => void): Request;
    releaseHosts(params: EC2.ReleaseHostsRequest, callback?: (err: any, data: EC2.ReleaseHostsResult|any) => void): Request;
    replaceNetworkAclAssociation(params: EC2.ReplaceNetworkAclAssociationRequest, callback?: (err: any, data: EC2.ReplaceNetworkAclAssociationResult|any) => void): Request;
    replaceNetworkAclEntry(params: EC2.ReplaceNetworkAclEntryRequest, callback?: (err: any, data: any) => void): Request;
    replaceRoute(params: EC2.ReplaceRouteRequest, callback?: (err: any, data: any) => void): Request;
    replaceRouteTableAssociation(params: EC2.ReplaceRouteTableAssociationRequest, callback?: (err: any, data: EC2.ReplaceRouteTableAssociationResult|any) => void): Request;
    reportInstanceStatus(params: EC2.ReportInstanceStatusRequest, callback?: (err: any, data: any) => void): Request;
    requestSpotFleet(params: EC2.RequestSpotFleetRequest, callback?: (err: any, data: EC2.RequestSpotFleetResponse|any) => void): Request;
    requestSpotInstances(params: EC2.RequestSpotInstancesRequest, callback?: (err: any, data: EC2.RequestSpotInstancesResult|any) => void): Request;
    resetImageAttribute(params: EC2.ResetImageAttributeRequest, callback?: (err: any, data: any) => void): Request;
    resetInstanceAttribute(params: EC2.ResetInstanceAttributeRequest, callback?: (err: any, data: any) => void): Request;
    resetNetworkInterfaceAttribute(params: EC2.ResetNetworkInterfaceAttributeRequest, callback?: (err: any, data: any) => void): Request;
    resetSnapshotAttribute(params: EC2.ResetSnapshotAttributeRequest, callback?: (err: any, data: any) => void): Request;
    restoreAddressToClassic(params: EC2.RestoreAddressToClassicRequest, callback?: (err: any, data: EC2.RestoreAddressToClassicResult|any) => void): Request;
    revokeSecurityGroupEgress(params: EC2.RevokeSecurityGroupEgressRequest, callback?: (err: any, data: any) => void): Request;
    revokeSecurityGroupIngress(params: EC2.RevokeSecurityGroupIngressRequest, callback?: (err: any, data: any) => void): Request;
    runInstances(params: EC2.RunInstancesRequest, callback?: (err: any, data: EC2.Reservation|any) => void): Request;
    runScheduledInstances(params: EC2.RunScheduledInstancesRequest, callback?: (err: any, data: EC2.RunScheduledInstancesResult|any) => void): Request;
    startInstances(params: EC2.StartInstancesRequest, callback?: (err: any, data: EC2.StartInstancesResult|any) => void): Request;
    stopInstances(params: EC2.StopInstancesRequest, callback?: (err: any, data: EC2.StopInstancesResult|any) => void): Request;
    terminateInstances(params: EC2.TerminateInstancesRequest, callback?: (err: any, data: EC2.TerminateInstancesResult|any) => void): Request;
    unassignPrivateIpAddresses(params: EC2.UnassignPrivateIpAddressesRequest, callback?: (err: any, data: any) => void): Request;
    unmonitorInstances(params: EC2.UnmonitorInstancesRequest, callback?: (err: any, data: EC2.UnmonitorInstancesResult|any) => void): Request;

  }

  export module EC2 {
    export type AccountAttributeList = AccountAttribute[];
    export type AccountAttributeName = string;
    export type AccountAttributeNameStringList = AccountAttributeName[];
    export type AccountAttributeValueList = AccountAttributeValue[];
    export type ActiveInstanceSet = ActiveInstance[];
    export type AddressList = Address[];
    export type Affinity = string;
    export type AllocationIdList = String[];
    export type AllocationState = string;
    export type AllocationStrategy = string;
    export type ArchitectureValues = string;
    export type AttachmentStatus = string;
    export type AutoPlacement = string;
    export type AvailabilityZoneList = AvailabilityZone[];
    export type AvailabilityZoneMessageList = AvailabilityZoneMessage[];
    export type AvailabilityZoneState = string;
    export type AvailableInstanceCapacityList = InstanceCapacity[];
    export type BatchState = string;
    export type Blob = any;    // type: blob
    export type BlockDeviceMappingList = BlockDeviceMapping[];
    export type BlockDeviceMappingRequestList = BlockDeviceMapping[];
    export type Boolean = boolean;
    export type BundleIdStringList = String[];
    export type BundleTaskList = BundleTask[];
    export type BundleTaskState = string;
    export type CancelBatchErrorCode = string;
    export type CancelSpotFleetRequestsErrorSet = CancelSpotFleetRequestsErrorItem[];
    export type CancelSpotFleetRequestsSuccessSet = CancelSpotFleetRequestsSuccessItem[];
    export type CancelSpotInstanceRequestState = string;
    export type CancelledSpotInstanceRequestList = CancelledSpotInstanceRequest[];
    export type ClassicLinkDnsSupportList = ClassicLinkDnsSupport[];
    export type ClassicLinkInstanceList = ClassicLinkInstance[];
    export type ContainerFormat = string;
    export type ConversionIdStringList = String[];
    export type ConversionTaskState = string;
    export type CreateVolumePermissionList = CreateVolumePermission[];
    export type CurrencyCodeValues = string;
    export type CustomerGatewayIdStringList = String[];
    export type CustomerGatewayList = CustomerGateway[];
    export type DatafeedSubscriptionState = string;
    export type DateTime = number;
    export type DescribeConversionTaskList = ConversionTask[];
    export type DeviceType = string;
    export type DhcpConfigurationList = DhcpConfiguration[];
    export type DhcpConfigurationValueList = AttributeValue[];
    export type DhcpOptionsIdStringList = String[];
    export type DhcpOptionsList = DhcpOptions[];
    export type DiskImageFormat = string;
    export type DiskImageList = DiskImage[];
    export type DomainType = string;
    export type Double = number;
    export type EventCode = string;
    export type EventType = string;
    export type ExcessCapacityTerminationPolicy = string;
    export type ExecutableByStringList = String[];
    export type ExportEnvironment = string;
    export type ExportTaskIdStringList = String[];
    export type ExportTaskList = ExportTask[];
    export type ExportTaskState = string;
    export type FilterList = Filter[];
    export type Float = number;
    export type FlowLogSet = FlowLog[];
    export type FlowLogsResourceType = string;
    export type GatewayType = string;
    export type GroupIdStringList = String[];
    export type GroupIdentifierList = GroupIdentifier[];
    export type GroupNameStringList = String[];
    export type HistoryRecords = HistoryRecord[];
    export type HostInstanceList = HostInstance[];
    export type HostList = Host[];
    export type HostTenancy = string;
    export type HypervisorType = string;
    export type IdFormatList = IdFormat[];
    export type ImageAttributeName = string;
    export type ImageDiskContainerList = ImageDiskContainer[];
    export type ImageIdStringList = String[];
    export type ImageList = Image[];
    export type ImageState = string;
    export type ImageTypeValues = string;
    export type ImportImageTaskList = ImportImageTask[];
    export type ImportInstanceVolumeDetailSet = ImportInstanceVolumeDetailItem[];
    export type ImportSnapshotTaskList = ImportSnapshotTask[];
    export type ImportTaskIdList = String[];
    export type InstanceAttributeName = string;
    export type InstanceBlockDeviceMappingList = InstanceBlockDeviceMapping[];
    export type InstanceBlockDeviceMappingSpecificationList = InstanceBlockDeviceMappingSpecification[];
    export type InstanceCountList = InstanceCount[];
    export type InstanceIdSet = String[];
    export type InstanceIdStringList = String[];
    export type InstanceLifecycleType = string;
    export type InstanceList = Instance[];
    export type InstanceMonitoringList = InstanceMonitoring[];
    export type InstanceNetworkInterfaceList = InstanceNetworkInterface[];
    export type InstanceNetworkInterfaceSpecificationList = InstanceNetworkInterfaceSpecification[];
    export type InstancePrivateIpAddressList = InstancePrivateIpAddress[];
    export type InstanceStateChangeList = InstanceStateChange[];
    export type InstanceStateName = string;
    export type InstanceStatusDetailsList = InstanceStatusDetails[];
    export type InstanceStatusEventList = InstanceStatusEvent[];
    export type InstanceStatusList = InstanceStatus[];
    export type InstanceType = string;
    export type InstanceTypeList = InstanceType[];
    export type Integer = number;
    export type InternetGatewayAttachmentList = InternetGatewayAttachment[];
    export type InternetGatewayList = InternetGateway[];
    export type IpPermissionList = IpPermission[];
    export type IpRangeList = IpRange[];
    export type KeyNameStringList = String[];
    export type KeyPairList = KeyPairInfo[];
    export type LaunchPermissionList = LaunchPermission[];
    export type LaunchSpecsList = SpotFleetLaunchSpecification[];    // min: 1
    export type ListingState = string;
    export type ListingStatus = string;
    export type Long = number;
    export type MaxResults = number;    // max: 255, min: 5
    export type MonitoringState = string;
    export type MoveStatus = string;
    export type MovingAddressStatusSet = MovingAddressStatus[];
    export type NatGatewayAddressList = NatGatewayAddress[];
    export type NatGatewayList = NatGateway[];
    export type NatGatewayState = string;
    export type NetworkAclAssociationList = NetworkAclAssociation[];
    export type NetworkAclEntryList = NetworkAclEntry[];
    export type NetworkAclList = NetworkAcl[];
    export type NetworkInterfaceAttribute = string;
    export type NetworkInterfaceIdList = String[];
    export type NetworkInterfaceList = NetworkInterface[];
    export type NetworkInterfacePrivateIpAddressList = NetworkInterfacePrivateIpAddress[];
    export type NetworkInterfaceStatus = string;
    export type NetworkInterfaceType = string;
    export type NewDhcpConfigurationList = NewDhcpConfiguration[];
    export type NextToken = string;    // max: 1024, min: 1
    export type OccurrenceDayRequestSet = Integer[];
    export type OccurrenceDaySet = Integer[];
    export type OfferingTypeValues = string;
    export type OperationType = string;
    export type OwnerStringList = String[];
    export type PermissionGroup = string;
    export type PlacementGroupList = PlacementGroup[];
    export type PlacementGroupState = string;
    export type PlacementGroupStringList = String[];
    export type PlacementStrategy = string;
    export type PlatformValues = string;
    export type PrefixListIdList = PrefixListId[];
    export type PrefixListSet = PrefixList[];
    export type PriceScheduleList = PriceSchedule[];
    export type PriceScheduleSpecificationList = PriceScheduleSpecification[];
    export type PricingDetailsList = PricingDetail[];
    export type PrivateIpAddressConfigSet = ScheduledInstancesPrivateIpAddressConfig[];
    export type PrivateIpAddressSpecificationList = PrivateIpAddressSpecification[];
    export type PrivateIpAddressStringList = String[];
    export type ProductCodeList = ProductCode[];
    export type ProductCodeStringList = String[];
    export type ProductCodeValues = string;
    export type ProductDescriptionList = String[];
    export type PropagatingVgwList = PropagatingVgw[];
    export type PublicIpStringList = String[];
    export type PurchaseRequestSet = PurchaseRequest[];    // min: 1
    export type PurchasedScheduledInstanceSet = ScheduledInstance[];
    export type RIProductDescription = string;
    export type ReasonCodesList = ReportInstanceReasonCodes[];
    export type RecurringChargeFrequency = string;
    export type RecurringChargesList = RecurringCharge[];
    export type RegionList = Region[];
    export type RegionNameStringList = String[];
    export type ReportInstanceReasonCodes = string;
    export type ReportStatusType = string;
    export type RequestHostIdList = String[];
    export type ReservationList = Reservation[];
    export type ReservedInstanceState = string;
    export type ReservedInstancesConfigurationList = ReservedInstancesConfiguration[];
    export type ReservedInstancesIdStringList = String[];
    export type ReservedInstancesList = ReservedInstances[];
    export type ReservedInstancesListingList = ReservedInstancesListing[];
    export type ReservedInstancesModificationIdStringList = String[];
    export type ReservedInstancesModificationList = ReservedInstancesModification[];
    export type ReservedInstancesModificationResultList = ReservedInstancesModificationResult[];
    export type ReservedInstancesOfferingIdStringList = String[];
    export type ReservedInstancesOfferingList = ReservedInstancesOffering[];
    export type ReservedIntancesIds = ReservedInstancesId[];
    export type ResetImageAttributeName = string;
    export type ResourceIdList = String[];
    export type ResourceType = string;
    export type ResponseHostIdList = String[];
    export type RestorableByStringList = String[];
    export type RouteList = Route[];
    export type RouteOrigin = string;
    export type RouteState = string;
    export type RouteTableAssociationList = RouteTableAssociation[];
    export type RouteTableList = RouteTable[];
    export type RuleAction = string;
    export type ScheduledInstanceAvailabilitySet = ScheduledInstanceAvailability[];
    export type ScheduledInstanceIdRequestSet = String[];
    export type ScheduledInstanceSet = ScheduledInstance[];
    export type ScheduledInstancesBlockDeviceMappingSet = ScheduledInstancesBlockDeviceMapping[];
    export type ScheduledInstancesNetworkInterfaceSet = ScheduledInstancesNetworkInterface[];
    export type ScheduledInstancesSecurityGroupIdSet = String[];
    export type SecurityGroupIdStringList = String[];
    export type SecurityGroupList = SecurityGroup[];
    export type SecurityGroupStringList = String[];
    export type ShutdownBehavior = string;
    export type SnapshotAttributeName = string;
    export type SnapshotDetailList = SnapshotDetail[];
    export type SnapshotIdStringList = String[];
    export type SnapshotList = Snapshot[];
    export type SnapshotState = string;
    export type SpotFleetRequestConfigSet = SpotFleetRequestConfig[];
    export type SpotInstanceRequestIdList = String[];
    export type SpotInstanceRequestList = SpotInstanceRequest[];
    export type SpotInstanceState = string;
    export type SpotInstanceType = string;
    export type SpotPriceHistoryList = SpotPrice[];
    export type State = string;
    export type Status = string;
    export type StatusName = string;
    export type StatusType = string;
    export type String = string;
    export type SubnetIdStringList = String[];
    export type SubnetList = Subnet[];
    export type SubnetState = string;
    export type SummaryStatus = string;
    export type TagDescriptionList = TagDescription[];
    export type TagList = Tag[];
    export type TelemetryStatus = string;
    export type Tenancy = string;
    export type TrafficType = string;
    export type UnsuccessfulItemList = UnsuccessfulItem[];
    export type UnsuccessfulItemSet = UnsuccessfulItem[];
    export type UserGroupStringList = String[];
    export type UserIdGroupPairList = UserIdGroupPair[];
    export type UserIdStringList = String[];
    export type ValueStringList = String[];
    export type VgwTelemetryList = VgwTelemetry[];
    export type VirtualizationType = string;
    export type VolumeAttachmentList = VolumeAttachment[];
    export type VolumeAttachmentState = string;
    export type VolumeAttributeName = string;
    export type VolumeIdStringList = String[];
    export type VolumeList = Volume[];
    export type VolumeState = string;
    export type VolumeStatusActionsList = VolumeStatusAction[];
    export type VolumeStatusDetailsList = VolumeStatusDetails[];
    export type VolumeStatusEventsList = VolumeStatusEvent[];
    export type VolumeStatusInfoStatus = string;
    export type VolumeStatusList = VolumeStatusItem[];
    export type VolumeStatusName = string;
    export type VolumeType = string;
    export type VpcAttachmentList = VpcAttachment[];
    export type VpcAttributeName = string;
    export type VpcClassicLinkIdList = String[];
    export type VpcClassicLinkList = VpcClassicLink[];
    export type VpcEndpointSet = VpcEndpoint[];
    export type VpcIdStringList = String[];
    export type VpcList = Vpc[];
    export type VpcPeeringConnectionList = VpcPeeringConnection[];
    export type VpcPeeringConnectionStateReasonCode = string;
    export type VpcState = string;
    export type VpnConnectionIdStringList = String[];
    export type VpnConnectionList = VpnConnection[];
    export type VpnGatewayIdStringList = String[];
    export type VpnGatewayList = VpnGateway[];
    export type VpnState = string;
    export type VpnStaticRouteList = VpnStaticRoute[];
    export type VpnStaticRouteSource = string;
    export type ZoneNameStringList = String[];

    export interface AcceptVpcPeeringConnectionRequest {
        DryRun?: Boolean;
        VpcPeeringConnectionId?: String;
    }
    export interface AcceptVpcPeeringConnectionResult {
        VpcPeeringConnection?: VpcPeeringConnection;
    }
    export interface AccountAttribute {
        AttributeName?: String;
        AttributeValues?: AccountAttributeValueList;
    }
    export interface AccountAttributeValue {
        AttributeValue?: String;
    }
    export interface ActiveInstance {
        InstanceType?: String;
        InstanceId?: String;
        SpotInstanceRequestId?: String;
    }
    export interface Address {
        InstanceId?: String;
        PublicIp?: String;
        AllocationId?: String;
        AssociationId?: String;
        Domain?: DomainType;
        NetworkInterfaceId?: String;
        NetworkInterfaceOwnerId?: String;
        PrivateIpAddress?: String;
    }
    export interface AllocateAddressRequest {
        DryRun?: Boolean;
        Domain?: DomainType;
    }
    export interface AllocateAddressResult {
        PublicIp?: String;
        Domain?: DomainType;
        AllocationId?: String;
    }
    export interface AllocateHostsRequest {
        AutoPlacement?: AutoPlacement;
        ClientToken?: String;
        InstanceType: String;
        Quantity: Integer;
        AvailabilityZone: String;
    }
    export interface AllocateHostsResult {
        HostIds?: ResponseHostIdList;
    }
    export interface AssignPrivateIpAddressesRequest {
        NetworkInterfaceId: String;
        PrivateIpAddresses?: PrivateIpAddressStringList;
        SecondaryPrivateIpAddressCount?: Integer;
        AllowReassignment?: Boolean;
    }
    export interface AssociateAddressRequest {
        DryRun?: Boolean;
        InstanceId?: String;
        PublicIp?: String;
        AllocationId?: String;
        NetworkInterfaceId?: String;
        PrivateIpAddress?: String;
        AllowReassociation?: Boolean;
    }
    export interface AssociateAddressResult {
        AssociationId?: String;
    }
    export interface AssociateDhcpOptionsRequest {
        DryRun?: Boolean;
        DhcpOptionsId: String;
        VpcId: String;
    }
    export interface AssociateRouteTableRequest {
        DryRun?: Boolean;
        SubnetId: String;
        RouteTableId: String;
    }
    export interface AssociateRouteTableResult {
        AssociationId?: String;
    }
    export interface AttachClassicLinkVpcRequest {
        DryRun?: Boolean;
        InstanceId: String;
        VpcId: String;
        Groups: GroupIdStringList;
    }
    export interface AttachClassicLinkVpcResult {
        Return?: Boolean;
    }
    export interface AttachInternetGatewayRequest {
        DryRun?: Boolean;
        InternetGatewayId: String;
        VpcId: String;
    }
    export interface AttachNetworkInterfaceRequest {
        DryRun?: Boolean;
        NetworkInterfaceId: String;
        InstanceId: String;
        DeviceIndex: Integer;
    }
    export interface AttachNetworkInterfaceResult {
        AttachmentId?: String;
    }
    export interface AttachVolumeRequest {
        DryRun?: Boolean;
        VolumeId: String;
        InstanceId: String;
        Device: String;
    }
    export interface AttachVpnGatewayRequest {
        DryRun?: Boolean;
        VpnGatewayId: String;
        VpcId: String;
    }
    export interface AttachVpnGatewayResult {
        VpcAttachment?: VpcAttachment;
    }
    export interface AttributeBooleanValue {
        Value?: Boolean;
    }
    export interface AttributeValue {
        Value?: String;
    }
    export interface AuthorizeSecurityGroupEgressRequest {
        DryRun?: Boolean;
        GroupId: String;
        SourceSecurityGroupName?: String;
        SourceSecurityGroupOwnerId?: String;
        IpProtocol?: String;
        FromPort?: Integer;
        ToPort?: Integer;
        CidrIp?: String;
        IpPermissions?: IpPermissionList;
    }
    export interface AuthorizeSecurityGroupIngressRequest {
        DryRun?: Boolean;
        GroupName?: String;
        GroupId?: String;
        SourceSecurityGroupName?: String;
        SourceSecurityGroupOwnerId?: String;
        IpProtocol?: String;
        FromPort?: Integer;
        ToPort?: Integer;
        CidrIp?: String;
        IpPermissions?: IpPermissionList;
    }
    export interface AvailabilityZone {
        ZoneName?: String;
        State?: AvailabilityZoneState;
        RegionName?: String;
        Messages?: AvailabilityZoneMessageList;
    }
    export interface AvailabilityZoneMessage {
        Message?: String;
    }
    export interface AvailableCapacity {
        AvailableInstanceCapacity?: AvailableInstanceCapacityList;
        AvailableVCpus?: Integer;
    }
    export interface BlobAttributeValue {
        Value?: Blob;
    }
    export interface BlockDeviceMapping {
        VirtualName?: String;
        DeviceName?: String;
        Ebs?: EbsBlockDevice;
        NoDevice?: String;
    }
    export interface BundleInstanceRequest {
        DryRun?: Boolean;
        InstanceId: String;
        Storage: Storage;
    }
    export interface BundleInstanceResult {
        BundleTask?: BundleTask;
    }
    export interface BundleTask {
        InstanceId?: String;
        BundleId?: String;
        State?: BundleTaskState;
        StartTime?: DateTime;
        UpdateTime?: DateTime;
        Storage?: Storage;
        Progress?: String;
        BundleTaskError?: BundleTaskError;
    }
    export interface BundleTaskError {
        Code?: String;
        Message?: String;
    }
    export interface CancelBundleTaskRequest {
        DryRun?: Boolean;
        BundleId: String;
    }
    export interface CancelBundleTaskResult {
        BundleTask?: BundleTask;
    }
    export interface CancelConversionRequest {
        DryRun?: Boolean;
        ConversionTaskId: String;
        ReasonMessage?: String;
    }
    export interface CancelExportTaskRequest {
        ExportTaskId: String;
    }
    export interface CancelImportTaskRequest {
        DryRun?: Boolean;
        ImportTaskId?: String;
        CancelReason?: String;
    }
    export interface CancelImportTaskResult {
        ImportTaskId?: String;
        State?: String;
        PreviousState?: String;
    }
    export interface CancelReservedInstancesListingRequest {
        ReservedInstancesListingId: String;
    }
    export interface CancelReservedInstancesListingResult {
        ReservedInstancesListings?: ReservedInstancesListingList;
    }
    export interface CancelSpotFleetRequestsError {
        Code: CancelBatchErrorCode;
        Message: String;
    }
    export interface CancelSpotFleetRequestsErrorItem {
        SpotFleetRequestId: String;
        Error: CancelSpotFleetRequestsError;
    }
    export interface CancelSpotFleetRequestsRequest {
        DryRun?: Boolean;
        SpotFleetRequestIds: ValueStringList;
        TerminateInstances: Boolean;
    }
    export interface CancelSpotFleetRequestsResponse {
        UnsuccessfulFleetRequests?: CancelSpotFleetRequestsErrorSet;
        SuccessfulFleetRequests?: CancelSpotFleetRequestsSuccessSet;
    }
    export interface CancelSpotFleetRequestsSuccessItem {
        SpotFleetRequestId: String;
        CurrentSpotFleetRequestState: BatchState;
        PreviousSpotFleetRequestState: BatchState;
    }
    export interface CancelSpotInstanceRequestsRequest {
        DryRun?: Boolean;
        SpotInstanceRequestIds: SpotInstanceRequestIdList;
    }
    export interface CancelSpotInstanceRequestsResult {
        CancelledSpotInstanceRequests?: CancelledSpotInstanceRequestList;
    }
    export interface CancelledSpotInstanceRequest {
        SpotInstanceRequestId?: String;
        State?: CancelSpotInstanceRequestState;
    }
    export interface ClassicLinkDnsSupport {
        VpcId?: String;
        ClassicLinkDnsSupported?: Boolean;
    }
    export interface ClassicLinkInstance {
        InstanceId?: String;
        VpcId?: String;
        Groups?: GroupIdentifierList;
        Tags?: TagList;
    }
    export interface ClientData {
        UploadStart?: DateTime;
        UploadEnd?: DateTime;
        UploadSize?: Double;
        Comment?: String;
    }
    export interface ConfirmProductInstanceRequest {
        DryRun?: Boolean;
        ProductCode: String;
        InstanceId: String;
    }
    export interface ConfirmProductInstanceResult {
        OwnerId?: String;
        Return?: Boolean;
    }
    export interface ConversionTask {
        ConversionTaskId: String;
        ExpirationTime?: String;
        ImportInstance?: ImportInstanceTaskDetails;
        ImportVolume?: ImportVolumeTaskDetails;
        State: ConversionTaskState;
        StatusMessage?: String;
        Tags?: TagList;
    }
    export interface CopyImageRequest {
        DryRun?: Boolean;
        SourceRegion: String;
        SourceImageId: String;
        Name: String;
        Description?: String;
        ClientToken?: String;
        Encrypted?: Boolean;
        KmsKeyId?: String;
    }
    export interface CopyImageResult {
        ImageId?: String;
    }
    export interface CopySnapshotRequest {
        DryRun?: Boolean;
        SourceRegion: String;
        SourceSnapshotId: String;
        Description?: String;
        DestinationRegion?: String;
        PresignedUrl?: String;
        Encrypted?: Boolean;
        KmsKeyId?: String;
    }
    export interface CopySnapshotResult {
        SnapshotId?: String;
    }
    export interface CreateCustomerGatewayRequest {
        DryRun?: Boolean;
        Type: GatewayType;
        PublicIp: String;
        BgpAsn: Integer;
    }
    export interface CreateCustomerGatewayResult {
        CustomerGateway?: CustomerGateway;
    }
    export interface CreateDhcpOptionsRequest {
        DryRun?: Boolean;
        DhcpConfigurations: NewDhcpConfigurationList;
    }
    export interface CreateDhcpOptionsResult {
        DhcpOptions?: DhcpOptions;
    }
    export interface CreateFlowLogsRequest {
        ResourceIds: ValueStringList;
        ResourceType: FlowLogsResourceType;
        TrafficType: TrafficType;
        LogGroupName: String;
        DeliverLogsPermissionArn: String;
        ClientToken?: String;
    }
    export interface CreateFlowLogsResult {
        FlowLogIds?: ValueStringList;
        ClientToken?: String;
        Unsuccessful?: UnsuccessfulItemSet;
    }
    export interface CreateImageRequest {
        DryRun?: Boolean;
        InstanceId: String;
        Name: String;
        Description?: String;
        NoReboot?: Boolean;
        BlockDeviceMappings?: BlockDeviceMappingRequestList;
    }
    export interface CreateImageResult {
        ImageId?: String;
    }
    export interface CreateInstanceExportTaskRequest {
        Description?: String;
        InstanceId: String;
        TargetEnvironment?: ExportEnvironment;
        ExportToS3Task?: ExportToS3TaskSpecification;
    }
    export interface CreateInstanceExportTaskResult {
        ExportTask?: ExportTask;
    }
    export interface CreateInternetGatewayRequest {
        DryRun?: Boolean;
    }
    export interface CreateInternetGatewayResult {
        InternetGateway?: InternetGateway;
    }
    export interface CreateKeyPairRequest {
        DryRun?: Boolean;
        KeyName: String;
    }
    export interface CreateNatGatewayRequest {
        SubnetId: String;
        AllocationId: String;
        ClientToken?: String;
    }
    export interface CreateNatGatewayResult {
        NatGateway?: NatGateway;
        ClientToken?: String;
    }
    export interface CreateNetworkAclEntryRequest {
        DryRun?: Boolean;
        NetworkAclId: String;
        RuleNumber: Integer;
        Protocol: String;
        RuleAction: RuleAction;
        Egress: Boolean;
        CidrBlock: String;
        IcmpTypeCode?: IcmpTypeCode;
        PortRange?: PortRange;
    }
    export interface CreateNetworkAclRequest {
        DryRun?: Boolean;
        VpcId: String;
    }
    export interface CreateNetworkAclResult {
        NetworkAcl?: NetworkAcl;
    }
    export interface CreateNetworkInterfaceRequest {
        SubnetId: String;
        Description?: String;
        PrivateIpAddress?: String;
        Groups?: SecurityGroupIdStringList;
        PrivateIpAddresses?: PrivateIpAddressSpecificationList;
        SecondaryPrivateIpAddressCount?: Integer;
        DryRun?: Boolean;
    }
    export interface CreateNetworkInterfaceResult {
        NetworkInterface?: NetworkInterface;
    }
    export interface CreatePlacementGroupRequest {
        DryRun?: Boolean;
        GroupName: String;
        Strategy: PlacementStrategy;
    }
    export interface CreateReservedInstancesListingRequest {
        ReservedInstancesId: String;
        InstanceCount: Integer;
        PriceSchedules: PriceScheduleSpecificationList;
        ClientToken: String;
    }
    export interface CreateReservedInstancesListingResult {
        ReservedInstancesListings?: ReservedInstancesListingList;
    }
    export interface CreateRouteRequest {
        DryRun?: Boolean;
        RouteTableId: String;
        DestinationCidrBlock: String;
        GatewayId?: String;
        InstanceId?: String;
        NetworkInterfaceId?: String;
        VpcPeeringConnectionId?: String;
        NatGatewayId?: String;
    }
    export interface CreateRouteResult {
        Return?: Boolean;
    }
    export interface CreateRouteTableRequest {
        DryRun?: Boolean;
        VpcId: String;
    }
    export interface CreateRouteTableResult {
        RouteTable?: RouteTable;
    }
    export interface CreateSecurityGroupRequest {
        DryRun?: Boolean;
        GroupName: String;
        Description: String;
        VpcId?: String;
    }
    export interface CreateSecurityGroupResult {
        GroupId?: String;
    }
    export interface CreateSnapshotRequest {
        DryRun?: Boolean;
        VolumeId: String;
        Description?: String;
    }
    export interface CreateSpotDatafeedSubscriptionRequest {
        DryRun?: Boolean;
        Bucket: String;
        Prefix?: String;
    }
    export interface CreateSpotDatafeedSubscriptionResult {
        SpotDatafeedSubscription?: SpotDatafeedSubscription;
    }
    export interface CreateSubnetRequest {
        DryRun?: Boolean;
        VpcId: String;
        CidrBlock: String;
        AvailabilityZone?: String;
    }
    export interface CreateSubnetResult {
        Subnet?: Subnet;
    }
    export interface CreateTagsRequest {
        DryRun?: Boolean;
        Resources: ResourceIdList;
        Tags: TagList;
    }
    export interface CreateVolumePermission {
        UserId?: String;
        Group?: PermissionGroup;
    }
    export interface CreateVolumePermissionModifications {
        Add?: CreateVolumePermissionList;
        Remove?: CreateVolumePermissionList;
    }
    export interface CreateVolumeRequest {
        DryRun?: Boolean;
        Size?: Integer;
        SnapshotId?: String;
        AvailabilityZone: String;
        VolumeType?: VolumeType;
        Iops?: Integer;
        Encrypted?: Boolean;
        KmsKeyId?: String;
    }
    export interface CreateVpcEndpointRequest {
        DryRun?: Boolean;
        VpcId: String;
        ServiceName: String;
        PolicyDocument?: String;
        RouteTableIds?: ValueStringList;
        ClientToken?: String;
    }
    export interface CreateVpcEndpointResult {
        VpcEndpoint?: VpcEndpoint;
        ClientToken?: String;
    }
    export interface CreateVpcPeeringConnectionRequest {
        DryRun?: Boolean;
        VpcId?: String;
        PeerVpcId?: String;
        PeerOwnerId?: String;
    }
    export interface CreateVpcPeeringConnectionResult {
        VpcPeeringConnection?: VpcPeeringConnection;
    }
    export interface CreateVpcRequest {
        DryRun?: Boolean;
        CidrBlock: String;
        InstanceTenancy?: Tenancy;
    }
    export interface CreateVpcResult {
        Vpc?: Vpc;
    }
    export interface CreateVpnConnectionRequest {
        DryRun?: Boolean;
        Type: String;
        CustomerGatewayId: String;
        VpnGatewayId: String;
        Options?: VpnConnectionOptionsSpecification;
    }
    export interface CreateVpnConnectionResult {
        VpnConnection?: VpnConnection;
    }
    export interface CreateVpnConnectionRouteRequest {
        VpnConnectionId: String;
        DestinationCidrBlock: String;
    }
    export interface CreateVpnGatewayRequest {
        DryRun?: Boolean;
        Type: GatewayType;
        AvailabilityZone?: String;
    }
    export interface CreateVpnGatewayResult {
        VpnGateway?: VpnGateway;
    }
    export interface CustomerGateway {
        CustomerGatewayId?: String;
        State?: String;
        Type?: String;
        IpAddress?: String;
        BgpAsn?: String;
        Tags?: TagList;
    }
    export interface DeleteCustomerGatewayRequest {
        DryRun?: Boolean;
        CustomerGatewayId: String;
    }
    export interface DeleteDhcpOptionsRequest {
        DryRun?: Boolean;
        DhcpOptionsId: String;
    }
    export interface DeleteFlowLogsRequest {
        FlowLogIds: ValueStringList;
    }
    export interface DeleteFlowLogsResult {
        Unsuccessful?: UnsuccessfulItemSet;
    }
    export interface DeleteInternetGatewayRequest {
        DryRun?: Boolean;
        InternetGatewayId: String;
    }
    export interface DeleteKeyPairRequest {
        DryRun?: Boolean;
        KeyName: String;
    }
    export interface DeleteNatGatewayRequest {
        NatGatewayId: String;
    }
    export interface DeleteNatGatewayResult {
        NatGatewayId?: String;
    }
    export interface DeleteNetworkAclEntryRequest {
        DryRun?: Boolean;
        NetworkAclId: String;
        RuleNumber: Integer;
        Egress: Boolean;
    }
    export interface DeleteNetworkAclRequest {
        DryRun?: Boolean;
        NetworkAclId: String;
    }
    export interface DeleteNetworkInterfaceRequest {
        DryRun?: Boolean;
        NetworkInterfaceId: String;
    }
    export interface DeletePlacementGroupRequest {
        DryRun?: Boolean;
        GroupName: String;
    }
    export interface DeleteRouteRequest {
        DryRun?: Boolean;
        RouteTableId: String;
        DestinationCidrBlock: String;
    }
    export interface DeleteRouteTableRequest {
        DryRun?: Boolean;
        RouteTableId: String;
    }
    export interface DeleteSecurityGroupRequest {
        DryRun?: Boolean;
        GroupName?: String;
        GroupId?: String;
    }
    export interface DeleteSnapshotRequest {
        DryRun?: Boolean;
        SnapshotId: String;
    }
    export interface DeleteSpotDatafeedSubscriptionRequest {
        DryRun?: Boolean;
    }
    export interface DeleteSubnetRequest {
        DryRun?: Boolean;
        SubnetId: String;
    }
    export interface DeleteTagsRequest {
        DryRun?: Boolean;
        Resources: ResourceIdList;
        Tags?: TagList;
    }
    export interface DeleteVolumeRequest {
        DryRun?: Boolean;
        VolumeId: String;
    }
    export interface DeleteVpcEndpointsRequest {
        DryRun?: Boolean;
        VpcEndpointIds: ValueStringList;
    }
    export interface DeleteVpcEndpointsResult {
        Unsuccessful?: UnsuccessfulItemSet;
    }
    export interface DeleteVpcPeeringConnectionRequest {
        DryRun?: Boolean;
        VpcPeeringConnectionId: String;
    }
    export interface DeleteVpcPeeringConnectionResult {
        Return?: Boolean;
    }
    export interface DeleteVpcRequest {
        DryRun?: Boolean;
        VpcId: String;
    }
    export interface DeleteVpnConnectionRequest {
        DryRun?: Boolean;
        VpnConnectionId: String;
    }
    export interface DeleteVpnConnectionRouteRequest {
        VpnConnectionId: String;
        DestinationCidrBlock: String;
    }
    export interface DeleteVpnGatewayRequest {
        DryRun?: Boolean;
        VpnGatewayId: String;
    }
    export interface DeregisterImageRequest {
        DryRun?: Boolean;
        ImageId: String;
    }
    export interface DescribeAccountAttributesRequest {
        DryRun?: Boolean;
        AttributeNames?: AccountAttributeNameStringList;
    }
    export interface DescribeAccountAttributesResult {
        AccountAttributes?: AccountAttributeList;
    }
    export interface DescribeAddressesRequest {
        DryRun?: Boolean;
        PublicIps?: PublicIpStringList;
        Filters?: FilterList;
        AllocationIds?: AllocationIdList;
    }
    export interface DescribeAddressesResult {
        Addresses?: AddressList;
    }
    export interface DescribeAvailabilityZonesRequest {
        DryRun?: Boolean;
        ZoneNames?: ZoneNameStringList;
        Filters?: FilterList;
    }
    export interface DescribeAvailabilityZonesResult {
        AvailabilityZones?: AvailabilityZoneList;
    }
    export interface DescribeBundleTasksRequest {
        DryRun?: Boolean;
        BundleIds?: BundleIdStringList;
        Filters?: FilterList;
    }
    export interface DescribeBundleTasksResult {
        BundleTasks?: BundleTaskList;
    }
    export interface DescribeClassicLinkInstancesRequest {
        DryRun?: Boolean;
        InstanceIds?: InstanceIdStringList;
        Filters?: FilterList;
        NextToken?: String;
        MaxResults?: Integer;
    }
    export interface DescribeClassicLinkInstancesResult {
        Instances?: ClassicLinkInstanceList;
        NextToken?: String;
    }
    export interface DescribeConversionTasksRequest {
        DryRun?: Boolean;
        Filters?: FilterList;
        ConversionTaskIds?: ConversionIdStringList;
    }
    export interface DescribeConversionTasksResult {
        ConversionTasks?: DescribeConversionTaskList;
    }
    export interface DescribeCustomerGatewaysRequest {
        DryRun?: Boolean;
        CustomerGatewayIds?: CustomerGatewayIdStringList;
        Filters?: FilterList;
    }
    export interface DescribeCustomerGatewaysResult {
        CustomerGateways?: CustomerGatewayList;
    }
    export interface DescribeDhcpOptionsRequest {
        DryRun?: Boolean;
        DhcpOptionsIds?: DhcpOptionsIdStringList;
        Filters?: FilterList;
    }
    export interface DescribeDhcpOptionsResult {
        DhcpOptions?: DhcpOptionsList;
    }
    export interface DescribeExportTasksRequest {
        ExportTaskIds?: ExportTaskIdStringList;
    }
    export interface DescribeExportTasksResult {
        ExportTasks?: ExportTaskList;
    }
    export interface DescribeFlowLogsRequest {
        FlowLogIds?: ValueStringList;
        Filter?: FilterList;
        NextToken?: String;
        MaxResults?: Integer;
    }
    export interface DescribeFlowLogsResult {
        FlowLogs?: FlowLogSet;
        NextToken?: String;
    }
    export interface DescribeHostsRequest {
        HostIds?: RequestHostIdList;
        NextToken?: String;
        MaxResults?: Integer;
        Filter?: FilterList;
    }
    export interface DescribeHostsResult {
        Hosts?: HostList;
        NextToken?: String;
    }
    export interface DescribeIdFormatRequest {
        Resource?: String;
    }
    export interface DescribeIdFormatResult {
        Statuses?: IdFormatList;
    }
    export interface DescribeImageAttributeRequest {
        DryRun?: Boolean;
        ImageId: String;
        Attribute: ImageAttributeName;
    }
    export interface DescribeImagesRequest {
        DryRun?: Boolean;
        ImageIds?: ImageIdStringList;
        Owners?: OwnerStringList;
        ExecutableUsers?: ExecutableByStringList;
        Filters?: FilterList;
    }
    export interface DescribeImagesResult {
        Images?: ImageList;
    }
    export interface DescribeImportImageTasksRequest {
        DryRun?: Boolean;
        ImportTaskIds?: ImportTaskIdList;
        NextToken?: String;
        MaxResults?: Integer;
        Filters?: FilterList;
    }
    export interface DescribeImportImageTasksResult {
        ImportImageTasks?: ImportImageTaskList;
        NextToken?: String;
    }
    export interface DescribeImportSnapshotTasksRequest {
        DryRun?: Boolean;
        ImportTaskIds?: ImportTaskIdList;
        NextToken?: String;
        MaxResults?: Integer;
        Filters?: FilterList;
    }
    export interface DescribeImportSnapshotTasksResult {
        ImportSnapshotTasks?: ImportSnapshotTaskList;
        NextToken?: String;
    }
    export interface DescribeInstanceAttributeRequest {
        DryRun?: Boolean;
        InstanceId: String;
        Attribute: InstanceAttributeName;
    }
    export interface DescribeInstanceStatusRequest {
        DryRun?: Boolean;
        InstanceIds?: InstanceIdStringList;
        Filters?: FilterList;
        NextToken?: String;
        MaxResults?: Integer;
        IncludeAllInstances?: Boolean;
    }
    export interface DescribeInstanceStatusResult {
        InstanceStatuses?: InstanceStatusList;
        NextToken?: String;
    }
    export interface DescribeInstancesRequest {
        DryRun?: Boolean;
        InstanceIds?: InstanceIdStringList;
        Filters?: FilterList;
        NextToken?: String;
        MaxResults?: Integer;
    }
    export interface DescribeInstancesResult {
        Reservations?: ReservationList;
        NextToken?: String;
    }
    export interface DescribeInternetGatewaysRequest {
        DryRun?: Boolean;
        InternetGatewayIds?: ValueStringList;
        Filters?: FilterList;
    }
    export interface DescribeInternetGatewaysResult {
        InternetGateways?: InternetGatewayList;
    }
    export interface DescribeKeyPairsRequest {
        DryRun?: Boolean;
        KeyNames?: KeyNameStringList;
        Filters?: FilterList;
    }
    export interface DescribeKeyPairsResult {
        KeyPairs?: KeyPairList;
    }
    export interface DescribeMovingAddressesRequest {
        DryRun?: Boolean;
        PublicIps?: ValueStringList;
        NextToken?: String;
        Filters?: FilterList;
        MaxResults?: Integer;
    }
    export interface DescribeMovingAddressesResult {
        MovingAddressStatuses?: MovingAddressStatusSet;
        NextToken?: String;
    }
    export interface DescribeNatGatewaysRequest {
        NatGatewayIds?: ValueStringList;
        Filter?: FilterList;
        MaxResults?: Integer;
        NextToken?: String;
    }
    export interface DescribeNatGatewaysResult {
        NatGateways?: NatGatewayList;
        NextToken?: String;
    }
    export interface DescribeNetworkAclsRequest {
        DryRun?: Boolean;
        NetworkAclIds?: ValueStringList;
        Filters?: FilterList;
    }
    export interface DescribeNetworkAclsResult {
        NetworkAcls?: NetworkAclList;
    }
    export interface DescribeNetworkInterfaceAttributeRequest {
        DryRun?: Boolean;
        NetworkInterfaceId: String;
        Attribute?: NetworkInterfaceAttribute;
    }
    export interface DescribeNetworkInterfaceAttributeResult {
        NetworkInterfaceId?: String;
        Description?: AttributeValue;
        SourceDestCheck?: AttributeBooleanValue;
        Groups?: GroupIdentifierList;
        Attachment?: NetworkInterfaceAttachment;
    }
    export interface DescribeNetworkInterfacesRequest {
        DryRun?: Boolean;
        NetworkInterfaceIds?: NetworkInterfaceIdList;
        Filters?: FilterList;
    }
    export interface DescribeNetworkInterfacesResult {
        NetworkInterfaces?: NetworkInterfaceList;
    }
    export interface DescribePlacementGroupsRequest {
        DryRun?: Boolean;
        GroupNames?: PlacementGroupStringList;
        Filters?: FilterList;
    }
    export interface DescribePlacementGroupsResult {
        PlacementGroups?: PlacementGroupList;
    }
    export interface DescribePrefixListsRequest {
        DryRun?: Boolean;
        PrefixListIds?: ValueStringList;
        Filters?: FilterList;
        MaxResults?: Integer;
        NextToken?: String;
    }
    export interface DescribePrefixListsResult {
        PrefixLists?: PrefixListSet;
        NextToken?: String;
    }
    export interface DescribeRegionsRequest {
        DryRun?: Boolean;
        RegionNames?: RegionNameStringList;
        Filters?: FilterList;
    }
    export interface DescribeRegionsResult {
        Regions?: RegionList;
    }
    export interface DescribeReservedInstancesListingsRequest {
        ReservedInstancesId?: String;
        ReservedInstancesListingId?: String;
        Filters?: FilterList;
    }
    export interface DescribeReservedInstancesListingsResult {
        ReservedInstancesListings?: ReservedInstancesListingList;
    }
    export interface DescribeReservedInstancesModificationsRequest {
        ReservedInstancesModificationIds?: ReservedInstancesModificationIdStringList;
        NextToken?: String;
        Filters?: FilterList;
    }
    export interface DescribeReservedInstancesModificationsResult {
        ReservedInstancesModifications?: ReservedInstancesModificationList;
        NextToken?: String;
    }
    export interface DescribeReservedInstancesOfferingsRequest {
        DryRun?: Boolean;
        ReservedInstancesOfferingIds?: ReservedInstancesOfferingIdStringList;
        InstanceType?: InstanceType;
        AvailabilityZone?: String;
        ProductDescription?: RIProductDescription;
        Filters?: FilterList;
        InstanceTenancy?: Tenancy;
        OfferingType?: OfferingTypeValues;
        NextToken?: String;
        MaxResults?: Integer;
        IncludeMarketplace?: Boolean;
        MinDuration?: Long;
        MaxDuration?: Long;
        MaxInstanceCount?: Integer;
    }
    export interface DescribeReservedInstancesOfferingsResult {
        ReservedInstancesOfferings?: ReservedInstancesOfferingList;
        NextToken?: String;
    }
    export interface DescribeReservedInstancesRequest {
        DryRun?: Boolean;
        ReservedInstancesIds?: ReservedInstancesIdStringList;
        Filters?: FilterList;
        OfferingType?: OfferingTypeValues;
    }
    export interface DescribeReservedInstancesResult {
        ReservedInstances?: ReservedInstancesList;
    }
    export interface DescribeRouteTablesRequest {
        DryRun?: Boolean;
        RouteTableIds?: ValueStringList;
        Filters?: FilterList;
    }
    export interface DescribeRouteTablesResult {
        RouteTables?: RouteTableList;
    }
    export interface DescribeScheduledInstanceAvailabilityRequest {
        DryRun?: Boolean;
        Recurrence: ScheduledInstanceRecurrenceRequest;
        FirstSlotStartTimeRange: SlotDateTimeRangeRequest;
        MinSlotDurationInHours?: Integer;
        MaxSlotDurationInHours?: Integer;
        NextToken?: String;
        MaxResults?: Integer;
        Filters?: FilterList;
    }
    export interface DescribeScheduledInstanceAvailabilityResult {
        NextToken?: String;
        ScheduledInstanceAvailabilitySet?: ScheduledInstanceAvailabilitySet;
    }
    export interface DescribeScheduledInstancesRequest {
        DryRun?: Boolean;
        ScheduledInstanceIds?: ScheduledInstanceIdRequestSet;
        SlotStartTimeRange?: SlotStartTimeRangeRequest;
        NextToken?: String;
        MaxResults?: Integer;
        Filters?: FilterList;
    }
    export interface DescribeScheduledInstancesResult {
        NextToken?: String;
        ScheduledInstanceSet?: ScheduledInstanceSet;
    }
    export interface DescribeSecurityGroupsRequest {
        DryRun?: Boolean;
        GroupNames?: GroupNameStringList;
        GroupIds?: GroupIdStringList;
        Filters?: FilterList;
    }
    export interface DescribeSecurityGroupsResult {
        SecurityGroups?: SecurityGroupList;
    }
    export interface DescribeSnapshotAttributeRequest {
        DryRun?: Boolean;
        SnapshotId: String;
        Attribute: SnapshotAttributeName;
    }
    export interface DescribeSnapshotAttributeResult {
        SnapshotId?: String;
        CreateVolumePermissions?: CreateVolumePermissionList;
        ProductCodes?: ProductCodeList;
    }
    export interface DescribeSnapshotsRequest {
        DryRun?: Boolean;
        SnapshotIds?: SnapshotIdStringList;
        OwnerIds?: OwnerStringList;
        RestorableByUserIds?: RestorableByStringList;
        Filters?: FilterList;
        NextToken?: String;
        MaxResults?: Integer;
    }
    export interface DescribeSnapshotsResult {
        Snapshots?: SnapshotList;
        NextToken?: String;
    }
    export interface DescribeSpotDatafeedSubscriptionRequest {
        DryRun?: Boolean;
    }
    export interface DescribeSpotDatafeedSubscriptionResult {
        SpotDatafeedSubscription?: SpotDatafeedSubscription;
    }
    export interface DescribeSpotFleetInstancesRequest {
        DryRun?: Boolean;
        SpotFleetRequestId: String;
        NextToken?: String;
        MaxResults?: Integer;
    }
    export interface DescribeSpotFleetInstancesResponse {
        SpotFleetRequestId: String;
        ActiveInstances: ActiveInstanceSet;
        NextToken?: String;
    }
    export interface DescribeSpotFleetRequestHistoryRequest {
        DryRun?: Boolean;
        SpotFleetRequestId: String;
        EventType?: EventType;
        StartTime: DateTime;
        NextToken?: String;
        MaxResults?: Integer;
    }
    export interface DescribeSpotFleetRequestHistoryResponse {
        SpotFleetRequestId: String;
        StartTime: DateTime;
        LastEvaluatedTime: DateTime;
        HistoryRecords: HistoryRecords;
        NextToken?: String;
    }
    export interface DescribeSpotFleetRequestsRequest {
        DryRun?: Boolean;
        SpotFleetRequestIds?: ValueStringList;
        NextToken?: String;
        MaxResults?: Integer;
    }
    export interface DescribeSpotFleetRequestsResponse {
        SpotFleetRequestConfigs: SpotFleetRequestConfigSet;
        NextToken?: String;
    }
    export interface DescribeSpotInstanceRequestsRequest {
        DryRun?: Boolean;
        SpotInstanceRequestIds?: SpotInstanceRequestIdList;
        Filters?: FilterList;
    }
    export interface DescribeSpotInstanceRequestsResult {
        SpotInstanceRequests?: SpotInstanceRequestList;
    }
    export interface DescribeSpotPriceHistoryRequest {
        DryRun?: Boolean;
        StartTime?: DateTime;
        EndTime?: DateTime;
        InstanceTypes?: InstanceTypeList;
        ProductDescriptions?: ProductDescriptionList;
        Filters?: FilterList;
        AvailabilityZone?: String;
        MaxResults?: Integer;
        NextToken?: String;
    }
    export interface DescribeSpotPriceHistoryResult {
        SpotPriceHistory?: SpotPriceHistoryList;
        NextToken?: String;
    }
    export interface DescribeSubnetsRequest {
        DryRun?: Boolean;
        SubnetIds?: SubnetIdStringList;
        Filters?: FilterList;
    }
    export interface DescribeSubnetsResult {
        Subnets?: SubnetList;
    }
    export interface DescribeTagsRequest {
        DryRun?: Boolean;
        Filters?: FilterList;
        MaxResults?: Integer;
        NextToken?: String;
    }
    export interface DescribeTagsResult {
        Tags?: TagDescriptionList;
        NextToken?: String;
    }
    export interface DescribeVolumeAttributeRequest {
        DryRun?: Boolean;
        VolumeId: String;
        Attribute?: VolumeAttributeName;
    }
    export interface DescribeVolumeAttributeResult {
        VolumeId?: String;
        AutoEnableIO?: AttributeBooleanValue;
        ProductCodes?: ProductCodeList;
    }
    export interface DescribeVolumeStatusRequest {
        DryRun?: Boolean;
        VolumeIds?: VolumeIdStringList;
        Filters?: FilterList;
        NextToken?: String;
        MaxResults?: Integer;
    }
    export interface DescribeVolumeStatusResult {
        VolumeStatuses?: VolumeStatusList;
        NextToken?: String;
    }
    export interface DescribeVolumesRequest {
        DryRun?: Boolean;
        VolumeIds?: VolumeIdStringList;
        Filters?: FilterList;
        NextToken?: String;
        MaxResults?: Integer;
    }
    export interface DescribeVolumesResult {
        Volumes?: VolumeList;
        NextToken?: String;
    }
    export interface DescribeVpcAttributeRequest {
        DryRun?: Boolean;
        VpcId: String;
        Attribute: VpcAttributeName;
    }
    export interface DescribeVpcAttributeResult {
        VpcId?: String;
        EnableDnsSupport?: AttributeBooleanValue;
        EnableDnsHostnames?: AttributeBooleanValue;
    }
    export interface DescribeVpcClassicLinkDnsSupportRequest {
        VpcIds?: VpcClassicLinkIdList;
        MaxResults?: MaxResults;
        NextToken?: NextToken;
    }
    export interface DescribeVpcClassicLinkDnsSupportResult {
        Vpcs?: ClassicLinkDnsSupportList;
        NextToken?: NextToken;
    }
    export interface DescribeVpcClassicLinkRequest {
        DryRun?: Boolean;
        VpcIds?: VpcClassicLinkIdList;
        Filters?: FilterList;
    }
    export interface DescribeVpcClassicLinkResult {
        Vpcs?: VpcClassicLinkList;
    }
    export interface DescribeVpcEndpointServicesRequest {
        DryRun?: Boolean;
        MaxResults?: Integer;
        NextToken?: String;
    }
    export interface DescribeVpcEndpointServicesResult {
        ServiceNames?: ValueStringList;
        NextToken?: String;
    }
    export interface DescribeVpcEndpointsRequest {
        DryRun?: Boolean;
        VpcEndpointIds?: ValueStringList;
        Filters?: FilterList;
        MaxResults?: Integer;
        NextToken?: String;
    }
    export interface DescribeVpcEndpointsResult {
        VpcEndpoints?: VpcEndpointSet;
        NextToken?: String;
    }
    export interface DescribeVpcPeeringConnectionsRequest {
        DryRun?: Boolean;
        VpcPeeringConnectionIds?: ValueStringList;
        Filters?: FilterList;
    }
    export interface DescribeVpcPeeringConnectionsResult {
        VpcPeeringConnections?: VpcPeeringConnectionList;
    }
    export interface DescribeVpcsRequest {
        DryRun?: Boolean;
        VpcIds?: VpcIdStringList;
        Filters?: FilterList;
    }
    export interface DescribeVpcsResult {
        Vpcs?: VpcList;
    }
    export interface DescribeVpnConnectionsRequest {
        DryRun?: Boolean;
        VpnConnectionIds?: VpnConnectionIdStringList;
        Filters?: FilterList;
    }
    export interface DescribeVpnConnectionsResult {
        VpnConnections?: VpnConnectionList;
    }
    export interface DescribeVpnGatewaysRequest {
        DryRun?: Boolean;
        VpnGatewayIds?: VpnGatewayIdStringList;
        Filters?: FilterList;
    }
    export interface DescribeVpnGatewaysResult {
        VpnGateways?: VpnGatewayList;
    }
    export interface DetachClassicLinkVpcRequest {
        DryRun?: Boolean;
        InstanceId: String;
        VpcId: String;
    }
    export interface DetachClassicLinkVpcResult {
        Return?: Boolean;
    }
    export interface DetachInternetGatewayRequest {
        DryRun?: Boolean;
        InternetGatewayId: String;
        VpcId: String;
    }
    export interface DetachNetworkInterfaceRequest {
        DryRun?: Boolean;
        AttachmentId: String;
        Force?: Boolean;
    }
    export interface DetachVolumeRequest {
        DryRun?: Boolean;
        VolumeId: String;
        InstanceId?: String;
        Device?: String;
        Force?: Boolean;
    }
    export interface DetachVpnGatewayRequest {
        DryRun?: Boolean;
        VpnGatewayId: String;
        VpcId: String;
    }
    export interface DhcpConfiguration {
        Key?: String;
        Values?: DhcpConfigurationValueList;
    }
    export interface DhcpOptions {
        DhcpOptionsId?: String;
        DhcpConfigurations?: DhcpConfigurationList;
        Tags?: TagList;
    }
    export interface DisableVgwRoutePropagationRequest {
        RouteTableId: String;
        GatewayId: String;
    }
    export interface DisableVpcClassicLinkDnsSupportRequest {
        VpcId?: String;
    }
    export interface DisableVpcClassicLinkDnsSupportResult {
        Return?: Boolean;
    }
    export interface DisableVpcClassicLinkRequest {
        DryRun?: Boolean;
        VpcId: String;
    }
    export interface DisableVpcClassicLinkResult {
        Return?: Boolean;
    }
    export interface DisassociateAddressRequest {
        DryRun?: Boolean;
        PublicIp?: String;
        AssociationId?: String;
    }
    export interface DisassociateRouteTableRequest {
        DryRun?: Boolean;
        AssociationId: String;
    }
    export interface DiskImage {
        Image?: DiskImageDetail;
        Description?: String;
        Volume?: VolumeDetail;
    }
    export interface DiskImageDescription {
        Format: DiskImageFormat;
        Size: Long;
        ImportManifestUrl: String;
        Checksum?: String;
    }
    export interface DiskImageDetail {
        Format: DiskImageFormat;
        Bytes: Long;
        ImportManifestUrl: String;
    }
    export interface DiskImageVolumeDescription {
        Size?: Long;
        Id: String;
    }
    export interface EbsBlockDevice {
        SnapshotId?: String;
        VolumeSize?: Integer;
        DeleteOnTermination?: Boolean;
        VolumeType?: VolumeType;
        Iops?: Integer;
        Encrypted?: Boolean;
    }
    export interface EbsInstanceBlockDevice {
        VolumeId?: String;
        Status?: AttachmentStatus;
        AttachTime?: DateTime;
        DeleteOnTermination?: Boolean;
    }
    export interface EbsInstanceBlockDeviceSpecification {
        VolumeId?: String;
        DeleteOnTermination?: Boolean;
    }
    export interface EnableVgwRoutePropagationRequest {
        RouteTableId: String;
        GatewayId: String;
    }
    export interface EnableVolumeIORequest {
        DryRun?: Boolean;
        VolumeId: String;
    }
    export interface EnableVpcClassicLinkDnsSupportRequest {
        VpcId?: String;
    }
    export interface EnableVpcClassicLinkDnsSupportResult {
        Return?: Boolean;
    }
    export interface EnableVpcClassicLinkRequest {
        DryRun?: Boolean;
        VpcId: String;
    }
    export interface EnableVpcClassicLinkResult {
        Return?: Boolean;
    }
    export interface EventInformation {
        InstanceId?: String;
        EventSubType?: String;
        EventDescription?: String;
    }
    export interface ExportTask {
        ExportTaskId?: String;
        Description?: String;
        State?: ExportTaskState;
        StatusMessage?: String;
        InstanceExportDetails?: InstanceExportDetails;
        ExportToS3Task?: ExportToS3Task;
    }
    export interface ExportToS3Task {
        DiskImageFormat?: DiskImageFormat;
        ContainerFormat?: ContainerFormat;
        S3Bucket?: String;
        S3Key?: String;
    }
    export interface ExportToS3TaskSpecification {
        DiskImageFormat?: DiskImageFormat;
        ContainerFormat?: ContainerFormat;
        S3Bucket?: String;
        S3Prefix?: String;
    }
    export interface Filter {
        Name?: String;
        Values?: ValueStringList;
    }
    export interface FlowLog {
        CreationTime?: DateTime;
        FlowLogId?: String;
        FlowLogStatus?: String;
        ResourceId?: String;
        TrafficType?: TrafficType;
        LogGroupName?: String;
        DeliverLogsStatus?: String;
        DeliverLogsErrorMessage?: String;
        DeliverLogsPermissionArn?: String;
    }
    export interface GetConsoleOutputRequest {
        DryRun?: Boolean;
        InstanceId: String;
    }
    export interface GetConsoleOutputResult {
        InstanceId?: String;
        Timestamp?: DateTime;
        Output?: String;
    }
    export interface GetPasswordDataRequest {
        DryRun?: Boolean;
        InstanceId: String;
    }
    export interface GetPasswordDataResult {
        InstanceId?: String;
        Timestamp?: DateTime;
        PasswordData?: String;
    }
    export interface GroupIdentifier {
        GroupName?: String;
        GroupId?: String;
    }
    export interface HistoryRecord {
        Timestamp: DateTime;
        EventType: EventType;
        EventInformation: EventInformation;
    }
    export interface Host {
        HostId?: String;
        AutoPlacement?: AutoPlacement;
        HostReservationId?: String;
        ClientToken?: String;
        HostProperties?: HostProperties;
        State?: AllocationState;
        AvailabilityZone?: String;
        Instances?: HostInstanceList;
        AvailableCapacity?: AvailableCapacity;
    }
    export interface HostInstance {
        InstanceId?: String;
        InstanceType?: String;
    }
    export interface HostProperties {
        Sockets?: Integer;
        Cores?: Integer;
        TotalVCpus?: Integer;
        InstanceType?: String;
    }
    export interface IamInstanceProfile {
        Arn?: String;
        Id?: String;
    }
    export interface IamInstanceProfileSpecification {
        Arn?: String;
        Name?: String;
    }
    export interface IcmpTypeCode {
        Type?: Integer;
        Code?: Integer;
    }
    export interface IdFormat {
        Resource?: String;
        UseLongIds?: Boolean;
        Deadline?: DateTime;
    }
    export interface Image {
        ImageId?: String;
        ImageLocation?: String;
        State?: ImageState;
        OwnerId?: String;
        CreationDate?: String;
        Public?: Boolean;
        ProductCodes?: ProductCodeList;
        Architecture?: ArchitectureValues;
        ImageType?: ImageTypeValues;
        KernelId?: String;
        RamdiskId?: String;
        Platform?: PlatformValues;
        SriovNetSupport?: String;
        StateReason?: StateReason;
        ImageOwnerAlias?: String;
        Name?: String;
        Description?: String;
        RootDeviceType?: DeviceType;
        RootDeviceName?: String;
        BlockDeviceMappings?: BlockDeviceMappingList;
        VirtualizationType?: VirtualizationType;
        Tags?: TagList;
        Hypervisor?: HypervisorType;
    }
    export interface ImageAttribute {
        ImageId?: String;
        LaunchPermissions?: LaunchPermissionList;
        ProductCodes?: ProductCodeList;
        KernelId?: AttributeValue;
        RamdiskId?: AttributeValue;
        Description?: AttributeValue;
        SriovNetSupport?: AttributeValue;
        BlockDeviceMappings?: BlockDeviceMappingList;
    }
    export interface ImageDiskContainer {
        Description?: String;
        Format?: String;
        Url?: String;
        UserBucket?: UserBucket;
        DeviceName?: String;
        SnapshotId?: String;
    }
    export interface ImportImageRequest {
        DryRun?: Boolean;
        Description?: String;
        DiskContainers?: ImageDiskContainerList;
        LicenseType?: String;
        Hypervisor?: String;
        Architecture?: String;
        Platform?: String;
        ClientData?: ClientData;
        ClientToken?: String;
        RoleName?: String;
    }
    export interface ImportImageResult {
        ImportTaskId?: String;
        Architecture?: String;
        LicenseType?: String;
        Platform?: String;
        Hypervisor?: String;
        Description?: String;
        SnapshotDetails?: SnapshotDetailList;
        ImageId?: String;
        Progress?: String;
        StatusMessage?: String;
        Status?: String;
    }
    export interface ImportImageTask {
        ImportTaskId?: String;
        Architecture?: String;
        LicenseType?: String;
        Platform?: String;
        Hypervisor?: String;
        Description?: String;
        SnapshotDetails?: SnapshotDetailList;
        ImageId?: String;
        Progress?: String;
        StatusMessage?: String;
        Status?: String;
    }
    export interface ImportInstanceLaunchSpecification {
        Architecture?: ArchitectureValues;
        GroupNames?: SecurityGroupStringList;
        GroupIds?: SecurityGroupIdStringList;
        AdditionalInfo?: String;
        UserData?: UserData;
        InstanceType?: InstanceType;
        Placement?: Placement;
        Monitoring?: Boolean;
        SubnetId?: String;
        InstanceInitiatedShutdownBehavior?: ShutdownBehavior;
        PrivateIpAddress?: String;
    }
    export interface ImportInstanceRequest {
        DryRun?: Boolean;
        Description?: String;
        LaunchSpecification?: ImportInstanceLaunchSpecification;
        DiskImages?: DiskImageList;
        Platform: PlatformValues;
    }
    export interface ImportInstanceResult {
        ConversionTask?: ConversionTask;
    }
    export interface ImportInstanceTaskDetails {
        Volumes: ImportInstanceVolumeDetailSet;
        InstanceId?: String;
        Platform?: PlatformValues;
        Description?: String;
    }
    export interface ImportInstanceVolumeDetailItem {
        BytesConverted: Long;
        AvailabilityZone: String;
        Image: DiskImageDescription;
        Volume: DiskImageVolumeDescription;
        Status: String;
        StatusMessage?: String;
        Description?: String;
    }
    export interface ImportKeyPairRequest {
        DryRun?: Boolean;
        KeyName: String;
        PublicKeyMaterial: Blob;
    }
    export interface ImportKeyPairResult {
        KeyName?: String;
        KeyFingerprint?: String;
    }
    export interface ImportSnapshotRequest {
        DryRun?: Boolean;
        Description?: String;
        DiskContainer?: SnapshotDiskContainer;
        ClientData?: ClientData;
        ClientToken?: String;
        RoleName?: String;
    }
    export interface ImportSnapshotResult {
        ImportTaskId?: String;
        SnapshotTaskDetail?: SnapshotTaskDetail;
        Description?: String;
    }
    export interface ImportSnapshotTask {
        ImportTaskId?: String;
        SnapshotTaskDetail?: SnapshotTaskDetail;
        Description?: String;
    }
    export interface ImportVolumeRequest {
        DryRun?: Boolean;
        AvailabilityZone: String;
        Image: DiskImageDetail;
        Description?: String;
        Volume: VolumeDetail;
    }
    export interface ImportVolumeResult {
        ConversionTask?: ConversionTask;
    }
    export interface ImportVolumeTaskDetails {
        BytesConverted: Long;
        AvailabilityZone: String;
        Description?: String;
        Image: DiskImageDescription;
        Volume: DiskImageVolumeDescription;
    }
    export interface Instance {
        InstanceId?: String;
        ImageId?: String;
        State?: InstanceState;
        PrivateDnsName?: String;
        PublicDnsName?: String;
        StateTransitionReason?: String;
        KeyName?: String;
        AmiLaunchIndex?: Integer;
        ProductCodes?: ProductCodeList;
        InstanceType?: InstanceType;
        LaunchTime?: DateTime;
        Placement?: Placement;
        KernelId?: String;
        RamdiskId?: String;
        Platform?: PlatformValues;
        Monitoring?: Monitoring;
        SubnetId?: String;
        VpcId?: String;
        PrivateIpAddress?: String;
        PublicIpAddress?: String;
        StateReason?: StateReason;
        Architecture?: ArchitectureValues;
        RootDeviceType?: DeviceType;
        RootDeviceName?: String;
        BlockDeviceMappings?: InstanceBlockDeviceMappingList;
        VirtualizationType?: VirtualizationType;
        InstanceLifecycle?: InstanceLifecycleType;
        SpotInstanceRequestId?: String;
        ClientToken?: String;
        Tags?: TagList;
        SecurityGroups?: GroupIdentifierList;
        SourceDestCheck?: Boolean;
        Hypervisor?: HypervisorType;
        NetworkInterfaces?: InstanceNetworkInterfaceList;
        IamInstanceProfile?: IamInstanceProfile;
        EbsOptimized?: Boolean;
        SriovNetSupport?: String;
    }
    export interface InstanceAttribute {
        InstanceId?: String;
        InstanceType?: AttributeValue;
        KernelId?: AttributeValue;
        RamdiskId?: AttributeValue;
        UserData?: AttributeValue;
        DisableApiTermination?: AttributeBooleanValue;
        InstanceInitiatedShutdownBehavior?: AttributeValue;
        RootDeviceName?: AttributeValue;
        BlockDeviceMappings?: InstanceBlockDeviceMappingList;
        ProductCodes?: ProductCodeList;
        EbsOptimized?: AttributeBooleanValue;
        SriovNetSupport?: AttributeValue;
        SourceDestCheck?: AttributeBooleanValue;
        Groups?: GroupIdentifierList;
    }
    export interface InstanceBlockDeviceMapping {
        DeviceName?: String;
        Ebs?: EbsInstanceBlockDevice;
    }
    export interface InstanceBlockDeviceMappingSpecification {
        DeviceName?: String;
        Ebs?: EbsInstanceBlockDeviceSpecification;
        VirtualName?: String;
        NoDevice?: String;
    }
    export interface InstanceCapacity {
        InstanceType?: String;
        AvailableCapacity?: Integer;
        TotalCapacity?: Integer;
    }
    export interface InstanceCount {
        State?: ListingState;
        InstanceCount?: Integer;
    }
    export interface InstanceExportDetails {
        InstanceId?: String;
        TargetEnvironment?: ExportEnvironment;
    }
    export interface InstanceMonitoring {
        InstanceId?: String;
        Monitoring?: Monitoring;
    }
    export interface InstanceNetworkInterface {
        NetworkInterfaceId?: String;
        SubnetId?: String;
        VpcId?: String;
        Description?: String;
        OwnerId?: String;
        Status?: NetworkInterfaceStatus;
        MacAddress?: String;
        PrivateIpAddress?: String;
        PrivateDnsName?: String;
        SourceDestCheck?: Boolean;
        Groups?: GroupIdentifierList;
        Attachment?: InstanceNetworkInterfaceAttachment;
        Association?: InstanceNetworkInterfaceAssociation;
        PrivateIpAddresses?: InstancePrivateIpAddressList;
    }
    export interface InstanceNetworkInterfaceAssociation {
        PublicIp?: String;
        PublicDnsName?: String;
        IpOwnerId?: String;
    }
    export interface InstanceNetworkInterfaceAttachment {
        AttachmentId?: String;
        DeviceIndex?: Integer;
        Status?: AttachmentStatus;
        AttachTime?: DateTime;
        DeleteOnTermination?: Boolean;
    }
    export interface InstanceNetworkInterfaceSpecification {
        NetworkInterfaceId?: String;
        DeviceIndex?: Integer;
        SubnetId?: String;
        Description?: String;
        PrivateIpAddress?: String;
        Groups?: SecurityGroupIdStringList;
        DeleteOnTermination?: Boolean;
        PrivateIpAddresses?: PrivateIpAddressSpecificationList;
        SecondaryPrivateIpAddressCount?: Integer;
        AssociatePublicIpAddress?: Boolean;
    }
    export interface InstancePrivateIpAddress {
        PrivateIpAddress?: String;
        PrivateDnsName?: String;
        Primary?: Boolean;
        Association?: InstanceNetworkInterfaceAssociation;
    }
    export interface InstanceState {
        Code?: Integer;
        Name?: InstanceStateName;
    }
    export interface InstanceStateChange {
        InstanceId?: String;
        CurrentState?: InstanceState;
        PreviousState?: InstanceState;
    }
    export interface InstanceStatus {
        InstanceId?: String;
        AvailabilityZone?: String;
        Events?: InstanceStatusEventList;
        InstanceState?: InstanceState;
        SystemStatus?: InstanceStatusSummary;
        InstanceStatus?: InstanceStatusSummary;
    }
    export interface InstanceStatusDetails {
        Name?: StatusName;
        Status?: StatusType;
        ImpairedSince?: DateTime;
    }
    export interface InstanceStatusEvent {
        Code?: EventCode;
        Description?: String;
        NotBefore?: DateTime;
        NotAfter?: DateTime;
    }
    export interface InstanceStatusSummary {
        Status?: SummaryStatus;
        Details?: InstanceStatusDetailsList;
    }
    export interface InternetGateway {
        InternetGatewayId?: String;
        Attachments?: InternetGatewayAttachmentList;
        Tags?: TagList;
    }
    export interface InternetGatewayAttachment {
        VpcId?: String;
        State?: AttachmentStatus;
    }
    export interface IpPermission {
        IpProtocol?: String;
        FromPort?: Integer;
        ToPort?: Integer;
        UserIdGroupPairs?: UserIdGroupPairList;
        IpRanges?: IpRangeList;
        PrefixListIds?: PrefixListIdList;
    }
    export interface IpRange {
        CidrIp?: String;
    }
    export interface KeyPair {
        KeyName?: String;
        KeyFingerprint?: String;
        KeyMaterial?: String;
    }
    export interface KeyPairInfo {
        KeyName?: String;
        KeyFingerprint?: String;
    }
    export interface LaunchPermission {
        UserId?: String;
        Group?: PermissionGroup;
    }
    export interface LaunchPermissionModifications {
        Add?: LaunchPermissionList;
        Remove?: LaunchPermissionList;
    }
    export interface LaunchSpecification {
        ImageId?: String;
        KeyName?: String;
        SecurityGroups?: GroupIdentifierList;
        UserData?: String;
        AddressingType?: String;
        InstanceType?: InstanceType;
        Placement?: SpotPlacement;
        KernelId?: String;
        RamdiskId?: String;
        BlockDeviceMappings?: BlockDeviceMappingList;
        SubnetId?: String;
        NetworkInterfaces?: InstanceNetworkInterfaceSpecificationList;
        IamInstanceProfile?: IamInstanceProfileSpecification;
        EbsOptimized?: Boolean;
        Monitoring?: RunInstancesMonitoringEnabled;
    }
    export interface ModifyHostsRequest {
        HostIds: RequestHostIdList;
        AutoPlacement: AutoPlacement;
    }
    export interface ModifyHostsResult {
        Successful?: ResponseHostIdList;
        Unsuccessful?: UnsuccessfulItemList;
    }
    export interface ModifyIdFormatRequest {
        Resource: String;
        UseLongIds: Boolean;
    }
    export interface ModifyImageAttributeRequest {
        DryRun?: Boolean;
        ImageId: String;
        Attribute?: String;
        OperationType?: OperationType;
        UserIds?: UserIdStringList;
        UserGroups?: UserGroupStringList;
        ProductCodes?: ProductCodeStringList;
        Value?: String;
        LaunchPermission?: LaunchPermissionModifications;
        Description?: AttributeValue;
    }
    export interface ModifyInstanceAttributeRequest {
        DryRun?: Boolean;
        InstanceId: String;
        Attribute?: InstanceAttributeName;
        Value?: String;
        BlockDeviceMappings?: InstanceBlockDeviceMappingSpecificationList;
        SourceDestCheck?: AttributeBooleanValue;
        DisableApiTermination?: AttributeBooleanValue;
        InstanceType?: AttributeValue;
        Kernel?: AttributeValue;
        Ramdisk?: AttributeValue;
        UserData?: BlobAttributeValue;
        InstanceInitiatedShutdownBehavior?: AttributeValue;
        Groups?: GroupIdStringList;
        EbsOptimized?: AttributeBooleanValue;
        SriovNetSupport?: AttributeValue;
    }
    export interface ModifyInstancePlacementRequest {
        InstanceId: String;
        Tenancy?: HostTenancy;
        Affinity?: Affinity;
        HostId?: String;
    }
    export interface ModifyInstancePlacementResult {
        Return?: Boolean;
    }
    export interface ModifyNetworkInterfaceAttributeRequest {
        DryRun?: Boolean;
        NetworkInterfaceId: String;
        Description?: AttributeValue;
        SourceDestCheck?: AttributeBooleanValue;
        Groups?: SecurityGroupIdStringList;
        Attachment?: NetworkInterfaceAttachmentChanges;
    }
    export interface ModifyReservedInstancesRequest {
        ClientToken?: String;
        ReservedInstancesIds: ReservedInstancesIdStringList;
        TargetConfigurations: ReservedInstancesConfigurationList;
    }
    export interface ModifyReservedInstancesResult {
        ReservedInstancesModificationId?: String;
    }
    export interface ModifySnapshotAttributeRequest {
        DryRun?: Boolean;
        SnapshotId: String;
        Attribute?: SnapshotAttributeName;
        OperationType?: OperationType;
        UserIds?: UserIdStringList;
        GroupNames?: GroupNameStringList;
        CreateVolumePermission?: CreateVolumePermissionModifications;
    }
    export interface ModifySpotFleetRequestRequest {
        SpotFleetRequestId: String;
        TargetCapacity?: Integer;
        ExcessCapacityTerminationPolicy?: ExcessCapacityTerminationPolicy;
    }
    export interface ModifySpotFleetRequestResponse {
        Return?: Boolean;
    }
    export interface ModifySubnetAttributeRequest {
        SubnetId: String;
        MapPublicIpOnLaunch?: AttributeBooleanValue;
    }
    export interface ModifyVolumeAttributeRequest {
        DryRun?: Boolean;
        VolumeId: String;
        AutoEnableIO?: AttributeBooleanValue;
    }
    export interface ModifyVpcAttributeRequest {
        VpcId: String;
        EnableDnsSupport?: AttributeBooleanValue;
        EnableDnsHostnames?: AttributeBooleanValue;
    }
    export interface ModifyVpcEndpointRequest {
        DryRun?: Boolean;
        VpcEndpointId: String;
        ResetPolicy?: Boolean;
        PolicyDocument?: String;
        AddRouteTableIds?: ValueStringList;
        RemoveRouteTableIds?: ValueStringList;
    }
    export interface ModifyVpcEndpointResult {
        Return?: Boolean;
    }
    export interface MonitorInstancesRequest {
        DryRun?: Boolean;
        InstanceIds: InstanceIdStringList;
    }
    export interface MonitorInstancesResult {
        InstanceMonitorings?: InstanceMonitoringList;
    }
    export interface Monitoring {
        State?: MonitoringState;
    }
    export interface MoveAddressToVpcRequest {
        DryRun?: Boolean;
        PublicIp: String;
    }
    export interface MoveAddressToVpcResult {
        AllocationId?: String;
        Status?: Status;
    }
    export interface MovingAddressStatus {
        PublicIp?: String;
        MoveStatus?: MoveStatus;
    }
    export interface NatGateway {
        VpcId?: String;
        SubnetId?: String;
        NatGatewayId?: String;
        CreateTime?: DateTime;
        DeleteTime?: DateTime;
        NatGatewayAddresses?: NatGatewayAddressList;
        State?: NatGatewayState;
        FailureCode?: String;
        FailureMessage?: String;
    }
    export interface NatGatewayAddress {
        PublicIp?: String;
        AllocationId?: String;
        PrivateIp?: String;
        NetworkInterfaceId?: String;
    }
    export interface NetworkAcl {
        NetworkAclId?: String;
        VpcId?: String;
        IsDefault?: Boolean;
        Entries?: NetworkAclEntryList;
        Associations?: NetworkAclAssociationList;
        Tags?: TagList;
    }
    export interface NetworkAclAssociation {
        NetworkAclAssociationId?: String;
        NetworkAclId?: String;
        SubnetId?: String;
    }
    export interface NetworkAclEntry {
        RuleNumber?: Integer;
        Protocol?: String;
        RuleAction?: RuleAction;
        Egress?: Boolean;
        CidrBlock?: String;
        IcmpTypeCode?: IcmpTypeCode;
        PortRange?: PortRange;
    }
    export interface NetworkInterface {
        NetworkInterfaceId?: String;
        SubnetId?: String;
        VpcId?: String;
        AvailabilityZone?: String;
        Description?: String;
        OwnerId?: String;
        RequesterId?: String;
        RequesterManaged?: Boolean;
        Status?: NetworkInterfaceStatus;
        MacAddress?: String;
        PrivateIpAddress?: String;
        PrivateDnsName?: String;
        SourceDestCheck?: Boolean;
        Groups?: GroupIdentifierList;
        Attachment?: NetworkInterfaceAttachment;
        Association?: NetworkInterfaceAssociation;
        TagSet?: TagList;
        PrivateIpAddresses?: NetworkInterfacePrivateIpAddressList;
        InterfaceType?: NetworkInterfaceType;
    }
    export interface NetworkInterfaceAssociation {
        PublicIp?: String;
        PublicDnsName?: String;
        IpOwnerId?: String;
        AllocationId?: String;
        AssociationId?: String;
    }
    export interface NetworkInterfaceAttachment {
        AttachmentId?: String;
        InstanceId?: String;
        InstanceOwnerId?: String;
        DeviceIndex?: Integer;
        Status?: AttachmentStatus;
        AttachTime?: DateTime;
        DeleteOnTermination?: Boolean;
    }
    export interface NetworkInterfaceAttachmentChanges {
        AttachmentId?: String;
        DeleteOnTermination?: Boolean;
    }
    export interface NetworkInterfacePrivateIpAddress {
        PrivateIpAddress?: String;
        PrivateDnsName?: String;
        Primary?: Boolean;
        Association?: NetworkInterfaceAssociation;
    }
    export interface NewDhcpConfiguration {
        Key?: String;
        Values?: ValueStringList;
    }
    export interface Placement {
        AvailabilityZone?: String;
        GroupName?: String;
        Tenancy?: Tenancy;
        HostId?: String;
        Affinity?: String;
    }
    export interface PlacementGroup {
        GroupName?: String;
        Strategy?: PlacementStrategy;
        State?: PlacementGroupState;
    }
    export interface PortRange {
        From?: Integer;
        To?: Integer;
    }
    export interface PrefixList {
        PrefixListId?: String;
        PrefixListName?: String;
        Cidrs?: ValueStringList;
    }
    export interface PrefixListId {
        PrefixListId?: String;
    }
    export interface PriceSchedule {
        Term?: Long;
        Price?: Double;
        CurrencyCode?: CurrencyCodeValues;
        Active?: Boolean;
    }
    export interface PriceScheduleSpecification {
        Term?: Long;
        Price?: Double;
        CurrencyCode?: CurrencyCodeValues;
    }
    export interface PricingDetail {
        Price?: Double;
        Count?: Integer;
    }
    export interface PrivateIpAddressSpecification {
        PrivateIpAddress: String;
        Primary?: Boolean;
    }
    export interface ProductCode {
        ProductCodeId?: String;
        ProductCodeType?: ProductCodeValues;
    }
    export interface PropagatingVgw {
        GatewayId?: String;
    }
    export interface PurchaseRequest {
        PurchaseToken: String;
        InstanceCount: Integer;
    }
    export interface PurchaseReservedInstancesOfferingRequest {
        DryRun?: Boolean;
        ReservedInstancesOfferingId: String;
        InstanceCount: Integer;
        LimitPrice?: ReservedInstanceLimitPrice;
    }
    export interface PurchaseReservedInstancesOfferingResult {
        ReservedInstancesId?: String;
    }
    export interface PurchaseScheduledInstancesRequest {
        DryRun?: Boolean;
        ClientToken?: String;
        PurchaseRequests: PurchaseRequestSet;
    }
    export interface PurchaseScheduledInstancesResult {
        ScheduledInstanceSet?: PurchasedScheduledInstanceSet;
    }
    export interface RebootInstancesRequest {
        DryRun?: Boolean;
        InstanceIds: InstanceIdStringList;
    }
    export interface RecurringCharge {
        Frequency?: RecurringChargeFrequency;
        Amount?: Double;
    }
    export interface Region {
        RegionName?: String;
        Endpoint?: String;
    }
    export interface RegisterImageRequest {
        DryRun?: Boolean;
        ImageLocation?: String;
        Name: String;
        Description?: String;
        Architecture?: ArchitectureValues;
        KernelId?: String;
        RamdiskId?: String;
        RootDeviceName?: String;
        BlockDeviceMappings?: BlockDeviceMappingRequestList;
        VirtualizationType?: String;
        SriovNetSupport?: String;
    }
    export interface RegisterImageResult {
        ImageId?: String;
    }
    export interface RejectVpcPeeringConnectionRequest {
        DryRun?: Boolean;
        VpcPeeringConnectionId: String;
    }
    export interface RejectVpcPeeringConnectionResult {
        Return?: Boolean;
    }
    export interface ReleaseAddressRequest {
        DryRun?: Boolean;
        PublicIp?: String;
        AllocationId?: String;
    }
    export interface ReleaseHostsRequest {
        HostIds: RequestHostIdList;
    }
    export interface ReleaseHostsResult {
        Successful?: ResponseHostIdList;
        Unsuccessful?: UnsuccessfulItemList;
    }
    export interface ReplaceNetworkAclAssociationRequest {
        DryRun?: Boolean;
        AssociationId: String;
        NetworkAclId: String;
    }
    export interface ReplaceNetworkAclAssociationResult {
        NewAssociationId?: String;
    }
    export interface ReplaceNetworkAclEntryRequest {
        DryRun?: Boolean;
        NetworkAclId: String;
        RuleNumber: Integer;
        Protocol: String;
        RuleAction: RuleAction;
        Egress: Boolean;
        CidrBlock: String;
        IcmpTypeCode?: IcmpTypeCode;
        PortRange?: PortRange;
    }
    export interface ReplaceRouteRequest {
        DryRun?: Boolean;
        RouteTableId: String;
        DestinationCidrBlock: String;
        GatewayId?: String;
        InstanceId?: String;
        NetworkInterfaceId?: String;
        VpcPeeringConnectionId?: String;
        NatGatewayId?: String;
    }
    export interface ReplaceRouteTableAssociationRequest {
        DryRun?: Boolean;
        AssociationId: String;
        RouteTableId: String;
    }
    export interface ReplaceRouteTableAssociationResult {
        NewAssociationId?: String;
    }
    export interface ReportInstanceStatusRequest {
        DryRun?: Boolean;
        Instances: InstanceIdStringList;
        Status: ReportStatusType;
        StartTime?: DateTime;
        EndTime?: DateTime;
        ReasonCodes: ReasonCodesList;
        Description?: String;
    }
    export interface RequestSpotFleetRequest {
        DryRun?: Boolean;
        SpotFleetRequestConfig: SpotFleetRequestConfigData;
    }
    export interface RequestSpotFleetResponse {
        SpotFleetRequestId: String;
    }
    export interface RequestSpotInstancesRequest {
        DryRun?: Boolean;
        SpotPrice: String;
        ClientToken?: String;
        InstanceCount?: Integer;
        Type?: SpotInstanceType;
        ValidFrom?: DateTime;
        ValidUntil?: DateTime;
        LaunchGroup?: String;
        AvailabilityZoneGroup?: String;
        BlockDurationMinutes?: Integer;
        LaunchSpecification?: RequestSpotLaunchSpecification;
    }
    export interface RequestSpotInstancesResult {
        SpotInstanceRequests?: SpotInstanceRequestList;
    }
    export interface RequestSpotLaunchSpecification {
        ImageId?: String;
        KeyName?: String;
        SecurityGroups?: ValueStringList;
        UserData?: String;
        AddressingType?: String;
        InstanceType?: InstanceType;
        Placement?: SpotPlacement;
        KernelId?: String;
        RamdiskId?: String;
        BlockDeviceMappings?: BlockDeviceMappingList;
        SubnetId?: String;
        NetworkInterfaces?: InstanceNetworkInterfaceSpecificationList;
        IamInstanceProfile?: IamInstanceProfileSpecification;
        EbsOptimized?: Boolean;
        Monitoring?: RunInstancesMonitoringEnabled;
        SecurityGroupIds?: ValueStringList;
    }
    export interface Reservation {
        ReservationId?: String;
        OwnerId?: String;
        RequesterId?: String;
        Groups?: GroupIdentifierList;
        Instances?: InstanceList;
    }
    export interface ReservedInstanceLimitPrice {
        Amount?: Double;
        CurrencyCode?: CurrencyCodeValues;
    }
    export interface ReservedInstances {
        ReservedInstancesId?: String;
        InstanceType?: InstanceType;
        AvailabilityZone?: String;
        Start?: DateTime;
        End?: DateTime;
        Duration?: Long;
        UsagePrice?: Float;
        FixedPrice?: Float;
        InstanceCount?: Integer;
        ProductDescription?: RIProductDescription;
        State?: ReservedInstanceState;
        Tags?: TagList;
        InstanceTenancy?: Tenancy;
        CurrencyCode?: CurrencyCodeValues;
        OfferingType?: OfferingTypeValues;
        RecurringCharges?: RecurringChargesList;
    }
    export interface ReservedInstancesConfiguration {
        AvailabilityZone?: String;
        Platform?: String;
        InstanceCount?: Integer;
        InstanceType?: InstanceType;
    }
    export interface ReservedInstancesId {
        ReservedInstancesId?: String;
    }
    export interface ReservedInstancesListing {
        ReservedInstancesListingId?: String;
        ReservedInstancesId?: String;
        CreateDate?: DateTime;
        UpdateDate?: DateTime;
        Status?: ListingStatus;
        StatusMessage?: String;
        InstanceCounts?: InstanceCountList;
        PriceSchedules?: PriceScheduleList;
        Tags?: TagList;
        ClientToken?: String;
    }
    export interface ReservedInstancesModification {
        ReservedInstancesModificationId?: String;
        ReservedInstancesIds?: ReservedIntancesIds;
        ModificationResults?: ReservedInstancesModificationResultList;
        CreateDate?: DateTime;
        UpdateDate?: DateTime;
        EffectiveDate?: DateTime;
        Status?: String;
        StatusMessage?: String;
        ClientToken?: String;
    }
    export interface ReservedInstancesModificationResult {
        ReservedInstancesId?: String;
        TargetConfiguration?: ReservedInstancesConfiguration;
    }
    export interface ReservedInstancesOffering {
        ReservedInstancesOfferingId?: String;
        InstanceType?: InstanceType;
        AvailabilityZone?: String;
        Duration?: Long;
        UsagePrice?: Float;
        FixedPrice?: Float;
        ProductDescription?: RIProductDescription;
        InstanceTenancy?: Tenancy;
        CurrencyCode?: CurrencyCodeValues;
        OfferingType?: OfferingTypeValues;
        RecurringCharges?: RecurringChargesList;
        Marketplace?: Boolean;
        PricingDetails?: PricingDetailsList;
    }
    export interface ResetImageAttributeRequest {
        DryRun?: Boolean;
        ImageId: String;
        Attribute: ResetImageAttributeName;
    }
    export interface ResetInstanceAttributeRequest {
        DryRun?: Boolean;
        InstanceId: String;
        Attribute: InstanceAttributeName;
    }
    export interface ResetNetworkInterfaceAttributeRequest {
        DryRun?: Boolean;
        NetworkInterfaceId: String;
        SourceDestCheck?: String;
    }
    export interface ResetSnapshotAttributeRequest {
        DryRun?: Boolean;
        SnapshotId: String;
        Attribute: SnapshotAttributeName;
    }
    export interface RestoreAddressToClassicRequest {
        DryRun?: Boolean;
        PublicIp: String;
    }
    export interface RestoreAddressToClassicResult {
        Status?: Status;
        PublicIp?: String;
    }
    export interface RevokeSecurityGroupEgressRequest {
        DryRun?: Boolean;
        GroupId: String;
        SourceSecurityGroupName?: String;
        SourceSecurityGroupOwnerId?: String;
        IpProtocol?: String;
        FromPort?: Integer;
        ToPort?: Integer;
        CidrIp?: String;
        IpPermissions?: IpPermissionList;
    }
    export interface RevokeSecurityGroupIngressRequest {
        DryRun?: Boolean;
        GroupName?: String;
        GroupId?: String;
        SourceSecurityGroupName?: String;
        SourceSecurityGroupOwnerId?: String;
        IpProtocol?: String;
        FromPort?: Integer;
        ToPort?: Integer;
        CidrIp?: String;
        IpPermissions?: IpPermissionList;
    }
    export interface Route {
        DestinationCidrBlock?: String;
        DestinationPrefixListId?: String;
        GatewayId?: String;
        InstanceId?: String;
        InstanceOwnerId?: String;
        NetworkInterfaceId?: String;
        VpcPeeringConnectionId?: String;
        NatGatewayId?: String;
        State?: RouteState;
        Origin?: RouteOrigin;
    }
    export interface RouteTable {
        RouteTableId?: String;
        VpcId?: String;
        Routes?: RouteList;
        Associations?: RouteTableAssociationList;
        Tags?: TagList;
        PropagatingVgws?: PropagatingVgwList;
    }
    export interface RouteTableAssociation {
        RouteTableAssociationId?: String;
        RouteTableId?: String;
        SubnetId?: String;
        Main?: Boolean;
    }
    export interface RunInstancesMonitoringEnabled {
        Enabled: Boolean;
    }
    export interface RunInstancesRequest {
        DryRun?: Boolean;
        ImageId: String;
        MinCount: Integer;
        MaxCount: Integer;
        KeyName?: String;
        SecurityGroups?: SecurityGroupStringList;
        SecurityGroupIds?: SecurityGroupIdStringList;
        UserData?: String;
        InstanceType?: InstanceType;
        Placement?: Placement;
        KernelId?: String;
        RamdiskId?: String;
        BlockDeviceMappings?: BlockDeviceMappingRequestList;
        Monitoring?: RunInstancesMonitoringEnabled;
        SubnetId?: String;
        DisableApiTermination?: Boolean;
        InstanceInitiatedShutdownBehavior?: ShutdownBehavior;
        PrivateIpAddress?: String;
        ClientToken?: String;
        AdditionalInfo?: String;
        NetworkInterfaces?: InstanceNetworkInterfaceSpecificationList;
        IamInstanceProfile?: IamInstanceProfileSpecification;
        EbsOptimized?: Boolean;
    }
    export interface RunScheduledInstancesRequest {
        DryRun?: Boolean;
        ClientToken?: String;
        InstanceCount?: Integer;
        ScheduledInstanceId: String;
        LaunchSpecification: ScheduledInstancesLaunchSpecification;
    }
    export interface RunScheduledInstancesResult {
        InstanceIdSet?: InstanceIdSet;
    }
    export interface S3Storage {
        Bucket?: String;
        Prefix?: String;
        AWSAccessKeyId?: String;
        UploadPolicy?: Blob;
        UploadPolicySignature?: String;
    }
    export interface ScheduledInstance {
        ScheduledInstanceId?: String;
        InstanceType?: String;
        Platform?: String;
        NetworkPlatform?: String;
        AvailabilityZone?: String;
        SlotDurationInHours?: Integer;
        Recurrence?: ScheduledInstanceRecurrence;
        PreviousSlotEndTime?: DateTime;
        NextSlotStartTime?: DateTime;
        HourlyPrice?: String;
        TotalScheduledInstanceHours?: Integer;
        InstanceCount?: Integer;
        TermStartDate?: DateTime;
        TermEndDate?: DateTime;
        CreateDate?: DateTime;
    }
    export interface ScheduledInstanceAvailability {
        InstanceType?: String;
        Platform?: String;
        NetworkPlatform?: String;
        AvailabilityZone?: String;
        PurchaseToken?: String;
        SlotDurationInHours?: Integer;
        Recurrence?: ScheduledInstanceRecurrence;
        FirstSlotStartTime?: DateTime;
        HourlyPrice?: String;
        TotalScheduledInstanceHours?: Integer;
        AvailableInstanceCount?: Integer;
        MinTermDurationInDays?: Integer;
        MaxTermDurationInDays?: Integer;
    }
    export interface ScheduledInstanceRecurrence {
        Frequency?: String;
        Interval?: Integer;
        OccurrenceDaySet?: OccurrenceDaySet;
        OccurrenceRelativeToEnd?: Boolean;
        OccurrenceUnit?: String;
    }
    export interface ScheduledInstanceRecurrenceRequest {
        Frequency?: String;
        Interval?: Integer;
        OccurrenceDays?: OccurrenceDayRequestSet;
        OccurrenceRelativeToEnd?: Boolean;
        OccurrenceUnit?: String;
    }
    export interface ScheduledInstancesBlockDeviceMapping {
        DeviceName?: String;
        NoDevice?: String;
        VirtualName?: String;
        Ebs?: ScheduledInstancesEbs;
    }
    export interface ScheduledInstancesEbs {
        SnapshotId?: String;
        VolumeSize?: Integer;
        DeleteOnTermination?: Boolean;
        VolumeType?: String;
        Iops?: Integer;
        Encrypted?: Boolean;
    }
    export interface ScheduledInstancesIamInstanceProfile {
        Arn?: String;
        Name?: String;
    }
    export interface ScheduledInstancesLaunchSpecification {
        ImageId: String;
        KeyName?: String;
        SecurityGroupIds?: ScheduledInstancesSecurityGroupIdSet;
        UserData?: String;
        Placement?: ScheduledInstancesPlacement;
        KernelId?: String;
        InstanceType?: String;
        RamdiskId?: String;
        BlockDeviceMappings?: ScheduledInstancesBlockDeviceMappingSet;
        Monitoring?: ScheduledInstancesMonitoring;
        SubnetId?: String;
        NetworkInterfaces?: ScheduledInstancesNetworkInterfaceSet;
        IamInstanceProfile?: ScheduledInstancesIamInstanceProfile;
        EbsOptimized?: Boolean;
    }
    export interface ScheduledInstancesMonitoring {
        Enabled?: Boolean;
    }
    export interface ScheduledInstancesNetworkInterface {
        NetworkInterfaceId?: String;
        DeviceIndex?: Integer;
        SubnetId?: String;
        Description?: String;
        PrivateIpAddress?: String;
        PrivateIpAddressConfigs?: PrivateIpAddressConfigSet;
        SecondaryPrivateIpAddressCount?: Integer;
        AssociatePublicIpAddress?: Boolean;
        Groups?: ScheduledInstancesSecurityGroupIdSet;
        DeleteOnTermination?: Boolean;
    }
    export interface ScheduledInstancesPlacement {
        AvailabilityZone?: String;
        GroupName?: String;
    }
    export interface ScheduledInstancesPrivateIpAddressConfig {
        PrivateIpAddress?: String;
        Primary?: Boolean;
    }
    export interface SecurityGroup {
        OwnerId?: String;
        GroupName?: String;
        GroupId?: String;
        Description?: String;
        IpPermissions?: IpPermissionList;
        IpPermissionsEgress?: IpPermissionList;
        VpcId?: String;
        Tags?: TagList;
    }
    export interface SlotDateTimeRangeRequest {
        EarliestTime: DateTime;
        LatestTime: DateTime;
    }
    export interface SlotStartTimeRangeRequest {
        EarliestTime?: DateTime;
        LatestTime?: DateTime;
    }
    export interface Snapshot {
        SnapshotId?: String;
        VolumeId?: String;
        State?: SnapshotState;
        StateMessage?: String;
        StartTime?: DateTime;
        Progress?: String;
        OwnerId?: String;
        Description?: String;
        VolumeSize?: Integer;
        OwnerAlias?: String;
        Tags?: TagList;
        Encrypted?: Boolean;
        KmsKeyId?: String;
        DataEncryptionKeyId?: String;
    }
    export interface SnapshotDetail {
        DiskImageSize?: Double;
        Description?: String;
        Format?: String;
        Url?: String;
        UserBucket?: UserBucketDetails;
        DeviceName?: String;
        SnapshotId?: String;
        Progress?: String;
        StatusMessage?: String;
        Status?: String;
    }
    export interface SnapshotDiskContainer {
        Description?: String;
        Format?: String;
        Url?: String;
        UserBucket?: UserBucket;
    }
    export interface SnapshotTaskDetail {
        DiskImageSize?: Double;
        Description?: String;
        Format?: String;
        Url?: String;
        UserBucket?: UserBucketDetails;
        SnapshotId?: String;
        Progress?: String;
        StatusMessage?: String;
        Status?: String;
    }
    export interface SpotDatafeedSubscription {
        OwnerId?: String;
        Bucket?: String;
        Prefix?: String;
        State?: DatafeedSubscriptionState;
        Fault?: SpotInstanceStateFault;
    }
    export interface SpotFleetLaunchSpecification {
        ImageId?: String;
        KeyName?: String;
        SecurityGroups?: GroupIdentifierList;
        UserData?: String;
        AddressingType?: String;
        InstanceType?: InstanceType;
        Placement?: SpotPlacement;
        KernelId?: String;
        RamdiskId?: String;
        BlockDeviceMappings?: BlockDeviceMappingList;
        Monitoring?: SpotFleetMonitoring;
        SubnetId?: String;
        NetworkInterfaces?: InstanceNetworkInterfaceSpecificationList;
        IamInstanceProfile?: IamInstanceProfileSpecification;
        EbsOptimized?: Boolean;
        WeightedCapacity?: Double;
        SpotPrice?: String;
    }
    export interface SpotFleetMonitoring {
        Enabled?: Boolean;
    }
    export interface SpotFleetRequestConfig {
        SpotFleetRequestId: String;
        SpotFleetRequestState: BatchState;
        SpotFleetRequestConfig: SpotFleetRequestConfigData;
        CreateTime: DateTime;
    }
    export interface SpotFleetRequestConfigData {
        ClientToken?: String;
        SpotPrice: String;
        TargetCapacity: Integer;
        ValidFrom?: DateTime;
        ValidUntil?: DateTime;
        TerminateInstancesWithExpiration?: Boolean;
        IamFleetRole: String;
        LaunchSpecifications: LaunchSpecsList;
        ExcessCapacityTerminationPolicy?: ExcessCapacityTerminationPolicy;
        AllocationStrategy?: AllocationStrategy;
    }
    export interface SpotInstanceRequest {
        SpotInstanceRequestId?: String;
        SpotPrice?: String;
        Type?: SpotInstanceType;
        State?: SpotInstanceState;
        Fault?: SpotInstanceStateFault;
        Status?: SpotInstanceStatus;
        ValidFrom?: DateTime;
        ValidUntil?: DateTime;
        LaunchGroup?: String;
        AvailabilityZoneGroup?: String;
        LaunchSpecification?: LaunchSpecification;
        InstanceId?: String;
        CreateTime?: DateTime;
        ProductDescription?: RIProductDescription;
        BlockDurationMinutes?: Integer;
        ActualBlockHourlyPrice?: String;
        Tags?: TagList;
        LaunchedAvailabilityZone?: String;
    }
    export interface SpotInstanceStateFault {
        Code?: String;
        Message?: String;
    }
    export interface SpotInstanceStatus {
        Code?: String;
        UpdateTime?: DateTime;
        Message?: String;
    }
    export interface SpotPlacement {
        AvailabilityZone?: String;
        GroupName?: String;
    }
    export interface SpotPrice {
        InstanceType?: InstanceType;
        ProductDescription?: RIProductDescription;
        SpotPrice?: String;
        Timestamp?: DateTime;
        AvailabilityZone?: String;
    }
    export interface StartInstancesRequest {
        InstanceIds: InstanceIdStringList;
        AdditionalInfo?: String;
        DryRun?: Boolean;
    }
    export interface StartInstancesResult {
        StartingInstances?: InstanceStateChangeList;
    }
    export interface StateReason {
        Code?: String;
        Message?: String;
    }
    export interface StopInstancesRequest {
        DryRun?: Boolean;
        InstanceIds: InstanceIdStringList;
        Force?: Boolean;
    }
    export interface StopInstancesResult {
        StoppingInstances?: InstanceStateChangeList;
    }
    export interface Storage {
        S3?: S3Storage;
    }
    export interface Subnet {
        SubnetId?: String;
        State?: SubnetState;
        VpcId?: String;
        CidrBlock?: String;
        AvailableIpAddressCount?: Integer;
        AvailabilityZone?: String;
        DefaultForAz?: Boolean;
        MapPublicIpOnLaunch?: Boolean;
        Tags?: TagList;
    }
    export interface Tag {
        Key?: String;
        Value?: String;
    }
    export interface TagDescription {
        ResourceId?: String;
        ResourceType?: ResourceType;
        Key?: String;
        Value?: String;
    }
    export interface TerminateInstancesRequest {
        DryRun?: Boolean;
        InstanceIds: InstanceIdStringList;
    }
    export interface TerminateInstancesResult {
        TerminatingInstances?: InstanceStateChangeList;
    }
    export interface UnassignPrivateIpAddressesRequest {
        NetworkInterfaceId: String;
        PrivateIpAddresses: PrivateIpAddressStringList;
    }
    export interface UnmonitorInstancesRequest {
        DryRun?: Boolean;
        InstanceIds: InstanceIdStringList;
    }
    export interface UnmonitorInstancesResult {
        InstanceMonitorings?: InstanceMonitoringList;
    }
    export interface UnsuccessfulItem {
        ResourceId?: String;
        Error: UnsuccessfulItemError;
    }
    export interface UnsuccessfulItemError {
        Code: String;
        Message: String;
    }
    export interface UserBucket {
        S3Bucket?: String;
        S3Key?: String;
    }
    export interface UserBucketDetails {
        S3Bucket?: String;
        S3Key?: String;
    }
    export interface UserData {
        Data?: String;
    }
    export interface UserIdGroupPair {
        UserId?: String;
        GroupName?: String;
        GroupId?: String;
        VpcId?: String;
        VpcPeeringConnectionId?: String;
        PeeringStatus?: String;
    }
    export interface VgwTelemetry {
        OutsideIpAddress?: String;
        Status?: TelemetryStatus;
        LastStatusChange?: DateTime;
        StatusMessage?: String;
        AcceptedRouteCount?: Integer;
    }
    export interface Volume {
        VolumeId?: String;
        Size?: Integer;
        SnapshotId?: String;
        AvailabilityZone?: String;
        State?: VolumeState;
        CreateTime?: DateTime;
        Attachments?: VolumeAttachmentList;
        Tags?: TagList;
        VolumeType?: VolumeType;
        Iops?: Integer;
        Encrypted?: Boolean;
        KmsKeyId?: String;
    }
    export interface VolumeAttachment {
        VolumeId?: String;
        InstanceId?: String;
        Device?: String;
        State?: VolumeAttachmentState;
        AttachTime?: DateTime;
        DeleteOnTermination?: Boolean;
    }
    export interface VolumeDetail {
        Size: Long;
    }
    export interface VolumeStatusAction {
        Code?: String;
        Description?: String;
        EventType?: String;
        EventId?: String;
    }
    export interface VolumeStatusDetails {
        Name?: VolumeStatusName;
        Status?: String;
    }
    export interface VolumeStatusEvent {
        EventType?: String;
        Description?: String;
        NotBefore?: DateTime;
        NotAfter?: DateTime;
        EventId?: String;
    }
    export interface VolumeStatusInfo {
        Status?: VolumeStatusInfoStatus;
        Details?: VolumeStatusDetailsList;
    }
    export interface VolumeStatusItem {
        VolumeId?: String;
        AvailabilityZone?: String;
        VolumeStatus?: VolumeStatusInfo;
        Events?: VolumeStatusEventsList;
        Actions?: VolumeStatusActionsList;
    }
    export interface Vpc {
        VpcId?: String;
        State?: VpcState;
        CidrBlock?: String;
        DhcpOptionsId?: String;
        Tags?: TagList;
        InstanceTenancy?: Tenancy;
        IsDefault?: Boolean;
    }
    export interface VpcAttachment {
        VpcId?: String;
        State?: AttachmentStatus;
    }
    export interface VpcClassicLink {
        VpcId?: String;
        ClassicLinkEnabled?: Boolean;
        Tags?: TagList;
    }
    export interface VpcEndpoint {
        VpcEndpointId?: String;
        VpcId?: String;
        ServiceName?: String;
        State?: State;
        PolicyDocument?: String;
        RouteTableIds?: ValueStringList;
        CreationTimestamp?: DateTime;
    }
    export interface VpcPeeringConnection {
        AccepterVpcInfo?: VpcPeeringConnectionVpcInfo;
        ExpirationTime?: DateTime;
        RequesterVpcInfo?: VpcPeeringConnectionVpcInfo;
        Status?: VpcPeeringConnectionStateReason;
        Tags?: TagList;
        VpcPeeringConnectionId?: String;
    }
    export interface VpcPeeringConnectionStateReason {
        Code?: VpcPeeringConnectionStateReasonCode;
        Message?: String;
    }
    export interface VpcPeeringConnectionVpcInfo {
        CidrBlock?: String;
        OwnerId?: String;
        VpcId?: String;
    }
    export interface VpnConnection {
        VpnConnectionId?: String;
        State?: VpnState;
        CustomerGatewayConfiguration?: String;
        Type?: GatewayType;
        CustomerGatewayId?: String;
        VpnGatewayId?: String;
        Tags?: TagList;
        VgwTelemetry?: VgwTelemetryList;
        Options?: VpnConnectionOptions;
        Routes?: VpnStaticRouteList;
    }
    export interface VpnConnectionOptions {
        StaticRoutesOnly?: Boolean;
    }
    export interface VpnConnectionOptionsSpecification {
        StaticRoutesOnly?: Boolean;
    }
    export interface VpnGateway {
        VpnGatewayId?: String;
        State?: VpnState;
        Type?: GatewayType;
        AvailabilityZone?: String;
        VpcAttachments?: VpcAttachmentList;
        Tags?: TagList;
    }
    export interface VpnStaticRoute {
        DestinationCidrBlock?: String;
        Source?: VpnStaticRouteSource;
        State?: VpnState;
    }
  }

  /*
   * apiVersion: 2015-09-21
   * endpointPrefix: ecr
   * serviceAbbreviation: Amazon ECR
   * signatureVersion: v4
   * protocol: json
   */
  export class ECR extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    batchCheckLayerAvailability(params: ECR.BatchCheckLayerAvailabilityRequest, callback?: (err: ECR.RepositoryNotFoundException|ECR.InvalidParameterException|ECR.ServerException|any, data: ECR.BatchCheckLayerAvailabilityResponse|any) => void): Request;
    batchDeleteImage(params: ECR.BatchDeleteImageRequest, callback?: (err: ECR.ServerException|ECR.InvalidParameterException|ECR.RepositoryNotFoundException|any, data: ECR.BatchDeleteImageResponse|any) => void): Request;
    batchGetImage(params: ECR.BatchGetImageRequest, callback?: (err: ECR.ServerException|ECR.InvalidParameterException|ECR.RepositoryNotFoundException|any, data: ECR.BatchGetImageResponse|any) => void): Request;
    completeLayerUpload(params: ECR.CompleteLayerUploadRequest, callback?: (err: ECR.ServerException|ECR.InvalidParameterException|ECR.RepositoryNotFoundException|ECR.UploadNotFoundException|ECR.InvalidLayerException|ECR.LayerPartTooSmallException|ECR.LayerAlreadyExistsException|ECR.EmptyUploadException|any, data: ECR.CompleteLayerUploadResponse|any) => void): Request;
    createRepository(params: ECR.CreateRepositoryRequest, callback?: (err: ECR.ServerException|ECR.InvalidParameterException|ECR.RepositoryAlreadyExistsException|ECR.LimitExceededException|any, data: ECR.CreateRepositoryResponse|any) => void): Request;
    deleteRepository(params: ECR.DeleteRepositoryRequest, callback?: (err: ECR.ServerException|ECR.InvalidParameterException|ECR.RepositoryNotFoundException|ECR.RepositoryNotEmptyException|any, data: ECR.DeleteRepositoryResponse|any) => void): Request;
    deleteRepositoryPolicy(params: ECR.DeleteRepositoryPolicyRequest, callback?: (err: ECR.ServerException|ECR.InvalidParameterException|ECR.RepositoryNotFoundException|ECR.RepositoryPolicyNotFoundException|any, data: ECR.DeleteRepositoryPolicyResponse|any) => void): Request;
    describeRepositories(params: ECR.DescribeRepositoriesRequest, callback?: (err: ECR.ServerException|ECR.InvalidParameterException|ECR.RepositoryNotFoundException|any, data: ECR.DescribeRepositoriesResponse|any) => void): Request;
    getAuthorizationToken(params: ECR.GetAuthorizationTokenRequest, callback?: (err: ECR.ServerException|ECR.InvalidParameterException|any, data: ECR.GetAuthorizationTokenResponse|any) => void): Request;
    getDownloadUrlForLayer(params: ECR.GetDownloadUrlForLayerRequest, callback?: (err: ECR.ServerException|ECR.InvalidParameterException|ECR.LayersNotFoundException|ECR.LayerInaccessibleException|ECR.RepositoryNotFoundException|any, data: ECR.GetDownloadUrlForLayerResponse|any) => void): Request;
    getRepositoryPolicy(params: ECR.GetRepositoryPolicyRequest, callback?: (err: ECR.ServerException|ECR.InvalidParameterException|ECR.RepositoryNotFoundException|ECR.RepositoryPolicyNotFoundException|any, data: ECR.GetRepositoryPolicyResponse|any) => void): Request;
    initiateLayerUpload(params: ECR.InitiateLayerUploadRequest, callback?: (err: ECR.ServerException|ECR.InvalidParameterException|ECR.RepositoryNotFoundException|any, data: ECR.InitiateLayerUploadResponse|any) => void): Request;
    listImages(params: ECR.ListImagesRequest, callback?: (err: ECR.ServerException|ECR.InvalidParameterException|ECR.RepositoryNotFoundException|any, data: ECR.ListImagesResponse|any) => void): Request;
    putImage(params: ECR.PutImageRequest, callback?: (err: ECR.ServerException|ECR.InvalidParameterException|ECR.RepositoryNotFoundException|ECR.ImageAlreadyExistsException|ECR.LayersNotFoundException|ECR.LimitExceededException|any, data: ECR.PutImageResponse|any) => void): Request;
    setRepositoryPolicy(params: ECR.SetRepositoryPolicyRequest, callback?: (err: ECR.ServerException|ECR.InvalidParameterException|ECR.RepositoryNotFoundException|any, data: ECR.SetRepositoryPolicyResponse|any) => void): Request;
    uploadLayerPart(params: ECR.UploadLayerPartRequest, callback?: (err: ECR.ServerException|ECR.InvalidParameterException|ECR.InvalidLayerPartException|ECR.RepositoryNotFoundException|ECR.UploadNotFoundException|ECR.LimitExceededException|any, data: ECR.UploadLayerPartResponse|any) => void): Request;

  }

  export module ECR {
    export type Arn = string;
    export type AuthorizationDataList = AuthorizationData[];
    export type Base64 = string;    // pattern: &quot;^\S+$&quot;
    export type BatchedOperationLayerDigest = string;    // max: 1000
    export type BatchedOperationLayerDigestList = BatchedOperationLayerDigest[];    // max: 100, min: 1
    export type ExceptionMessage = string;
    export type ExpirationTimestamp = number;
    export type ForceFlag = boolean;
    export type GetAuthorizationTokenRegistryIdList = RegistryId[];    // max: 10, min: 1
    export type ImageDigest = string;
    export type ImageFailureCode = string;
    export type ImageFailureList = ImageFailure[];
    export type ImageFailureReason = string;
    export type ImageIdentifierList = ImageIdentifier[];    // max: 100, min: 1
    export type ImageList = Image[];
    export type ImageManifest = string;
    export type ImageTag = string;
    export type LayerAvailability = string;
    export type LayerDigest = string;    // pattern: &quot;[a-zA-Z0-9-_+.]+:[a-fA-F0-9]+&quot;
    export type LayerDigestList = LayerDigest[];    // max: 100, min: 1
    export type LayerFailureCode = string;
    export type LayerFailureList = LayerFailure[];
    export type LayerFailureReason = string;
    export type LayerList = Layer[];
    export type LayerPartBlob = any;    // type: blob
    export type LayerSizeInBytes = number;
    export type MaxResults = number;    // max: 100, min: 1
    export type NextToken = string;
    export type PartSize = number;
    export type ProxyEndpoint = string;
    export type RegistryId = string;    // pattern: &quot;[0-9]{12}&quot;
    export type RepositoryList = Repository[];
    export type RepositoryName = string;    // pattern: &quot;(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*&quot;, max: 256, min: 2
    export type RepositoryNameList = RepositoryName[];    // max: 100, min: 1
    export type RepositoryPolicyText = string;    // max: 10240
    export type UploadId = string;    // pattern: &quot;[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}&quot;
    export type Url = string;

    export interface AuthorizationData {
        authorizationToken?: Base64;
        expiresAt?: ExpirationTimestamp;
        proxyEndpoint?: ProxyEndpoint;
    }
    export interface BatchCheckLayerAvailabilityRequest {
        registryId?: RegistryId;
        repositoryName: RepositoryName;
        layerDigests: BatchedOperationLayerDigestList;
    }
    export interface BatchCheckLayerAvailabilityResponse {
        layers?: LayerList;
        failures?: LayerFailureList;
    }
    export interface BatchDeleteImageRequest {
        registryId?: RegistryId;
        repositoryName: RepositoryName;
        imageIds: ImageIdentifierList;
    }
    export interface BatchDeleteImageResponse {
        imageIds?: ImageIdentifierList;
        failures?: ImageFailureList;
    }
    export interface BatchGetImageRequest {
        registryId?: RegistryId;
        repositoryName: RepositoryName;
        imageIds: ImageIdentifierList;
    }
    export interface BatchGetImageResponse {
        images?: ImageList;
        failures?: ImageFailureList;
    }
    export interface CompleteLayerUploadRequest {
        registryId?: RegistryId;
        repositoryName: RepositoryName;
        uploadId: UploadId;
        layerDigests: LayerDigestList;
    }
    export interface CompleteLayerUploadResponse {
        registryId?: RegistryId;
        repositoryName?: RepositoryName;
        uploadId?: UploadId;
        layerDigest?: LayerDigest;
    }
    export interface CreateRepositoryRequest {
        repositoryName: RepositoryName;
    }
    export interface CreateRepositoryResponse {
        repository?: Repository;
    }
    export interface DeleteRepositoryPolicyRequest {
        registryId?: RegistryId;
        repositoryName: RepositoryName;
    }
    export interface DeleteRepositoryPolicyResponse {
        registryId?: RegistryId;
        repositoryName?: RepositoryName;
        policyText?: RepositoryPolicyText;
    }
    export interface DeleteRepositoryRequest {
        registryId?: RegistryId;
        repositoryName: RepositoryName;
        force?: ForceFlag;
    }
    export interface DeleteRepositoryResponse {
        repository?: Repository;
    }
    export interface DescribeRepositoriesRequest {
        registryId?: RegistryId;
        repositoryNames?: RepositoryNameList;
        nextToken?: NextToken;
        maxResults?: MaxResults;
    }
    export interface DescribeRepositoriesResponse {
        repositories?: RepositoryList;
        nextToken?: NextToken;
    }
    export interface EmptyUploadException {
        message?: ExceptionMessage;
    }
    export interface GetAuthorizationTokenRequest {
        registryIds?: GetAuthorizationTokenRegistryIdList;
    }
    export interface GetAuthorizationTokenResponse {
        authorizationData?: AuthorizationDataList;
    }
    export interface GetDownloadUrlForLayerRequest {
        registryId?: RegistryId;
        repositoryName: RepositoryName;
        layerDigest: LayerDigest;
    }
    export interface GetDownloadUrlForLayerResponse {
        downloadUrl?: Url;
        layerDigest?: LayerDigest;
    }
    export interface GetRepositoryPolicyRequest {
        registryId?: RegistryId;
        repositoryName: RepositoryName;
    }
    export interface GetRepositoryPolicyResponse {
        registryId?: RegistryId;
        repositoryName?: RepositoryName;
        policyText?: RepositoryPolicyText;
    }
    export interface Image {
        registryId?: RegistryId;
        repositoryName?: RepositoryName;
        imageId?: ImageIdentifier;
        imageManifest?: ImageManifest;
    }
    export interface ImageAlreadyExistsException {
        message?: ExceptionMessage;
    }
    export interface ImageFailure {
        imageId?: ImageIdentifier;
        failureCode?: ImageFailureCode;
        failureReason?: ImageFailureReason;
    }
    export interface ImageIdentifier {
        imageDigest?: ImageDigest;
        imageTag?: ImageTag;
    }
    export interface InitiateLayerUploadRequest {
        registryId?: RegistryId;
        repositoryName: RepositoryName;
    }
    export interface InitiateLayerUploadResponse {
        uploadId?: UploadId;
        partSize?: PartSize;
    }
    export interface InvalidLayerException {
        message?: ExceptionMessage;
    }
    export interface InvalidLayerPartException {
        registryId?: RegistryId;
        repositoryName?: RepositoryName;
        uploadId?: UploadId;
        lastValidByteReceived?: PartSize;
        message?: ExceptionMessage;
    }
    export interface InvalidParameterException {
        message?: ExceptionMessage;
    }
    export interface Layer {
        layerDigest?: LayerDigest;
        layerAvailability?: LayerAvailability;
        layerSize?: LayerSizeInBytes;
    }
    export interface LayerAlreadyExistsException {
        message?: ExceptionMessage;
    }
    export interface LayerFailure {
        layerDigest?: BatchedOperationLayerDigest;
        failureCode?: LayerFailureCode;
        failureReason?: LayerFailureReason;
    }
    export interface LayerInaccessibleException {
        message?: ExceptionMessage;
    }
    export interface LayerPartTooSmallException {
        message?: ExceptionMessage;
    }
    export interface LayersNotFoundException {
        message?: ExceptionMessage;
    }
    export interface LimitExceededException {
        message?: ExceptionMessage;
    }
    export interface ListImagesRequest {
        registryId?: RegistryId;
        repositoryName: RepositoryName;
        nextToken?: NextToken;
        maxResults?: MaxResults;
    }
    export interface ListImagesResponse {
        imageIds?: ImageIdentifierList;
        nextToken?: NextToken;
    }
    export interface PutImageRequest {
        registryId?: RegistryId;
        repositoryName: RepositoryName;
        imageManifest: ImageManifest;
    }
    export interface PutImageResponse {
        image?: Image;
    }
    export interface Repository {
        repositoryArn?: Arn;
        registryId?: RegistryId;
        repositoryName?: RepositoryName;
    }
    export interface RepositoryAlreadyExistsException {
        message?: ExceptionMessage;
    }
    export interface RepositoryNotEmptyException {
        message?: ExceptionMessage;
    }
    export interface RepositoryNotFoundException {
        message?: ExceptionMessage;
    }
    export interface RepositoryPolicyNotFoundException {
        message?: ExceptionMessage;
    }
    export interface ServerException {
        message?: ExceptionMessage;
    }
    export interface SetRepositoryPolicyRequest {
        registryId?: RegistryId;
        repositoryName: RepositoryName;
        policyText: RepositoryPolicyText;
        force?: ForceFlag;
    }
    export interface SetRepositoryPolicyResponse {
        registryId?: RegistryId;
        repositoryName?: RepositoryName;
        policyText?: RepositoryPolicyText;
    }
    export interface UploadLayerPartRequest {
        registryId?: RegistryId;
        repositoryName: RepositoryName;
        uploadId: UploadId;
        partFirstByte: PartSize;
        partLastByte: PartSize;
        layerPartBlob: LayerPartBlob;
    }
    export interface UploadLayerPartResponse {
        registryId?: RegistryId;
        repositoryName?: RepositoryName;
        uploadId?: UploadId;
        lastByteReceived?: PartSize;
    }
    export interface UploadNotFoundException {
        message?: ExceptionMessage;
    }
  }

  /*
   * apiVersion: 2014-11-13
   * endpointPrefix: ecs
   * serviceAbbreviation: Amazon ECS
   * signatureVersion: v4
   * protocol: json
   */
  export class ECS extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    createCluster(params: ECS.CreateClusterRequest, callback?: (err: ECS.ServerException|ECS.ClientException|ECS.InvalidParameterException|any, data: ECS.CreateClusterResponse|any) => void): Request;
    createService(params: ECS.CreateServiceRequest, callback?: (err: ECS.ServerException|ECS.ClientException|ECS.InvalidParameterException|ECS.ClusterNotFoundException|any, data: ECS.CreateServiceResponse|any) => void): Request;
    deleteCluster(params: ECS.DeleteClusterRequest, callback?: (err: ECS.ServerException|ECS.ClientException|ECS.InvalidParameterException|ECS.ClusterNotFoundException|ECS.ClusterContainsContainerInstancesException|ECS.ClusterContainsServicesException|any, data: ECS.DeleteClusterResponse|any) => void): Request;
    deleteService(params: ECS.DeleteServiceRequest, callback?: (err: ECS.ServerException|ECS.ClientException|ECS.InvalidParameterException|ECS.ClusterNotFoundException|ECS.ServiceNotFoundException|any, data: ECS.DeleteServiceResponse|any) => void): Request;
    deregisterContainerInstance(params: ECS.DeregisterContainerInstanceRequest, callback?: (err: ECS.ServerException|ECS.ClientException|ECS.InvalidParameterException|ECS.ClusterNotFoundException|any, data: ECS.DeregisterContainerInstanceResponse|any) => void): Request;
    deregisterTaskDefinition(params: ECS.DeregisterTaskDefinitionRequest, callback?: (err: ECS.ServerException|ECS.ClientException|ECS.InvalidParameterException|any, data: ECS.DeregisterTaskDefinitionResponse|any) => void): Request;
    describeClusters(params: ECS.DescribeClustersRequest, callback?: (err: ECS.ServerException|ECS.ClientException|ECS.InvalidParameterException|any, data: ECS.DescribeClustersResponse|any) => void): Request;
    describeContainerInstances(params: ECS.DescribeContainerInstancesRequest, callback?: (err: ECS.ServerException|ECS.ClientException|ECS.InvalidParameterException|ECS.ClusterNotFoundException|any, data: ECS.DescribeContainerInstancesResponse|any) => void): Request;
    describeServices(params: ECS.DescribeServicesRequest, callback?: (err: ECS.ServerException|ECS.ClientException|ECS.InvalidParameterException|ECS.ClusterNotFoundException|any, data: ECS.DescribeServicesResponse|any) => void): Request;
    describeTaskDefinition(params: ECS.DescribeTaskDefinitionRequest, callback?: (err: ECS.ServerException|ECS.ClientException|ECS.InvalidParameterException|any, data: ECS.DescribeTaskDefinitionResponse|any) => void): Request;
    describeTasks(params: ECS.DescribeTasksRequest, callback?: (err: ECS.ServerException|ECS.ClientException|ECS.InvalidParameterException|ECS.ClusterNotFoundException|any, data: ECS.DescribeTasksResponse|any) => void): Request;
    discoverPollEndpoint(params: ECS.DiscoverPollEndpointRequest, callback?: (err: ECS.ServerException|ECS.ClientException|any, data: ECS.DiscoverPollEndpointResponse|any) => void): Request;
    listClusters(params: ECS.ListClustersRequest, callback?: (err: ECS.ServerException|ECS.ClientException|ECS.InvalidParameterException|any, data: ECS.ListClustersResponse|any) => void): Request;
    listContainerInstances(params: ECS.ListContainerInstancesRequest, callback?: (err: ECS.ServerException|ECS.ClientException|ECS.InvalidParameterException|ECS.ClusterNotFoundException|any, data: ECS.ListContainerInstancesResponse|any) => void): Request;
    listServices(params: ECS.ListServicesRequest, callback?: (err: ECS.ServerException|ECS.ClientException|ECS.InvalidParameterException|ECS.ClusterNotFoundException|any, data: ECS.ListServicesResponse|any) => void): Request;
    listTaskDefinitionFamilies(params: ECS.ListTaskDefinitionFamiliesRequest, callback?: (err: ECS.ServerException|ECS.ClientException|ECS.InvalidParameterException|any, data: ECS.ListTaskDefinitionFamiliesResponse|any) => void): Request;
    listTaskDefinitions(params: ECS.ListTaskDefinitionsRequest, callback?: (err: ECS.ServerException|ECS.ClientException|ECS.InvalidParameterException|any, data: ECS.ListTaskDefinitionsResponse|any) => void): Request;
    listTasks(params: ECS.ListTasksRequest, callback?: (err: ECS.ServerException|ECS.ClientException|ECS.InvalidParameterException|ECS.ClusterNotFoundException|ECS.ServiceNotFoundException|any, data: ECS.ListTasksResponse|any) => void): Request;
    registerContainerInstance(params: ECS.RegisterContainerInstanceRequest, callback?: (err: ECS.ServerException|ECS.ClientException|any, data: ECS.RegisterContainerInstanceResponse|any) => void): Request;
    registerTaskDefinition(params: ECS.RegisterTaskDefinitionRequest, callback?: (err: ECS.ServerException|ECS.ClientException|ECS.InvalidParameterException|any, data: ECS.RegisterTaskDefinitionResponse|any) => void): Request;
    runTask(params: ECS.RunTaskRequest, callback?: (err: ECS.ServerException|ECS.ClientException|ECS.InvalidParameterException|ECS.ClusterNotFoundException|any, data: ECS.RunTaskResponse|any) => void): Request;
    startTask(params: ECS.StartTaskRequest, callback?: (err: ECS.ServerException|ECS.ClientException|ECS.InvalidParameterException|ECS.ClusterNotFoundException|any, data: ECS.StartTaskResponse|any) => void): Request;
    stopTask(params: ECS.StopTaskRequest, callback?: (err: ECS.ServerException|ECS.ClientException|ECS.InvalidParameterException|ECS.ClusterNotFoundException|any, data: ECS.StopTaskResponse|any) => void): Request;
    submitContainerStateChange(params: ECS.SubmitContainerStateChangeRequest, callback?: (err: ECS.ServerException|ECS.ClientException|any, data: ECS.SubmitContainerStateChangeResponse|any) => void): Request;
    submitTaskStateChange(params: ECS.SubmitTaskStateChangeRequest, callback?: (err: ECS.ServerException|ECS.ClientException|any, data: ECS.SubmitTaskStateChangeResponse|any) => void): Request;
    updateContainerAgent(params: ECS.UpdateContainerAgentRequest, callback?: (err: ECS.ServerException|ECS.ClientException|ECS.InvalidParameterException|ECS.ClusterNotFoundException|ECS.UpdateInProgressException|ECS.NoUpdateAvailableException|ECS.MissingVersionException|any, data: ECS.UpdateContainerAgentResponse|any) => void): Request;
    updateService(params: ECS.UpdateServiceRequest, callback?: (err: ECS.ServerException|ECS.ClientException|ECS.InvalidParameterException|ECS.ClusterNotFoundException|ECS.ServiceNotFoundException|ECS.ServiceNotActiveException|any, data: ECS.UpdateServiceResponse|any) => void): Request;

  }

  export module ECS {
    export type AgentUpdateStatus = string;
    export type Attributes = Attribute[];
    export type Boolean = boolean;
    export type BoxedBoolean = boolean;
    export type BoxedInteger = number;
    export type Clusters = Cluster[];
    export type ContainerDefinitions = ContainerDefinition[];
    export type ContainerInstances = ContainerInstance[];
    export type ContainerOverrides = ContainerOverride[];
    export type Containers = Container[];
    export type Deployments = Deployment[];
    export type DesiredStatus = string;
    export type DockerLabelsMap = {[key:string]: String};
    export type Double = number;
    export type EnvironmentVariables = KeyValuePair[];
    export type Failures = Failure[];
    export type HostEntryList = HostEntry[];
    export type Integer = number;
    export type LoadBalancers = LoadBalancer[];
    export type LogConfigurationOptionsMap = {[key:string]: String};
    export type LogDriver = string;
    export type Long = number;
    export type MountPointList = MountPoint[];
    export type NetworkBindings = NetworkBinding[];
    export type PortMappingList = PortMapping[];
    export type RequiresAttributes = Attribute[];
    export type Resources = Resource[];
    export type ServiceEvents = ServiceEvent[];
    export type Services = Service[];
    export type SortOrder = string;
    export type String = string;
    export type StringList = String[];
    export type TaskDefinitionStatus = string;
    export type Tasks = Task[];
    export type Timestamp = number;
    export type TransportProtocol = string;
    export type UlimitList = Ulimit[];
    export type UlimitName = string;
    export type VolumeFromList = VolumeFrom[];
    export type VolumeList = Volume[];

    export interface Attribute {
        name: String;
        value?: String;
    }
    export interface ClientException {
        message?: String;
    }
    export interface Cluster {
        clusterArn?: String;
        clusterName?: String;
        status?: String;
        registeredContainerInstancesCount?: Integer;
        runningTasksCount?: Integer;
        pendingTasksCount?: Integer;
        activeServicesCount?: Integer;
    }
    export interface ClusterContainsContainerInstancesException {
    }
    export interface ClusterContainsServicesException {
    }
    export interface ClusterNotFoundException {
    }
    export interface Container {
        containerArn?: String;
        taskArn?: String;
        name?: String;
        lastStatus?: String;
        exitCode?: BoxedInteger;
        reason?: String;
        networkBindings?: NetworkBindings;
    }
    export interface ContainerDefinition {
        name?: String;
        image?: String;
        cpu?: Integer;
        memory?: Integer;
        links?: StringList;
        portMappings?: PortMappingList;
        essential?: BoxedBoolean;
        entryPoint?: StringList;
        command?: StringList;
        environment?: EnvironmentVariables;
        mountPoints?: MountPointList;
        volumesFrom?: VolumeFromList;
        hostname?: String;
        user?: String;
        workingDirectory?: String;
        disableNetworking?: BoxedBoolean;
        privileged?: BoxedBoolean;
        readonlyRootFilesystem?: BoxedBoolean;
        dnsServers?: StringList;
        dnsSearchDomains?: StringList;
        extraHosts?: HostEntryList;
        dockerSecurityOptions?: StringList;
        dockerLabels?: DockerLabelsMap;
        ulimits?: UlimitList;
        logConfiguration?: LogConfiguration;
    }
    export interface ContainerInstance {
        containerInstanceArn?: String;
        ec2InstanceId?: String;
        versionInfo?: VersionInfo;
        remainingResources?: Resources;
        registeredResources?: Resources;
        status?: String;
        agentConnected?: Boolean;
        runningTasksCount?: Integer;
        pendingTasksCount?: Integer;
        agentUpdateStatus?: AgentUpdateStatus;
        attributes?: Attributes;
    }
    export interface ContainerOverride {
        name?: String;
        command?: StringList;
        environment?: EnvironmentVariables;
    }
    export interface CreateClusterRequest {
        clusterName?: String;
    }
    export interface CreateClusterResponse {
        cluster?: Cluster;
    }
    export interface CreateServiceRequest {
        cluster?: String;
        serviceName: String;
        taskDefinition: String;
        loadBalancers?: LoadBalancers;
        desiredCount: BoxedInteger;
        clientToken?: String;
        role?: String;
        deploymentConfiguration?: DeploymentConfiguration;
    }
    export interface CreateServiceResponse {
        service?: Service;
    }
    export interface DeleteClusterRequest {
        cluster: String;
    }
    export interface DeleteClusterResponse {
        cluster?: Cluster;
    }
    export interface DeleteServiceRequest {
        cluster?: String;
        service: String;
    }
    export interface DeleteServiceResponse {
        service?: Service;
    }
    export interface Deployment {
        id?: String;
        status?: String;
        taskDefinition?: String;
        desiredCount?: Integer;
        pendingCount?: Integer;
        runningCount?: Integer;
        createdAt?: Timestamp;
        updatedAt?: Timestamp;
    }
    export interface DeploymentConfiguration {
        maximumPercent?: BoxedInteger;
        minimumHealthyPercent?: BoxedInteger;
    }
    export interface DeregisterContainerInstanceRequest {
        cluster?: String;
        containerInstance: String;
        force?: BoxedBoolean;
    }
    export interface DeregisterContainerInstanceResponse {
        containerInstance?: ContainerInstance;
    }
    export interface DeregisterTaskDefinitionRequest {
        taskDefinition: String;
    }
    export interface DeregisterTaskDefinitionResponse {
        taskDefinition?: TaskDefinition;
    }
    export interface DescribeClustersRequest {
        clusters?: StringList;
    }
    export interface DescribeClustersResponse {
        clusters?: Clusters;
        failures?: Failures;
    }
    export interface DescribeContainerInstancesRequest {
        cluster?: String;
        containerInstances: StringList;
    }
    export interface DescribeContainerInstancesResponse {
        containerInstances?: ContainerInstances;
        failures?: Failures;
    }
    export interface DescribeServicesRequest {
        cluster?: String;
        services: StringList;
    }
    export interface DescribeServicesResponse {
        services?: Services;
        failures?: Failures;
    }
    export interface DescribeTaskDefinitionRequest {
        taskDefinition: String;
    }
    export interface DescribeTaskDefinitionResponse {
        taskDefinition?: TaskDefinition;
    }
    export interface DescribeTasksRequest {
        cluster?: String;
        tasks: StringList;
    }
    export interface DescribeTasksResponse {
        tasks?: Tasks;
        failures?: Failures;
    }
    export interface DiscoverPollEndpointRequest {
        containerInstance?: String;
        cluster?: String;
    }
    export interface DiscoverPollEndpointResponse {
        endpoint?: String;
        telemetryEndpoint?: String;
    }
    export interface Failure {
        arn?: String;
        reason?: String;
    }
    export interface HostEntry {
        hostname: String;
        ipAddress: String;
    }
    export interface HostVolumeProperties {
        sourcePath?: String;
    }
    export interface InvalidParameterException {
    }
    export interface KeyValuePair {
        name?: String;
        value?: String;
    }
    export interface ListClustersRequest {
        nextToken?: String;
        maxResults?: BoxedInteger;
    }
    export interface ListClustersResponse {
        clusterArns?: StringList;
        nextToken?: String;
    }
    export interface ListContainerInstancesRequest {
        cluster?: String;
        nextToken?: String;
        maxResults?: BoxedInteger;
    }
    export interface ListContainerInstancesResponse {
        containerInstanceArns?: StringList;
        nextToken?: String;
    }
    export interface ListServicesRequest {
        cluster?: String;
        nextToken?: String;
        maxResults?: BoxedInteger;
    }
    export interface ListServicesResponse {
        serviceArns?: StringList;
        nextToken?: String;
    }
    export interface ListTaskDefinitionFamiliesRequest {
        familyPrefix?: String;
        nextToken?: String;
        maxResults?: BoxedInteger;
    }
    export interface ListTaskDefinitionFamiliesResponse {
        families?: StringList;
        nextToken?: String;
    }
    export interface ListTaskDefinitionsRequest {
        familyPrefix?: String;
        status?: TaskDefinitionStatus;
        sort?: SortOrder;
        nextToken?: String;
        maxResults?: BoxedInteger;
    }
    export interface ListTaskDefinitionsResponse {
        taskDefinitionArns?: StringList;
        nextToken?: String;
    }
    export interface ListTasksRequest {
        cluster?: String;
        containerInstance?: String;
        family?: String;
        nextToken?: String;
        maxResults?: BoxedInteger;
        startedBy?: String;
        serviceName?: String;
        desiredStatus?: DesiredStatus;
    }
    export interface ListTasksResponse {
        taskArns?: StringList;
        nextToken?: String;
    }
    export interface LoadBalancer {
        loadBalancerName?: String;
        containerName?: String;
        containerPort?: BoxedInteger;
    }
    export interface LogConfiguration {
        logDriver: LogDriver;
        options?: LogConfigurationOptionsMap;
    }
    export interface MissingVersionException {
    }
    export interface MountPoint {
        sourceVolume?: String;
        containerPath?: String;
        readOnly?: BoxedBoolean;
    }
    export interface NetworkBinding {
        bindIP?: String;
        containerPort?: BoxedInteger;
        hostPort?: BoxedInteger;
        protocol?: TransportProtocol;
    }
    export interface NoUpdateAvailableException {
    }
    export interface PortMapping {
        containerPort?: Integer;
        hostPort?: Integer;
        protocol?: TransportProtocol;
    }
    export interface RegisterContainerInstanceRequest {
        cluster?: String;
        instanceIdentityDocument?: String;
        instanceIdentityDocumentSignature?: String;
        totalResources?: Resources;
        versionInfo?: VersionInfo;
        containerInstanceArn?: String;
        attributes?: Attributes;
    }
    export interface RegisterContainerInstanceResponse {
        containerInstance?: ContainerInstance;
    }
    export interface RegisterTaskDefinitionRequest {
        family: String;
        containerDefinitions: ContainerDefinitions;
        volumes?: VolumeList;
    }
    export interface RegisterTaskDefinitionResponse {
        taskDefinition?: TaskDefinition;
    }
    export interface Resource {
        name?: String;
        type?: String;
        doubleValue?: Double;
        longValue?: Long;
        integerValue?: Integer;
        stringSetValue?: StringList;
    }
    export interface RunTaskRequest {
        cluster?: String;
        taskDefinition: String;
        overrides?: TaskOverride;
        count?: BoxedInteger;
        startedBy?: String;
    }
    export interface RunTaskResponse {
        tasks?: Tasks;
        failures?: Failures;
    }
    export interface ServerException {
        message?: String;
    }
    export interface Service {
        serviceArn?: String;
        serviceName?: String;
        clusterArn?: String;
        loadBalancers?: LoadBalancers;
        status?: String;
        desiredCount?: Integer;
        runningCount?: Integer;
        pendingCount?: Integer;
        taskDefinition?: String;
        deploymentConfiguration?: DeploymentConfiguration;
        deployments?: Deployments;
        roleArn?: String;
        events?: ServiceEvents;
    }
    export interface ServiceEvent {
        id?: String;
        createdAt?: Timestamp;
        message?: String;
    }
    export interface ServiceNotActiveException {
    }
    export interface ServiceNotFoundException {
    }
    export interface StartTaskRequest {
        cluster?: String;
        taskDefinition: String;
        overrides?: TaskOverride;
        containerInstances: StringList;
        startedBy?: String;
    }
    export interface StartTaskResponse {
        tasks?: Tasks;
        failures?: Failures;
    }
    export interface StopTaskRequest {
        cluster?: String;
        task: String;
        reason?: String;
    }
    export interface StopTaskResponse {
        task?: Task;
    }
    export interface SubmitContainerStateChangeRequest {
        cluster?: String;
        task?: String;
        containerName?: String;
        status?: String;
        exitCode?: BoxedInteger;
        reason?: String;
        networkBindings?: NetworkBindings;
    }
    export interface SubmitContainerStateChangeResponse {
        acknowledgment?: String;
    }
    export interface SubmitTaskStateChangeRequest {
        cluster?: String;
        task?: String;
        status?: String;
        reason?: String;
    }
    export interface SubmitTaskStateChangeResponse {
        acknowledgment?: String;
    }
    export interface Task {
        taskArn?: String;
        clusterArn?: String;
        taskDefinitionArn?: String;
        containerInstanceArn?: String;
        overrides?: TaskOverride;
        lastStatus?: String;
        desiredStatus?: String;
        containers?: Containers;
        startedBy?: String;
        stoppedReason?: String;
        createdAt?: Timestamp;
        startedAt?: Timestamp;
        stoppedAt?: Timestamp;
    }
    export interface TaskDefinition {
        taskDefinitionArn?: String;
        containerDefinitions?: ContainerDefinitions;
        family?: String;
        revision?: Integer;
        volumes?: VolumeList;
        status?: TaskDefinitionStatus;
        requiresAttributes?: RequiresAttributes;
    }
    export interface TaskOverride {
        containerOverrides?: ContainerOverrides;
    }
    export interface Ulimit {
        name: UlimitName;
        softLimit: Integer;
        hardLimit: Integer;
    }
    export interface UpdateContainerAgentRequest {
        cluster?: String;
        containerInstance: String;
    }
    export interface UpdateContainerAgentResponse {
        containerInstance?: ContainerInstance;
    }
    export interface UpdateInProgressException {
    }
    export interface UpdateServiceRequest {
        cluster?: String;
        service: String;
        desiredCount?: BoxedInteger;
        taskDefinition?: String;
        deploymentConfiguration?: DeploymentConfiguration;
    }
    export interface UpdateServiceResponse {
        service?: Service;
    }
    export interface VersionInfo {
        agentVersion?: String;
        agentHash?: String;
        dockerVersion?: String;
    }
    export interface Volume {
        name?: String;
        host?: HostVolumeProperties;
    }
    export interface VolumeFrom {
        sourceContainer?: String;
        readOnly?: BoxedBoolean;
    }
  }

  /*
   * apiVersion: 2015-02-01
   * endpointPrefix: elasticfilesystem
   * serviceAbbreviation: EFS
   * signatureVersion: v4
   * protocol: rest-json
   */
  export class EFS extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    createFileSystem(params: EFS.CreateFileSystemRequest, callback?: (err: EFS.BadRequest|EFS.InternalServerError|EFS.FileSystemAlreadyExists|EFS.FileSystemLimitExceeded|any, data: EFS.FileSystemDescription|any) => void): Request;
    createMountTarget(params: EFS.CreateMountTargetRequest, callback?: (err: EFS.BadRequest|EFS.InternalServerError|EFS.FileSystemNotFound|EFS.IncorrectFileSystemLifeCycleState|EFS.MountTargetConflict|EFS.SubnetNotFound|EFS.NoFreeAddressesInSubnet|EFS.IpAddressInUse|EFS.NetworkInterfaceLimitExceeded|EFS.SecurityGroupLimitExceeded|EFS.SecurityGroupNotFound|EFS.UnsupportedAvailabilityZone|any, data: EFS.MountTargetDescription|any) => void): Request;
    createTags(params: EFS.CreateTagsRequest, callback?: (err: EFS.BadRequest|EFS.InternalServerError|EFS.FileSystemNotFound|any, data: any) => void): Request;
    deleteFileSystem(params: EFS.DeleteFileSystemRequest, callback?: (err: EFS.BadRequest|EFS.InternalServerError|EFS.FileSystemNotFound|EFS.FileSystemInUse|any, data: any) => void): Request;
    deleteMountTarget(params: EFS.DeleteMountTargetRequest, callback?: (err: EFS.BadRequest|EFS.InternalServerError|EFS.DependencyTimeout|EFS.MountTargetNotFound|any, data: any) => void): Request;
    deleteTags(params: EFS.DeleteTagsRequest, callback?: (err: EFS.BadRequest|EFS.InternalServerError|EFS.FileSystemNotFound|any, data: any) => void): Request;
    describeFileSystems(params: EFS.DescribeFileSystemsRequest, callback?: (err: EFS.BadRequest|EFS.InternalServerError|EFS.FileSystemNotFound|any, data: EFS.DescribeFileSystemsResponse|any) => void): Request;
    describeMountTargetSecurityGroups(params: EFS.DescribeMountTargetSecurityGroupsRequest, callback?: (err: EFS.BadRequest|EFS.InternalServerError|EFS.MountTargetNotFound|EFS.IncorrectMountTargetState|any, data: EFS.DescribeMountTargetSecurityGroupsResponse|any) => void): Request;
    describeMountTargets(params: EFS.DescribeMountTargetsRequest, callback?: (err: EFS.BadRequest|EFS.InternalServerError|EFS.FileSystemNotFound|EFS.MountTargetNotFound|any, data: EFS.DescribeMountTargetsResponse|any) => void): Request;
    describeTags(params: EFS.DescribeTagsRequest, callback?: (err: EFS.BadRequest|EFS.InternalServerError|EFS.FileSystemNotFound|any, data: EFS.DescribeTagsResponse|any) => void): Request;
    modifyMountTargetSecurityGroups(params: EFS.ModifyMountTargetSecurityGroupsRequest, callback?: (err: EFS.BadRequest|EFS.InternalServerError|EFS.MountTargetNotFound|EFS.IncorrectMountTargetState|EFS.SecurityGroupLimitExceeded|EFS.SecurityGroupNotFound|any, data: any) => void): Request;

  }

  export module EFS {
    export type AwsAccountId = string;
    export type CreationToken = string;    // max: 64, min: 1
    export type ErrorCode = string;    // min: 1
    export type ErrorMessage = string;
    export type FileSystemDescriptions = FileSystemDescription[];
    export type FileSystemId = string;
    export type FileSystemSizeValue = number;
    export type IpAddress = string;
    export type LifeCycleState = string;
    export type Marker = string;
    export type MaxItems = number;    // min: 1
    export type MountTargetCount = number;
    export type MountTargetDescriptions = MountTargetDescription[];
    export type MountTargetId = string;
    export type NetworkInterfaceId = string;
    export type SecurityGroup = string;
    export type SecurityGroups = SecurityGroup[];    // max: 5
    export type SubnetId = string;
    export type TagKey = string;    // max: 128, min: 1
    export type TagKeys = TagKey[];
    export type TagValue = string;    // max: 256
    export type Tags = Tag[];
    export type Timestamp = number;

    export interface BadRequest {
        ErrorCode: ErrorCode;
        Message?: ErrorMessage;
    }
    export interface CreateFileSystemRequest {
        CreationToken: CreationToken;
    }
    export interface CreateMountTargetRequest {
        FileSystemId: FileSystemId;
        SubnetId: SubnetId;
        IpAddress?: IpAddress;
        SecurityGroups?: SecurityGroups;
    }
    export interface CreateTagsRequest {
        FileSystemId: FileSystemId;
        Tags: Tags;
    }
    export interface DeleteFileSystemRequest {
        FileSystemId: FileSystemId;
    }
    export interface DeleteMountTargetRequest {
        MountTargetId: MountTargetId;
    }
    export interface DeleteTagsRequest {
        FileSystemId: FileSystemId;
        TagKeys: TagKeys;
    }
    export interface DependencyTimeout {
        ErrorCode: ErrorCode;
        Message?: ErrorMessage;
    }
    export interface DescribeFileSystemsRequest {
        MaxItems?: MaxItems;
        Marker?: Marker;
        CreationToken?: CreationToken;
        FileSystemId?: FileSystemId;
    }
    export interface DescribeFileSystemsResponse {
        Marker?: Marker;
        FileSystems?: FileSystemDescriptions;
        NextMarker?: Marker;
    }
    export interface DescribeMountTargetSecurityGroupsRequest {
        MountTargetId: MountTargetId;
    }
    export interface DescribeMountTargetSecurityGroupsResponse {
        SecurityGroups: SecurityGroups;
    }
    export interface DescribeMountTargetsRequest {
        MaxItems?: MaxItems;
        Marker?: Marker;
        FileSystemId?: FileSystemId;
        MountTargetId?: MountTargetId;
    }
    export interface DescribeMountTargetsResponse {
        Marker?: Marker;
        MountTargets?: MountTargetDescriptions;
        NextMarker?: Marker;
    }
    export interface DescribeTagsRequest {
        MaxItems?: MaxItems;
        Marker?: Marker;
        FileSystemId: FileSystemId;
    }
    export interface DescribeTagsResponse {
        Marker?: Marker;
        Tags: Tags;
        NextMarker?: Marker;
    }
    export interface FileSystemAlreadyExists {
        ErrorCode: ErrorCode;
        Message?: ErrorMessage;
        FileSystemId: FileSystemId;
    }
    export interface FileSystemDescription {
        OwnerId: AwsAccountId;
        CreationToken: CreationToken;
        FileSystemId: FileSystemId;
        CreationTime: Timestamp;
        LifeCycleState: LifeCycleState;
        Name?: TagValue;
        NumberOfMountTargets: MountTargetCount;
        SizeInBytes: FileSystemSize;
    }
    export interface FileSystemInUse {
        ErrorCode: ErrorCode;
        Message?: ErrorMessage;
    }
    export interface FileSystemLimitExceeded {
        ErrorCode: ErrorCode;
        Message?: ErrorMessage;
    }
    export interface FileSystemNotFound {
        ErrorCode: ErrorCode;
        Message?: ErrorMessage;
    }
    export interface FileSystemSize {
        Value: FileSystemSizeValue;
        Timestamp?: Timestamp;
    }
    export interface IncorrectFileSystemLifeCycleState {
        ErrorCode: ErrorCode;
        Message?: ErrorMessage;
    }
    export interface IncorrectMountTargetState {
        ErrorCode: ErrorCode;
        Message?: ErrorMessage;
    }
    export interface InternalServerError {
        ErrorCode: ErrorCode;
        Message?: ErrorMessage;
    }
    export interface IpAddressInUse {
        ErrorCode: ErrorCode;
        Message?: ErrorMessage;
    }
    export interface ModifyMountTargetSecurityGroupsRequest {
        MountTargetId: MountTargetId;
        SecurityGroups?: SecurityGroups;
    }
    export interface MountTargetConflict {
        ErrorCode: ErrorCode;
        Message?: ErrorMessage;
    }
    export interface MountTargetDescription {
        OwnerId?: AwsAccountId;
        MountTargetId: MountTargetId;
        FileSystemId: FileSystemId;
        SubnetId: SubnetId;
        LifeCycleState: LifeCycleState;
        IpAddress?: IpAddress;
        NetworkInterfaceId?: NetworkInterfaceId;
    }
    export interface MountTargetNotFound {
        ErrorCode: ErrorCode;
        Message?: ErrorMessage;
    }
    export interface NetworkInterfaceLimitExceeded {
        ErrorCode: ErrorCode;
        Message?: ErrorMessage;
    }
    export interface NoFreeAddressesInSubnet {
        ErrorCode: ErrorCode;
        Message?: ErrorMessage;
    }
    export interface SecurityGroupLimitExceeded {
        ErrorCode: ErrorCode;
        Message?: ErrorMessage;
    }
    export interface SecurityGroupNotFound {
        ErrorCode: ErrorCode;
        Message?: ErrorMessage;
    }
    export interface SubnetNotFound {
        ErrorCode: ErrorCode;
        Message?: ErrorMessage;
    }
    export interface Tag {
        Key: TagKey;
        Value: TagValue;
    }
    export interface UnsupportedAvailabilityZone {
        ErrorCode: ErrorCode;
        Message?: ErrorMessage;
    }
  }

  /*
   * apiVersion: 2015-02-02
   * endpointPrefix: elasticache
   * serviceAbbreviation: 
   * signatureVersion: v4
   * protocol: query
   */
  export class ElastiCache extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    addTagsToResource(params: ElastiCache.AddTagsToResourceMessage, callback?: (err: ElastiCache.CacheClusterNotFoundFault|ElastiCache.SnapshotNotFoundFault|ElastiCache.TagQuotaPerResourceExceeded|ElastiCache.InvalidARNFault|any, data: ElastiCache.TagListMessage|any) => void): Request;
    authorizeCacheSecurityGroupIngress(params: ElastiCache.AuthorizeCacheSecurityGroupIngressMessage, callback?: (err: ElastiCache.CacheSecurityGroupNotFoundFault|ElastiCache.InvalidCacheSecurityGroupStateFault|ElastiCache.AuthorizationAlreadyExistsFault|ElastiCache.InvalidParameterValueException|ElastiCache.InvalidParameterCombinationException|any, data: ElastiCache.AuthorizeCacheSecurityGroupIngressResult|any) => void): Request;
    copySnapshot(params: ElastiCache.CopySnapshotMessage, callback?: (err: ElastiCache.SnapshotAlreadyExistsFault|ElastiCache.SnapshotNotFoundFault|ElastiCache.SnapshotQuotaExceededFault|ElastiCache.InvalidSnapshotStateFault|ElastiCache.InvalidParameterValueException|ElastiCache.InvalidParameterCombinationException|any, data: ElastiCache.CopySnapshotResult|any) => void): Request;
    createCacheCluster(params: ElastiCache.CreateCacheClusterMessage, callback?: (err: ElastiCache.ReplicationGroupNotFoundFault|ElastiCache.InvalidReplicationGroupStateFault|ElastiCache.CacheClusterAlreadyExistsFault|ElastiCache.InsufficientCacheClusterCapacityFault|ElastiCache.CacheSecurityGroupNotFoundFault|ElastiCache.CacheSubnetGroupNotFoundFault|ElastiCache.ClusterQuotaForCustomerExceededFault|ElastiCache.NodeQuotaForClusterExceededFault|ElastiCache.NodeQuotaForCustomerExceededFault|ElastiCache.CacheParameterGroupNotFoundFault|ElastiCache.InvalidVPCNetworkStateFault|ElastiCache.TagQuotaPerResourceExceeded|ElastiCache.InvalidParameterValueException|ElastiCache.InvalidParameterCombinationException|any, data: ElastiCache.CreateCacheClusterResult|any) => void): Request;
    createCacheParameterGroup(params: ElastiCache.CreateCacheParameterGroupMessage, callback?: (err: ElastiCache.CacheParameterGroupQuotaExceededFault|ElastiCache.CacheParameterGroupAlreadyExistsFault|ElastiCache.InvalidCacheParameterGroupStateFault|ElastiCache.InvalidParameterValueException|ElastiCache.InvalidParameterCombinationException|any, data: ElastiCache.CreateCacheParameterGroupResult|any) => void): Request;
    createCacheSecurityGroup(params: ElastiCache.CreateCacheSecurityGroupMessage, callback?: (err: ElastiCache.CacheSecurityGroupAlreadyExistsFault|ElastiCache.CacheSecurityGroupQuotaExceededFault|ElastiCache.InvalidParameterValueException|ElastiCache.InvalidParameterCombinationException|any, data: ElastiCache.CreateCacheSecurityGroupResult|any) => void): Request;
    createCacheSubnetGroup(params: ElastiCache.CreateCacheSubnetGroupMessage, callback?: (err: ElastiCache.CacheSubnetGroupAlreadyExistsFault|ElastiCache.CacheSubnetGroupQuotaExceededFault|ElastiCache.CacheSubnetQuotaExceededFault|ElastiCache.InvalidSubnet|any, data: ElastiCache.CreateCacheSubnetGroupResult|any) => void): Request;
    createReplicationGroup(params: ElastiCache.CreateReplicationGroupMessage, callback?: (err: ElastiCache.CacheClusterNotFoundFault|ElastiCache.InvalidCacheClusterStateFault|ElastiCache.ReplicationGroupAlreadyExistsFault|ElastiCache.InsufficientCacheClusterCapacityFault|ElastiCache.CacheSecurityGroupNotFoundFault|ElastiCache.CacheSubnetGroupNotFoundFault|ElastiCache.ClusterQuotaForCustomerExceededFault|ElastiCache.NodeQuotaForClusterExceededFault|ElastiCache.NodeQuotaForCustomerExceededFault|ElastiCache.CacheParameterGroupNotFoundFault|ElastiCache.InvalidVPCNetworkStateFault|ElastiCache.TagQuotaPerResourceExceeded|ElastiCache.InvalidParameterValueException|ElastiCache.InvalidParameterCombinationException|any, data: ElastiCache.CreateReplicationGroupResult|any) => void): Request;
    createSnapshot(params: ElastiCache.CreateSnapshotMessage, callback?: (err: ElastiCache.SnapshotAlreadyExistsFault|ElastiCache.CacheClusterNotFoundFault|ElastiCache.InvalidCacheClusterStateFault|ElastiCache.SnapshotQuotaExceededFault|ElastiCache.SnapshotFeatureNotSupportedFault|ElastiCache.InvalidParameterCombinationException|ElastiCache.InvalidParameterValueException|any, data: ElastiCache.CreateSnapshotResult|any) => void): Request;
    deleteCacheCluster(params: ElastiCache.DeleteCacheClusterMessage, callback?: (err: ElastiCache.CacheClusterNotFoundFault|ElastiCache.InvalidCacheClusterStateFault|ElastiCache.SnapshotAlreadyExistsFault|ElastiCache.SnapshotFeatureNotSupportedFault|ElastiCache.SnapshotQuotaExceededFault|ElastiCache.InvalidParameterValueException|ElastiCache.InvalidParameterCombinationException|any, data: ElastiCache.DeleteCacheClusterResult|any) => void): Request;
    deleteCacheParameterGroup(params: ElastiCache.DeleteCacheParameterGroupMessage, callback?: (err: ElastiCache.InvalidCacheParameterGroupStateFault|ElastiCache.CacheParameterGroupNotFoundFault|ElastiCache.InvalidParameterValueException|ElastiCache.InvalidParameterCombinationException|any, data: any) => void): Request;
    deleteCacheSecurityGroup(params: ElastiCache.DeleteCacheSecurityGroupMessage, callback?: (err: ElastiCache.InvalidCacheSecurityGroupStateFault|ElastiCache.CacheSecurityGroupNotFoundFault|ElastiCache.InvalidParameterValueException|ElastiCache.InvalidParameterCombinationException|any, data: any) => void): Request;
    deleteCacheSubnetGroup(params: ElastiCache.DeleteCacheSubnetGroupMessage, callback?: (err: ElastiCache.CacheSubnetGroupInUse|ElastiCache.CacheSubnetGroupNotFoundFault|any, data: any) => void): Request;
    deleteReplicationGroup(params: ElastiCache.DeleteReplicationGroupMessage, callback?: (err: ElastiCache.ReplicationGroupNotFoundFault|ElastiCache.InvalidReplicationGroupStateFault|ElastiCache.SnapshotAlreadyExistsFault|ElastiCache.SnapshotFeatureNotSupportedFault|ElastiCache.SnapshotQuotaExceededFault|ElastiCache.InvalidParameterValueException|ElastiCache.InvalidParameterCombinationException|any, data: ElastiCache.DeleteReplicationGroupResult|any) => void): Request;
    deleteSnapshot(params: ElastiCache.DeleteSnapshotMessage, callback?: (err: ElastiCache.SnapshotNotFoundFault|ElastiCache.InvalidSnapshotStateFault|ElastiCache.InvalidParameterValueException|ElastiCache.InvalidParameterCombinationException|any, data: ElastiCache.DeleteSnapshotResult|any) => void): Request;
    describeCacheClusters(params: ElastiCache.DescribeCacheClustersMessage, callback?: (err: ElastiCache.CacheClusterNotFoundFault|ElastiCache.InvalidParameterValueException|ElastiCache.InvalidParameterCombinationException|any, data: ElastiCache.CacheClusterMessage|any) => void): Request;
    describeCacheEngineVersions(params: ElastiCache.DescribeCacheEngineVersionsMessage, callback?: (err: any, data: ElastiCache.CacheEngineVersionMessage|any) => void): Request;
    describeCacheParameterGroups(params: ElastiCache.DescribeCacheParameterGroupsMessage, callback?: (err: ElastiCache.CacheParameterGroupNotFoundFault|ElastiCache.InvalidParameterValueException|ElastiCache.InvalidParameterCombinationException|any, data: ElastiCache.CacheParameterGroupsMessage|any) => void): Request;
    describeCacheParameters(params: ElastiCache.DescribeCacheParametersMessage, callback?: (err: ElastiCache.CacheParameterGroupNotFoundFault|ElastiCache.InvalidParameterValueException|ElastiCache.InvalidParameterCombinationException|any, data: ElastiCache.CacheParameterGroupDetails|any) => void): Request;
    describeCacheSecurityGroups(params: ElastiCache.DescribeCacheSecurityGroupsMessage, callback?: (err: ElastiCache.CacheSecurityGroupNotFoundFault|ElastiCache.InvalidParameterValueException|ElastiCache.InvalidParameterCombinationException|any, data: ElastiCache.CacheSecurityGroupMessage|any) => void): Request;
    describeCacheSubnetGroups(params: ElastiCache.DescribeCacheSubnetGroupsMessage, callback?: (err: ElastiCache.CacheSubnetGroupNotFoundFault|any, data: ElastiCache.CacheSubnetGroupMessage|any) => void): Request;
    describeEngineDefaultParameters(params: ElastiCache.DescribeEngineDefaultParametersMessage, callback?: (err: ElastiCache.InvalidParameterValueException|ElastiCache.InvalidParameterCombinationException|any, data: ElastiCache.DescribeEngineDefaultParametersResult|any) => void): Request;
    describeEvents(params: ElastiCache.DescribeEventsMessage, callback?: (err: ElastiCache.InvalidParameterValueException|ElastiCache.InvalidParameterCombinationException|any, data: ElastiCache.EventsMessage|any) => void): Request;
    describeReplicationGroups(params: ElastiCache.DescribeReplicationGroupsMessage, callback?: (err: ElastiCache.ReplicationGroupNotFoundFault|ElastiCache.InvalidParameterValueException|ElastiCache.InvalidParameterCombinationException|any, data: ElastiCache.ReplicationGroupMessage|any) => void): Request;
    describeReservedCacheNodes(params: ElastiCache.DescribeReservedCacheNodesMessage, callback?: (err: ElastiCache.ReservedCacheNodeNotFoundFault|ElastiCache.InvalidParameterValueException|ElastiCache.InvalidParameterCombinationException|any, data: ElastiCache.ReservedCacheNodeMessage|any) => void): Request;
    describeReservedCacheNodesOfferings(params: ElastiCache.DescribeReservedCacheNodesOfferingsMessage, callback?: (err: ElastiCache.ReservedCacheNodesOfferingNotFoundFault|ElastiCache.InvalidParameterValueException|ElastiCache.InvalidParameterCombinationException|any, data: ElastiCache.ReservedCacheNodesOfferingMessage|any) => void): Request;
    describeSnapshots(params: ElastiCache.DescribeSnapshotsMessage, callback?: (err: ElastiCache.CacheClusterNotFoundFault|ElastiCache.SnapshotNotFoundFault|ElastiCache.InvalidParameterValueException|ElastiCache.InvalidParameterCombinationException|any, data: ElastiCache.DescribeSnapshotsListMessage|any) => void): Request;
    listTagsForResource(params: ElastiCache.ListTagsForResourceMessage, callback?: (err: ElastiCache.CacheClusterNotFoundFault|ElastiCache.SnapshotNotFoundFault|ElastiCache.InvalidARNFault|any, data: ElastiCache.TagListMessage|any) => void): Request;
    modifyCacheCluster(params: ElastiCache.ModifyCacheClusterMessage, callback?: (err: ElastiCache.InvalidCacheClusterStateFault|ElastiCache.InvalidCacheSecurityGroupStateFault|ElastiCache.InsufficientCacheClusterCapacityFault|ElastiCache.CacheClusterNotFoundFault|ElastiCache.NodeQuotaForClusterExceededFault|ElastiCache.NodeQuotaForCustomerExceededFault|ElastiCache.CacheSecurityGroupNotFoundFault|ElastiCache.CacheParameterGroupNotFoundFault|ElastiCache.InvalidVPCNetworkStateFault|ElastiCache.InvalidParameterValueException|ElastiCache.InvalidParameterCombinationException|any, data: ElastiCache.ModifyCacheClusterResult|any) => void): Request;
    modifyCacheParameterGroup(params: ElastiCache.ModifyCacheParameterGroupMessage, callback?: (err: ElastiCache.CacheParameterGroupNotFoundFault|ElastiCache.InvalidCacheParameterGroupStateFault|ElastiCache.InvalidParameterValueException|ElastiCache.InvalidParameterCombinationException|any, data: ElastiCache.CacheParameterGroupNameMessage|any) => void): Request;
    modifyCacheSubnetGroup(params: ElastiCache.ModifyCacheSubnetGroupMessage, callback?: (err: ElastiCache.CacheSubnetGroupNotFoundFault|ElastiCache.CacheSubnetQuotaExceededFault|ElastiCache.SubnetInUse|ElastiCache.InvalidSubnet|any, data: ElastiCache.ModifyCacheSubnetGroupResult|any) => void): Request;
    modifyReplicationGroup(params: ElastiCache.ModifyReplicationGroupMessage, callback?: (err: ElastiCache.ReplicationGroupNotFoundFault|ElastiCache.InvalidReplicationGroupStateFault|ElastiCache.InvalidCacheClusterStateFault|ElastiCache.InvalidCacheSecurityGroupStateFault|ElastiCache.InsufficientCacheClusterCapacityFault|ElastiCache.CacheClusterNotFoundFault|ElastiCache.NodeQuotaForClusterExceededFault|ElastiCache.NodeQuotaForCustomerExceededFault|ElastiCache.CacheSecurityGroupNotFoundFault|ElastiCache.CacheParameterGroupNotFoundFault|ElastiCache.InvalidVPCNetworkStateFault|ElastiCache.InvalidParameterValueException|ElastiCache.InvalidParameterCombinationException|any, data: ElastiCache.ModifyReplicationGroupResult|any) => void): Request;
    purchaseReservedCacheNodesOffering(params: ElastiCache.PurchaseReservedCacheNodesOfferingMessage, callback?: (err: ElastiCache.ReservedCacheNodesOfferingNotFoundFault|ElastiCache.ReservedCacheNodeAlreadyExistsFault|ElastiCache.ReservedCacheNodeQuotaExceededFault|ElastiCache.InvalidParameterValueException|ElastiCache.InvalidParameterCombinationException|any, data: ElastiCache.PurchaseReservedCacheNodesOfferingResult|any) => void): Request;
    rebootCacheCluster(params: ElastiCache.RebootCacheClusterMessage, callback?: (err: ElastiCache.InvalidCacheClusterStateFault|ElastiCache.CacheClusterNotFoundFault|any, data: ElastiCache.RebootCacheClusterResult|any) => void): Request;
    removeTagsFromResource(params: ElastiCache.RemoveTagsFromResourceMessage, callback?: (err: ElastiCache.CacheClusterNotFoundFault|ElastiCache.SnapshotNotFoundFault|ElastiCache.InvalidARNFault|ElastiCache.TagNotFoundFault|any, data: ElastiCache.TagListMessage|any) => void): Request;
    resetCacheParameterGroup(params: ElastiCache.ResetCacheParameterGroupMessage, callback?: (err: ElastiCache.InvalidCacheParameterGroupStateFault|ElastiCache.CacheParameterGroupNotFoundFault|ElastiCache.InvalidParameterValueException|ElastiCache.InvalidParameterCombinationException|any, data: ElastiCache.CacheParameterGroupNameMessage|any) => void): Request;
    revokeCacheSecurityGroupIngress(params: ElastiCache.RevokeCacheSecurityGroupIngressMessage, callback?: (err: ElastiCache.CacheSecurityGroupNotFoundFault|ElastiCache.AuthorizationNotFoundFault|ElastiCache.InvalidCacheSecurityGroupStateFault|ElastiCache.InvalidParameterValueException|ElastiCache.InvalidParameterCombinationException|any, data: ElastiCache.RevokeCacheSecurityGroupIngressResult|any) => void): Request;

  }

  export module ElastiCache {
    export type AZMode = string;
    export type AutomaticFailoverStatus = string;
    export type AvailabilityZonesList = String[];
    export type AwsQueryErrorMessage = string;
    export type Boolean = boolean;
    export type BooleanOptional = boolean;
    export type CacheClusterList = CacheCluster[];
    export type CacheEngineVersionList = CacheEngineVersion[];
    export type CacheNodeIdsList = String[];
    export type CacheNodeList = CacheNode[];
    export type CacheNodeTypeSpecificParametersList = CacheNodeTypeSpecificParameter[];
    export type CacheNodeTypeSpecificValueList = CacheNodeTypeSpecificValue[];
    export type CacheParameterGroupList = CacheParameterGroup[];
    export type CacheSecurityGroupMembershipList = CacheSecurityGroupMembership[];
    export type CacheSecurityGroupNameList = String[];
    export type CacheSecurityGroups = CacheSecurityGroup[];
    export type CacheSubnetGroups = CacheSubnetGroup[];
    export type ClusterIdList = String[];
    export type Double = number;
    export type EC2SecurityGroupList = EC2SecurityGroup[];
    export type EventList = Event[];
    export type Integer = number;
    export type IntegerOptional = number;
    export type KeyList = String[];
    export type NodeGroupList = NodeGroup[];
    export type NodeGroupMemberList = NodeGroupMember[];
    export type NodeSnapshotList = NodeSnapshot[];
    export type ParameterNameValueList = ParameterNameValue[];
    export type ParametersList = Parameter[];
    export type PendingAutomaticFailoverStatus = string;
    export type PreferredAvailabilityZoneList = String[];
    export type RecurringChargeList = RecurringCharge[];
    export type ReplicationGroupList = ReplicationGroup[];
    export type ReservedCacheNodeList = ReservedCacheNode[];
    export type ReservedCacheNodesOfferingList = ReservedCacheNodesOffering[];
    export type SecurityGroupIdsList = String[];
    export type SecurityGroupMembershipList = SecurityGroupMembership[];
    export type SnapshotArnsList = String[];
    export type SnapshotList = Snapshot[];
    export type SourceType = string;
    export type String = string;
    export type SubnetIdentifierList = String[];
    export type SubnetList = Subnet[];
    export type TStamp = number;
    export type TagList = Tag[];

    export interface AddTagsToResourceMessage {
        ResourceName: String;
        Tags: TagList;
    }
    export interface AuthorizationAlreadyExistsFault {
    }
    export interface AuthorizationNotFoundFault {
    }
    export interface AuthorizeCacheSecurityGroupIngressMessage {
        CacheSecurityGroupName: String;
        EC2SecurityGroupName: String;
        EC2SecurityGroupOwnerId: String;
    }
    export interface AvailabilityZone {
        Name?: String;
    }
    export interface CacheCluster {
        CacheClusterId?: String;
        ConfigurationEndpoint?: Endpoint;
        ClientDownloadLandingPage?: String;
        CacheNodeType?: String;
        Engine?: String;
        EngineVersion?: String;
        CacheClusterStatus?: String;
        NumCacheNodes?: IntegerOptional;
        PreferredAvailabilityZone?: String;
        CacheClusterCreateTime?: TStamp;
        PreferredMaintenanceWindow?: String;
        PendingModifiedValues?: PendingModifiedValues;
        NotificationConfiguration?: NotificationConfiguration;
        CacheSecurityGroups?: CacheSecurityGroupMembershipList;
        CacheParameterGroup?: CacheParameterGroupStatus;
        CacheSubnetGroupName?: String;
        CacheNodes?: CacheNodeList;
        AutoMinorVersionUpgrade?: Boolean;
        SecurityGroups?: SecurityGroupMembershipList;
        ReplicationGroupId?: String;
        SnapshotRetentionLimit?: IntegerOptional;
        SnapshotWindow?: String;
    }
    export interface CacheClusterAlreadyExistsFault {
    }
    export interface CacheClusterMessage {
        Marker?: String;
        CacheClusters?: CacheClusterList;
    }
    export interface CacheClusterNotFoundFault {
    }
    export interface CacheEngineVersion {
        Engine?: String;
        EngineVersion?: String;
        CacheParameterGroupFamily?: String;
        CacheEngineDescription?: String;
        CacheEngineVersionDescription?: String;
    }
    export interface CacheEngineVersionMessage {
        Marker?: String;
        CacheEngineVersions?: CacheEngineVersionList;
    }
    export interface CacheNode {
        CacheNodeId?: String;
        CacheNodeStatus?: String;
        CacheNodeCreateTime?: TStamp;
        Endpoint?: Endpoint;
        ParameterGroupStatus?: String;
        SourceCacheNodeId?: String;
        CustomerAvailabilityZone?: String;
    }
    export interface CacheNodeTypeSpecificParameter {
        ParameterName?: String;
        Description?: String;
        Source?: String;
        DataType?: String;
        AllowedValues?: String;
        IsModifiable?: Boolean;
        MinimumEngineVersion?: String;
        CacheNodeTypeSpecificValues?: CacheNodeTypeSpecificValueList;
    }
    export interface CacheNodeTypeSpecificValue {
        CacheNodeType?: String;
        Value?: String;
    }
    export interface CacheParameterGroup {
        CacheParameterGroupName?: String;
        CacheParameterGroupFamily?: String;
        Description?: String;
    }
    export interface CacheParameterGroupAlreadyExistsFault {
    }
    export interface CacheParameterGroupDetails {
        Marker?: String;
        Parameters?: ParametersList;
        CacheNodeTypeSpecificParameters?: CacheNodeTypeSpecificParametersList;
    }
    export interface CacheParameterGroupNameMessage {
        CacheParameterGroupName?: String;
    }
    export interface CacheParameterGroupNotFoundFault {
    }
    export interface CacheParameterGroupQuotaExceededFault {
    }
    export interface CacheParameterGroupStatus {
        CacheParameterGroupName?: String;
        ParameterApplyStatus?: String;
        CacheNodeIdsToReboot?: CacheNodeIdsList;
    }
    export interface CacheParameterGroupsMessage {
        Marker?: String;
        CacheParameterGroups?: CacheParameterGroupList;
    }
    export interface CacheSecurityGroup {
        OwnerId?: String;
        CacheSecurityGroupName?: String;
        Description?: String;
        EC2SecurityGroups?: EC2SecurityGroupList;
    }
    export interface CacheSecurityGroupAlreadyExistsFault {
    }
    export interface CacheSecurityGroupMembership {
        CacheSecurityGroupName?: String;
        Status?: String;
    }
    export interface CacheSecurityGroupMessage {
        Marker?: String;
        CacheSecurityGroups?: CacheSecurityGroups;
    }
    export interface CacheSecurityGroupNotFoundFault {
    }
    export interface CacheSecurityGroupQuotaExceededFault {
    }
    export interface CacheSubnetGroup {
        CacheSubnetGroupName?: String;
        CacheSubnetGroupDescription?: String;
        VpcId?: String;
        Subnets?: SubnetList;
    }
    export interface CacheSubnetGroupAlreadyExistsFault {
    }
    export interface CacheSubnetGroupInUse {
    }
    export interface CacheSubnetGroupMessage {
        Marker?: String;
        CacheSubnetGroups?: CacheSubnetGroups;
    }
    export interface CacheSubnetGroupNotFoundFault {
    }
    export interface CacheSubnetGroupQuotaExceededFault {
    }
    export interface CacheSubnetQuotaExceededFault {
    }
    export interface ClusterQuotaForCustomerExceededFault {
    }
    export interface CopySnapshotMessage {
        SourceSnapshotName: String;
        TargetSnapshotName: String;
    }
    export interface CreateCacheClusterMessage {
        CacheClusterId: String;
        ReplicationGroupId?: String;
        AZMode?: AZMode;
        PreferredAvailabilityZone?: String;
        PreferredAvailabilityZones?: PreferredAvailabilityZoneList;
        NumCacheNodes?: IntegerOptional;
        CacheNodeType?: String;
        Engine?: String;
        EngineVersion?: String;
        CacheParameterGroupName?: String;
        CacheSubnetGroupName?: String;
        CacheSecurityGroupNames?: CacheSecurityGroupNameList;
        SecurityGroupIds?: SecurityGroupIdsList;
        Tags?: TagList;
        SnapshotArns?: SnapshotArnsList;
        SnapshotName?: String;
        PreferredMaintenanceWindow?: String;
        Port?: IntegerOptional;
        NotificationTopicArn?: String;
        AutoMinorVersionUpgrade?: BooleanOptional;
        SnapshotRetentionLimit?: IntegerOptional;
        SnapshotWindow?: String;
    }
    export interface CreateCacheParameterGroupMessage {
        CacheParameterGroupName: String;
        CacheParameterGroupFamily: String;
        Description: String;
    }
    export interface CreateCacheSecurityGroupMessage {
        CacheSecurityGroupName: String;
        Description: String;
    }
    export interface CreateCacheSubnetGroupMessage {
        CacheSubnetGroupName: String;
        CacheSubnetGroupDescription: String;
        SubnetIds: SubnetIdentifierList;
    }
    export interface CreateReplicationGroupMessage {
        ReplicationGroupId: String;
        ReplicationGroupDescription: String;
        PrimaryClusterId?: String;
        AutomaticFailoverEnabled?: BooleanOptional;
        NumCacheClusters?: IntegerOptional;
        PreferredCacheClusterAZs?: AvailabilityZonesList;
        CacheNodeType?: String;
        Engine?: String;
        EngineVersion?: String;
        CacheParameterGroupName?: String;
        CacheSubnetGroupName?: String;
        CacheSecurityGroupNames?: CacheSecurityGroupNameList;
        SecurityGroupIds?: SecurityGroupIdsList;
        Tags?: TagList;
        SnapshotArns?: SnapshotArnsList;
        SnapshotName?: String;
        PreferredMaintenanceWindow?: String;
        Port?: IntegerOptional;
        NotificationTopicArn?: String;
        AutoMinorVersionUpgrade?: BooleanOptional;
        SnapshotRetentionLimit?: IntegerOptional;
        SnapshotWindow?: String;
    }
    export interface CreateSnapshotMessage {
        CacheClusterId: String;
        SnapshotName: String;
    }
    export interface DeleteCacheClusterMessage {
        CacheClusterId: String;
        FinalSnapshotIdentifier?: String;
    }
    export interface DeleteCacheParameterGroupMessage {
        CacheParameterGroupName: String;
    }
    export interface DeleteCacheSecurityGroupMessage {
        CacheSecurityGroupName: String;
    }
    export interface DeleteCacheSubnetGroupMessage {
        CacheSubnetGroupName: String;
    }
    export interface DeleteReplicationGroupMessage {
        ReplicationGroupId: String;
        RetainPrimaryCluster?: BooleanOptional;
        FinalSnapshotIdentifier?: String;
    }
    export interface DeleteSnapshotMessage {
        SnapshotName: String;
    }
    export interface DescribeCacheClustersMessage {
        CacheClusterId?: String;
        MaxRecords?: IntegerOptional;
        Marker?: String;
        ShowCacheNodeInfo?: BooleanOptional;
    }
    export interface DescribeCacheEngineVersionsMessage {
        Engine?: String;
        EngineVersion?: String;
        CacheParameterGroupFamily?: String;
        MaxRecords?: IntegerOptional;
        Marker?: String;
        DefaultOnly?: Boolean;
    }
    export interface DescribeCacheParameterGroupsMessage {
        CacheParameterGroupName?: String;
        MaxRecords?: IntegerOptional;
        Marker?: String;
    }
    export interface DescribeCacheParametersMessage {
        CacheParameterGroupName: String;
        Source?: String;
        MaxRecords?: IntegerOptional;
        Marker?: String;
    }
    export interface DescribeCacheSecurityGroupsMessage {
        CacheSecurityGroupName?: String;
        MaxRecords?: IntegerOptional;
        Marker?: String;
    }
    export interface DescribeCacheSubnetGroupsMessage {
        CacheSubnetGroupName?: String;
        MaxRecords?: IntegerOptional;
        Marker?: String;
    }
    export interface DescribeEngineDefaultParametersMessage {
        CacheParameterGroupFamily: String;
        MaxRecords?: IntegerOptional;
        Marker?: String;
    }
    export interface DescribeEventsMessage {
        SourceIdentifier?: String;
        SourceType?: SourceType;
        StartTime?: TStamp;
        EndTime?: TStamp;
        Duration?: IntegerOptional;
        MaxRecords?: IntegerOptional;
        Marker?: String;
    }
    export interface DescribeReplicationGroupsMessage {
        ReplicationGroupId?: String;
        MaxRecords?: IntegerOptional;
        Marker?: String;
    }
    export interface DescribeReservedCacheNodesMessage {
        ReservedCacheNodeId?: String;
        ReservedCacheNodesOfferingId?: String;
        CacheNodeType?: String;
        Duration?: String;
        ProductDescription?: String;
        OfferingType?: String;
        MaxRecords?: IntegerOptional;
        Marker?: String;
    }
    export interface DescribeReservedCacheNodesOfferingsMessage {
        ReservedCacheNodesOfferingId?: String;
        CacheNodeType?: String;
        Duration?: String;
        ProductDescription?: String;
        OfferingType?: String;
        MaxRecords?: IntegerOptional;
        Marker?: String;
    }
    export interface DescribeSnapshotsListMessage {
        Marker?: String;
        Snapshots?: SnapshotList;
    }
    export interface DescribeSnapshotsMessage {
        CacheClusterId?: String;
        SnapshotName?: String;
        SnapshotSource?: String;
        Marker?: String;
        MaxRecords?: IntegerOptional;
    }
    export interface EC2SecurityGroup {
        Status?: String;
        EC2SecurityGroupName?: String;
        EC2SecurityGroupOwnerId?: String;
    }
    export interface Endpoint {
        Address?: String;
        Port?: Integer;
    }
    export interface EngineDefaults {
        CacheParameterGroupFamily?: String;
        Marker?: String;
        Parameters?: ParametersList;
        CacheNodeTypeSpecificParameters?: CacheNodeTypeSpecificParametersList;
    }
    export interface Event {
        SourceIdentifier?: String;
        SourceType?: SourceType;
        Message?: String;
        Date?: TStamp;
    }
    export interface EventsMessage {
        Marker?: String;
        Events?: EventList;
    }
    export interface InsufficientCacheClusterCapacityFault {
    }
    export interface InvalidARNFault {
    }
    export interface InvalidCacheClusterStateFault {
    }
    export interface InvalidCacheParameterGroupStateFault {
    }
    export interface InvalidCacheSecurityGroupStateFault {
    }
    export interface InvalidParameterCombinationException {
        message?: AwsQueryErrorMessage;
    }
    export interface InvalidParameterValueException {
        message?: AwsQueryErrorMessage;
    }
    export interface InvalidReplicationGroupStateFault {
    }
    export interface InvalidSnapshotStateFault {
    }
    export interface InvalidSubnet {
    }
    export interface InvalidVPCNetworkStateFault {
    }
    export interface ListTagsForResourceMessage {
        ResourceName: String;
    }
    export interface ModifyCacheClusterMessage {
        CacheClusterId: String;
        NumCacheNodes?: IntegerOptional;
        CacheNodeIdsToRemove?: CacheNodeIdsList;
        AZMode?: AZMode;
        NewAvailabilityZones?: PreferredAvailabilityZoneList;
        CacheSecurityGroupNames?: CacheSecurityGroupNameList;
        SecurityGroupIds?: SecurityGroupIdsList;
        PreferredMaintenanceWindow?: String;
        NotificationTopicArn?: String;
        CacheParameterGroupName?: String;
        NotificationTopicStatus?: String;
        ApplyImmediately?: Boolean;
        EngineVersion?: String;
        AutoMinorVersionUpgrade?: BooleanOptional;
        SnapshotRetentionLimit?: IntegerOptional;
        SnapshotWindow?: String;
    }
    export interface ModifyCacheParameterGroupMessage {
        CacheParameterGroupName: String;
        ParameterNameValues: ParameterNameValueList;
    }
    export interface ModifyCacheSubnetGroupMessage {
        CacheSubnetGroupName: String;
        CacheSubnetGroupDescription?: String;
        SubnetIds?: SubnetIdentifierList;
    }
    export interface ModifyReplicationGroupMessage {
        ReplicationGroupId: String;
        ReplicationGroupDescription?: String;
        PrimaryClusterId?: String;
        SnapshottingClusterId?: String;
        AutomaticFailoverEnabled?: BooleanOptional;
        CacheSecurityGroupNames?: CacheSecurityGroupNameList;
        SecurityGroupIds?: SecurityGroupIdsList;
        PreferredMaintenanceWindow?: String;
        NotificationTopicArn?: String;
        CacheParameterGroupName?: String;
        NotificationTopicStatus?: String;
        ApplyImmediately?: Boolean;
        EngineVersion?: String;
        AutoMinorVersionUpgrade?: BooleanOptional;
        SnapshotRetentionLimit?: IntegerOptional;
        SnapshotWindow?: String;
    }
    export interface NodeGroup {
        NodeGroupId?: String;
        Status?: String;
        PrimaryEndpoint?: Endpoint;
        NodeGroupMembers?: NodeGroupMemberList;
    }
    export interface NodeGroupMember {
        CacheClusterId?: String;
        CacheNodeId?: String;
        ReadEndpoint?: Endpoint;
        PreferredAvailabilityZone?: String;
        CurrentRole?: String;
    }
    export interface NodeQuotaForClusterExceededFault {
    }
    export interface NodeQuotaForCustomerExceededFault {
    }
    export interface NodeSnapshot {
        CacheNodeId?: String;
        CacheSize?: String;
        CacheNodeCreateTime?: TStamp;
        SnapshotCreateTime?: TStamp;
    }
    export interface NotificationConfiguration {
        TopicArn?: String;
        TopicStatus?: String;
    }
    export interface Parameter {
        ParameterName?: String;
        ParameterValue?: String;
        Description?: String;
        Source?: String;
        DataType?: String;
        AllowedValues?: String;
        IsModifiable?: Boolean;
        MinimumEngineVersion?: String;
    }
    export interface ParameterNameValue {
        ParameterName?: String;
        ParameterValue?: String;
    }
    export interface PendingModifiedValues {
        NumCacheNodes?: IntegerOptional;
        CacheNodeIdsToRemove?: CacheNodeIdsList;
        EngineVersion?: String;
    }
    export interface PurchaseReservedCacheNodesOfferingMessage {
        ReservedCacheNodesOfferingId: String;
        ReservedCacheNodeId?: String;
        CacheNodeCount?: IntegerOptional;
    }
    export interface RebootCacheClusterMessage {
        CacheClusterId: String;
        CacheNodeIdsToReboot: CacheNodeIdsList;
    }
    export interface RecurringCharge {
        RecurringChargeAmount?: Double;
        RecurringChargeFrequency?: String;
    }
    export interface RemoveTagsFromResourceMessage {
        ResourceName: String;
        TagKeys: KeyList;
    }
    export interface ReplicationGroup {
        ReplicationGroupId?: String;
        Description?: String;
        Status?: String;
        PendingModifiedValues?: ReplicationGroupPendingModifiedValues;
        MemberClusters?: ClusterIdList;
        NodeGroups?: NodeGroupList;
        SnapshottingClusterId?: String;
        AutomaticFailover?: AutomaticFailoverStatus;
    }
    export interface ReplicationGroupAlreadyExistsFault {
    }
    export interface ReplicationGroupMessage {
        Marker?: String;
        ReplicationGroups?: ReplicationGroupList;
    }
    export interface ReplicationGroupNotFoundFault {
    }
    export interface ReplicationGroupPendingModifiedValues {
        PrimaryClusterId?: String;
        AutomaticFailoverStatus?: PendingAutomaticFailoverStatus;
    }
    export interface ReservedCacheNode {
        ReservedCacheNodeId?: String;
        ReservedCacheNodesOfferingId?: String;
        CacheNodeType?: String;
        StartTime?: TStamp;
        Duration?: Integer;
        FixedPrice?: Double;
        UsagePrice?: Double;
        CacheNodeCount?: Integer;
        ProductDescription?: String;
        OfferingType?: String;
        State?: String;
        RecurringCharges?: RecurringChargeList;
    }
    export interface ReservedCacheNodeAlreadyExistsFault {
    }
    export interface ReservedCacheNodeMessage {
        Marker?: String;
        ReservedCacheNodes?: ReservedCacheNodeList;
    }
    export interface ReservedCacheNodeNotFoundFault {
    }
    export interface ReservedCacheNodeQuotaExceededFault {
    }
    export interface ReservedCacheNodesOffering {
        ReservedCacheNodesOfferingId?: String;
        CacheNodeType?: String;
        Duration?: Integer;
        FixedPrice?: Double;
        UsagePrice?: Double;
        ProductDescription?: String;
        OfferingType?: String;
        RecurringCharges?: RecurringChargeList;
    }
    export interface ReservedCacheNodesOfferingMessage {
        Marker?: String;
        ReservedCacheNodesOfferings?: ReservedCacheNodesOfferingList;
    }
    export interface ReservedCacheNodesOfferingNotFoundFault {
    }
    export interface ResetCacheParameterGroupMessage {
        CacheParameterGroupName: String;
        ResetAllParameters?: Boolean;
        ParameterNameValues: ParameterNameValueList;
    }
    export interface RevokeCacheSecurityGroupIngressMessage {
        CacheSecurityGroupName: String;
        EC2SecurityGroupName: String;
        EC2SecurityGroupOwnerId: String;
    }
    export interface SecurityGroupMembership {
        SecurityGroupId?: String;
        Status?: String;
    }
    export interface Snapshot {
        SnapshotName?: String;
        CacheClusterId?: String;
        SnapshotStatus?: String;
        SnapshotSource?: String;
        CacheNodeType?: String;
        Engine?: String;
        EngineVersion?: String;
        NumCacheNodes?: IntegerOptional;
        PreferredAvailabilityZone?: String;
        CacheClusterCreateTime?: TStamp;
        PreferredMaintenanceWindow?: String;
        TopicArn?: String;
        Port?: IntegerOptional;
        CacheParameterGroupName?: String;
        CacheSubnetGroupName?: String;
        VpcId?: String;
        AutoMinorVersionUpgrade?: Boolean;
        SnapshotRetentionLimit?: IntegerOptional;
        SnapshotWindow?: String;
        NodeSnapshots?: NodeSnapshotList;
    }
    export interface SnapshotAlreadyExistsFault {
    }
    export interface SnapshotFeatureNotSupportedFault {
    }
    export interface SnapshotNotFoundFault {
    }
    export interface SnapshotQuotaExceededFault {
    }
    export interface Subnet {
        SubnetIdentifier?: String;
        SubnetAvailabilityZone?: AvailabilityZone;
    }
    export interface SubnetInUse {
    }
    export interface Tag {
        Key?: String;
        Value?: String;
    }
    export interface TagListMessage {
        TagList?: TagList;
    }
    export interface TagNotFoundFault {
    }
    export interface TagQuotaPerResourceExceeded {
    }
    export interface AuthorizeCacheSecurityGroupIngressResult {
        CacheSecurityGroup?: CacheSecurityGroup;
    }
    export interface CopySnapshotResult {
        Snapshot?: Snapshot;
    }
    export interface CreateCacheClusterResult {
        CacheCluster?: CacheCluster;
    }
    export interface CreateCacheParameterGroupResult {
        CacheParameterGroup?: CacheParameterGroup;
    }
    export interface CreateCacheSecurityGroupResult {
        CacheSecurityGroup?: CacheSecurityGroup;
    }
    export interface CreateCacheSubnetGroupResult {
        CacheSubnetGroup?: CacheSubnetGroup;
    }
    export interface CreateReplicationGroupResult {
        ReplicationGroup?: ReplicationGroup;
    }
    export interface CreateSnapshotResult {
        Snapshot?: Snapshot;
    }
    export interface DeleteCacheClusterResult {
        CacheCluster?: CacheCluster;
    }
    export interface DeleteReplicationGroupResult {
        ReplicationGroup?: ReplicationGroup;
    }
    export interface DeleteSnapshotResult {
        Snapshot?: Snapshot;
    }
    export interface DescribeEngineDefaultParametersResult {
        EngineDefaults?: EngineDefaults;
    }
    export interface ModifyCacheClusterResult {
        CacheCluster?: CacheCluster;
    }
    export interface ModifyCacheSubnetGroupResult {
        CacheSubnetGroup?: CacheSubnetGroup;
    }
    export interface ModifyReplicationGroupResult {
        ReplicationGroup?: ReplicationGroup;
    }
    export interface PurchaseReservedCacheNodesOfferingResult {
        ReservedCacheNode?: ReservedCacheNode;
    }
    export interface RebootCacheClusterResult {
        CacheCluster?: CacheCluster;
    }
    export interface RevokeCacheSecurityGroupIngressResult {
        CacheSecurityGroup?: CacheSecurityGroup;
    }
  }

  /*
   * apiVersion: 2010-12-01
   * endpointPrefix: elasticbeanstalk
   * serviceAbbreviation: Elastic Beanstalk
   * signatureVersion: v4
   * protocol: query
   */
  export class ElasticBeanstalk extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    abortEnvironmentUpdate(params: ElasticBeanstalk.AbortEnvironmentUpdateMessage, callback?: (err: ElasticBeanstalk.InsufficientPrivilegesException|any, data: any) => void): Request;
    checkDNSAvailability(params: ElasticBeanstalk.CheckDNSAvailabilityMessage, callback?: (err: any, data: ElasticBeanstalk.CheckDNSAvailabilityResultMessage|any) => void): Request;
    composeEnvironments(params: ElasticBeanstalk.ComposeEnvironmentsMessage, callback?: (err: ElasticBeanstalk.TooManyEnvironmentsException|ElasticBeanstalk.InsufficientPrivilegesException|any, data: ElasticBeanstalk.EnvironmentDescriptionsMessage|any) => void): Request;
    createApplication(params: ElasticBeanstalk.CreateApplicationMessage, callback?: (err: ElasticBeanstalk.TooManyApplicationsException|any, data: ElasticBeanstalk.ApplicationDescriptionMessage|any) => void): Request;
    createApplicationVersion(params: ElasticBeanstalk.CreateApplicationVersionMessage, callback?: (err: ElasticBeanstalk.TooManyApplicationsException|ElasticBeanstalk.TooManyApplicationVersionsException|ElasticBeanstalk.InsufficientPrivilegesException|ElasticBeanstalk.S3LocationNotInServiceRegionException|any, data: ElasticBeanstalk.ApplicationVersionDescriptionMessage|any) => void): Request;
    createConfigurationTemplate(params: ElasticBeanstalk.CreateConfigurationTemplateMessage, callback?: (err: ElasticBeanstalk.InsufficientPrivilegesException|ElasticBeanstalk.TooManyConfigurationTemplatesException|any, data: ElasticBeanstalk.ConfigurationSettingsDescription|any) => void): Request;
    createEnvironment(params: ElasticBeanstalk.CreateEnvironmentMessage, callback?: (err: ElasticBeanstalk.TooManyEnvironmentsException|ElasticBeanstalk.InsufficientPrivilegesException|any, data: ElasticBeanstalk.EnvironmentDescription|any) => void): Request;
    createStorageLocation(callback?: (err: ElasticBeanstalk.TooManyBucketsException|ElasticBeanstalk.S3SubscriptionRequiredException|ElasticBeanstalk.InsufficientPrivilegesException|any, data: ElasticBeanstalk.CreateStorageLocationResultMessage|any) => void): Request;
    deleteApplication(params: ElasticBeanstalk.DeleteApplicationMessage, callback?: (err: ElasticBeanstalk.OperationInProgressException|any, data: any) => void): Request;
    deleteApplicationVersion(params: ElasticBeanstalk.DeleteApplicationVersionMessage, callback?: (err: ElasticBeanstalk.SourceBundleDeletionException|ElasticBeanstalk.InsufficientPrivilegesException|ElasticBeanstalk.OperationInProgressException|ElasticBeanstalk.S3LocationNotInServiceRegionException|any, data: any) => void): Request;
    deleteConfigurationTemplate(params: ElasticBeanstalk.DeleteConfigurationTemplateMessage, callback?: (err: ElasticBeanstalk.OperationInProgressException|any, data: any) => void): Request;
    deleteEnvironmentConfiguration(params: ElasticBeanstalk.DeleteEnvironmentConfigurationMessage, callback?: (err: any, data: any) => void): Request;
    describeApplicationVersions(params: ElasticBeanstalk.DescribeApplicationVersionsMessage, callback?: (err: any, data: ElasticBeanstalk.ApplicationVersionDescriptionsMessage|any) => void): Request;
    describeApplications(params: ElasticBeanstalk.DescribeApplicationsMessage, callback?: (err: any, data: ElasticBeanstalk.ApplicationDescriptionsMessage|any) => void): Request;
    describeConfigurationOptions(params: ElasticBeanstalk.DescribeConfigurationOptionsMessage, callback?: (err: any, data: ElasticBeanstalk.ConfigurationOptionsDescription|any) => void): Request;
    describeConfigurationSettings(params: ElasticBeanstalk.DescribeConfigurationSettingsMessage, callback?: (err: any, data: ElasticBeanstalk.ConfigurationSettingsDescriptions|any) => void): Request;
    describeEnvironmentHealth(params: ElasticBeanstalk.DescribeEnvironmentHealthRequest, callback?: (err: ElasticBeanstalk.InvalidRequestException|ElasticBeanstalk.ElasticBeanstalkServiceException|any, data: ElasticBeanstalk.DescribeEnvironmentHealthResult|any) => void): Request;
    describeEnvironmentResources(params: ElasticBeanstalk.DescribeEnvironmentResourcesMessage, callback?: (err: ElasticBeanstalk.InsufficientPrivilegesException|any, data: ElasticBeanstalk.EnvironmentResourceDescriptionsMessage|any) => void): Request;
    describeEnvironments(params: ElasticBeanstalk.DescribeEnvironmentsMessage, callback?: (err: any, data: ElasticBeanstalk.EnvironmentDescriptionsMessage|any) => void): Request;
    describeEvents(params: ElasticBeanstalk.DescribeEventsMessage, callback?: (err: any, data: ElasticBeanstalk.EventDescriptionsMessage|any) => void): Request;
    describeInstancesHealth(params: ElasticBeanstalk.DescribeInstancesHealthRequest, callback?: (err: ElasticBeanstalk.InvalidRequestException|ElasticBeanstalk.ElasticBeanstalkServiceException|any, data: ElasticBeanstalk.DescribeInstancesHealthResult|any) => void): Request;
    listAvailableSolutionStacks(callback?: (err: any, data: ElasticBeanstalk.ListAvailableSolutionStacksResultMessage|any) => void): Request;
    rebuildEnvironment(params: ElasticBeanstalk.RebuildEnvironmentMessage, callback?: (err: ElasticBeanstalk.InsufficientPrivilegesException|any, data: any) => void): Request;
    requestEnvironmentInfo(params: ElasticBeanstalk.RequestEnvironmentInfoMessage, callback?: (err: any, data: any) => void): Request;
    restartAppServer(params: ElasticBeanstalk.RestartAppServerMessage, callback?: (err: any, data: any) => void): Request;
    retrieveEnvironmentInfo(params: ElasticBeanstalk.RetrieveEnvironmentInfoMessage, callback?: (err: any, data: ElasticBeanstalk.RetrieveEnvironmentInfoResultMessage|any) => void): Request;
    swapEnvironmentCNAMEs(params: ElasticBeanstalk.SwapEnvironmentCNAMEsMessage, callback?: (err: any, data: any) => void): Request;
    terminateEnvironment(params: ElasticBeanstalk.TerminateEnvironmentMessage, callback?: (err: ElasticBeanstalk.InsufficientPrivilegesException|any, data: ElasticBeanstalk.EnvironmentDescription|any) => void): Request;
    updateApplication(params: ElasticBeanstalk.UpdateApplicationMessage, callback?: (err: any, data: ElasticBeanstalk.ApplicationDescriptionMessage|any) => void): Request;
    updateApplicationVersion(params: ElasticBeanstalk.UpdateApplicationVersionMessage, callback?: (err: any, data: ElasticBeanstalk.ApplicationVersionDescriptionMessage|any) => void): Request;
    updateConfigurationTemplate(params: ElasticBeanstalk.UpdateConfigurationTemplateMessage, callback?: (err: ElasticBeanstalk.InsufficientPrivilegesException|any, data: ElasticBeanstalk.ConfigurationSettingsDescription|any) => void): Request;
    updateEnvironment(params: ElasticBeanstalk.UpdateEnvironmentMessage, callback?: (err: ElasticBeanstalk.InsufficientPrivilegesException|any, data: ElasticBeanstalk.EnvironmentDescription|any) => void): Request;
    validateConfigurationSettings(params: ElasticBeanstalk.ValidateConfigurationSettingsMessage, callback?: (err: ElasticBeanstalk.InsufficientPrivilegesException|any, data: ElasticBeanstalk.ConfigurationSettingsValidationMessages|any) => void): Request;

  }

  export module ElasticBeanstalk {
    export type AbortableOperationInProgress = boolean;
    export type ApplicationDescriptionList = ApplicationDescription[];
    export type ApplicationName = string;    // max: 100, min: 1
    export type ApplicationNamesList = ApplicationName[];
    export type ApplicationVersionDescriptionList = ApplicationVersionDescription[];
    export type ApplicationVersionProccess = boolean;
    export type ApplicationVersionStatus = string;
    export type AutoCreateApplication = boolean;
    export type AutoScalingGroupList = AutoScalingGroup[];
    export type AvailableSolutionStackDetailsList = SolutionStackDescription[];
    export type AvailableSolutionStackNamesList = SolutionStackName[];
    export type Cause = string;    // max: 255, min: 1
    export type Causes = Cause[];
    export type CnameAvailability = boolean;
    export type ConfigurationDeploymentStatus = string;
    export type ConfigurationOptionDefaultValue = string;
    export type ConfigurationOptionDescriptionsList = ConfigurationOptionDescription[];
    export type ConfigurationOptionName = string;
    export type ConfigurationOptionPossibleValue = string;
    export type ConfigurationOptionPossibleValues = ConfigurationOptionPossibleValue[];
    export type ConfigurationOptionSettingsList = ConfigurationOptionSetting[];
    export type ConfigurationOptionSeverity = string;
    export type ConfigurationOptionValue = string;
    export type ConfigurationOptionValueType = string;
    export type ConfigurationSettingsDescriptionList = ConfigurationSettingsDescription[];
    export type ConfigurationTemplateName = string;    // max: 100, min: 1
    export type ConfigurationTemplateNamesList = ConfigurationTemplateName[];
    export type CreationDate = number;
    export type DNSCname = string;    // max: 255, min: 1
    export type DNSCnamePrefix = string;    // max: 63, min: 4
    export type DeleteSourceBundle = boolean;
    export type Description = string;    // max: 200
    export type Ec2InstanceId = string;
    export type EndpointURL = string;
    export type EnvironmentDescriptionsList = EnvironmentDescription[];
    export type EnvironmentHealth = string;
    export type EnvironmentHealthAttribute = string;
    export type EnvironmentHealthAttributes = EnvironmentHealthAttribute[];
    export type EnvironmentHealthStatus = string;
    export type EnvironmentId = string;
    export type EnvironmentIdList = EnvironmentId[];
    export type EnvironmentInfoDescriptionList = EnvironmentInfoDescription[];
    export type EnvironmentInfoType = string;
    export type EnvironmentLinks = EnvironmentLink[];
    export type EnvironmentName = string;    // max: 23, min: 4
    export type EnvironmentNamesList = EnvironmentName[];
    export type EnvironmentStatus = string;
    export type EventDate = number;
    export type EventDescriptionList = EventDescription[];
    export type EventMessage = string;
    export type EventSeverity = string;
    export type ExceptionMessage = string;
    export type FileTypeExtension = string;    // max: 100, min: 1
    export type ForceTerminate = boolean;
    export type GroupName = string;    // max: 19, min: 1
    export type IncludeDeleted = boolean;
    export type IncludeDeletedBackTo = number;
    export type InstanceHealthList = SingleInstanceHealth[];
    export type InstanceId = string;    // max: 255, min: 1
    export type InstanceList = Instance[];
    export type InstancesHealthAttribute = string;
    export type InstancesHealthAttributes = InstancesHealthAttribute[];
    export type Integer = number;
    export type LaunchConfigurationList = LaunchConfiguration[];
    export type LaunchedAt = number;
    export type LoadAverage = LoadAverageValue[];
    export type LoadAverageValue = number;
    export type LoadBalancerList = LoadBalancer[];
    export type LoadBalancerListenersDescription = Listener[];
    export type MaxRecords = number;    // max: 1000, min: 1
    export type Message = string;
    export type NextToken = string;    // max: 100, min: 1
    export type NullableDouble = number;
    export type NullableInteger = number;
    export type OptionNamespace = string;
    export type OptionRestrictionMaxLength = number;
    export type OptionRestrictionMaxValue = number;
    export type OptionRestrictionMinValue = number;
    export type OptionsSpecifierList = OptionSpecification[];
    export type QueueList = Queue[];
    export type RefreshedAt = number;
    export type RegexLabel = string;
    export type RegexPattern = string;
    export type RequestCount = number;
    export type RequestId = string;
    export type ResourceId = string;
    export type ResourceName = string;    // max: 256, min: 1
    export type S3Bucket = string;    // max: 255
    export type S3Key = string;    // max: 1024
    export type SampleTimestamp = number;
    export type SolutionStackFileTypeList = FileTypeExtension[];
    export type SolutionStackName = string;    // max: 100
    export type String = string;
    export type TagKey = string;    // max: 128, min: 1
    export type TagValue = string;    // max: 256, min: 1
    export type Tags = Tag[];
    export type TerminateEnvForce = boolean;
    export type TerminateEnvironmentResources = boolean;
    export type TimeFilterEnd = number;
    export type TimeFilterStart = number;
    export type Token = string;
    export type TriggerList = Trigger[];
    export type UpdateDate = number;
    export type UserDefinedOption = boolean;
    export type ValidationMessageString = string;
    export type ValidationMessagesList = ValidationMessage[];
    export type ValidationSeverity = string;
    export type VersionLabel = string;    // max: 100, min: 1
    export type VersionLabels = VersionLabel[];
    export type VersionLabelsList = VersionLabel[];

    export interface AbortEnvironmentUpdateMessage {
        EnvironmentId?: EnvironmentId;
        EnvironmentName?: EnvironmentName;
    }
    export interface ApplicationDescription {
        ApplicationName?: ApplicationName;
        Description?: Description;
        DateCreated?: CreationDate;
        DateUpdated?: UpdateDate;
        Versions?: VersionLabelsList;
        ConfigurationTemplates?: ConfigurationTemplateNamesList;
    }
    export interface ApplicationDescriptionMessage {
        Application?: ApplicationDescription;
    }
    export interface ApplicationDescriptionsMessage {
        Applications?: ApplicationDescriptionList;
    }
    export interface ApplicationMetrics {
        Duration?: NullableInteger;
        RequestCount?: RequestCount;
        StatusCodes?: StatusCodes;
        Latency?: Latency;
    }
    export interface ApplicationVersionDescription {
        ApplicationName?: ApplicationName;
        Description?: Description;
        VersionLabel?: VersionLabel;
        SourceBundle?: S3Location;
        DateCreated?: CreationDate;
        DateUpdated?: UpdateDate;
        Status?: ApplicationVersionStatus;
    }
    export interface ApplicationVersionDescriptionMessage {
        ApplicationVersion?: ApplicationVersionDescription;
    }
    export interface ApplicationVersionDescriptionsMessage {
        ApplicationVersions?: ApplicationVersionDescriptionList;
    }
    export interface AutoScalingGroup {
        Name?: ResourceId;
    }
    export interface CPUUtilization {
        User?: NullableDouble;
        Nice?: NullableDouble;
        System?: NullableDouble;
        Idle?: NullableDouble;
        IOWait?: NullableDouble;
        IRQ?: NullableDouble;
        SoftIRQ?: NullableDouble;
    }
    export interface CheckDNSAvailabilityMessage {
        CNAMEPrefix: DNSCnamePrefix;
    }
    export interface CheckDNSAvailabilityResultMessage {
        Available?: CnameAvailability;
        FullyQualifiedCNAME?: DNSCname;
    }
    export interface ComposeEnvironmentsMessage {
        ApplicationName?: ApplicationName;
        GroupName?: GroupName;
        VersionLabels?: VersionLabels;
    }
    export interface ConfigurationOptionDescription {
        Namespace?: OptionNamespace;
        Name?: ConfigurationOptionName;
        DefaultValue?: ConfigurationOptionDefaultValue;
        ChangeSeverity?: ConfigurationOptionSeverity;
        UserDefined?: UserDefinedOption;
        ValueType?: ConfigurationOptionValueType;
        ValueOptions?: ConfigurationOptionPossibleValues;
        MinValue?: OptionRestrictionMinValue;
        MaxValue?: OptionRestrictionMaxValue;
        MaxLength?: OptionRestrictionMaxLength;
        Regex?: OptionRestrictionRegex;
    }
    export interface ConfigurationOptionSetting {
        ResourceName?: ResourceName;
        Namespace?: OptionNamespace;
        OptionName?: ConfigurationOptionName;
        Value?: ConfigurationOptionValue;
    }
    export interface ConfigurationOptionsDescription {
        SolutionStackName?: SolutionStackName;
        Options?: ConfigurationOptionDescriptionsList;
    }
    export interface ConfigurationSettingsDescription {
        SolutionStackName?: SolutionStackName;
        ApplicationName?: ApplicationName;
        TemplateName?: ConfigurationTemplateName;
        Description?: Description;
        EnvironmentName?: EnvironmentName;
        DeploymentStatus?: ConfigurationDeploymentStatus;
        DateCreated?: CreationDate;
        DateUpdated?: UpdateDate;
        OptionSettings?: ConfigurationOptionSettingsList;
    }
    export interface ConfigurationSettingsDescriptions {
        ConfigurationSettings?: ConfigurationSettingsDescriptionList;
    }
    export interface ConfigurationSettingsValidationMessages {
        Messages?: ValidationMessagesList;
    }
    export interface CreateApplicationMessage {
        ApplicationName: ApplicationName;
        Description?: Description;
    }
    export interface CreateApplicationVersionMessage {
        ApplicationName: ApplicationName;
        VersionLabel: VersionLabel;
        Description?: Description;
        SourceBundle?: S3Location;
        AutoCreateApplication?: AutoCreateApplication;
        Process?: ApplicationVersionProccess;
    }
    export interface CreateConfigurationTemplateMessage {
        ApplicationName: ApplicationName;
        TemplateName: ConfigurationTemplateName;
        SolutionStackName?: SolutionStackName;
        SourceConfiguration?: SourceConfiguration;
        EnvironmentId?: EnvironmentId;
        Description?: Description;
        OptionSettings?: ConfigurationOptionSettingsList;
    }
    export interface CreateEnvironmentMessage {
        ApplicationName: ApplicationName;
        EnvironmentName?: EnvironmentName;
        GroupName?: GroupName;
        Description?: Description;
        CNAMEPrefix?: DNSCnamePrefix;
        Tier?: EnvironmentTier;
        Tags?: Tags;
        VersionLabel?: VersionLabel;
        TemplateName?: ConfigurationTemplateName;
        SolutionStackName?: SolutionStackName;
        OptionSettings?: ConfigurationOptionSettingsList;
        OptionsToRemove?: OptionsSpecifierList;
    }
    export interface CreateStorageLocationResultMessage {
        S3Bucket?: S3Bucket;
    }
    export interface DeleteApplicationMessage {
        ApplicationName: ApplicationName;
        TerminateEnvByForce?: TerminateEnvForce;
    }
    export interface DeleteApplicationVersionMessage {
        ApplicationName: ApplicationName;
        VersionLabel: VersionLabel;
        DeleteSourceBundle?: DeleteSourceBundle;
    }
    export interface DeleteConfigurationTemplateMessage {
        ApplicationName: ApplicationName;
        TemplateName: ConfigurationTemplateName;
    }
    export interface DeleteEnvironmentConfigurationMessage {
        ApplicationName: ApplicationName;
        EnvironmentName: EnvironmentName;
    }
    export interface DescribeApplicationVersionsMessage {
        ApplicationName?: ApplicationName;
        VersionLabels?: VersionLabelsList;
    }
    export interface DescribeApplicationsMessage {
        ApplicationNames?: ApplicationNamesList;
    }
    export interface DescribeConfigurationOptionsMessage {
        ApplicationName?: ApplicationName;
        TemplateName?: ConfigurationTemplateName;
        EnvironmentName?: EnvironmentName;
        SolutionStackName?: SolutionStackName;
        Options?: OptionsSpecifierList;
    }
    export interface DescribeConfigurationSettingsMessage {
        ApplicationName: ApplicationName;
        TemplateName?: ConfigurationTemplateName;
        EnvironmentName?: EnvironmentName;
    }
    export interface DescribeEnvironmentHealthRequest {
        EnvironmentName?: EnvironmentName;
        EnvironmentId?: EnvironmentId;
        AttributeNames?: EnvironmentHealthAttributes;
    }
    export interface DescribeEnvironmentHealthResult {
        EnvironmentName?: EnvironmentName;
        HealthStatus?: String;
        Status?: EnvironmentHealth;
        Color?: String;
        Causes?: Causes;
        ApplicationMetrics?: ApplicationMetrics;
        InstancesHealth?: InstanceHealthSummary;
        RefreshedAt?: RefreshedAt;
    }
    export interface DescribeEnvironmentResourcesMessage {
        EnvironmentId?: EnvironmentId;
        EnvironmentName?: EnvironmentName;
    }
    export interface DescribeEnvironmentsMessage {
        ApplicationName?: ApplicationName;
        VersionLabel?: VersionLabel;
        EnvironmentIds?: EnvironmentIdList;
        EnvironmentNames?: EnvironmentNamesList;
        IncludeDeleted?: IncludeDeleted;
        IncludedDeletedBackTo?: IncludeDeletedBackTo;
    }
    export interface DescribeEventsMessage {
        ApplicationName?: ApplicationName;
        VersionLabel?: VersionLabel;
        TemplateName?: ConfigurationTemplateName;
        EnvironmentId?: EnvironmentId;
        EnvironmentName?: EnvironmentName;
        RequestId?: RequestId;
        Severity?: EventSeverity;
        StartTime?: TimeFilterStart;
        EndTime?: TimeFilterEnd;
        MaxRecords?: MaxRecords;
        NextToken?: Token;
    }
    export interface DescribeInstancesHealthRequest {
        EnvironmentName?: EnvironmentName;
        EnvironmentId?: EnvironmentId;
        AttributeNames?: InstancesHealthAttributes;
        NextToken?: NextToken;
    }
    export interface DescribeInstancesHealthResult {
        InstanceHealthList?: InstanceHealthList;
        RefreshedAt?: RefreshedAt;
        NextToken?: NextToken;
    }
    export interface ElasticBeanstalkServiceException {
        message?: ExceptionMessage;
    }
    export interface EnvironmentDescription {
        EnvironmentName?: EnvironmentName;
        EnvironmentId?: EnvironmentId;
        ApplicationName?: ApplicationName;
        VersionLabel?: VersionLabel;
        SolutionStackName?: SolutionStackName;
        TemplateName?: ConfigurationTemplateName;
        Description?: Description;
        EndpointURL?: EndpointURL;
        CNAME?: DNSCname;
        DateCreated?: CreationDate;
        DateUpdated?: UpdateDate;
        Status?: EnvironmentStatus;
        AbortableOperationInProgress?: AbortableOperationInProgress;
        Health?: EnvironmentHealth;
        HealthStatus?: EnvironmentHealthStatus;
        Resources?: EnvironmentResourcesDescription;
        Tier?: EnvironmentTier;
        EnvironmentLinks?: EnvironmentLinks;
    }
    export interface EnvironmentDescriptionsMessage {
        Environments?: EnvironmentDescriptionsList;
    }
    export interface EnvironmentInfoDescription {
        InfoType?: EnvironmentInfoType;
        Ec2InstanceId?: Ec2InstanceId;
        SampleTimestamp?: SampleTimestamp;
        Message?: Message;
    }
    export interface EnvironmentLink {
        LinkName?: String;
        EnvironmentName?: String;
    }
    export interface EnvironmentResourceDescription {
        EnvironmentName?: EnvironmentName;
        AutoScalingGroups?: AutoScalingGroupList;
        Instances?: InstanceList;
        LaunchConfigurations?: LaunchConfigurationList;
        LoadBalancers?: LoadBalancerList;
        Triggers?: TriggerList;
        Queues?: QueueList;
    }
    export interface EnvironmentResourceDescriptionsMessage {
        EnvironmentResources?: EnvironmentResourceDescription;
    }
    export interface EnvironmentResourcesDescription {
        LoadBalancer?: LoadBalancerDescription;
    }
    export interface EnvironmentTier {
        Name?: String;
        Type?: String;
        Version?: String;
    }
    export interface EventDescription {
        EventDate?: EventDate;
        Message?: EventMessage;
        ApplicationName?: ApplicationName;
        VersionLabel?: VersionLabel;
        TemplateName?: ConfigurationTemplateName;
        EnvironmentName?: EnvironmentName;
        RequestId?: RequestId;
        Severity?: EventSeverity;
    }
    export interface EventDescriptionsMessage {
        Events?: EventDescriptionList;
        NextToken?: Token;
    }
    export interface Instance {
        Id?: ResourceId;
    }
    export interface InstanceHealthSummary {
        NoData?: NullableInteger;
        Unknown?: NullableInteger;
        Pending?: NullableInteger;
        Ok?: NullableInteger;
        Info?: NullableInteger;
        Warning?: NullableInteger;
        Degraded?: NullableInteger;
        Severe?: NullableInteger;
    }
    export interface InsufficientPrivilegesException {
    }
    export interface InvalidRequestException {
    }
    export interface Latency {
        P999?: NullableDouble;
        P99?: NullableDouble;
        P95?: NullableDouble;
        P90?: NullableDouble;
        P85?: NullableDouble;
        P75?: NullableDouble;
        P50?: NullableDouble;
        P10?: NullableDouble;
    }
    export interface LaunchConfiguration {
        Name?: ResourceId;
    }
    export interface ListAvailableSolutionStacksResultMessage {
        SolutionStacks?: AvailableSolutionStackNamesList;
        SolutionStackDetails?: AvailableSolutionStackDetailsList;
    }
    export interface Listener {
        Protocol?: String;
        Port?: Integer;
    }
    export interface LoadBalancer {
        Name?: ResourceId;
    }
    export interface LoadBalancerDescription {
        LoadBalancerName?: String;
        Domain?: String;
        Listeners?: LoadBalancerListenersDescription;
    }
    export interface OperationInProgressException {
    }
    export interface OptionRestrictionRegex {
        Pattern?: RegexPattern;
        Label?: RegexLabel;
    }
    export interface OptionSpecification {
        ResourceName?: ResourceName;
        Namespace?: OptionNamespace;
        OptionName?: ConfigurationOptionName;
    }
    export interface Queue {
        Name?: String;
        URL?: String;
    }
    export interface RebuildEnvironmentMessage {
        EnvironmentId?: EnvironmentId;
        EnvironmentName?: EnvironmentName;
    }
    export interface RequestEnvironmentInfoMessage {
        EnvironmentId?: EnvironmentId;
        EnvironmentName?: EnvironmentName;
        InfoType: EnvironmentInfoType;
    }
    export interface RestartAppServerMessage {
        EnvironmentId?: EnvironmentId;
        EnvironmentName?: EnvironmentName;
    }
    export interface RetrieveEnvironmentInfoMessage {
        EnvironmentId?: EnvironmentId;
        EnvironmentName?: EnvironmentName;
        InfoType: EnvironmentInfoType;
    }
    export interface RetrieveEnvironmentInfoResultMessage {
        EnvironmentInfo?: EnvironmentInfoDescriptionList;
    }
    export interface S3Location {
        S3Bucket?: S3Bucket;
        S3Key?: S3Key;
    }
    export interface S3LocationNotInServiceRegionException {
    }
    export interface S3SubscriptionRequiredException {
    }
    export interface SingleInstanceHealth {
        InstanceId?: InstanceId;
        HealthStatus?: String;
        Color?: String;
        Causes?: Causes;
        LaunchedAt?: LaunchedAt;
        ApplicationMetrics?: ApplicationMetrics;
        System?: SystemStatus;
    }
    export interface SolutionStackDescription {
        SolutionStackName?: SolutionStackName;
        PermittedFileTypes?: SolutionStackFileTypeList;
    }
    export interface SourceBundleDeletionException {
    }
    export interface SourceConfiguration {
        ApplicationName?: ApplicationName;
        TemplateName?: ConfigurationTemplateName;
    }
    export interface StatusCodes {
        Status2xx?: NullableInteger;
        Status3xx?: NullableInteger;
        Status4xx?: NullableInteger;
        Status5xx?: NullableInteger;
    }
    export interface SwapEnvironmentCNAMEsMessage {
        SourceEnvironmentId?: EnvironmentId;
        SourceEnvironmentName?: EnvironmentName;
        DestinationEnvironmentId?: EnvironmentId;
        DestinationEnvironmentName?: EnvironmentName;
    }
    export interface SystemStatus {
        CPUUtilization?: CPUUtilization;
        LoadAverage?: LoadAverage;
    }
    export interface Tag {
        Key?: TagKey;
        Value?: TagValue;
    }
    export interface TerminateEnvironmentMessage {
        EnvironmentId?: EnvironmentId;
        EnvironmentName?: EnvironmentName;
        TerminateResources?: TerminateEnvironmentResources;
        ForceTerminate?: ForceTerminate;
    }
    export interface TooManyApplicationVersionsException {
    }
    export interface TooManyApplicationsException {
    }
    export interface TooManyBucketsException {
    }
    export interface TooManyConfigurationTemplatesException {
    }
    export interface TooManyEnvironmentsException {
    }
    export interface Trigger {
        Name?: ResourceId;
    }
    export interface UpdateApplicationMessage {
        ApplicationName: ApplicationName;
        Description?: Description;
    }
    export interface UpdateApplicationVersionMessage {
        ApplicationName: ApplicationName;
        VersionLabel: VersionLabel;
        Description?: Description;
    }
    export interface UpdateConfigurationTemplateMessage {
        ApplicationName: ApplicationName;
        TemplateName: ConfigurationTemplateName;
        Description?: Description;
        OptionSettings?: ConfigurationOptionSettingsList;
        OptionsToRemove?: OptionsSpecifierList;
    }
    export interface UpdateEnvironmentMessage {
        ApplicationName?: ApplicationName;
        EnvironmentId?: EnvironmentId;
        EnvironmentName?: EnvironmentName;
        GroupName?: GroupName;
        Description?: Description;
        Tier?: EnvironmentTier;
        VersionLabel?: VersionLabel;
        TemplateName?: ConfigurationTemplateName;
        SolutionStackName?: SolutionStackName;
        OptionSettings?: ConfigurationOptionSettingsList;
        OptionsToRemove?: OptionsSpecifierList;
    }
    export interface ValidateConfigurationSettingsMessage {
        ApplicationName: ApplicationName;
        TemplateName?: ConfigurationTemplateName;
        EnvironmentName?: EnvironmentName;
        OptionSettings: ConfigurationOptionSettingsList;
    }
    export interface ValidationMessage {
        Message?: ValidationMessageString;
        Severity?: ValidationSeverity;
        Namespace?: OptionNamespace;
        OptionName?: ConfigurationOptionName;
    }
  }

  /*
   * apiVersion: 2012-06-01
   * endpointPrefix: elasticloadbalancing
   * serviceAbbreviation: 
   * signatureVersion: v4
   * protocol: query
   */
  export class ELB extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    addTags(params: ELB.AddTagsInput, callback?: (err: ELB.AccessPointNotFoundException|ELB.TooManyTagsException|ELB.DuplicateTagKeysException|any, data: ELB.AddTagsOutput|any) => void): Request;
    applySecurityGroupsToLoadBalancer(params: ELB.ApplySecurityGroupsToLoadBalancerInput, callback?: (err: ELB.AccessPointNotFoundException|ELB.InvalidConfigurationRequestException|ELB.InvalidSecurityGroupException|any, data: ELB.ApplySecurityGroupsToLoadBalancerOutput|any) => void): Request;
    attachLoadBalancerToSubnets(params: ELB.AttachLoadBalancerToSubnetsInput, callback?: (err: ELB.AccessPointNotFoundException|ELB.InvalidConfigurationRequestException|ELB.SubnetNotFoundException|ELB.InvalidSubnetException|any, data: ELB.AttachLoadBalancerToSubnetsOutput|any) => void): Request;
    configureHealthCheck(params: ELB.ConfigureHealthCheckInput, callback?: (err: ELB.AccessPointNotFoundException|any, data: ELB.ConfigureHealthCheckOutput|any) => void): Request;
    createAppCookieStickinessPolicy(params: ELB.CreateAppCookieStickinessPolicyInput, callback?: (err: ELB.AccessPointNotFoundException|ELB.DuplicatePolicyNameException|ELB.TooManyPoliciesException|ELB.InvalidConfigurationRequestException|any, data: ELB.CreateAppCookieStickinessPolicyOutput|any) => void): Request;
    createLBCookieStickinessPolicy(params: ELB.CreateLBCookieStickinessPolicyInput, callback?: (err: ELB.AccessPointNotFoundException|ELB.DuplicatePolicyNameException|ELB.TooManyPoliciesException|ELB.InvalidConfigurationRequestException|any, data: ELB.CreateLBCookieStickinessPolicyOutput|any) => void): Request;
    createLoadBalancer(params: ELB.CreateAccessPointInput, callback?: (err: ELB.DuplicateAccessPointNameException|ELB.TooManyAccessPointsException|ELB.CertificateNotFoundException|ELB.InvalidConfigurationRequestException|ELB.SubnetNotFoundException|ELB.InvalidSubnetException|ELB.InvalidSecurityGroupException|ELB.InvalidSchemeException|ELB.TooManyTagsException|ELB.DuplicateTagKeysException|any, data: ELB.CreateAccessPointOutput|any) => void): Request;
    createLoadBalancerListeners(params: ELB.CreateLoadBalancerListenerInput, callback?: (err: ELB.AccessPointNotFoundException|ELB.DuplicateListenerException|ELB.CertificateNotFoundException|ELB.InvalidConfigurationRequestException|any, data: ELB.CreateLoadBalancerListenerOutput|any) => void): Request;
    createLoadBalancerPolicy(params: ELB.CreateLoadBalancerPolicyInput, callback?: (err: ELB.AccessPointNotFoundException|ELB.PolicyTypeNotFoundException|ELB.DuplicatePolicyNameException|ELB.TooManyPoliciesException|ELB.InvalidConfigurationRequestException|any, data: ELB.CreateLoadBalancerPolicyOutput|any) => void): Request;
    deleteLoadBalancer(params: ELB.DeleteAccessPointInput, callback?: (err: any, data: ELB.DeleteAccessPointOutput|any) => void): Request;
    deleteLoadBalancerListeners(params: ELB.DeleteLoadBalancerListenerInput, callback?: (err: ELB.AccessPointNotFoundException|any, data: ELB.DeleteLoadBalancerListenerOutput|any) => void): Request;
    deleteLoadBalancerPolicy(params: ELB.DeleteLoadBalancerPolicyInput, callback?: (err: ELB.AccessPointNotFoundException|ELB.InvalidConfigurationRequestException|any, data: ELB.DeleteLoadBalancerPolicyOutput|any) => void): Request;
    deregisterInstancesFromLoadBalancer(params: ELB.DeregisterEndPointsInput, callback?: (err: ELB.AccessPointNotFoundException|ELB.InvalidEndPointException|any, data: ELB.DeregisterEndPointsOutput|any) => void): Request;
    describeInstanceHealth(params: ELB.DescribeEndPointStateInput, callback?: (err: ELB.AccessPointNotFoundException|ELB.InvalidEndPointException|any, data: ELB.DescribeEndPointStateOutput|any) => void): Request;
    describeLoadBalancerAttributes(params: ELB.DescribeLoadBalancerAttributesInput, callback?: (err: ELB.AccessPointNotFoundException|ELB.LoadBalancerAttributeNotFoundException|any, data: ELB.DescribeLoadBalancerAttributesOutput|any) => void): Request;
    describeLoadBalancerPolicies(params: ELB.DescribeLoadBalancerPoliciesInput, callback?: (err: ELB.AccessPointNotFoundException|ELB.PolicyNotFoundException|any, data: ELB.DescribeLoadBalancerPoliciesOutput|any) => void): Request;
    describeLoadBalancerPolicyTypes(params: ELB.DescribeLoadBalancerPolicyTypesInput, callback?: (err: ELB.PolicyTypeNotFoundException|any, data: ELB.DescribeLoadBalancerPolicyTypesOutput|any) => void): Request;
    describeLoadBalancers(params: ELB.DescribeAccessPointsInput, callback?: (err: ELB.AccessPointNotFoundException|any, data: ELB.DescribeAccessPointsOutput|any) => void): Request;
    describeTags(params: ELB.DescribeTagsInput, callback?: (err: ELB.AccessPointNotFoundException|any, data: ELB.DescribeTagsOutput|any) => void): Request;
    detachLoadBalancerFromSubnets(params: ELB.DetachLoadBalancerFromSubnetsInput, callback?: (err: ELB.AccessPointNotFoundException|ELB.InvalidConfigurationRequestException|any, data: ELB.DetachLoadBalancerFromSubnetsOutput|any) => void): Request;
    disableAvailabilityZonesForLoadBalancer(params: ELB.RemoveAvailabilityZonesInput, callback?: (err: ELB.AccessPointNotFoundException|ELB.InvalidConfigurationRequestException|any, data: ELB.RemoveAvailabilityZonesOutput|any) => void): Request;
    enableAvailabilityZonesForLoadBalancer(params: ELB.AddAvailabilityZonesInput, callback?: (err: ELB.AccessPointNotFoundException|any, data: ELB.AddAvailabilityZonesOutput|any) => void): Request;
    modifyLoadBalancerAttributes(params: ELB.ModifyLoadBalancerAttributesInput, callback?: (err: ELB.AccessPointNotFoundException|ELB.LoadBalancerAttributeNotFoundException|ELB.InvalidConfigurationRequestException|any, data: ELB.ModifyLoadBalancerAttributesOutput|any) => void): Request;
    registerInstancesWithLoadBalancer(params: ELB.RegisterEndPointsInput, callback?: (err: ELB.AccessPointNotFoundException|ELB.InvalidEndPointException|any, data: ELB.RegisterEndPointsOutput|any) => void): Request;
    removeTags(params: ELB.RemoveTagsInput, callback?: (err: ELB.AccessPointNotFoundException|any, data: ELB.RemoveTagsOutput|any) => void): Request;
    setLoadBalancerListenerSSLCertificate(params: ELB.SetLoadBalancerListenerSSLCertificateInput, callback?: (err: ELB.CertificateNotFoundException|ELB.AccessPointNotFoundException|ELB.ListenerNotFoundException|ELB.InvalidConfigurationRequestException|any, data: ELB.SetLoadBalancerListenerSSLCertificateOutput|any) => void): Request;
    setLoadBalancerPoliciesForBackendServer(params: ELB.SetLoadBalancerPoliciesForBackendServerInput, callback?: (err: ELB.AccessPointNotFoundException|ELB.PolicyNotFoundException|ELB.InvalidConfigurationRequestException|any, data: ELB.SetLoadBalancerPoliciesForBackendServerOutput|any) => void): Request;
    setLoadBalancerPoliciesOfListener(params: ELB.SetLoadBalancerPoliciesOfListenerInput, callback?: (err: ELB.AccessPointNotFoundException|ELB.PolicyNotFoundException|ELB.ListenerNotFoundException|ELB.InvalidConfigurationRequestException|any, data: ELB.SetLoadBalancerPoliciesOfListenerOutput|any) => void): Request;

  }

  export module ELB {
    export type AccessLogEnabled = boolean;
    export type AccessLogInterval = number;
    export type AccessLogPrefix = string;
    export type AccessPointName = string;
    export type AccessPointPort = number;
    export type AdditionalAttributes = AdditionalAttribute[];
    export type AppCookieStickinessPolicies = AppCookieStickinessPolicy[];
    export type AttributeName = string;
    export type AttributeType = string;
    export type AttributeValue = string;
    export type AvailabilityZone = string;
    export type AvailabilityZones = AvailabilityZone[];
    export type BackendServerDescriptions = BackendServerDescription[];
    export type Cardinality = string;
    export type ConnectionDrainingEnabled = boolean;
    export type ConnectionDrainingTimeout = number;
    export type CookieExpirationPeriod = number;
    export type CookieName = string;
    export type CreatedTime = number;
    export type CrossZoneLoadBalancingEnabled = boolean;
    export type DNSName = string;
    export type DefaultValue = string;
    export type Description = string;
    export type EndPointPort = number;
    export type HealthCheckInterval = number;    // max: 300, min: 1
    export type HealthCheckTarget = string;
    export type HealthCheckTimeout = number;    // max: 300, min: 1
    export type HealthyThreshold = number;    // max: 10, min: 2
    export type IdleTimeout = number;    // max: 3600, min: 1
    export type InstanceId = string;
    export type InstancePort = number;    // max: 65535, min: 1
    export type InstanceStates = InstanceState[];
    export type Instances = Instance[];
    export type LBCookieStickinessPolicies = LBCookieStickinessPolicy[];
    export type ListenerDescriptions = ListenerDescription[];
    export type Listeners = Listener[];
    export type LoadBalancerDescriptions = LoadBalancerDescription[];
    export type LoadBalancerNames = AccessPointName[];
    export type LoadBalancerNamesMax20 = AccessPointName[];    // max: 20, min: 1
    export type LoadBalancerScheme = string;
    export type Marker = string;
    export type PageSize = number;    // max: 400, min: 1
    export type PolicyAttributeDescriptions = PolicyAttributeDescription[];
    export type PolicyAttributeTypeDescriptions = PolicyAttributeTypeDescription[];
    export type PolicyAttributes = PolicyAttribute[];
    export type PolicyDescriptions = PolicyDescription[];
    export type PolicyName = string;
    export type PolicyNames = PolicyName[];
    export type PolicyTypeDescriptions = PolicyTypeDescription[];
    export type PolicyTypeName = string;
    export type PolicyTypeNames = PolicyTypeName[];
    export type Ports = AccessPointPort[];
    export type Protocol = string;
    export type ReasonCode = string;
    export type S3BucketName = string;
    export type SSLCertificateId = string;
    export type SecurityGroupId = string;
    export type SecurityGroupName = string;
    export type SecurityGroupOwnerAlias = string;
    export type SecurityGroups = SecurityGroupId[];
    export type State = string;
    export type StringVal = string;
    export type SubnetId = string;
    export type Subnets = SubnetId[];
    export type TagDescriptions = TagDescription[];
    export type TagKey = string;    // pattern: &quot;^([\p{L}\p{Z}\p{N}_.:/=+\-@]*)$&quot;, max: 128, min: 1
    export type TagKeyList = TagKeyOnly[];    // min: 1
    export type TagList = Tag[];    // min: 1
    export type TagValue = string;    // pattern: &quot;^([\p{L}\p{Z}\p{N}_.:/=+\-@]*)$&quot;, max: 256
    export type UnhealthyThreshold = number;    // max: 10, min: 2
    export type VPCId = string;

    export interface AccessLog {
        Enabled: AccessLogEnabled;
        S3BucketName?: S3BucketName;
        EmitInterval?: AccessLogInterval;
        S3BucketPrefix?: AccessLogPrefix;
    }
    export interface AccessPointNotFoundException {
    }
    export interface AddAvailabilityZonesInput {
        LoadBalancerName: AccessPointName;
        AvailabilityZones: AvailabilityZones;
    }
    export interface AddAvailabilityZonesOutput {
        AvailabilityZones?: AvailabilityZones;
    }
    export interface AddTagsInput {
        LoadBalancerNames: LoadBalancerNames;
        Tags: TagList;
    }
    export interface AddTagsOutput {
    }
    export interface AdditionalAttribute {
        Key?: StringVal;
        Value?: StringVal;
    }
    export interface AppCookieStickinessPolicy {
        PolicyName?: PolicyName;
        CookieName?: CookieName;
    }
    export interface ApplySecurityGroupsToLoadBalancerInput {
        LoadBalancerName: AccessPointName;
        SecurityGroups: SecurityGroups;
    }
    export interface ApplySecurityGroupsToLoadBalancerOutput {
        SecurityGroups?: SecurityGroups;
    }
    export interface AttachLoadBalancerToSubnetsInput {
        LoadBalancerName: AccessPointName;
        Subnets: Subnets;
    }
    export interface AttachLoadBalancerToSubnetsOutput {
        Subnets?: Subnets;
    }
    export interface BackendServerDescription {
        InstancePort?: InstancePort;
        PolicyNames?: PolicyNames;
    }
    export interface CertificateNotFoundException {
    }
    export interface ConfigureHealthCheckInput {
        LoadBalancerName: AccessPointName;
        HealthCheck: HealthCheck;
    }
    export interface ConfigureHealthCheckOutput {
        HealthCheck?: HealthCheck;
    }
    export interface ConnectionDraining {
        Enabled: ConnectionDrainingEnabled;
        Timeout?: ConnectionDrainingTimeout;
    }
    export interface ConnectionSettings {
        IdleTimeout: IdleTimeout;
    }
    export interface CreateAccessPointInput {
        LoadBalancerName: AccessPointName;
        Listeners: Listeners;
        AvailabilityZones?: AvailabilityZones;
        Subnets?: Subnets;
        SecurityGroups?: SecurityGroups;
        Scheme?: LoadBalancerScheme;
        Tags?: TagList;
    }
    export interface CreateAccessPointOutput {
        DNSName?: DNSName;
    }
    export interface CreateAppCookieStickinessPolicyInput {
        LoadBalancerName: AccessPointName;
        PolicyName: PolicyName;
        CookieName: CookieName;
    }
    export interface CreateAppCookieStickinessPolicyOutput {
    }
    export interface CreateLBCookieStickinessPolicyInput {
        LoadBalancerName: AccessPointName;
        PolicyName: PolicyName;
        CookieExpirationPeriod?: CookieExpirationPeriod;
    }
    export interface CreateLBCookieStickinessPolicyOutput {
    }
    export interface CreateLoadBalancerListenerInput {
        LoadBalancerName: AccessPointName;
        Listeners: Listeners;
    }
    export interface CreateLoadBalancerListenerOutput {
    }
    export interface CreateLoadBalancerPolicyInput {
        LoadBalancerName: AccessPointName;
        PolicyName: PolicyName;
        PolicyTypeName: PolicyTypeName;
        PolicyAttributes?: PolicyAttributes;
    }
    export interface CreateLoadBalancerPolicyOutput {
    }
    export interface CrossZoneLoadBalancing {
        Enabled: CrossZoneLoadBalancingEnabled;
    }
    export interface DeleteAccessPointInput {
        LoadBalancerName: AccessPointName;
    }
    export interface DeleteAccessPointOutput {
    }
    export interface DeleteLoadBalancerListenerInput {
        LoadBalancerName: AccessPointName;
        LoadBalancerPorts: Ports;
    }
    export interface DeleteLoadBalancerListenerOutput {
    }
    export interface DeleteLoadBalancerPolicyInput {
        LoadBalancerName: AccessPointName;
        PolicyName: PolicyName;
    }
    export interface DeleteLoadBalancerPolicyOutput {
    }
    export interface DeregisterEndPointsInput {
        LoadBalancerName: AccessPointName;
        Instances: Instances;
    }
    export interface DeregisterEndPointsOutput {
        Instances?: Instances;
    }
    export interface DescribeAccessPointsInput {
        LoadBalancerNames?: LoadBalancerNames;
        Marker?: Marker;
        PageSize?: PageSize;
    }
    export interface DescribeAccessPointsOutput {
        LoadBalancerDescriptions?: LoadBalancerDescriptions;
        NextMarker?: Marker;
    }
    export interface DescribeEndPointStateInput {
        LoadBalancerName: AccessPointName;
        Instances?: Instances;
    }
    export interface DescribeEndPointStateOutput {
        InstanceStates?: InstanceStates;
    }
    export interface DescribeLoadBalancerAttributesInput {
        LoadBalancerName: AccessPointName;
    }
    export interface DescribeLoadBalancerAttributesOutput {
        LoadBalancerAttributes?: LoadBalancerAttributes;
    }
    export interface DescribeLoadBalancerPoliciesInput {
        LoadBalancerName?: AccessPointName;
        PolicyNames?: PolicyNames;
    }
    export interface DescribeLoadBalancerPoliciesOutput {
        PolicyDescriptions?: PolicyDescriptions;
    }
    export interface DescribeLoadBalancerPolicyTypesInput {
        PolicyTypeNames?: PolicyTypeNames;
    }
    export interface DescribeLoadBalancerPolicyTypesOutput {
        PolicyTypeDescriptions?: PolicyTypeDescriptions;
    }
    export interface DescribeTagsInput {
        LoadBalancerNames: LoadBalancerNamesMax20;
    }
    export interface DescribeTagsOutput {
        TagDescriptions?: TagDescriptions;
    }
    export interface DetachLoadBalancerFromSubnetsInput {
        LoadBalancerName: AccessPointName;
        Subnets: Subnets;
    }
    export interface DetachLoadBalancerFromSubnetsOutput {
        Subnets?: Subnets;
    }
    export interface DuplicateAccessPointNameException {
    }
    export interface DuplicateListenerException {
    }
    export interface DuplicatePolicyNameException {
    }
    export interface DuplicateTagKeysException {
    }
    export interface HealthCheck {
        Target: HealthCheckTarget;
        Interval: HealthCheckInterval;
        Timeout: HealthCheckTimeout;
        UnhealthyThreshold: UnhealthyThreshold;
        HealthyThreshold: HealthyThreshold;
    }
    export interface Instance {
        InstanceId?: InstanceId;
    }
    export interface InstanceState {
        InstanceId?: InstanceId;
        State?: State;
        ReasonCode?: ReasonCode;
        Description?: Description;
    }
    export interface InvalidConfigurationRequestException {
    }
    export interface InvalidEndPointException {
    }
    export interface InvalidSchemeException {
    }
    export interface InvalidSecurityGroupException {
    }
    export interface InvalidSubnetException {
    }
    export interface LBCookieStickinessPolicy {
        PolicyName?: PolicyName;
        CookieExpirationPeriod?: CookieExpirationPeriod;
    }
    export interface Listener {
        Protocol: Protocol;
        LoadBalancerPort: AccessPointPort;
        InstanceProtocol?: Protocol;
        InstancePort: InstancePort;
        SSLCertificateId?: SSLCertificateId;
    }
    export interface ListenerDescription {
        Listener?: Listener;
        PolicyNames?: PolicyNames;
    }
    export interface ListenerNotFoundException {
    }
    export interface LoadBalancerAttributeNotFoundException {
    }
    export interface LoadBalancerAttributes {
        CrossZoneLoadBalancing?: CrossZoneLoadBalancing;
        AccessLog?: AccessLog;
        ConnectionDraining?: ConnectionDraining;
        ConnectionSettings?: ConnectionSettings;
        AdditionalAttributes?: AdditionalAttributes;
    }
    export interface LoadBalancerDescription {
        LoadBalancerName?: AccessPointName;
        DNSName?: DNSName;
        CanonicalHostedZoneName?: DNSName;
        CanonicalHostedZoneNameID?: DNSName;
        ListenerDescriptions?: ListenerDescriptions;
        Policies?: Policies;
        BackendServerDescriptions?: BackendServerDescriptions;
        AvailabilityZones?: AvailabilityZones;
        Subnets?: Subnets;
        VPCId?: VPCId;
        Instances?: Instances;
        HealthCheck?: HealthCheck;
        SourceSecurityGroup?: SourceSecurityGroup;
        SecurityGroups?: SecurityGroups;
        CreatedTime?: CreatedTime;
        Scheme?: LoadBalancerScheme;
    }
    export interface ModifyLoadBalancerAttributesInput {
        LoadBalancerName: AccessPointName;
        LoadBalancerAttributes: LoadBalancerAttributes;
    }
    export interface ModifyLoadBalancerAttributesOutput {
        LoadBalancerName?: AccessPointName;
        LoadBalancerAttributes?: LoadBalancerAttributes;
    }
    export interface Policies {
        AppCookieStickinessPolicies?: AppCookieStickinessPolicies;
        LBCookieStickinessPolicies?: LBCookieStickinessPolicies;
        OtherPolicies?: PolicyNames;
    }
    export interface PolicyAttribute {
        AttributeName?: AttributeName;
        AttributeValue?: AttributeValue;
    }
    export interface PolicyAttributeDescription {
        AttributeName?: AttributeName;
        AttributeValue?: AttributeValue;
    }
    export interface PolicyAttributeTypeDescription {
        AttributeName?: AttributeName;
        AttributeType?: AttributeType;
        Description?: Description;
        DefaultValue?: DefaultValue;
        Cardinality?: Cardinality;
    }
    export interface PolicyDescription {
        PolicyName?: PolicyName;
        PolicyTypeName?: PolicyTypeName;
        PolicyAttributeDescriptions?: PolicyAttributeDescriptions;
    }
    export interface PolicyNotFoundException {
    }
    export interface PolicyTypeDescription {
        PolicyTypeName?: PolicyTypeName;
        Description?: Description;
        PolicyAttributeTypeDescriptions?: PolicyAttributeTypeDescriptions;
    }
    export interface PolicyTypeNotFoundException {
    }
    export interface RegisterEndPointsInput {
        LoadBalancerName: AccessPointName;
        Instances: Instances;
    }
    export interface RegisterEndPointsOutput {
        Instances?: Instances;
    }
    export interface RemoveAvailabilityZonesInput {
        LoadBalancerName: AccessPointName;
        AvailabilityZones: AvailabilityZones;
    }
    export interface RemoveAvailabilityZonesOutput {
        AvailabilityZones?: AvailabilityZones;
    }
    export interface RemoveTagsInput {
        LoadBalancerNames: LoadBalancerNames;
        Tags: TagKeyList;
    }
    export interface RemoveTagsOutput {
    }
    export interface SetLoadBalancerListenerSSLCertificateInput {
        LoadBalancerName: AccessPointName;
        LoadBalancerPort: AccessPointPort;
        SSLCertificateId: SSLCertificateId;
    }
    export interface SetLoadBalancerListenerSSLCertificateOutput {
    }
    export interface SetLoadBalancerPoliciesForBackendServerInput {
        LoadBalancerName: AccessPointName;
        InstancePort: EndPointPort;
        PolicyNames: PolicyNames;
    }
    export interface SetLoadBalancerPoliciesForBackendServerOutput {
    }
    export interface SetLoadBalancerPoliciesOfListenerInput {
        LoadBalancerName: AccessPointName;
        LoadBalancerPort: AccessPointPort;
        PolicyNames: PolicyNames;
    }
    export interface SetLoadBalancerPoliciesOfListenerOutput {
    }
    export interface SourceSecurityGroup {
        OwnerAlias?: SecurityGroupOwnerAlias;
        GroupName?: SecurityGroupName;
    }
    export interface SubnetNotFoundException {
    }
    export interface Tag {
        Key: TagKey;
        Value?: TagValue;
    }
    export interface TagDescription {
        LoadBalancerName?: AccessPointName;
        Tags?: TagList;
    }
    export interface TagKeyOnly {
        Key?: TagKey;
    }
    export interface TooManyAccessPointsException {
    }
    export interface TooManyPoliciesException {
    }
    export interface TooManyTagsException {
    }
  }

  /*
   * apiVersion: 2009-03-31
   * endpointPrefix: elasticmapreduce
   * serviceAbbreviation: Amazon EMR
   * signatureVersion: v4
   * protocol: json
   */
  export class EMR extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    addInstanceGroups(params: EMR.AddInstanceGroupsInput, callback?: (err: EMR.InternalServerError|any, data: EMR.AddInstanceGroupsOutput|any) => void): Request;
    addJobFlowSteps(params: EMR.AddJobFlowStepsInput, callback?: (err: EMR.InternalServerError|any, data: EMR.AddJobFlowStepsOutput|any) => void): Request;
    addTags(params: EMR.AddTagsInput, callback?: (err: EMR.InternalServerException|EMR.InvalidRequestException|any, data: EMR.AddTagsOutput|any) => void): Request;
    describeCluster(params: EMR.DescribeClusterInput, callback?: (err: EMR.InternalServerException|EMR.InvalidRequestException|any, data: EMR.DescribeClusterOutput|any) => void): Request;
    describeJobFlows(params: EMR.DescribeJobFlowsInput, callback?: (err: EMR.InternalServerError|any, data: EMR.DescribeJobFlowsOutput|any) => void): Request;
    describeStep(params: EMR.DescribeStepInput, callback?: (err: EMR.InternalServerException|EMR.InvalidRequestException|any, data: EMR.DescribeStepOutput|any) => void): Request;
    listBootstrapActions(params: EMR.ListBootstrapActionsInput, callback?: (err: EMR.InternalServerException|EMR.InvalidRequestException|any, data: EMR.ListBootstrapActionsOutput|any) => void): Request;
    listClusters(params: EMR.ListClustersInput, callback?: (err: EMR.InternalServerException|EMR.InvalidRequestException|any, data: EMR.ListClustersOutput|any) => void): Request;
    listInstanceGroups(params: EMR.ListInstanceGroupsInput, callback?: (err: EMR.InternalServerException|EMR.InvalidRequestException|any, data: EMR.ListInstanceGroupsOutput|any) => void): Request;
    listInstances(params: EMR.ListInstancesInput, callback?: (err: EMR.InternalServerException|EMR.InvalidRequestException|any, data: EMR.ListInstancesOutput|any) => void): Request;
    listSteps(params: EMR.ListStepsInput, callback?: (err: EMR.InternalServerException|EMR.InvalidRequestException|any, data: EMR.ListStepsOutput|any) => void): Request;
    modifyInstanceGroups(params: EMR.ModifyInstanceGroupsInput, callback?: (err: EMR.InternalServerError|any, data: any) => void): Request;
    removeTags(params: EMR.RemoveTagsInput, callback?: (err: EMR.InternalServerException|EMR.InvalidRequestException|any, data: EMR.RemoveTagsOutput|any) => void): Request;
    runJobFlow(params: EMR.RunJobFlowInput, callback?: (err: EMR.InternalServerError|any, data: EMR.RunJobFlowOutput|any) => void): Request;
    setTerminationProtection(params: EMR.SetTerminationProtectionInput, callback?: (err: EMR.InternalServerError|any, data: any) => void): Request;
    setVisibleToAllUsers(params: EMR.SetVisibleToAllUsersInput, callback?: (err: EMR.InternalServerError|any, data: any) => void): Request;
    terminateJobFlows(params: EMR.TerminateJobFlowsInput, callback?: (err: EMR.InternalServerError|any, data: any) => void): Request;

  }

  export module EMR {
    export type ActionOnFailure = string;
    export type ApplicationList = Application[];
    export type Boolean = boolean;
    export type BooleanObject = boolean;
    export type BootstrapActionConfigList = BootstrapActionConfig[];
    export type BootstrapActionDetailList = BootstrapActionDetail[];
    export type ClusterId = string;
    export type ClusterState = string;
    export type ClusterStateChangeReasonCode = string;
    export type ClusterStateList = ClusterState[];
    export type ClusterSummaryList = ClusterSummary[];
    export type CommandList = Command[];
    export type ConfigurationList = Configuration[];
    export type Date = number;
    export type EC2InstanceIdsToTerminateList = InstanceId[];
    export type EbsBlockDeviceConfigList = EbsBlockDeviceConfig[];
    export type EbsBlockDeviceList = EbsBlockDevice[];
    export type EbsVolumeList = EbsVolume[];
    export type ErrorCode = string;    // max: 256, min: 1
    export type ErrorMessage = string;
    export type InstanceGroupConfigList = InstanceGroupConfig[];
    export type InstanceGroupDetailList = InstanceGroupDetail[];
    export type InstanceGroupId = string;
    export type InstanceGroupIdsList = XmlStringMaxLen256[];
    export type InstanceGroupList = InstanceGroup[];
    export type InstanceGroupModifyConfigList = InstanceGroupModifyConfig[];
    export type InstanceGroupState = string;
    export type InstanceGroupStateChangeReasonCode = string;
    export type InstanceGroupType = string;
    export type InstanceGroupTypeList = InstanceGroupType[];
    export type InstanceId = string;
    export type InstanceList = Instance[];
    export type InstanceRoleType = string;
    export type InstanceState = string;
    export type InstanceStateChangeReasonCode = string;
    export type InstanceType = string;    // pattern: &quot;[\u0020-\uD7FF\uE000-\uFFFD\uD800\uDC00-\uDBFF\uDFFF\r\n\t]*&quot;, max: 256, min: 1
    export type Integer = number;
    export type JobFlowDetailList = JobFlowDetail[];
    export type JobFlowExecutionState = string;
    export type JobFlowExecutionStateList = JobFlowExecutionState[];
    export type KeyValueList = KeyValue[];
    export type Marker = string;
    export type MarketType = string;
    export type NewSupportedProductsList = SupportedProductConfig[];
    export type ResourceId = string;
    export type SecurityGroupsList = XmlStringMaxLen256[];
    export type StepConfigList = StepConfig[];
    export type StepDetailList = StepDetail[];
    export type StepExecutionState = string;
    export type StepId = string;
    export type StepIdsList = XmlStringMaxLen256[];
    export type StepState = string;
    export type StepStateChangeReasonCode = string;
    export type StepStateList = StepState[];
    export type StepSummaryList = StepSummary[];
    export type String = string;
    export type StringList = String[];
    export type StringMap = {[key:string]: String};
    export type SupportedProductsList = XmlStringMaxLen256[];
    export type TagList = Tag[];
    export type XmlString = string;    // pattern: &quot;[\u0020-\uD7FF\uE000-\uFFFD\uD800\uDC00-\uDBFF\uDFFF\r\n\t]*&quot;, max: 10280
    export type XmlStringList = XmlString[];
    export type XmlStringMaxLen256 = string;    // pattern: &quot;[\u0020-\uD7FF\uE000-\uFFFD\uD800\uDC00-\uDBFF\uDFFF\r\n\t]*&quot;, max: 256

    export interface AddInstanceGroupsInput {
        InstanceGroups: InstanceGroupConfigList;
        JobFlowId: XmlStringMaxLen256;
    }
    export interface AddInstanceGroupsOutput {
        JobFlowId?: XmlStringMaxLen256;
        InstanceGroupIds?: InstanceGroupIdsList;
    }
    export interface AddJobFlowStepsInput {
        JobFlowId: XmlStringMaxLen256;
        Steps: StepConfigList;
    }
    export interface AddJobFlowStepsOutput {
        StepIds?: StepIdsList;
    }
    export interface AddTagsInput {
        ResourceId: ResourceId;
        Tags: TagList;
    }
    export interface AddTagsOutput {
    }
    export interface Application {
        Name?: String;
        Version?: String;
        Args?: StringList;
        AdditionalInfo?: StringMap;
    }
    export interface BootstrapActionConfig {
        Name: XmlStringMaxLen256;
        ScriptBootstrapAction: ScriptBootstrapActionConfig;
    }
    export interface BootstrapActionDetail {
        BootstrapActionConfig?: BootstrapActionConfig;
    }
    export interface Cluster {
        Id?: ClusterId;
        Name?: String;
        Status?: ClusterStatus;
        Ec2InstanceAttributes?: Ec2InstanceAttributes;
        LogUri?: String;
        RequestedAmiVersion?: String;
        RunningAmiVersion?: String;
        ReleaseLabel?: String;
        AutoTerminate?: Boolean;
        TerminationProtected?: Boolean;
        VisibleToAllUsers?: Boolean;
        Applications?: ApplicationList;
        Tags?: TagList;
        ServiceRole?: String;
        NormalizedInstanceHours?: Integer;
        MasterPublicDnsName?: String;
        Configurations?: ConfigurationList;
    }
    export interface ClusterStateChangeReason {
        Code?: ClusterStateChangeReasonCode;
        Message?: String;
    }
    export interface ClusterStatus {
        State?: ClusterState;
        StateChangeReason?: ClusterStateChangeReason;
        Timeline?: ClusterTimeline;
    }
    export interface ClusterSummary {
        Id?: ClusterId;
        Name?: String;
        Status?: ClusterStatus;
        NormalizedInstanceHours?: Integer;
    }
    export interface ClusterTimeline {
        CreationDateTime?: Date;
        ReadyDateTime?: Date;
        EndDateTime?: Date;
    }
    export interface Command {
        Name?: String;
        ScriptPath?: String;
        Args?: StringList;
    }
    export interface Configuration {
        Classification?: String;
        Configurations?: ConfigurationList;
        Properties?: StringMap;
    }
    export interface DescribeClusterInput {
        ClusterId: ClusterId;
    }
    export interface DescribeClusterOutput {
        Cluster?: Cluster;
    }
    export interface DescribeJobFlowsInput {
        CreatedAfter?: Date;
        CreatedBefore?: Date;
        JobFlowIds?: XmlStringList;
        JobFlowStates?: JobFlowExecutionStateList;
    }
    export interface DescribeJobFlowsOutput {
        JobFlows?: JobFlowDetailList;
    }
    export interface DescribeStepInput {
        ClusterId: ClusterId;
        StepId: StepId;
    }
    export interface DescribeStepOutput {
        Step?: Step;
    }
    export interface EbsBlockDevice {
        VolumeSpecification?: VolumeSpecification;
        Device?: String;
    }
    export interface EbsBlockDeviceConfig {
        VolumeSpecification: VolumeSpecification;
        VolumesPerInstance?: Integer;
    }
    export interface EbsConfiguration {
        EbsBlockDeviceConfigs?: EbsBlockDeviceConfigList;
        EbsOptimized?: BooleanObject;
    }
    export interface EbsVolume {
        Device?: String;
        VolumeId?: String;
    }
    export interface Ec2InstanceAttributes {
        Ec2KeyName?: String;
        Ec2SubnetId?: String;
        Ec2AvailabilityZone?: String;
        IamInstanceProfile?: String;
        EmrManagedMasterSecurityGroup?: String;
        EmrManagedSlaveSecurityGroup?: String;
        ServiceAccessSecurityGroup?: String;
        AdditionalMasterSecurityGroups?: StringList;
        AdditionalSlaveSecurityGroups?: StringList;
    }
    export interface HadoopJarStepConfig {
        Properties?: KeyValueList;
        Jar: XmlString;
        MainClass?: XmlString;
        Args?: XmlStringList;
    }
    export interface HadoopStepConfig {
        Jar?: String;
        Properties?: StringMap;
        MainClass?: String;
        Args?: StringList;
    }
    export interface Instance {
        Id?: InstanceId;
        Ec2InstanceId?: InstanceId;
        PublicDnsName?: String;
        PublicIpAddress?: String;
        PrivateDnsName?: String;
        PrivateIpAddress?: String;
        Status?: InstanceStatus;
        InstanceGroupId?: String;
        EbsVolumes?: EbsVolumeList;
    }
    export interface InstanceGroup {
        Id?: InstanceGroupId;
        Name?: String;
        Market?: MarketType;
        InstanceGroupType?: InstanceGroupType;
        BidPrice?: String;
        InstanceType?: InstanceType;
        RequestedInstanceCount?: Integer;
        RunningInstanceCount?: Integer;
        Status?: InstanceGroupStatus;
        Configurations?: ConfigurationList;
        EbsBlockDevices?: EbsBlockDeviceList;
        EbsOptimized?: BooleanObject;
    }
    export interface InstanceGroupConfig {
        Name?: XmlStringMaxLen256;
        Market?: MarketType;
        InstanceRole: InstanceRoleType;
        BidPrice?: XmlStringMaxLen256;
        InstanceType: InstanceType;
        InstanceCount: Integer;
        Configurations?: ConfigurationList;
        EbsConfiguration?: EbsConfiguration;
    }
    export interface InstanceGroupDetail {
        InstanceGroupId?: XmlStringMaxLen256;
        Name?: XmlStringMaxLen256;
        Market: MarketType;
        InstanceRole: InstanceRoleType;
        BidPrice?: XmlStringMaxLen256;
        InstanceType: InstanceType;
        InstanceRequestCount: Integer;
        InstanceRunningCount: Integer;
        State: InstanceGroupState;
        LastStateChangeReason?: XmlString;
        CreationDateTime: Date;
        StartDateTime?: Date;
        ReadyDateTime?: Date;
        EndDateTime?: Date;
    }
    export interface InstanceGroupModifyConfig {
        InstanceGroupId: XmlStringMaxLen256;
        InstanceCount?: Integer;
        EC2InstanceIdsToTerminate?: EC2InstanceIdsToTerminateList;
    }
    export interface InstanceGroupStateChangeReason {
        Code?: InstanceGroupStateChangeReasonCode;
        Message?: String;
    }
    export interface InstanceGroupStatus {
        State?: InstanceGroupState;
        StateChangeReason?: InstanceGroupStateChangeReason;
        Timeline?: InstanceGroupTimeline;
    }
    export interface InstanceGroupTimeline {
        CreationDateTime?: Date;
        ReadyDateTime?: Date;
        EndDateTime?: Date;
    }
    export interface InstanceStateChangeReason {
        Code?: InstanceStateChangeReasonCode;
        Message?: String;
    }
    export interface InstanceStatus {
        State?: InstanceState;
        StateChangeReason?: InstanceStateChangeReason;
        Timeline?: InstanceTimeline;
    }
    export interface InstanceTimeline {
        CreationDateTime?: Date;
        ReadyDateTime?: Date;
        EndDateTime?: Date;
    }
    export interface InternalServerError {
    }
    export interface InternalServerException {
        Message?: ErrorMessage;
    }
    export interface InvalidRequestException {
        ErrorCode?: ErrorCode;
        Message?: ErrorMessage;
    }
    export interface JobFlowDetail {
        JobFlowId: XmlStringMaxLen256;
        Name: XmlStringMaxLen256;
        LogUri?: XmlString;
        AmiVersion?: XmlStringMaxLen256;
        ExecutionStatusDetail: JobFlowExecutionStatusDetail;
        Instances: JobFlowInstancesDetail;
        Steps?: StepDetailList;
        BootstrapActions?: BootstrapActionDetailList;
        SupportedProducts?: SupportedProductsList;
        VisibleToAllUsers?: Boolean;
        JobFlowRole?: XmlString;
        ServiceRole?: XmlString;
    }
    export interface JobFlowExecutionStatusDetail {
        State: JobFlowExecutionState;
        CreationDateTime: Date;
        StartDateTime?: Date;
        ReadyDateTime?: Date;
        EndDateTime?: Date;
        LastStateChangeReason?: XmlString;
    }
    export interface JobFlowInstancesConfig {
        MasterInstanceType?: InstanceType;
        SlaveInstanceType?: InstanceType;
        InstanceCount?: Integer;
        InstanceGroups?: InstanceGroupConfigList;
        Ec2KeyName?: XmlStringMaxLen256;
        Placement?: PlacementType;
        KeepJobFlowAliveWhenNoSteps?: Boolean;
        TerminationProtected?: Boolean;
        HadoopVersion?: XmlStringMaxLen256;
        Ec2SubnetId?: XmlStringMaxLen256;
        EmrManagedMasterSecurityGroup?: XmlStringMaxLen256;
        EmrManagedSlaveSecurityGroup?: XmlStringMaxLen256;
        ServiceAccessSecurityGroup?: XmlStringMaxLen256;
        AdditionalMasterSecurityGroups?: SecurityGroupsList;
        AdditionalSlaveSecurityGroups?: SecurityGroupsList;
    }
    export interface JobFlowInstancesDetail {
        MasterInstanceType: InstanceType;
        MasterPublicDnsName?: XmlString;
        MasterInstanceId?: XmlString;
        SlaveInstanceType: InstanceType;
        InstanceCount: Integer;
        InstanceGroups?: InstanceGroupDetailList;
        NormalizedInstanceHours?: Integer;
        Ec2KeyName?: XmlStringMaxLen256;
        Ec2SubnetId?: XmlStringMaxLen256;
        Placement?: PlacementType;
        KeepJobFlowAliveWhenNoSteps?: Boolean;
        TerminationProtected?: Boolean;
        HadoopVersion?: XmlStringMaxLen256;
    }
    export interface KeyValue {
        Key?: XmlString;
        Value?: XmlString;
    }
    export interface ListBootstrapActionsInput {
        ClusterId: ClusterId;
        Marker?: Marker;
    }
    export interface ListBootstrapActionsOutput {
        BootstrapActions?: CommandList;
        Marker?: Marker;
    }
    export interface ListClustersInput {
        CreatedAfter?: Date;
        CreatedBefore?: Date;
        ClusterStates?: ClusterStateList;
        Marker?: Marker;
    }
    export interface ListClustersOutput {
        Clusters?: ClusterSummaryList;
        Marker?: Marker;
    }
    export interface ListInstanceGroupsInput {
        ClusterId: ClusterId;
        Marker?: Marker;
    }
    export interface ListInstanceGroupsOutput {
        InstanceGroups?: InstanceGroupList;
        Marker?: Marker;
    }
    export interface ListInstancesInput {
        ClusterId: ClusterId;
        InstanceGroupId?: InstanceGroupId;
        InstanceGroupTypes?: InstanceGroupTypeList;
        Marker?: Marker;
    }
    export interface ListInstancesOutput {
        Instances?: InstanceList;
        Marker?: Marker;
    }
    export interface ListStepsInput {
        ClusterId: ClusterId;
        StepStates?: StepStateList;
        StepIds?: XmlStringList;
        Marker?: Marker;
    }
    export interface ListStepsOutput {
        Steps?: StepSummaryList;
        Marker?: Marker;
    }
    export interface ModifyInstanceGroupsInput {
        InstanceGroups?: InstanceGroupModifyConfigList;
    }
    export interface PlacementType {
        AvailabilityZone: XmlString;
    }
    export interface RemoveTagsInput {
        ResourceId: ResourceId;
        TagKeys: StringList;
    }
    export interface RemoveTagsOutput {
    }
    export interface RunJobFlowInput {
        Name: XmlStringMaxLen256;
        LogUri?: XmlString;
        AdditionalInfo?: XmlString;
        AmiVersion?: XmlStringMaxLen256;
        ReleaseLabel?: XmlStringMaxLen256;
        Instances: JobFlowInstancesConfig;
        Steps?: StepConfigList;
        BootstrapActions?: BootstrapActionConfigList;
        SupportedProducts?: SupportedProductsList;
        NewSupportedProducts?: NewSupportedProductsList;
        Applications?: ApplicationList;
        Configurations?: ConfigurationList;
        VisibleToAllUsers?: Boolean;
        JobFlowRole?: XmlString;
        ServiceRole?: XmlString;
        Tags?: TagList;
    }
    export interface RunJobFlowOutput {
        JobFlowId?: XmlStringMaxLen256;
    }
    export interface ScriptBootstrapActionConfig {
        Path: XmlString;
        Args?: XmlStringList;
    }
    export interface SetTerminationProtectionInput {
        JobFlowIds: XmlStringList;
        TerminationProtected: Boolean;
    }
    export interface SetVisibleToAllUsersInput {
        JobFlowIds: XmlStringList;
        VisibleToAllUsers: Boolean;
    }
    export interface Step {
        Id?: StepId;
        Name?: String;
        Config?: HadoopStepConfig;
        ActionOnFailure?: ActionOnFailure;
        Status?: StepStatus;
    }
    export interface StepConfig {
        Name: XmlStringMaxLen256;
        ActionOnFailure?: ActionOnFailure;
        HadoopJarStep: HadoopJarStepConfig;
    }
    export interface StepDetail {
        StepConfig: StepConfig;
        ExecutionStatusDetail: StepExecutionStatusDetail;
    }
    export interface StepExecutionStatusDetail {
        State: StepExecutionState;
        CreationDateTime: Date;
        StartDateTime?: Date;
        EndDateTime?: Date;
        LastStateChangeReason?: XmlString;
    }
    export interface StepStateChangeReason {
        Code?: StepStateChangeReasonCode;
        Message?: String;
    }
    export interface StepStatus {
        State?: StepState;
        StateChangeReason?: StepStateChangeReason;
        Timeline?: StepTimeline;
    }
    export interface StepSummary {
        Id?: StepId;
        Name?: String;
        Config?: HadoopStepConfig;
        ActionOnFailure?: ActionOnFailure;
        Status?: StepStatus;
    }
    export interface StepTimeline {
        CreationDateTime?: Date;
        StartDateTime?: Date;
        EndDateTime?: Date;
    }
    export interface SupportedProductConfig {
        Name?: XmlStringMaxLen256;
        Args?: XmlStringList;
    }
    export interface Tag {
        Key?: String;
        Value?: String;
    }
    export interface TerminateJobFlowsInput {
        JobFlowIds: XmlStringList;
    }
    export interface VolumeSpecification {
        VolumeType: String;
        Iops?: Integer;
        SizeInGB: Integer;
    }
  }

  /*
   * apiVersion: 2015-01-01
   * endpointPrefix: es
   * serviceAbbreviation: 
   * signatureVersion: v4
   * protocol: rest-json
   */
  export class ES extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    addTags(params: ES.AddTagsRequest, callback?: (err: ES.BaseException|ES.LimitExceededException|ES.ValidationException|ES.InternalException|any, data: any) => void): Request;
    createElasticsearchDomain(params: ES.CreateElasticsearchDomainRequest, callback?: (err: ES.BaseException|ES.DisabledOperationException|ES.InternalException|ES.InvalidTypeException|ES.LimitExceededException|ES.ResourceAlreadyExistsException|ES.ValidationException|any, data: ES.CreateElasticsearchDomainResponse|any) => void): Request;
    deleteElasticsearchDomain(params: ES.DeleteElasticsearchDomainRequest, callback?: (err: ES.BaseException|ES.InternalException|ES.ResourceNotFoundException|ES.ValidationException|any, data: ES.DeleteElasticsearchDomainResponse|any) => void): Request;
    describeElasticsearchDomain(params: ES.DescribeElasticsearchDomainRequest, callback?: (err: ES.BaseException|ES.InternalException|ES.ResourceNotFoundException|ES.ValidationException|any, data: ES.DescribeElasticsearchDomainResponse|any) => void): Request;
    describeElasticsearchDomainConfig(params: ES.DescribeElasticsearchDomainConfigRequest, callback?: (err: ES.BaseException|ES.InternalException|ES.ResourceNotFoundException|ES.ValidationException|any, data: ES.DescribeElasticsearchDomainConfigResponse|any) => void): Request;
    describeElasticsearchDomains(params: ES.DescribeElasticsearchDomainsRequest, callback?: (err: ES.BaseException|ES.InternalException|ES.ValidationException|any, data: ES.DescribeElasticsearchDomainsResponse|any) => void): Request;
    listDomainNames(callback?: (err: ES.BaseException|ES.ValidationException|any, data: ES.ListDomainNamesResponse|any) => void): Request;
    listTags(params: ES.ListTagsRequest, callback?: (err: ES.BaseException|ES.ResourceNotFoundException|ES.ValidationException|ES.InternalException|any, data: ES.ListTagsResponse|any) => void): Request;
    removeTags(params: ES.RemoveTagsRequest, callback?: (err: ES.BaseException|ES.ValidationException|ES.InternalException|any, data: any) => void): Request;
    updateElasticsearchDomainConfig(params: ES.UpdateElasticsearchDomainConfigRequest, callback?: (err: ES.BaseException|ES.InternalException|ES.InvalidTypeException|ES.LimitExceededException|ES.ResourceNotFoundException|ES.ValidationException|any, data: ES.UpdateElasticsearchDomainConfigResponse|any) => void): Request;

  }

  export module ES {
    export type ARN = string;
    export type AdvancedOptions = {[key:string]: String};
    export type Boolean = boolean;
    export type DomainId = string;    // max: 64, min: 1
    export type DomainInfoList = DomainInfo[];
    export type DomainName = string;    // pattern: &quot;[a-z][a-z0-9\-]+&quot;, max: 28, min: 3
    export type DomainNameList = DomainName[];
    export type ESPartitionInstanceType = string;
    export type ElasticsearchDomainStatusList = ElasticsearchDomainStatus[];
    export type ErrorMessage = string;
    export type IntegerClass = number;
    export type OptionState = string;
    export type PolicyDocument = string;
    export type ServiceUrl = string;
    export type String = string;
    export type StringList = String[];
    export type TagKey = string;    // max: 128, min: 1
    export type TagList = Tag[];
    export type TagValue = string;    // max: 256
    export type UIntValue = number;
    export type UpdateTimestamp = number;
    export type VolumeType = string;

    export interface AccessPoliciesStatus {
        Options: PolicyDocument;
        Status: OptionStatus;
    }
    export interface AddTagsRequest {
        ARN: ARN;
        TagList: TagList;
    }
    export interface AdvancedOptionsStatus {
        Options: AdvancedOptions;
        Status: OptionStatus;
    }
    export interface BaseException {
        message?: ErrorMessage;
    }
    export interface CreateElasticsearchDomainRequest {
        DomainName: DomainName;
        ElasticsearchClusterConfig?: ElasticsearchClusterConfig;
        EBSOptions?: EBSOptions;
        AccessPolicies?: PolicyDocument;
        SnapshotOptions?: SnapshotOptions;
        AdvancedOptions?: AdvancedOptions;
    }
    export interface CreateElasticsearchDomainResponse {
        DomainStatus?: ElasticsearchDomainStatus;
    }
    export interface DeleteElasticsearchDomainRequest {
        DomainName: DomainName;
    }
    export interface DeleteElasticsearchDomainResponse {
        DomainStatus?: ElasticsearchDomainStatus;
    }
    export interface DescribeElasticsearchDomainConfigRequest {
        DomainName: DomainName;
    }
    export interface DescribeElasticsearchDomainConfigResponse {
        DomainConfig: ElasticsearchDomainConfig;
    }
    export interface DescribeElasticsearchDomainRequest {
        DomainName: DomainName;
    }
    export interface DescribeElasticsearchDomainResponse {
        DomainStatus: ElasticsearchDomainStatus;
    }
    export interface DescribeElasticsearchDomainsRequest {
        DomainNames: DomainNameList;
    }
    export interface DescribeElasticsearchDomainsResponse {
        DomainStatusList: ElasticsearchDomainStatusList;
    }
    export interface DisabledOperationException {
    }
    export interface DomainInfo {
        DomainName?: DomainName;
    }
    export interface EBSOptions {
        EBSEnabled?: Boolean;
        VolumeType?: VolumeType;
        VolumeSize?: IntegerClass;
        Iops?: IntegerClass;
    }
    export interface EBSOptionsStatus {
        Options: EBSOptions;
        Status: OptionStatus;
    }
    export interface ElasticsearchClusterConfig {
        InstanceType?: ESPartitionInstanceType;
        InstanceCount?: IntegerClass;
        DedicatedMasterEnabled?: Boolean;
        ZoneAwarenessEnabled?: Boolean;
        DedicatedMasterType?: ESPartitionInstanceType;
        DedicatedMasterCount?: IntegerClass;
    }
    export interface ElasticsearchClusterConfigStatus {
        Options: ElasticsearchClusterConfig;
        Status: OptionStatus;
    }
    export interface ElasticsearchDomainConfig {
        ElasticsearchClusterConfig?: ElasticsearchClusterConfigStatus;
        EBSOptions?: EBSOptionsStatus;
        AccessPolicies?: AccessPoliciesStatus;
        SnapshotOptions?: SnapshotOptionsStatus;
        AdvancedOptions?: AdvancedOptionsStatus;
    }
    export interface ElasticsearchDomainStatus {
        DomainId: DomainId;
        DomainName: DomainName;
        ARN: ARN;
        Created?: Boolean;
        Deleted?: Boolean;
        Endpoint?: ServiceUrl;
        Processing?: Boolean;
        ElasticsearchClusterConfig: ElasticsearchClusterConfig;
        EBSOptions?: EBSOptions;
        AccessPolicies?: PolicyDocument;
        SnapshotOptions?: SnapshotOptions;
        AdvancedOptions?: AdvancedOptions;
    }
    export interface InternalException {
    }
    export interface InvalidTypeException {
    }
    export interface LimitExceededException {
    }
    export interface ListDomainNamesResponse {
        DomainNames?: DomainInfoList;
    }
    export interface ListTagsRequest {
        ARN: ARN;
    }
    export interface ListTagsResponse {
        TagList?: TagList;
    }
    export interface OptionStatus {
        CreationDate: UpdateTimestamp;
        UpdateDate: UpdateTimestamp;
        UpdateVersion?: UIntValue;
        State: OptionState;
        PendingDeletion?: Boolean;
    }
    export interface RemoveTagsRequest {
        ARN: ARN;
        TagKeys: StringList;
    }
    export interface ResourceAlreadyExistsException {
    }
    export interface ResourceNotFoundException {
    }
    export interface SnapshotOptions {
        AutomatedSnapshotStartHour?: IntegerClass;
    }
    export interface SnapshotOptionsStatus {
        Options: SnapshotOptions;
        Status: OptionStatus;
    }
    export interface Tag {
        Key: TagKey;
        Value: TagValue;
    }
    export interface UpdateElasticsearchDomainConfigRequest {
        DomainName: DomainName;
        ElasticsearchClusterConfig?: ElasticsearchClusterConfig;
        EBSOptions?: EBSOptions;
        SnapshotOptions?: SnapshotOptions;
        AdvancedOptions?: AdvancedOptions;
        AccessPolicies?: PolicyDocument;
    }
    export interface UpdateElasticsearchDomainConfigResponse {
        DomainConfig: ElasticsearchDomainConfig;
    }
    export interface ValidationException {
    }
  }

  /*
   * apiVersion: 2012-09-25
   * endpointPrefix: elastictranscoder
   * serviceAbbreviation: 
   * signatureVersion: v4
   * protocol: rest-json
   */
  export class ElasticTranscoder extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    cancelJob(params: ElasticTranscoder.CancelJobRequest, callback?: (err: ElasticTranscoder.ValidationException|ElasticTranscoder.IncompatibleVersionException|ElasticTranscoder.ResourceNotFoundException|ElasticTranscoder.ResourceInUseException|ElasticTranscoder.AccessDeniedException|ElasticTranscoder.InternalServiceException|any, data: ElasticTranscoder.CancelJobResponse|any) => void): Request;
    createJob(params: ElasticTranscoder.CreateJobRequest, callback?: (err: ElasticTranscoder.ValidationException|ElasticTranscoder.IncompatibleVersionException|ElasticTranscoder.ResourceNotFoundException|ElasticTranscoder.AccessDeniedException|ElasticTranscoder.LimitExceededException|ElasticTranscoder.InternalServiceException|any, data: ElasticTranscoder.CreateJobResponse|any) => void): Request;
    createPipeline(params: ElasticTranscoder.CreatePipelineRequest, callback?: (err: ElasticTranscoder.ValidationException|ElasticTranscoder.IncompatibleVersionException|ElasticTranscoder.AccessDeniedException|ElasticTranscoder.ResourceNotFoundException|ElasticTranscoder.LimitExceededException|ElasticTranscoder.InternalServiceException|any, data: ElasticTranscoder.CreatePipelineResponse|any) => void): Request;
    createPreset(params: ElasticTranscoder.CreatePresetRequest, callback?: (err: ElasticTranscoder.ValidationException|ElasticTranscoder.IncompatibleVersionException|ElasticTranscoder.AccessDeniedException|ElasticTranscoder.LimitExceededException|ElasticTranscoder.InternalServiceException|any, data: ElasticTranscoder.CreatePresetResponse|any) => void): Request;
    deletePipeline(params: ElasticTranscoder.DeletePipelineRequest, callback?: (err: ElasticTranscoder.ValidationException|ElasticTranscoder.IncompatibleVersionException|ElasticTranscoder.ResourceNotFoundException|ElasticTranscoder.ResourceInUseException|ElasticTranscoder.AccessDeniedException|ElasticTranscoder.InternalServiceException|any, data: ElasticTranscoder.DeletePipelineResponse|any) => void): Request;
    deletePreset(params: ElasticTranscoder.DeletePresetRequest, callback?: (err: ElasticTranscoder.ValidationException|ElasticTranscoder.IncompatibleVersionException|ElasticTranscoder.ResourceNotFoundException|ElasticTranscoder.AccessDeniedException|ElasticTranscoder.InternalServiceException|any, data: ElasticTranscoder.DeletePresetResponse|any) => void): Request;
    listJobsByPipeline(params: ElasticTranscoder.ListJobsByPipelineRequest, callback?: (err: ElasticTranscoder.ValidationException|ElasticTranscoder.IncompatibleVersionException|ElasticTranscoder.ResourceNotFoundException|ElasticTranscoder.AccessDeniedException|ElasticTranscoder.InternalServiceException|any, data: ElasticTranscoder.ListJobsByPipelineResponse|any) => void): Request;
    listJobsByStatus(params: ElasticTranscoder.ListJobsByStatusRequest, callback?: (err: ElasticTranscoder.ValidationException|ElasticTranscoder.IncompatibleVersionException|ElasticTranscoder.ResourceNotFoundException|ElasticTranscoder.AccessDeniedException|ElasticTranscoder.InternalServiceException|any, data: ElasticTranscoder.ListJobsByStatusResponse|any) => void): Request;
    listPipelines(params: ElasticTranscoder.ListPipelinesRequest, callback?: (err: ElasticTranscoder.ValidationException|ElasticTranscoder.IncompatibleVersionException|ElasticTranscoder.AccessDeniedException|ElasticTranscoder.InternalServiceException|any, data: ElasticTranscoder.ListPipelinesResponse|any) => void): Request;
    listPresets(params: ElasticTranscoder.ListPresetsRequest, callback?: (err: ElasticTranscoder.ValidationException|ElasticTranscoder.IncompatibleVersionException|ElasticTranscoder.AccessDeniedException|ElasticTranscoder.InternalServiceException|any, data: ElasticTranscoder.ListPresetsResponse|any) => void): Request;
    readJob(params: ElasticTranscoder.ReadJobRequest, callback?: (err: ElasticTranscoder.ValidationException|ElasticTranscoder.IncompatibleVersionException|ElasticTranscoder.ResourceNotFoundException|ElasticTranscoder.AccessDeniedException|ElasticTranscoder.InternalServiceException|any, data: ElasticTranscoder.ReadJobResponse|any) => void): Request;
    readPipeline(params: ElasticTranscoder.ReadPipelineRequest, callback?: (err: ElasticTranscoder.ValidationException|ElasticTranscoder.IncompatibleVersionException|ElasticTranscoder.ResourceNotFoundException|ElasticTranscoder.AccessDeniedException|ElasticTranscoder.InternalServiceException|any, data: ElasticTranscoder.ReadPipelineResponse|any) => void): Request;
    readPreset(params: ElasticTranscoder.ReadPresetRequest, callback?: (err: ElasticTranscoder.ValidationException|ElasticTranscoder.IncompatibleVersionException|ElasticTranscoder.ResourceNotFoundException|ElasticTranscoder.AccessDeniedException|ElasticTranscoder.InternalServiceException|any, data: ElasticTranscoder.ReadPresetResponse|any) => void): Request;
    testRole(params: ElasticTranscoder.TestRoleRequest, callback?: (err: ElasticTranscoder.ValidationException|ElasticTranscoder.IncompatibleVersionException|ElasticTranscoder.ResourceNotFoundException|ElasticTranscoder.AccessDeniedException|ElasticTranscoder.InternalServiceException|any, data: ElasticTranscoder.TestRoleResponse|any) => void): Request;
    updatePipeline(params: ElasticTranscoder.UpdatePipelineRequest, callback?: (err: ElasticTranscoder.ValidationException|ElasticTranscoder.IncompatibleVersionException|ElasticTranscoder.AccessDeniedException|ElasticTranscoder.ResourceInUseException|ElasticTranscoder.ResourceNotFoundException|ElasticTranscoder.InternalServiceException|any, data: ElasticTranscoder.UpdatePipelineResponse|any) => void): Request;
    updatePipelineNotifications(params: ElasticTranscoder.UpdatePipelineNotificationsRequest, callback?: (err: ElasticTranscoder.ValidationException|ElasticTranscoder.IncompatibleVersionException|ElasticTranscoder.ResourceNotFoundException|ElasticTranscoder.ResourceInUseException|ElasticTranscoder.AccessDeniedException|ElasticTranscoder.InternalServiceException|any, data: ElasticTranscoder.UpdatePipelineNotificationsResponse|any) => void): Request;
    updatePipelineStatus(params: ElasticTranscoder.UpdatePipelineStatusRequest, callback?: (err: ElasticTranscoder.ValidationException|ElasticTranscoder.IncompatibleVersionException|ElasticTranscoder.ResourceNotFoundException|ElasticTranscoder.ResourceInUseException|ElasticTranscoder.AccessDeniedException|ElasticTranscoder.InternalServiceException|any, data: ElasticTranscoder.UpdatePipelineStatusResponse|any) => void): Request;

  }

  export module ElasticTranscoder {
    export type AccessControl = string;    // pattern: &quot;(^FullControl$)|(^Read$)|(^ReadAcp$)|(^WriteAcp$)&quot;
    export type AccessControls = AccessControl[];    // max: 30
    export type Artworks = Artwork[];
    export type Ascending = string;    // pattern: &quot;(^true$)|(^false$)&quot;
    export type AspectRatio = string;    // pattern: &quot;(^auto$)|(^1:1$)|(^4:3$)|(^3:2$)|(^16:9$)&quot;
    export type AudioBitDepth = string;    // pattern: &quot;(^16$)|(^24$)&quot;
    export type AudioBitOrder = string;    // pattern: &quot;(^LittleEndian$)&quot;
    export type AudioBitRate = string;    // pattern: &quot;^\d{1,3}$&quot;
    export type AudioChannels = string;    // pattern: &quot;(^auto$)|(^0$)|(^1$)|(^2$)&quot;
    export type AudioCodec = string;    // pattern: &quot;(^AAC$)|(^vorbis$)|(^mp3$)|(^mp2$)|(^pcm$)|(^flac$)&quot;
    export type AudioCodecProfile = string;    // pattern: &quot;(^auto$)|(^AAC-LC$)|(^HE-AAC$)|(^HE-AACv2$)&quot;
    export type AudioPackingMode = string;    // pattern: &quot;(^SingleTrack$)|(^OneChannelPerTrack$)|(^OneChannelPerTrackWithMosTo8Tracks$)&quot;
    export type AudioSampleRate = string;    // pattern: &quot;(^auto$)|(^22050$)|(^32000$)|(^44100$)|(^48000$)|(^96000$)|(^192000$)&quot;
    export type AudioSigned = string;    // pattern: &quot;(^Signed$)&quot;
    export type Base64EncodedString = string;    // pattern: &quot;^$|(^(?:[A-Za-z0-9\+/]{4})*(?:[A-Za-z0-9\+/]{2}==|[A-Za-z0-9\+/]{3}=)?$)&quot;
    export type BucketName = string;    // pattern: &quot;^(\w|\.|-){1,255}$&quot;
    export type CaptionFormatFormat = string;    // pattern: &quot;(^mov-text$)|(^srt$)|(^scc$)|(^webvtt$)|(^dfxp$)&quot;
    export type CaptionFormatPattern = string;    // pattern: &quot;(^$)|(^.*\{language\}.*$)&quot;
    export type CaptionFormats = CaptionFormat[];    // max: 4
    export type CaptionMergePolicy = string;    // pattern: &quot;(^MergeOverride$)|(^MergeRetain$)|(^Override$)&quot;
    export type CaptionSources = CaptionSource[];    // max: 20
    export type CodecOption = string;    // max: 255, min: 1
    export type CodecOptions = {[key:string]: CodecOption};    // max: 30
    export type Composition = Clip[];
    export type CreateJobOutputs = CreateJobOutput[];    // max: 30
    export type CreateJobPlaylists = CreateJobPlaylist[];    // max: 30
    export type Description = string;    // max: 255
    export type Digits = string;    // pattern: &quot;^\d{1,5}$&quot;
    export type DigitsOrAuto = string;    // pattern: &quot;(^auto$)|(^\d{2,4}$)&quot;
    export type EncryptionMode = string;    // pattern: &quot;(^s3$)|(^s3-aws-kms$)|(^aes-cbc-pkcs7$)|(^aes-ctr$)|(^aes-gcm$)&quot;
    export type ExceptionMessages = String[];
    export type Filename = string;    // max: 255, min: 1
    export type FixedGOP = string;    // pattern: &quot;(^true$)|(^false$)&quot;
    export type FloatString = string;    // pattern: &quot;^\d{1,5}(\.\d{0,5})?$&quot;
    export type FrameRate = string;    // pattern: &quot;(^auto$)|(^10$)|(^15$)|(^23.97$)|(^24$)|(^25$)|(^29.97$)|(^30$)|(^50$)|(^60$)&quot;
    export type Grantee = string;    // max: 255, min: 1
    export type GranteeType = string;    // pattern: &quot;(^Canonical$)|(^Email$)|(^Group$)&quot;
    export type HlsContentProtectionMethod = string;    // pattern: &quot;(^aes-128$)&quot;
    export type HorizontalAlign = string;    // pattern: &quot;(^Left$)|(^Right$)|(^Center$)&quot;
    export type Id = string;    // pattern: &quot;^\d{13}-\w{6}$&quot;
    export type Interlaced = string;    // pattern: &quot;(^auto$)|(^true$)|(^false$)&quot;
    export type JobContainer = string;    // pattern: &quot;(^auto$)|(^3gp$)|(^asf$)|(^avi$)|(^divx$)|(^flv$)|(^mkv$)|(^mov$)|(^mp4$)|(^mpeg$)|(^mpeg-ps$)|(^mpeg-ts$)|(^mxf$)|(^ogg$)|(^ts$)|(^vob$)|(^wav$)|(^webm$)|(^mp3$)|(^m4a$)|(^aac$)&quot;
    export type JobOutputs = JobOutput[];
    export type JobStatus = string;    // pattern: &quot;(^Submitted$)|(^Progressing$)|(^Complete$)|(^Canceled$)|(^Error$)&quot;
    export type JobWatermarks = JobWatermark[];
    export type Jobs = Job[];
    export type JpgOrPng = string;    // pattern: &quot;(^jpg$)|(^png$)&quot;
    export type Key = string;    // max: 255, min: 1
    export type KeyArn = string;    // max: 255
    export type KeyIdGuid = string;    // pattern: &quot;(^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{12}$)|(^[0-9A-Fa-f]{32}$)&quot;
    export type KeyStoragePolicy = string;    // pattern: &quot;(^NoStore$)|(^WithVariantPlaylists$)&quot;
    export type KeyframesMaxDist = string;    // pattern: &quot;^\d{1,6}$&quot;
    export type MaxFrameRate = string;    // pattern: &quot;(^10$)|(^15$)|(^23.97$)|(^24$)|(^25$)|(^29.97$)|(^30$)|(^50$)|(^60$)&quot;
    export type MergePolicy = string;    // pattern: &quot;(^Replace$)|(^Prepend$)|(^Append$)|(^Fallback$)&quot;
    export type Name = string;    // max: 40, min: 1
    export type NonEmptyBase64EncodedString = string;    // pattern: &quot;(^(?:[A-Za-z0-9\+/]{4})*(?:[A-Za-z0-9\+/]{2}==|[A-Za-z0-9\+/]{3}=)?$)&quot;
    export type NullableInteger = number;
    export type NullableLong = number;
    export type OneTo512String = string;    // max: 512, min: 1
    export type Opacity = string;    // pattern: &quot;^\d{1,3}(\.\d{0,20})?$&quot;
    export type OutputKeys = Key[];    // max: 30
    export type PaddingPolicy = string;    // pattern: &quot;(^Pad$)|(^NoPad$)&quot;
    export type Permissions = Permission[];    // max: 30
    export type PipelineStatus = string;    // pattern: &quot;(^Active$)|(^Paused$)&quot;
    export type Pipelines = Pipeline[];
    export type PixelsOrPercent = string;    // pattern: &quot;(^\d{1,3}(\.\d{0,5})?%$)|(^\d{1,4}?px$)&quot;
    export type PlayReadyDrmFormatString = string;    // pattern: &quot;(^microsoft$)|(^discretix-3.0$)&quot;
    export type PlaylistFormat = string;    // pattern: &quot;(^HLSv3$)|(^HLSv4$)|(^Smooth$)&quot;
    export type Playlists = Playlist[];
    export type PresetContainer = string;    // pattern: &quot;(^mp4$)|(^ts$)|(^webm$)|(^mp3$)|(^flac$)|(^oga$)|(^ogg$)|(^fmp4$)|(^mpg$)|(^flv$)|(^gif$)|(^mxf$)&quot;
    export type PresetType = string;    // pattern: &quot;(^System$)|(^Custom$)&quot;
    export type PresetWatermarkId = string;    // max: 40, min: 1
    export type PresetWatermarks = PresetWatermark[];
    export type Presets = Preset[];
    export type Resolution = string;    // pattern: &quot;(^auto$)|(^\d{1,5}x\d{1,5}$)&quot;
    export type Role = string;    // pattern: &quot;^arn:aws:iam::\w{12}:role/.+$&quot;
    export type Rotate = string;    // pattern: &quot;(^auto$)|(^0$)|(^90$)|(^180$)|(^270$)&quot;
    export type SizingPolicy = string;    // pattern: &quot;(^Fit$)|(^Fill$)|(^Stretch$)|(^Keep$)|(^ShrinkToFit$)|(^ShrinkToFill$)&quot;
    export type SnsTopic = string;    // pattern: &quot;(^$)|(^arn:aws:sns:.*:\w{12}:.+$)&quot;
    export type SnsTopics = SnsTopic[];    // max: 30
    export type StorageClass = string;    // pattern: &quot;(^ReducedRedundancy$)|(^Standard$)&quot;
    export type String = string;
    export type Success = string;    // pattern: &quot;(^true$)|(^false$)&quot;
    export type Target = string;    // pattern: &quot;(^Content$)|(^Frame$)&quot;
    export type ThumbnailPattern = string;    // pattern: &quot;(^$)|(^.*\{count\}.*$)&quot;
    export type ThumbnailResolution = string;    // pattern: &quot;^\d{1,5}x\d{1,5}$&quot;
    export type Time = string;    // pattern: &quot;(^\d{1,5}(\.\d{0,3})?$)|(^([0-1]?[0-9]:|2[0-3]:)?([0-5]?[0-9]:)?[0-5]?[0-9](\.\d{0,3})?$)&quot;
    export type TimeOffset = string;    // pattern: &quot;(^[+-]?\d{1,5}(\.\d{0,3})?$)|(^[+-]?([0-1]?[0-9]:|2[0-3]:)?([0-5]?[0-9]:)?[0-5]?[0-9](\.\d{0,3})?$)&quot;
    export type UserMetadata = {[key:string]: String};
    export type VerticalAlign = string;    // pattern: &quot;(^Top$)|(^Bottom$)|(^Center$)&quot;
    export type VideoBitRate = string;    // pattern: &quot;(^\d{2,5}$)|(^auto$)&quot;
    export type VideoCodec = string;    // pattern: &quot;(^H\.264$)|(^vp8$)|(^mpeg2$)|(^gif$)&quot;
    export type Warnings = Warning[];
    export type WatermarkKey = string;    // pattern: &quot;(^.{1,}.jpg$)|(^.{1,}.jpeg$)|(^.{1,}.png$)&quot;, max: 255, min: 1
    export type WatermarkSizingPolicy = string;    // pattern: &quot;(^Fit$)|(^Stretch$)|(^ShrinkToFit$)&quot;
    export type ZeroTo255String = string;    // max: 255
    export type ZeroTo512String = string;    // max: 512

    export interface AccessDeniedException {
    }
    export interface Artwork {
        InputKey?: WatermarkKey;
        MaxWidth?: DigitsOrAuto;
        MaxHeight?: DigitsOrAuto;
        SizingPolicy?: SizingPolicy;
        PaddingPolicy?: PaddingPolicy;
        AlbumArtFormat?: JpgOrPng;
        Encryption?: Encryption;
    }
    export interface AudioCodecOptions {
        Profile?: AudioCodecProfile;
        BitDepth?: AudioBitDepth;
        BitOrder?: AudioBitOrder;
        Signed?: AudioSigned;
    }
    export interface AudioParameters {
        Codec?: AudioCodec;
        SampleRate?: AudioSampleRate;
        BitRate?: AudioBitRate;
        Channels?: AudioChannels;
        AudioPackingMode?: AudioPackingMode;
        CodecOptions?: AudioCodecOptions;
    }
    export interface CancelJobRequest {
        Id: Id;
    }
    export interface CancelJobResponse {
    }
    export interface CaptionFormat {
        Format?: CaptionFormatFormat;
        Pattern?: CaptionFormatPattern;
        Encryption?: Encryption;
    }
    export interface CaptionSource {
        Key?: Key;
        Language?: Key;
        TimeOffset?: TimeOffset;
        Label?: Name;
        Encryption?: Encryption;
    }
    export interface Captions {
        MergePolicy?: CaptionMergePolicy;
        CaptionSources?: CaptionSources;
        CaptionFormats?: CaptionFormats;
    }
    export interface Clip {
        TimeSpan?: TimeSpan;
    }
    export interface CreateJobOutput {
        Key?: Key;
        ThumbnailPattern?: ThumbnailPattern;
        ThumbnailEncryption?: Encryption;
        Rotate?: Rotate;
        PresetId?: Id;
        SegmentDuration?: FloatString;
        Watermarks?: JobWatermarks;
        AlbumArt?: JobAlbumArt;
        Composition?: Composition;
        Captions?: Captions;
        Encryption?: Encryption;
    }
    export interface CreateJobPlaylist {
        Name?: Filename;
        Format?: PlaylistFormat;
        OutputKeys?: OutputKeys;
        HlsContentProtection?: HlsContentProtection;
        PlayReadyDrm?: PlayReadyDrm;
    }
    export interface CreateJobRequest {
        PipelineId: Id;
        Input: JobInput;
        Output?: CreateJobOutput;
        Outputs?: CreateJobOutputs;
        OutputKeyPrefix?: Key;
        Playlists?: CreateJobPlaylists;
        UserMetadata?: UserMetadata;
    }
    export interface CreateJobResponse {
        Job?: Job;
    }
    export interface CreatePipelineRequest {
        Name: Name;
        InputBucket: BucketName;
        OutputBucket?: BucketName;
        Role: Role;
        AwsKmsKeyArn?: KeyArn;
        Notifications?: Notifications;
        ContentConfig?: PipelineOutputConfig;
        ThumbnailConfig?: PipelineOutputConfig;
    }
    export interface CreatePipelineResponse {
        Pipeline?: Pipeline;
        Warnings?: Warnings;
    }
    export interface CreatePresetRequest {
        Name: Name;
        Description?: Description;
        Container: PresetContainer;
        Video?: VideoParameters;
        Audio?: AudioParameters;
        Thumbnails?: Thumbnails;
    }
    export interface CreatePresetResponse {
        Preset?: Preset;
        Warning?: String;
    }
    export interface DeletePipelineRequest {
        Id: Id;
    }
    export interface DeletePipelineResponse {
    }
    export interface DeletePresetRequest {
        Id: Id;
    }
    export interface DeletePresetResponse {
    }
    export interface DetectedProperties {
        Width?: NullableInteger;
        Height?: NullableInteger;
        FrameRate?: FloatString;
        FileSize?: NullableLong;
        DurationMillis?: NullableLong;
    }
    export interface Encryption {
        Mode?: EncryptionMode;
        Key?: Base64EncodedString;
        KeyMd5?: Base64EncodedString;
        InitializationVector?: ZeroTo255String;
    }
    export interface HlsContentProtection {
        Method?: HlsContentProtectionMethod;
        Key?: Base64EncodedString;
        KeyMd5?: Base64EncodedString;
        InitializationVector?: ZeroTo255String;
        LicenseAcquisitionUrl?: ZeroTo512String;
        KeyStoragePolicy?: KeyStoragePolicy;
    }
    export interface IncompatibleVersionException {
    }
    export interface InternalServiceException {
    }
    export interface Job {
        Id?: Id;
        Arn?: String;
        PipelineId?: Id;
        Input?: JobInput;
        Output?: JobOutput;
        Outputs?: JobOutputs;
        OutputKeyPrefix?: Key;
        Playlists?: Playlists;
        Status?: JobStatus;
        UserMetadata?: UserMetadata;
        Timing?: Timing;
    }
    export interface JobAlbumArt {
        MergePolicy?: MergePolicy;
        Artwork?: Artworks;
    }
    export interface JobInput {
        Key?: Key;
        FrameRate?: FrameRate;
        Resolution?: Resolution;
        AspectRatio?: AspectRatio;
        Interlaced?: Interlaced;
        Container?: JobContainer;
        Encryption?: Encryption;
        DetectedProperties?: DetectedProperties;
    }
    export interface JobOutput {
        Id?: String;
        Key?: Key;
        ThumbnailPattern?: ThumbnailPattern;
        ThumbnailEncryption?: Encryption;
        Rotate?: Rotate;
        PresetId?: Id;
        SegmentDuration?: FloatString;
        Status?: JobStatus;
        StatusDetail?: Description;
        Duration?: NullableLong;
        Width?: NullableInteger;
        Height?: NullableInteger;
        FrameRate?: FloatString;
        FileSize?: NullableLong;
        DurationMillis?: NullableLong;
        Watermarks?: JobWatermarks;
        AlbumArt?: JobAlbumArt;
        Composition?: Composition;
        Captions?: Captions;
        Encryption?: Encryption;
        AppliedColorSpaceConversion?: String;
    }
    export interface JobWatermark {
        PresetWatermarkId?: PresetWatermarkId;
        InputKey?: WatermarkKey;
        Encryption?: Encryption;
    }
    export interface LimitExceededException {
    }
    export interface ListJobsByPipelineRequest {
        PipelineId: Id;
        Ascending?: Ascending;
        PageToken?: Id;
    }
    export interface ListJobsByPipelineResponse {
        Jobs?: Jobs;
        NextPageToken?: Id;
    }
    export interface ListJobsByStatusRequest {
        Status: JobStatus;
        Ascending?: Ascending;
        PageToken?: Id;
    }
    export interface ListJobsByStatusResponse {
        Jobs?: Jobs;
        NextPageToken?: Id;
    }
    export interface ListPipelinesRequest {
        Ascending?: Ascending;
        PageToken?: Id;
    }
    export interface ListPipelinesResponse {
        Pipelines?: Pipelines;
        NextPageToken?: Id;
    }
    export interface ListPresetsRequest {
        Ascending?: Ascending;
        PageToken?: Id;
    }
    export interface ListPresetsResponse {
        Presets?: Presets;
        NextPageToken?: Id;
    }
    export interface Notifications {
        Progressing?: SnsTopic;
        Completed?: SnsTopic;
        Warning?: SnsTopic;
        Error?: SnsTopic;
    }
    export interface Permission {
        GranteeType?: GranteeType;
        Grantee?: Grantee;
        Access?: AccessControls;
    }
    export interface Pipeline {
        Id?: Id;
        Arn?: String;
        Name?: Name;
        Status?: PipelineStatus;
        InputBucket?: BucketName;
        OutputBucket?: BucketName;
        Role?: Role;
        AwsKmsKeyArn?: KeyArn;
        Notifications?: Notifications;
        ContentConfig?: PipelineOutputConfig;
        ThumbnailConfig?: PipelineOutputConfig;
    }
    export interface PipelineOutputConfig {
        Bucket?: BucketName;
        StorageClass?: StorageClass;
        Permissions?: Permissions;
    }
    export interface PlayReadyDrm {
        Format?: PlayReadyDrmFormatString;
        Key?: NonEmptyBase64EncodedString;
        KeyMd5?: NonEmptyBase64EncodedString;
        KeyId?: KeyIdGuid;
        InitializationVector?: ZeroTo255String;
        LicenseAcquisitionUrl?: OneTo512String;
    }
    export interface Playlist {
        Name?: Filename;
        Format?: PlaylistFormat;
        OutputKeys?: OutputKeys;
        HlsContentProtection?: HlsContentProtection;
        PlayReadyDrm?: PlayReadyDrm;
        Status?: JobStatus;
        StatusDetail?: Description;
    }
    export interface Preset {
        Id?: Id;
        Arn?: String;
        Name?: Name;
        Description?: Description;
        Container?: PresetContainer;
        Audio?: AudioParameters;
        Video?: VideoParameters;
        Thumbnails?: Thumbnails;
        Type?: PresetType;
    }
    export interface PresetWatermark {
        Id?: PresetWatermarkId;
        MaxWidth?: PixelsOrPercent;
        MaxHeight?: PixelsOrPercent;
        SizingPolicy?: WatermarkSizingPolicy;
        HorizontalAlign?: HorizontalAlign;
        HorizontalOffset?: PixelsOrPercent;
        VerticalAlign?: VerticalAlign;
        VerticalOffset?: PixelsOrPercent;
        Opacity?: Opacity;
        Target?: Target;
    }
    export interface ReadJobRequest {
        Id: Id;
    }
    export interface ReadJobResponse {
        Job?: Job;
    }
    export interface ReadPipelineRequest {
        Id: Id;
    }
    export interface ReadPipelineResponse {
        Pipeline?: Pipeline;
        Warnings?: Warnings;
    }
    export interface ReadPresetRequest {
        Id: Id;
    }
    export interface ReadPresetResponse {
        Preset?: Preset;
    }
    export interface ResourceInUseException {
    }
    export interface ResourceNotFoundException {
    }
    export interface TestRoleRequest {
        Role: Role;
        InputBucket: BucketName;
        OutputBucket: BucketName;
        Topics: SnsTopics;
    }
    export interface TestRoleResponse {
        Success?: Success;
        Messages?: ExceptionMessages;
    }
    export interface Thumbnails {
        Format?: JpgOrPng;
        Interval?: Digits;
        Resolution?: ThumbnailResolution;
        AspectRatio?: AspectRatio;
        MaxWidth?: DigitsOrAuto;
        MaxHeight?: DigitsOrAuto;
        SizingPolicy?: SizingPolicy;
        PaddingPolicy?: PaddingPolicy;
    }
    export interface TimeSpan {
        StartTime?: Time;
        Duration?: Time;
    }
    export interface Timing {
        SubmitTimeMillis?: NullableLong;
        StartTimeMillis?: NullableLong;
        FinishTimeMillis?: NullableLong;
    }
    export interface UpdatePipelineNotificationsRequest {
        Id: Id;
        Notifications: Notifications;
    }
    export interface UpdatePipelineNotificationsResponse {
        Pipeline?: Pipeline;
    }
    export interface UpdatePipelineRequest {
        Id: Id;
        Name?: Name;
        InputBucket?: BucketName;
        Role?: Role;
        AwsKmsKeyArn?: KeyArn;
        Notifications?: Notifications;
        ContentConfig?: PipelineOutputConfig;
        ThumbnailConfig?: PipelineOutputConfig;
    }
    export interface UpdatePipelineResponse {
        Pipeline?: Pipeline;
        Warnings?: Warnings;
    }
    export interface UpdatePipelineStatusRequest {
        Id: Id;
        Status: PipelineStatus;
    }
    export interface UpdatePipelineStatusResponse {
        Pipeline?: Pipeline;
    }
    export interface ValidationException {
    }
    export interface VideoParameters {
        Codec?: VideoCodec;
        CodecOptions?: CodecOptions;
        KeyframesMaxDist?: KeyframesMaxDist;
        FixedGOP?: FixedGOP;
        BitRate?: VideoBitRate;
        FrameRate?: FrameRate;
        MaxFrameRate?: MaxFrameRate;
        Resolution?: Resolution;
        AspectRatio?: AspectRatio;
        MaxWidth?: DigitsOrAuto;
        MaxHeight?: DigitsOrAuto;
        DisplayAspectRatio?: AspectRatio;
        SizingPolicy?: SizingPolicy;
        PaddingPolicy?: PaddingPolicy;
        Watermarks?: PresetWatermarks;
    }
    export interface Warning {
        Code?: String;
        Message?: String;
    }
  }

  /*
   * apiVersion: 2015-08-04
   * endpointPrefix: firehose
   * serviceAbbreviation: Firehose
   * signatureVersion: v4
   * protocol: json
   */
  export class Firehose extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    createDeliveryStream(params: Firehose.CreateDeliveryStreamInput, callback?: (err: Firehose.InvalidArgumentException|Firehose.LimitExceededException|Firehose.ResourceInUseException|any, data: Firehose.CreateDeliveryStreamOutput|any) => void): Request;
    deleteDeliveryStream(params: Firehose.DeleteDeliveryStreamInput, callback?: (err: Firehose.ResourceInUseException|Firehose.ResourceNotFoundException|any, data: Firehose.DeleteDeliveryStreamOutput|any) => void): Request;
    describeDeliveryStream(params: Firehose.DescribeDeliveryStreamInput, callback?: (err: Firehose.ResourceNotFoundException|any, data: Firehose.DescribeDeliveryStreamOutput|any) => void): Request;
    listDeliveryStreams(params: Firehose.ListDeliveryStreamsInput, callback?: (err: any, data: Firehose.ListDeliveryStreamsOutput|any) => void): Request;
    putRecord(params: Firehose.PutRecordInput, callback?: (err: Firehose.ResourceNotFoundException|Firehose.InvalidArgumentException|Firehose.ServiceUnavailableException|any, data: Firehose.PutRecordOutput|any) => void): Request;
    putRecordBatch(params: Firehose.PutRecordBatchInput, callback?: (err: Firehose.ResourceNotFoundException|Firehose.InvalidArgumentException|Firehose.ServiceUnavailableException|any, data: Firehose.PutRecordBatchOutput|any) => void): Request;
    updateDestination(params: Firehose.UpdateDestinationInput, callback?: (err: Firehose.InvalidArgumentException|Firehose.ResourceInUseException|Firehose.ResourceNotFoundException|Firehose.ConcurrentModificationException|any, data: Firehose.UpdateDestinationOutput|any) => void): Request;

  }

  export module Firehose {
    export type AWSKMSKeyARN = string;    // pattern: &quot;arn:.*&quot;, max: 512, min: 1
    export type BooleanObject = boolean;
    export type BucketARN = string;    // pattern: &quot;arn:.*&quot;, max: 2048, min: 1
    export type ClusterJDBCURL = string;    // pattern: &quot;jdbc:(redshift|postgresql)://((?!-)[A-Za-z0-9-]{1,63}(?&lt;!-)\.)+redshift\.amazonaws\.com:\d{1,5}/[a-zA-Z0-9_$]+&quot;, min: 1
    export type CompressionFormat = string;
    export type CopyOptions = string;
    export type Data = any;    // max: 1024000, type: blob
    export type DataTableColumns = string;
    export type DataTableName = string;    // min: 1
    export type DeliveryStreamARN = string;
    export type DeliveryStreamName = string;    // pattern: &quot;[a-zA-Z0-9_.-]+&quot;, max: 64, min: 1
    export type DeliveryStreamNameList = DeliveryStreamName[];
    export type DeliveryStreamStatus = string;
    export type DeliveryStreamVersionId = string;    // pattern: &quot;[0-9]+&quot;, max: 50, min: 1
    export type DescribeDeliveryStreamInputLimit = number;    // max: 10000, min: 1
    export type DestinationDescriptionList = DestinationDescription[];
    export type DestinationId = string;    // max: 100, min: 1
    export type ErrorCode = string;
    export type ErrorMessage = string;
    export type IntervalInSeconds = number;    // max: 900, min: 60
    export type ListDeliveryStreamsInputLimit = number;    // max: 10000, min: 1
    export type NoEncryptionConfig = string;
    export type NonNegativeIntegerObject = number;
    export type Password = string;    // min: 6
    export type Prefix = string;
    export type PutRecordBatchRequestEntryList = Record[];    // max: 500, min: 1
    export type PutRecordBatchResponseEntryList = PutRecordBatchResponseEntry[];    // max: 500, min: 1
    export type PutResponseRecordId = string;    // min: 1
    export type RoleARN = string;    // pattern: &quot;arn:.*&quot;, max: 512, min: 1
    export type SizeInMBs = number;    // max: 128, min: 1
    export type Timestamp = number;
    export type Username = string;    // min: 1

    export interface BufferingHints {
        SizeInMBs?: SizeInMBs;
        IntervalInSeconds?: IntervalInSeconds;
    }
    export interface ConcurrentModificationException {
        message?: ErrorMessage;
    }
    export interface CopyCommand {
        DataTableName: DataTableName;
        DataTableColumns?: DataTableColumns;
        CopyOptions?: CopyOptions;
    }
    export interface CreateDeliveryStreamInput {
        DeliveryStreamName: DeliveryStreamName;
        S3DestinationConfiguration?: S3DestinationConfiguration;
        RedshiftDestinationConfiguration?: RedshiftDestinationConfiguration;
    }
    export interface CreateDeliveryStreamOutput {
        DeliveryStreamARN?: DeliveryStreamARN;
    }
    export interface DeleteDeliveryStreamInput {
        DeliveryStreamName: DeliveryStreamName;
    }
    export interface DeleteDeliveryStreamOutput {
    }
    export interface DeliveryStreamDescription {
        DeliveryStreamName: DeliveryStreamName;
        DeliveryStreamARN: DeliveryStreamARN;
        DeliveryStreamStatus: DeliveryStreamStatus;
        VersionId: DeliveryStreamVersionId;
        CreateTimestamp?: Timestamp;
        LastUpdateTimestamp?: Timestamp;
        Destinations: DestinationDescriptionList;
        HasMoreDestinations: BooleanObject;
    }
    export interface DescribeDeliveryStreamInput {
        DeliveryStreamName: DeliveryStreamName;
        Limit?: DescribeDeliveryStreamInputLimit;
        ExclusiveStartDestinationId?: DestinationId;
    }
    export interface DescribeDeliveryStreamOutput {
        DeliveryStreamDescription: DeliveryStreamDescription;
    }
    export interface DestinationDescription {
        DestinationId: DestinationId;
        S3DestinationDescription?: S3DestinationDescription;
        RedshiftDestinationDescription?: RedshiftDestinationDescription;
    }
    export interface EncryptionConfiguration {
        NoEncryptionConfig?: NoEncryptionConfig;
        KMSEncryptionConfig?: KMSEncryptionConfig;
    }
    export interface InvalidArgumentException {
        message?: ErrorMessage;
    }
    export interface KMSEncryptionConfig {
        AWSKMSKeyARN: AWSKMSKeyARN;
    }
    export interface LimitExceededException {
        message?: ErrorMessage;
    }
    export interface ListDeliveryStreamsInput {
        Limit?: ListDeliveryStreamsInputLimit;
        ExclusiveStartDeliveryStreamName?: DeliveryStreamName;
    }
    export interface ListDeliveryStreamsOutput {
        DeliveryStreamNames: DeliveryStreamNameList;
        HasMoreDeliveryStreams: BooleanObject;
    }
    export interface PutRecordBatchInput {
        DeliveryStreamName: DeliveryStreamName;
        Records: PutRecordBatchRequestEntryList;
    }
    export interface PutRecordBatchOutput {
        FailedPutCount: NonNegativeIntegerObject;
        RequestResponses: PutRecordBatchResponseEntryList;
    }
    export interface PutRecordBatchResponseEntry {
        RecordId?: PutResponseRecordId;
        ErrorCode?: ErrorCode;
        ErrorMessage?: ErrorMessage;
    }
    export interface PutRecordInput {
        DeliveryStreamName: DeliveryStreamName;
        Record: Record;
    }
    export interface PutRecordOutput {
        RecordId: PutResponseRecordId;
    }
    export interface Record {
        Data: Data;
    }
    export interface RedshiftDestinationConfiguration {
        RoleARN: RoleARN;
        ClusterJDBCURL: ClusterJDBCURL;
        CopyCommand: CopyCommand;
        Username: Username;
        Password: Password;
        S3Configuration: S3DestinationConfiguration;
    }
    export interface RedshiftDestinationDescription {
        RoleARN: RoleARN;
        ClusterJDBCURL: ClusterJDBCURL;
        CopyCommand: CopyCommand;
        Username: Username;
        S3DestinationDescription: S3DestinationDescription;
    }
    export interface RedshiftDestinationUpdate {
        RoleARN?: RoleARN;
        ClusterJDBCURL?: ClusterJDBCURL;
        CopyCommand?: CopyCommand;
        Username?: Username;
        Password?: Password;
        S3Update?: S3DestinationUpdate;
    }
    export interface ResourceInUseException {
        message?: ErrorMessage;
    }
    export interface ResourceNotFoundException {
        message?: ErrorMessage;
    }
    export interface S3DestinationConfiguration {
        RoleARN: RoleARN;
        BucketARN: BucketARN;
        Prefix?: Prefix;
        BufferingHints?: BufferingHints;
        CompressionFormat?: CompressionFormat;
        EncryptionConfiguration?: EncryptionConfiguration;
    }
    export interface S3DestinationDescription {
        RoleARN: RoleARN;
        BucketARN: BucketARN;
        Prefix?: Prefix;
        BufferingHints: BufferingHints;
        CompressionFormat: CompressionFormat;
        EncryptionConfiguration: EncryptionConfiguration;
    }
    export interface S3DestinationUpdate {
        RoleARN?: RoleARN;
        BucketARN?: BucketARN;
        Prefix?: Prefix;
        BufferingHints?: BufferingHints;
        CompressionFormat?: CompressionFormat;
        EncryptionConfiguration?: EncryptionConfiguration;
    }
    export interface ServiceUnavailableException {
        message?: ErrorMessage;
    }
    export interface UpdateDestinationInput {
        DeliveryStreamName: DeliveryStreamName;
        CurrentDeliveryStreamVersionId: DeliveryStreamVersionId;
        DestinationId: DestinationId;
        S3DestinationUpdate?: S3DestinationUpdate;
        RedshiftDestinationUpdate?: RedshiftDestinationUpdate;
    }
    export interface UpdateDestinationOutput {
    }
  }

  /*
   * apiVersion: 2015-10-01
   * endpointPrefix: gamelift
   * serviceAbbreviation: 
   * signatureVersion: v4
   * protocol: json
   */
  export class GameLift extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    createAlias(params: GameLift.CreateAliasInput, callback?: (err: GameLift.UnauthorizedException|GameLift.InvalidRequestException|GameLift.ConflictException|GameLift.InternalServiceException|GameLift.LimitExceededException|any, data: GameLift.CreateAliasOutput|any) => void): Request;
    createBuild(params: GameLift.CreateBuildInput, callback?: (err: GameLift.UnauthorizedException|GameLift.InvalidRequestException|GameLift.ConflictException|GameLift.InternalServiceException|any, data: GameLift.CreateBuildOutput|any) => void): Request;
    createFleet(params: GameLift.CreateFleetInput, callback?: (err: GameLift.InternalServiceException|GameLift.NotFoundException|GameLift.ConflictException|GameLift.LimitExceededException|GameLift.InvalidRequestException|GameLift.UnauthorizedException|any, data: GameLift.CreateFleetOutput|any) => void): Request;
    createGameSession(params: GameLift.CreateGameSessionInput, callback?: (err: GameLift.ConflictException|GameLift.InternalServiceException|GameLift.UnauthorizedException|GameLift.InvalidFleetStatusException|GameLift.TerminalRoutingStrategyException|GameLift.InvalidRequestException|GameLift.NotFoundException|GameLift.FleetCapacityExceededException|any, data: GameLift.CreateGameSessionOutput|any) => void): Request;
    createPlayerSession(params: GameLift.CreatePlayerSessionInput, callback?: (err: GameLift.InternalServiceException|GameLift.UnauthorizedException|GameLift.InvalidGameSessionStatusException|GameLift.GameSessionFullException|GameLift.TerminalRoutingStrategyException|GameLift.InvalidRequestException|GameLift.NotFoundException|any, data: GameLift.CreatePlayerSessionOutput|any) => void): Request;
    createPlayerSessions(params: GameLift.CreatePlayerSessionsInput, callback?: (err: GameLift.InternalServiceException|GameLift.UnauthorizedException|GameLift.InvalidGameSessionStatusException|GameLift.GameSessionFullException|GameLift.TerminalRoutingStrategyException|GameLift.InvalidRequestException|GameLift.NotFoundException|any, data: GameLift.CreatePlayerSessionsOutput|any) => void): Request;
    deleteAlias(params: GameLift.DeleteAliasInput, callback?: (err: GameLift.UnauthorizedException|GameLift.NotFoundException|GameLift.InvalidRequestException|GameLift.InternalServiceException|any, data: any) => void): Request;
    deleteBuild(params: GameLift.DeleteBuildInput, callback?: (err: GameLift.UnauthorizedException|GameLift.NotFoundException|GameLift.InternalServiceException|GameLift.InvalidRequestException|any, data: any) => void): Request;
    deleteFleet(params: GameLift.DeleteFleetInput, callback?: (err: GameLift.NotFoundException|GameLift.InternalServiceException|GameLift.InvalidFleetStatusException|GameLift.UnauthorizedException|GameLift.InvalidRequestException|GameLift.InvalidFleetStatusException|any, data: any) => void): Request;
    deleteScalingPolicy(params: GameLift.DeleteScalingPolicyInput, callback?: (err: GameLift.InternalServiceException|GameLift.InvalidRequestException|GameLift.UnauthorizedException|GameLift.NotFoundException|any, data: any) => void): Request;
    describeAlias(params: GameLift.DescribeAliasInput, callback?: (err: GameLift.UnauthorizedException|GameLift.InvalidRequestException|GameLift.NotFoundException|GameLift.InternalServiceException|any, data: GameLift.DescribeAliasOutput|any) => void): Request;
    describeBuild(params: GameLift.DescribeBuildInput, callback?: (err: GameLift.UnauthorizedException|GameLift.InvalidRequestException|GameLift.NotFoundException|GameLift.InternalServiceException|any, data: GameLift.DescribeBuildOutput|any) => void): Request;
    describeEC2InstanceLimits(params: GameLift.DescribeEC2InstanceLimitsInput, callback?: (err: GameLift.InvalidRequestException|GameLift.InternalServiceException|GameLift.UnauthorizedException|any, data: GameLift.DescribeEC2InstanceLimitsOutput|any) => void): Request;
    describeFleetAttributes(params: GameLift.DescribeFleetAttributesInput, callback?: (err: GameLift.InternalServiceException|GameLift.NotFoundException|GameLift.InvalidRequestException|GameLift.UnauthorizedException|any, data: GameLift.DescribeFleetAttributesOutput|any) => void): Request;
    describeFleetCapacity(params: GameLift.DescribeFleetCapacityInput, callback?: (err: GameLift.InternalServiceException|GameLift.NotFoundException|GameLift.InvalidRequestException|GameLift.UnauthorizedException|any, data: GameLift.DescribeFleetCapacityOutput|any) => void): Request;
    describeFleetEvents(params: GameLift.DescribeFleetEventsInput, callback?: (err: GameLift.NotFoundException|GameLift.InternalServiceException|GameLift.UnauthorizedException|GameLift.InvalidRequestException|any, data: GameLift.DescribeFleetEventsOutput|any) => void): Request;
    describeFleetPortSettings(params: GameLift.DescribeFleetPortSettingsInput, callback?: (err: GameLift.InternalServiceException|GameLift.NotFoundException|GameLift.InvalidRequestException|GameLift.UnauthorizedException|any, data: GameLift.DescribeFleetPortSettingsOutput|any) => void): Request;
    describeFleetUtilization(params: GameLift.DescribeFleetUtilizationInput, callback?: (err: GameLift.InternalServiceException|GameLift.NotFoundException|GameLift.InvalidRequestException|GameLift.UnauthorizedException|any, data: GameLift.DescribeFleetUtilizationOutput|any) => void): Request;
    describeGameSessionDetails(params: GameLift.DescribeGameSessionDetailsInput, callback?: (err: GameLift.InternalServiceException|GameLift.NotFoundException|GameLift.InvalidRequestException|GameLift.UnauthorizedException|GameLift.TerminalRoutingStrategyException|any, data: GameLift.DescribeGameSessionDetailsOutput|any) => void): Request;
    describeGameSessions(params: GameLift.DescribeGameSessionsInput, callback?: (err: GameLift.InternalServiceException|GameLift.NotFoundException|GameLift.InvalidRequestException|GameLift.UnauthorizedException|GameLift.TerminalRoutingStrategyException|any, data: GameLift.DescribeGameSessionsOutput|any) => void): Request;
    describePlayerSessions(params: GameLift.DescribePlayerSessionsInput, callback?: (err: GameLift.InternalServiceException|GameLift.NotFoundException|GameLift.InvalidRequestException|GameLift.UnauthorizedException|any, data: GameLift.DescribePlayerSessionsOutput|any) => void): Request;
    describeScalingPolicies(params: GameLift.DescribeScalingPoliciesInput, callback?: (err: GameLift.InternalServiceException|GameLift.InvalidRequestException|GameLift.UnauthorizedException|GameLift.NotFoundException|any, data: GameLift.DescribeScalingPoliciesOutput|any) => void): Request;
    getGameSessionLogUrl(params: GameLift.GetGameSessionLogUrlInput, callback?: (err: GameLift.InternalServiceException|GameLift.NotFoundException|GameLift.UnauthorizedException|GameLift.InvalidRequestException|any, data: GameLift.GetGameSessionLogUrlOutput|any) => void): Request;
    listAliases(params: GameLift.ListAliasesInput, callback?: (err: GameLift.UnauthorizedException|GameLift.InvalidRequestException|GameLift.InternalServiceException|any, data: GameLift.ListAliasesOutput|any) => void): Request;
    listBuilds(params: GameLift.ListBuildsInput, callback?: (err: GameLift.UnauthorizedException|GameLift.InvalidRequestException|GameLift.InternalServiceException|any, data: GameLift.ListBuildsOutput|any) => void): Request;
    listFleets(params: GameLift.ListFleetsInput, callback?: (err: GameLift.InternalServiceException|GameLift.NotFoundException|GameLift.InvalidRequestException|GameLift.UnauthorizedException|any, data: GameLift.ListFleetsOutput|any) => void): Request;
    putScalingPolicy(params: GameLift.PutScalingPolicyInput, callback?: (err: GameLift.InternalServiceException|GameLift.InvalidRequestException|GameLift.UnauthorizedException|GameLift.NotFoundException|any, data: GameLift.PutScalingPolicyOutput|any) => void): Request;
    requestUploadCredentials(params: GameLift.RequestUploadCredentialsInput, callback?: (err: GameLift.UnauthorizedException|GameLift.InvalidRequestException|GameLift.NotFoundException|GameLift.InternalServiceException|any, data: GameLift.RequestUploadCredentialsOutput|any) => void): Request;
    resolveAlias(params: GameLift.ResolveAliasInput, callback?: (err: GameLift.UnauthorizedException|GameLift.InvalidRequestException|GameLift.NotFoundException|GameLift.TerminalRoutingStrategyException|GameLift.InternalServiceException|any, data: GameLift.ResolveAliasOutput|any) => void): Request;
    updateAlias(params: GameLift.UpdateAliasInput, callback?: (err: GameLift.UnauthorizedException|GameLift.InvalidRequestException|GameLift.NotFoundException|GameLift.InternalServiceException|any, data: GameLift.UpdateAliasOutput|any) => void): Request;
    updateBuild(params: GameLift.UpdateBuildInput, callback?: (err: GameLift.UnauthorizedException|GameLift.InvalidRequestException|GameLift.NotFoundException|GameLift.InternalServiceException|any, data: GameLift.UpdateBuildOutput|any) => void): Request;
    updateFleetAttributes(params: GameLift.UpdateFleetAttributesInput, callback?: (err: GameLift.NotFoundException|GameLift.ConflictException|GameLift.InvalidFleetStatusException|GameLift.LimitExceededException|GameLift.InternalServiceException|GameLift.InvalidRequestException|GameLift.UnauthorizedException|any, data: GameLift.UpdateFleetAttributesOutput|any) => void): Request;
    updateFleetCapacity(params: GameLift.UpdateFleetCapacityInput, callback?: (err: GameLift.NotFoundException|GameLift.ConflictException|GameLift.LimitExceededException|GameLift.InvalidFleetStatusException|GameLift.InternalServiceException|GameLift.InvalidRequestException|GameLift.UnauthorizedException|any, data: GameLift.UpdateFleetCapacityOutput|any) => void): Request;
    updateFleetPortSettings(params: GameLift.UpdateFleetPortSettingsInput, callback?: (err: GameLift.NotFoundException|GameLift.ConflictException|GameLift.InvalidFleetStatusException|GameLift.LimitExceededException|GameLift.InternalServiceException|GameLift.InvalidRequestException|GameLift.UnauthorizedException|any, data: GameLift.UpdateFleetPortSettingsOutput|any) => void): Request;
    updateGameSession(params: GameLift.UpdateGameSessionInput, callback?: (err: GameLift.NotFoundException|GameLift.ConflictException|GameLift.InternalServiceException|GameLift.UnauthorizedException|GameLift.InvalidGameSessionStatusException|GameLift.InvalidRequestException|any, data: GameLift.UpdateGameSessionOutput|any) => void): Request;

  }

  export module GameLift {
    export type AliasId = string;    // pattern: &quot;^alias-\S+&quot;
    export type AliasList = Alias[];
    export type BuildId = string;    // pattern: &quot;^build-\S+&quot;
    export type BuildList = Build[];
    export type BuildStatus = string;
    export type ComparisonOperatorType = string;
    export type Double = number;
    export type EC2InstanceLimitList = EC2InstanceLimit[];
    export type EC2InstanceType = string;
    export type EventCode = string;
    export type EventList = Event[];
    export type FleetAttributesList = FleetAttributes[];
    export type FleetCapacityList = FleetCapacity[];
    export type FleetId = string;    // pattern: &quot;^fleet-\S+&quot;
    export type FleetIdList = FleetId[];    // min: 1
    export type FleetStatus = string;
    export type FleetUtilizationList = FleetUtilization[];
    export type FreeText = string;
    export type GamePropertyKey = string;    // max: 32
    export type GamePropertyList = GameProperty[];    // max: 16
    export type GamePropertyValue = string;    // max: 96
    export type GameSessionDetailList = GameSessionDetail[];
    export type GameSessionId = string;    // pattern: &quot;^(gamei-|gsess-)\S+&quot;
    export type GameSessionList = GameSession[];
    export type GameSessionStatus = string;
    export type Integer = number;
    export type IpAddress = string;
    export type IpPermissionsList = IpPermission[];    // max: 50
    export type IpProtocol = string;
    export type MetricName = string;
    export type NonBlankString = string;    // pattern: &quot;[^\s]+&quot;
    export type NonEmptyString = string;    // min: 1
    export type NonZeroAndMaxString = string;    // max: 1024, min: 1
    export type PlayerIdList = NonZeroAndMaxString[];    // max: 25, min: 1
    export type PlayerSessionCreationPolicy = string;
    export type PlayerSessionId = string;    // pattern: &quot;^psess-\S+&quot;
    export type PlayerSessionList = PlayerSession[];
    export type PlayerSessionStatus = string;
    export type PortNumber = number;    // max: 60000, min: 1025
    export type PositiveInteger = number;    // min: 1
    export type PositiveLong = number;    // min: 1
    export type ProtectionPolicy = string;
    export type RoutingStrategyType = string;
    export type ScalingAdjustmentType = string;
    export type ScalingPolicyList = ScalingPolicy[];
    export type ScalingStatusType = string;
    export type StringList = NonZeroAndMaxString[];
    export type Timestamp = number;
    export type WholeNumber = number;

    export interface Alias {
        AliasId?: AliasId;
        Name?: FreeText;
        Description?: FreeText;
        RoutingStrategy?: RoutingStrategy;
        CreationTime?: Timestamp;
        LastUpdatedTime?: Timestamp;
    }
    export interface AwsCredentials {
        AccessKeyId?: NonEmptyString;
        SecretAccessKey?: NonEmptyString;
        SessionToken?: NonEmptyString;
    }
    export interface Build {
        BuildId?: BuildId;
        Name?: FreeText;
        Version?: FreeText;
        Status?: BuildStatus;
        SizeOnDisk?: PositiveLong;
        CreationTime?: Timestamp;
    }
    export interface ConflictException {
        Message?: NonEmptyString;
    }
    export interface CreateAliasInput {
        Name: NonZeroAndMaxString;
        Description?: NonZeroAndMaxString;
        RoutingStrategy: RoutingStrategy;
    }
    export interface CreateAliasOutput {
        Alias?: Alias;
    }
    export interface CreateBuildInput {
        Name?: NonZeroAndMaxString;
        Version?: NonZeroAndMaxString;
        StorageLocation?: S3Location;
    }
    export interface CreateBuildOutput {
        Build?: Build;
        UploadCredentials?: AwsCredentials;
        StorageLocation?: S3Location;
    }
    export interface CreateFleetInput {
        Name: NonZeroAndMaxString;
        Description?: NonZeroAndMaxString;
        BuildId: BuildId;
        ServerLaunchPath: NonZeroAndMaxString;
        ServerLaunchParameters?: NonZeroAndMaxString;
        LogPaths?: StringList;
        EC2InstanceType: EC2InstanceType;
        EC2InboundPermissions?: IpPermissionsList;
        NewGameSessionProtectionPolicy?: ProtectionPolicy;
    }
    export interface CreateFleetOutput {
        FleetAttributes?: FleetAttributes;
    }
    export interface CreateGameSessionInput {
        FleetId?: FleetId;
        AliasId?: AliasId;
        MaximumPlayerSessionCount: WholeNumber;
        Name?: NonZeroAndMaxString;
        GameProperties?: GamePropertyList;
    }
    export interface CreateGameSessionOutput {
        GameSession?: GameSession;
    }
    export interface CreatePlayerSessionInput {
        GameSessionId: GameSessionId;
        PlayerId: NonZeroAndMaxString;
    }
    export interface CreatePlayerSessionOutput {
        PlayerSession?: PlayerSession;
    }
    export interface CreatePlayerSessionsInput {
        GameSessionId: GameSessionId;
        PlayerIds: PlayerIdList;
    }
    export interface CreatePlayerSessionsOutput {
        PlayerSessions?: PlayerSessionList;
    }
    export interface DeleteAliasInput {
        AliasId: AliasId;
    }
    export interface DeleteBuildInput {
        BuildId: BuildId;
    }
    export interface DeleteFleetInput {
        FleetId: FleetId;
    }
    export interface DeleteScalingPolicyInput {
        Name: NonZeroAndMaxString;
        FleetId: FleetId;
    }
    export interface DescribeAliasInput {
        AliasId: AliasId;
    }
    export interface DescribeAliasOutput {
        Alias?: Alias;
    }
    export interface DescribeBuildInput {
        BuildId: BuildId;
    }
    export interface DescribeBuildOutput {
        Build?: Build;
    }
    export interface DescribeEC2InstanceLimitsInput {
        EC2InstanceType?: EC2InstanceType;
    }
    export interface DescribeEC2InstanceLimitsOutput {
        EC2InstanceLimits?: EC2InstanceLimitList;
    }
    export interface DescribeFleetAttributesInput {
        FleetIds?: FleetIdList;
        Limit?: PositiveInteger;
        NextToken?: NonZeroAndMaxString;
    }
    export interface DescribeFleetAttributesOutput {
        FleetAttributes?: FleetAttributesList;
        NextToken?: NonZeroAndMaxString;
    }
    export interface DescribeFleetCapacityInput {
        FleetIds?: FleetIdList;
        Limit?: PositiveInteger;
        NextToken?: NonZeroAndMaxString;
    }
    export interface DescribeFleetCapacityOutput {
        FleetCapacity?: FleetCapacityList;
        NextToken?: NonZeroAndMaxString;
    }
    export interface DescribeFleetEventsInput {
        FleetId: FleetId;
        StartTime?: Timestamp;
        EndTime?: Timestamp;
        Limit?: PositiveInteger;
        NextToken?: NonZeroAndMaxString;
    }
    export interface DescribeFleetEventsOutput {
        Events?: EventList;
        NextToken?: NonZeroAndMaxString;
    }
    export interface DescribeFleetPortSettingsInput {
        FleetId: FleetId;
    }
    export interface DescribeFleetPortSettingsOutput {
        InboundPermissions?: IpPermissionsList;
    }
    export interface DescribeFleetUtilizationInput {
        FleetIds?: FleetIdList;
        Limit?: PositiveInteger;
        NextToken?: NonZeroAndMaxString;
    }
    export interface DescribeFleetUtilizationOutput {
        FleetUtilization?: FleetUtilizationList;
        NextToken?: NonZeroAndMaxString;
    }
    export interface DescribeGameSessionDetailsInput {
        FleetId?: FleetId;
        GameSessionId?: GameSessionId;
        AliasId?: AliasId;
        StatusFilter?: NonZeroAndMaxString;
        Limit?: PositiveInteger;
        NextToken?: NonZeroAndMaxString;
    }
    export interface DescribeGameSessionDetailsOutput {
        GameSessionDetails?: GameSessionDetailList;
        NextToken?: NonZeroAndMaxString;
    }
    export interface DescribeGameSessionsInput {
        FleetId?: FleetId;
        GameSessionId?: GameSessionId;
        AliasId?: AliasId;
        StatusFilter?: NonZeroAndMaxString;
        Limit?: PositiveInteger;
        NextToken?: NonZeroAndMaxString;
    }
    export interface DescribeGameSessionsOutput {
        GameSessions?: GameSessionList;
        NextToken?: NonZeroAndMaxString;
    }
    export interface DescribePlayerSessionsInput {
        GameSessionId?: GameSessionId;
        PlayerId?: NonZeroAndMaxString;
        PlayerSessionId?: PlayerSessionId;
        PlayerSessionStatusFilter?: NonZeroAndMaxString;
        Limit?: PositiveInteger;
        NextToken?: NonZeroAndMaxString;
    }
    export interface DescribePlayerSessionsOutput {
        PlayerSessions?: PlayerSessionList;
        NextToken?: NonZeroAndMaxString;
    }
    export interface DescribeScalingPoliciesInput {
        FleetId: FleetId;
        StatusFilter?: ScalingStatusType;
        Limit?: PositiveInteger;
        NextToken?: NonZeroAndMaxString;
    }
    export interface DescribeScalingPoliciesOutput {
        ScalingPolicies?: ScalingPolicyList;
        NextToken?: NonZeroAndMaxString;
    }
    export interface EC2InstanceCounts {
        DESIRED?: WholeNumber;
        MINIMUM?: WholeNumber;
        MAXIMUM?: WholeNumber;
        PENDING?: WholeNumber;
        ACTIVE?: WholeNumber;
        IDLE?: WholeNumber;
        TERMINATING?: WholeNumber;
    }
    export interface EC2InstanceLimit {
        EC2InstanceType?: EC2InstanceType;
        CurrentInstances?: WholeNumber;
        InstanceLimit?: WholeNumber;
    }
    export interface Event {
        EventId?: NonZeroAndMaxString;
        ResourceId?: NonZeroAndMaxString;
        EventCode?: EventCode;
        Message?: NonEmptyString;
        EventTime?: Timestamp;
    }
    export interface FleetAttributes {
        FleetId?: FleetId;
        Description?: NonZeroAndMaxString;
        Name?: NonZeroAndMaxString;
        CreationTime?: Timestamp;
        TerminationTime?: Timestamp;
        Status?: FleetStatus;
        BuildId?: BuildId;
        ServerLaunchPath?: NonZeroAndMaxString;
        ServerLaunchParameters?: NonZeroAndMaxString;
        LogPaths?: StringList;
        NewGameSessionProtectionPolicy?: ProtectionPolicy;
    }
    export interface FleetCapacity {
        FleetId?: FleetId;
        InstanceType?: EC2InstanceType;
        InstanceCounts?: EC2InstanceCounts;
    }
    export interface FleetCapacityExceededException {
        Message?: NonEmptyString;
    }
    export interface FleetUtilization {
        FleetId?: FleetId;
        ActiveGameSessionCount?: WholeNumber;
        CurrentPlayerSessionCount?: WholeNumber;
        MaximumPlayerSessionCount?: WholeNumber;
    }
    export interface GameProperty {
        Key: GamePropertyKey;
        Value: GamePropertyValue;
    }
    export interface GameSession {
        GameSessionId?: GameSessionId;
        Name?: NonZeroAndMaxString;
        FleetId?: FleetId;
        CreationTime?: Timestamp;
        TerminationTime?: Timestamp;
        CurrentPlayerSessionCount?: WholeNumber;
        MaximumPlayerSessionCount?: WholeNumber;
        Status?: GameSessionStatus;
        GameProperties?: GamePropertyList;
        IpAddress?: IpAddress;
        PlayerSessionCreationPolicy?: PlayerSessionCreationPolicy;
    }
    export interface GameSessionDetail {
        GameSession?: GameSession;
        ProtectionPolicy?: ProtectionPolicy;
    }
    export interface GameSessionFullException {
        Message?: NonEmptyString;
    }
    export interface GetGameSessionLogUrlInput {
        GameSessionId: GameSessionId;
    }
    export interface GetGameSessionLogUrlOutput {
        PreSignedUrl?: NonZeroAndMaxString;
    }
    export interface InternalServiceException {
        Message?: NonEmptyString;
    }
    export interface InvalidFleetStatusException {
        Message?: NonEmptyString;
    }
    export interface InvalidGameSessionStatusException {
        Message?: NonEmptyString;
    }
    export interface InvalidRequestException {
        Message?: NonEmptyString;
    }
    export interface IpPermission {
        FromPort: PortNumber;
        ToPort: PortNumber;
        IpRange: NonBlankString;
        Protocol: IpProtocol;
    }
    export interface LimitExceededException {
        Message?: NonEmptyString;
    }
    export interface ListAliasesInput {
        RoutingStrategyType?: RoutingStrategyType;
        Name?: NonEmptyString;
        Limit?: PositiveInteger;
        NextToken?: NonEmptyString;
    }
    export interface ListAliasesOutput {
        Aliases?: AliasList;
        NextToken?: NonEmptyString;
    }
    export interface ListBuildsInput {
        Status?: BuildStatus;
        Limit?: PositiveInteger;
        NextToken?: NonEmptyString;
    }
    export interface ListBuildsOutput {
        Builds?: BuildList;
        NextToken?: NonEmptyString;
    }
    export interface ListFleetsInput {
        BuildId?: BuildId;
        Limit?: PositiveInteger;
        NextToken?: NonZeroAndMaxString;
    }
    export interface ListFleetsOutput {
        FleetIds?: FleetIdList;
        NextToken?: NonZeroAndMaxString;
    }
    export interface NotFoundException {
        Message?: NonEmptyString;
    }
    export interface PlayerSession {
        PlayerSessionId?: PlayerSessionId;
        PlayerId?: NonZeroAndMaxString;
        GameSessionId?: GameSessionId;
        FleetId?: FleetId;
        CreationTime?: Timestamp;
        TerminationTime?: Timestamp;
        Status?: PlayerSessionStatus;
        IpAddress?: IpAddress;
    }
    export interface PutScalingPolicyInput {
        Name: NonZeroAndMaxString;
        FleetId: FleetId;
        ScalingAdjustment: Integer;
        ScalingAdjustmentType: ScalingAdjustmentType;
        Threshold: Double;
        ComparisonOperator: ComparisonOperatorType;
        EvaluationPeriods: PositiveInteger;
        MetricName: MetricName;
    }
    export interface PutScalingPolicyOutput {
        Name?: NonZeroAndMaxString;
    }
    export interface RequestUploadCredentialsInput {
        BuildId: BuildId;
    }
    export interface RequestUploadCredentialsOutput {
        UploadCredentials?: AwsCredentials;
        StorageLocation?: S3Location;
    }
    export interface ResolveAliasInput {
        AliasId: AliasId;
    }
    export interface ResolveAliasOutput {
        FleetId?: FleetId;
    }
    export interface RoutingStrategy {
        Type?: RoutingStrategyType;
        FleetId?: FleetId;
        Message?: FreeText;
    }
    export interface S3Location {
        Bucket?: NonEmptyString;
        Key?: NonEmptyString;
        RoleArn?: NonEmptyString;
    }
    export interface ScalingPolicy {
        FleetId?: FleetId;
        Name?: NonZeroAndMaxString;
        Status?: ScalingStatusType;
        ScalingAdjustment?: Integer;
        ScalingAdjustmentType?: ScalingAdjustmentType;
        ComparisonOperator?: ComparisonOperatorType;
        Threshold?: Double;
        EvaluationPeriods?: PositiveInteger;
        MetricName?: MetricName;
    }
    export interface TerminalRoutingStrategyException {
        Message?: NonEmptyString;
    }
    export interface UnauthorizedException {
        Message?: NonEmptyString;
    }
    export interface UpdateAliasInput {
        AliasId: AliasId;
        Name?: NonZeroAndMaxString;
        Description?: NonZeroAndMaxString;
        RoutingStrategy?: RoutingStrategy;
    }
    export interface UpdateAliasOutput {
        Alias?: Alias;
    }
    export interface UpdateBuildInput {
        BuildId: BuildId;
        Name?: NonZeroAndMaxString;
        Version?: NonZeroAndMaxString;
    }
    export interface UpdateBuildOutput {
        Build?: Build;
    }
    export interface UpdateFleetAttributesInput {
        FleetId: FleetId;
        Name?: NonZeroAndMaxString;
        Description?: NonZeroAndMaxString;
        NewGameSessionProtectionPolicy?: ProtectionPolicy;
    }
    export interface UpdateFleetAttributesOutput {
        FleetId?: FleetId;
    }
    export interface UpdateFleetCapacityInput {
        FleetId: FleetId;
        DesiredInstances?: WholeNumber;
        MinSize?: WholeNumber;
        MaxSize?: WholeNumber;
    }
    export interface UpdateFleetCapacityOutput {
        FleetId?: FleetId;
    }
    export interface UpdateFleetPortSettingsInput {
        FleetId: FleetId;
        InboundPermissionAuthorizations?: IpPermissionsList;
        InboundPermissionRevocations?: IpPermissionsList;
    }
    export interface UpdateFleetPortSettingsOutput {
        FleetId?: FleetId;
    }
    export interface UpdateGameSessionInput {
        GameSessionId: GameSessionId;
        MaximumPlayerSessionCount?: WholeNumber;
        Name?: NonZeroAndMaxString;
        PlayerSessionCreationPolicy?: PlayerSessionCreationPolicy;
        ProtectionPolicy?: ProtectionPolicy;
    }
    export interface UpdateGameSessionOutput {
        GameSession?: GameSession;
    }
  }

  /*
   * apiVersion: 2012-06-01
   * endpointPrefix: glacier
   * serviceAbbreviation: 
   * signatureVersion: v4
   * protocol: rest-json
   */
  export class Glacier extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    abortMultipartUpload(params: Glacier.AbortMultipartUploadInput, callback?: (err: Glacier.ResourceNotFoundException|Glacier.InvalidParameterValueException|Glacier.MissingParameterValueException|Glacier.ServiceUnavailableException|any, data: any) => void): Request;
    abortVaultLock(params: Glacier.AbortVaultLockInput, callback?: (err: Glacier.ResourceNotFoundException|Glacier.InvalidParameterValueException|Glacier.MissingParameterValueException|Glacier.ServiceUnavailableException|any, data: any) => void): Request;
    addTagsToVault(params: Glacier.AddTagsToVaultInput, callback?: (err: Glacier.InvalidParameterValueException|Glacier.MissingParameterValueException|Glacier.ResourceNotFoundException|Glacier.LimitExceededException|Glacier.ServiceUnavailableException|any, data: any) => void): Request;
    completeMultipartUpload(params: Glacier.CompleteMultipartUploadInput, callback?: (err: Glacier.ResourceNotFoundException|Glacier.InvalidParameterValueException|Glacier.MissingParameterValueException|Glacier.ServiceUnavailableException|any, data: Glacier.ArchiveCreationOutput|any) => void): Request;
    completeVaultLock(params: Glacier.CompleteVaultLockInput, callback?: (err: Glacier.ResourceNotFoundException|Glacier.InvalidParameterValueException|Glacier.MissingParameterValueException|Glacier.ServiceUnavailableException|any, data: any) => void): Request;
    createVault(params: Glacier.CreateVaultInput, callback?: (err: Glacier.InvalidParameterValueException|Glacier.MissingParameterValueException|Glacier.ServiceUnavailableException|Glacier.LimitExceededException|any, data: Glacier.CreateVaultOutput|any) => void): Request;
    deleteArchive(params: Glacier.DeleteArchiveInput, callback?: (err: Glacier.ResourceNotFoundException|Glacier.InvalidParameterValueException|Glacier.MissingParameterValueException|Glacier.ServiceUnavailableException|any, data: any) => void): Request;
    deleteVault(params: Glacier.DeleteVaultInput, callback?: (err: Glacier.ResourceNotFoundException|Glacier.InvalidParameterValueException|Glacier.MissingParameterValueException|Glacier.ServiceUnavailableException|any, data: any) => void): Request;
    deleteVaultAccessPolicy(params: Glacier.DeleteVaultAccessPolicyInput, callback?: (err: Glacier.ResourceNotFoundException|Glacier.InvalidParameterValueException|Glacier.MissingParameterValueException|Glacier.ServiceUnavailableException|any, data: any) => void): Request;
    deleteVaultNotifications(params: Glacier.DeleteVaultNotificationsInput, callback?: (err: Glacier.ResourceNotFoundException|Glacier.InvalidParameterValueException|Glacier.MissingParameterValueException|Glacier.ServiceUnavailableException|any, data: any) => void): Request;
    describeJob(params: Glacier.DescribeJobInput, callback?: (err: Glacier.ResourceNotFoundException|Glacier.InvalidParameterValueException|Glacier.MissingParameterValueException|Glacier.ServiceUnavailableException|any, data: Glacier.GlacierJobDescription|any) => void): Request;
    describeVault(params: Glacier.DescribeVaultInput, callback?: (err: Glacier.ResourceNotFoundException|Glacier.InvalidParameterValueException|Glacier.MissingParameterValueException|Glacier.ServiceUnavailableException|any, data: Glacier.DescribeVaultOutput|any) => void): Request;
    getDataRetrievalPolicy(params: Glacier.GetDataRetrievalPolicyInput, callback?: (err: Glacier.InvalidParameterValueException|Glacier.MissingParameterValueException|Glacier.ServiceUnavailableException|any, data: Glacier.GetDataRetrievalPolicyOutput|any) => void): Request;
    getJobOutput(params: Glacier.GetJobOutputInput, callback?: (err: Glacier.ResourceNotFoundException|Glacier.InvalidParameterValueException|Glacier.MissingParameterValueException|Glacier.ServiceUnavailableException|any, data: Glacier.GetJobOutputOutput|any) => void): Request;
    getVaultAccessPolicy(params: Glacier.GetVaultAccessPolicyInput, callback?: (err: Glacier.ResourceNotFoundException|Glacier.InvalidParameterValueException|Glacier.MissingParameterValueException|Glacier.ServiceUnavailableException|any, data: Glacier.GetVaultAccessPolicyOutput|any) => void): Request;
    getVaultLock(params: Glacier.GetVaultLockInput, callback?: (err: Glacier.ResourceNotFoundException|Glacier.InvalidParameterValueException|Glacier.MissingParameterValueException|Glacier.ServiceUnavailableException|any, data: Glacier.GetVaultLockOutput|any) => void): Request;
    getVaultNotifications(params: Glacier.GetVaultNotificationsInput, callback?: (err: Glacier.ResourceNotFoundException|Glacier.InvalidParameterValueException|Glacier.MissingParameterValueException|Glacier.ServiceUnavailableException|any, data: Glacier.GetVaultNotificationsOutput|any) => void): Request;
    initiateJob(params: Glacier.InitiateJobInput, callback?: (err: Glacier.ResourceNotFoundException|Glacier.PolicyEnforcedException|Glacier.InvalidParameterValueException|Glacier.MissingParameterValueException|Glacier.ServiceUnavailableException|any, data: Glacier.InitiateJobOutput|any) => void): Request;
    initiateMultipartUpload(params: Glacier.InitiateMultipartUploadInput, callback?: (err: Glacier.ResourceNotFoundException|Glacier.InvalidParameterValueException|Glacier.MissingParameterValueException|Glacier.ServiceUnavailableException|any, data: Glacier.InitiateMultipartUploadOutput|any) => void): Request;
    initiateVaultLock(params: Glacier.InitiateVaultLockInput, callback?: (err: Glacier.ResourceNotFoundException|Glacier.InvalidParameterValueException|Glacier.MissingParameterValueException|Glacier.ServiceUnavailableException|any, data: Glacier.InitiateVaultLockOutput|any) => void): Request;
    listJobs(params: Glacier.ListJobsInput, callback?: (err: Glacier.ResourceNotFoundException|Glacier.InvalidParameterValueException|Glacier.MissingParameterValueException|Glacier.ServiceUnavailableException|any, data: Glacier.ListJobsOutput|any) => void): Request;
    listMultipartUploads(params: Glacier.ListMultipartUploadsInput, callback?: (err: Glacier.ResourceNotFoundException|Glacier.InvalidParameterValueException|Glacier.MissingParameterValueException|Glacier.ServiceUnavailableException|any, data: Glacier.ListMultipartUploadsOutput|any) => void): Request;
    listParts(params: Glacier.ListPartsInput, callback?: (err: Glacier.ResourceNotFoundException|Glacier.InvalidParameterValueException|Glacier.MissingParameterValueException|Glacier.ServiceUnavailableException|any, data: Glacier.ListPartsOutput|any) => void): Request;
    listTagsForVault(params: Glacier.ListTagsForVaultInput, callback?: (err: Glacier.InvalidParameterValueException|Glacier.MissingParameterValueException|Glacier.ResourceNotFoundException|Glacier.ServiceUnavailableException|any, data: Glacier.ListTagsForVaultOutput|any) => void): Request;
    listVaults(params: Glacier.ListVaultsInput, callback?: (err: Glacier.ResourceNotFoundException|Glacier.InvalidParameterValueException|Glacier.MissingParameterValueException|Glacier.ServiceUnavailableException|any, data: Glacier.ListVaultsOutput|any) => void): Request;
    removeTagsFromVault(params: Glacier.RemoveTagsFromVaultInput, callback?: (err: Glacier.InvalidParameterValueException|Glacier.MissingParameterValueException|Glacier.ResourceNotFoundException|Glacier.ServiceUnavailableException|any, data: any) => void): Request;
    setDataRetrievalPolicy(params: Glacier.SetDataRetrievalPolicyInput, callback?: (err: Glacier.InvalidParameterValueException|Glacier.MissingParameterValueException|Glacier.ServiceUnavailableException|any, data: any) => void): Request;
    setVaultAccessPolicy(params: Glacier.SetVaultAccessPolicyInput, callback?: (err: Glacier.ResourceNotFoundException|Glacier.InvalidParameterValueException|Glacier.MissingParameterValueException|Glacier.ServiceUnavailableException|any, data: any) => void): Request;
    setVaultNotifications(params: Glacier.SetVaultNotificationsInput, callback?: (err: Glacier.ResourceNotFoundException|Glacier.InvalidParameterValueException|Glacier.MissingParameterValueException|Glacier.ServiceUnavailableException|any, data: any) => void): Request;
    uploadArchive(params: Glacier.UploadArchiveInput, callback?: (err: Glacier.ResourceNotFoundException|Glacier.InvalidParameterValueException|Glacier.MissingParameterValueException|Glacier.RequestTimeoutException|Glacier.ServiceUnavailableException|any, data: Glacier.ArchiveCreationOutput|any) => void): Request;
    uploadMultipartPart(params: Glacier.UploadMultipartPartInput, callback?: (err: Glacier.ResourceNotFoundException|Glacier.InvalidParameterValueException|Glacier.MissingParameterValueException|Glacier.RequestTimeoutException|Glacier.ServiceUnavailableException|any, data: Glacier.UploadMultipartPartOutput|any) => void): Request;

    /***
     * Found on JS Sources - Sorry for the inconvenience :)
     * *
     * @!group Computing Checksums
     *
     * Computes the SHA-256 linear and tree hash checksums for a given
     * block of Buffer data. Pass the tree hash of the computed checksums
     * as the checksum input to the {completeMultipartUpload} when performing
     * a multi-part upload.
     *
     * @example Calculate checksum of 5.5MB data chunk
     *   var glacier = new AWS.Glacier();
     *   var data = new Buffer(5.5 * 1024 * 1024);
     *   data.fill('0'); // fill with zeros
     *   var results = glacier.computeChecksums(data);
     *   // Result: { linearHash: '68aff0c5a9...', treeHash: '154e26c78f...' }
     * @param data [Buffer, String] data to calculate the checksum for
     * @return [map<linearHash:String,treeHash:String>] a map containing
     *   the linearHash and treeHash properties representing hex based digests
     *   of the respective checksums.
     * @see completeMultipartUpload
   
     **/
    computeChecksums(...args: any[]): any
  }

  export module Glacier {
    export type ActionCode = string;
    export type DataRetrievalRulesList = DataRetrievalRule[];
    export type DateTime = string;
    export type JobList = GlacierJobDescription[];
    export type NotificationEventList = string[];
    export type NullableLong = number;
    export type PartList = PartListElement[];
    export type Size = number;
    export type StatusCode = string;
    export type Stream = any;    // type: blob
    export type TagKey = string;
    export type TagKeyList = string[];
    export type TagMap = {[key:string]: TagValue};
    export type TagValue = string;
    export type UploadsList = UploadListElement[];
    export type VaultList = DescribeVaultOutput[];
    export type httpstatus = number;
    export type long = number;

    export interface AbortMultipartUploadInput {
        accountId: string;
        vaultName: string;
        uploadId: string;
    }
    export interface AbortVaultLockInput {
        accountId: string;
        vaultName: string;
    }
    export interface AddTagsToVaultInput {
        accountId: string;
        vaultName: string;
        Tags?: TagMap;
    }
    export interface ArchiveCreationOutput {
        location?: string;
        checksum?: string;
        archiveId?: string;
    }
    export interface CompleteMultipartUploadInput {
        accountId: string;
        vaultName: string;
        uploadId: string;
        archiveSize?: string;
        checksum?: string;
    }
    export interface CompleteVaultLockInput {
        accountId: string;
        vaultName: string;
        lockId: string;
    }
    export interface CreateVaultInput {
        accountId: string;
        vaultName: string;
    }
    export interface CreateVaultOutput {
        location?: string;
    }
    export interface DataRetrievalPolicy {
        Rules?: DataRetrievalRulesList;
    }
    export interface DataRetrievalRule {
        Strategy?: string;
        BytesPerHour?: NullableLong;
    }
    export interface DeleteArchiveInput {
        accountId: string;
        vaultName: string;
        archiveId: string;
    }
    export interface DeleteVaultAccessPolicyInput {
        accountId: string;
        vaultName: string;
    }
    export interface DeleteVaultInput {
        accountId: string;
        vaultName: string;
    }
    export interface DeleteVaultNotificationsInput {
        accountId: string;
        vaultName: string;
    }
    export interface DescribeJobInput {
        accountId: string;
        vaultName: string;
        jobId: string;
    }
    export interface DescribeVaultInput {
        accountId: string;
        vaultName: string;
    }
    export interface DescribeVaultOutput {
        VaultARN?: string;
        VaultName?: string;
        CreationDate?: string;
        LastInventoryDate?: string;
        NumberOfArchives?: long;
        SizeInBytes?: long;
    }
    export interface GetDataRetrievalPolicyInput {
        accountId: string;
    }
    export interface GetDataRetrievalPolicyOutput {
        Policy?: DataRetrievalPolicy;
    }
    export interface GetJobOutputInput {
        accountId: string;
        vaultName: string;
        jobId: string;
        range?: string;
    }
    export interface GetJobOutputOutput {
        body?: Stream;
        checksum?: string;
        status?: httpstatus;
        contentRange?: string;
        acceptRanges?: string;
        contentType?: string;
        archiveDescription?: string;
    }
    export interface GetVaultAccessPolicyInput {
        accountId: string;
        vaultName: string;
    }
    export interface GetVaultAccessPolicyOutput {
        policy?: VaultAccessPolicy;
    }
    export interface GetVaultLockInput {
        accountId: string;
        vaultName: string;
    }
    export interface GetVaultLockOutput {
        Policy?: string;
        State?: string;
        ExpirationDate?: string;
        CreationDate?: string;
    }
    export interface GetVaultNotificationsInput {
        accountId: string;
        vaultName: string;
    }
    export interface GetVaultNotificationsOutput {
        vaultNotificationConfig?: VaultNotificationConfig;
    }
    export interface GlacierJobDescription {
        JobId?: string;
        JobDescription?: string;
        Action?: ActionCode;
        ArchiveId?: string;
        VaultARN?: string;
        CreationDate?: string;
        Completed?: boolean;
        StatusCode?: StatusCode;
        StatusMessage?: string;
        ArchiveSizeInBytes?: Size;
        InventorySizeInBytes?: Size;
        SNSTopic?: string;
        CompletionDate?: string;
        SHA256TreeHash?: string;
        ArchiveSHA256TreeHash?: string;
        RetrievalByteRange?: string;
        InventoryRetrievalParameters?: InventoryRetrievalJobDescription;
    }
    export interface InitiateJobInput {
        accountId: string;
        vaultName: string;
        jobParameters?: JobParameters;
    }
    export interface InitiateJobOutput {
        location?: string;
        jobId?: string;
    }
    export interface InitiateMultipartUploadInput {
        accountId: string;
        vaultName: string;
        archiveDescription?: string;
        partSize?: string;
    }
    export interface InitiateMultipartUploadOutput {
        location?: string;
        uploadId?: string;
    }
    export interface InitiateVaultLockInput {
        accountId: string;
        vaultName: string;
        policy?: VaultLockPolicy;
    }
    export interface InitiateVaultLockOutput {
        lockId?: string;
    }
    export interface InvalidParameterValueException {
        type?: string;
        code?: string;
        message?: string;
    }
    export interface InventoryRetrievalJobDescription {
        Format?: string;
        StartDate?: DateTime;
        EndDate?: DateTime;
        Limit?: string;
        Marker?: string;
    }
    export interface InventoryRetrievalJobInput {
        StartDate?: string;
        EndDate?: string;
        Limit?: string;
        Marker?: string;
    }
    export interface JobParameters {
        Format?: string;
        Type?: string;
        ArchiveId?: string;
        Description?: string;
        SNSTopic?: string;
        RetrievalByteRange?: string;
        InventoryRetrievalParameters?: InventoryRetrievalJobInput;
    }
    export interface LimitExceededException {
        type?: string;
        code?: string;
        message?: string;
    }
    export interface ListJobsInput {
        accountId: string;
        vaultName: string;
        limit?: string;
        marker?: string;
        statuscode?: string;
        completed?: string;
    }
    export interface ListJobsOutput {
        JobList?: JobList;
        Marker?: string;
    }
    export interface ListMultipartUploadsInput {
        accountId: string;
        vaultName: string;
        marker?: string;
        limit?: string;
    }
    export interface ListMultipartUploadsOutput {
        UploadsList?: UploadsList;
        Marker?: string;
    }
    export interface ListPartsInput {
        accountId: string;
        vaultName: string;
        uploadId: string;
        marker?: string;
        limit?: string;
    }
    export interface ListPartsOutput {
        MultipartUploadId?: string;
        VaultARN?: string;
        ArchiveDescription?: string;
        PartSizeInBytes?: long;
        CreationDate?: string;
        Parts?: PartList;
        Marker?: string;
    }
    export interface ListTagsForVaultInput {
        accountId: string;
        vaultName: string;
    }
    export interface ListTagsForVaultOutput {
        Tags?: TagMap;
    }
    export interface ListVaultsInput {
        accountId: string;
        marker?: string;
        limit?: string;
    }
    export interface ListVaultsOutput {
        VaultList?: VaultList;
        Marker?: string;
    }
    export interface MissingParameterValueException {
        type?: string;
        code?: string;
        message?: string;
    }
    export interface PartListElement {
        RangeInBytes?: string;
        SHA256TreeHash?: string;
    }
    export interface PolicyEnforcedException {
        type?: string;
        code?: string;
        message?: string;
    }
    export interface RemoveTagsFromVaultInput {
        accountId: string;
        vaultName: string;
        TagKeys?: TagKeyList;
    }
    export interface RequestTimeoutException {
        type?: string;
        code?: string;
        message?: string;
    }
    export interface ResourceNotFoundException {
        type?: string;
        code?: string;
        message?: string;
    }
    export interface ServiceUnavailableException {
        type?: string;
        code?: string;
        message?: string;
    }
    export interface SetDataRetrievalPolicyInput {
        accountId: string;
        Policy?: DataRetrievalPolicy;
    }
    export interface SetVaultAccessPolicyInput {
        accountId: string;
        vaultName: string;
        policy?: VaultAccessPolicy;
    }
    export interface SetVaultNotificationsInput {
        accountId: string;
        vaultName: string;
        vaultNotificationConfig?: VaultNotificationConfig;
    }
    export interface UploadArchiveInput {
        vaultName: string;
        accountId: string;
        archiveDescription?: string;
        checksum?: string;
        body?: Stream;
    }
    export interface UploadListElement {
        MultipartUploadId?: string;
        VaultARN?: string;
        ArchiveDescription?: string;
        PartSizeInBytes?: long;
        CreationDate?: string;
    }
    export interface UploadMultipartPartInput {
        accountId: string;
        vaultName: string;
        uploadId: string;
        checksum?: string;
        range?: string;
        body?: Stream;
    }
    export interface UploadMultipartPartOutput {
        checksum?: string;
    }
    export interface VaultAccessPolicy {
        Policy?: string;
    }
    export interface VaultLockPolicy {
        Policy?: string;
    }
    export interface VaultNotificationConfig {
        SNSTopic?: string;
        Events?: NotificationEventList;
    }
  }

  /*
   * apiVersion: 2010-05-08
   * endpointPrefix: iam
   * serviceAbbreviation: IAM
   * signatureVersion: v4
   * protocol: query
   */
  export class IAM extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    addClientIDToOpenIDConnectProvider(params: IAM.AddClientIDToOpenIDConnectProviderRequest, callback?: (err: IAM.InvalidInputException|IAM.NoSuchEntityException|IAM.LimitExceededException|IAM.ServiceFailureException|any, data: any) => void): Request;
    addRoleToInstanceProfile(params: IAM.AddRoleToInstanceProfileRequest, callback?: (err: IAM.NoSuchEntityException|IAM.EntityAlreadyExistsException|IAM.LimitExceededException|IAM.ServiceFailureException|any, data: any) => void): Request;
    addUserToGroup(params: IAM.AddUserToGroupRequest, callback?: (err: IAM.NoSuchEntityException|IAM.LimitExceededException|IAM.ServiceFailureException|any, data: any) => void): Request;
    attachGroupPolicy(params: IAM.AttachGroupPolicyRequest, callback?: (err: IAM.NoSuchEntityException|IAM.LimitExceededException|IAM.InvalidInputException|IAM.ServiceFailureException|any, data: any) => void): Request;
    attachRolePolicy(params: IAM.AttachRolePolicyRequest, callback?: (err: IAM.NoSuchEntityException|IAM.LimitExceededException|IAM.InvalidInputException|IAM.ServiceFailureException|any, data: any) => void): Request;
    attachUserPolicy(params: IAM.AttachUserPolicyRequest, callback?: (err: IAM.NoSuchEntityException|IAM.LimitExceededException|IAM.InvalidInputException|IAM.ServiceFailureException|any, data: any) => void): Request;
    changePassword(params: IAM.ChangePasswordRequest, callback?: (err: IAM.NoSuchEntityException|IAM.InvalidUserTypeException|IAM.LimitExceededException|IAM.EntityTemporarilyUnmodifiableException|IAM.PasswordPolicyViolationException|IAM.ServiceFailureException|any, data: any) => void): Request;
    createAccessKey(params: IAM.CreateAccessKeyRequest, callback?: (err: IAM.NoSuchEntityException|IAM.LimitExceededException|IAM.ServiceFailureException|any, data: IAM.CreateAccessKeyResponse|any) => void): Request;
    createAccountAlias(params: IAM.CreateAccountAliasRequest, callback?: (err: IAM.EntityAlreadyExistsException|IAM.LimitExceededException|IAM.ServiceFailureException|any, data: any) => void): Request;
    createGroup(params: IAM.CreateGroupRequest, callback?: (err: IAM.LimitExceededException|IAM.EntityAlreadyExistsException|IAM.NoSuchEntityException|IAM.ServiceFailureException|any, data: IAM.CreateGroupResponse|any) => void): Request;
    createInstanceProfile(params: IAM.CreateInstanceProfileRequest, callback?: (err: IAM.EntityAlreadyExistsException|IAM.LimitExceededException|IAM.ServiceFailureException|any, data: IAM.CreateInstanceProfileResponse|any) => void): Request;
    createLoginProfile(params: IAM.CreateLoginProfileRequest, callback?: (err: IAM.EntityAlreadyExistsException|IAM.NoSuchEntityException|IAM.PasswordPolicyViolationException|IAM.LimitExceededException|IAM.ServiceFailureException|any, data: IAM.CreateLoginProfileResponse|any) => void): Request;
    createOpenIDConnectProvider(params: IAM.CreateOpenIDConnectProviderRequest, callback?: (err: IAM.InvalidInputException|IAM.EntityAlreadyExistsException|IAM.LimitExceededException|IAM.ServiceFailureException|any, data: IAM.CreateOpenIDConnectProviderResponse|any) => void): Request;
    createPolicy(params: IAM.CreatePolicyRequest, callback?: (err: IAM.InvalidInputException|IAM.LimitExceededException|IAM.EntityAlreadyExistsException|IAM.MalformedPolicyDocumentException|IAM.ServiceFailureException|any, data: IAM.CreatePolicyResponse|any) => void): Request;
    createPolicyVersion(params: IAM.CreatePolicyVersionRequest, callback?: (err: IAM.NoSuchEntityException|IAM.MalformedPolicyDocumentException|IAM.InvalidInputException|IAM.LimitExceededException|IAM.ServiceFailureException|any, data: IAM.CreatePolicyVersionResponse|any) => void): Request;
    createRole(params: IAM.CreateRoleRequest, callback?: (err: IAM.LimitExceededException|IAM.EntityAlreadyExistsException|IAM.MalformedPolicyDocumentException|IAM.ServiceFailureException|any, data: IAM.CreateRoleResponse|any) => void): Request;
    createSAMLProvider(params: IAM.CreateSAMLProviderRequest, callback?: (err: IAM.InvalidInputException|IAM.EntityAlreadyExistsException|IAM.LimitExceededException|IAM.ServiceFailureException|any, data: IAM.CreateSAMLProviderResponse|any) => void): Request;
    createUser(params: IAM.CreateUserRequest, callback?: (err: IAM.LimitExceededException|IAM.EntityAlreadyExistsException|IAM.NoSuchEntityException|IAM.ServiceFailureException|any, data: IAM.CreateUserResponse|any) => void): Request;
    createVirtualMFADevice(params: IAM.CreateVirtualMFADeviceRequest, callback?: (err: IAM.LimitExceededException|IAM.EntityAlreadyExistsException|IAM.ServiceFailureException|any, data: IAM.CreateVirtualMFADeviceResponse|any) => void): Request;
    deactivateMFADevice(params: IAM.DeactivateMFADeviceRequest, callback?: (err: IAM.EntityTemporarilyUnmodifiableException|IAM.NoSuchEntityException|IAM.LimitExceededException|IAM.ServiceFailureException|any, data: any) => void): Request;
    deleteAccessKey(params: IAM.DeleteAccessKeyRequest, callback?: (err: IAM.NoSuchEntityException|IAM.LimitExceededException|IAM.ServiceFailureException|any, data: any) => void): Request;
    deleteAccountAlias(params: IAM.DeleteAccountAliasRequest, callback?: (err: IAM.NoSuchEntityException|IAM.LimitExceededException|IAM.ServiceFailureException|any, data: any) => void): Request;
    deleteAccountPasswordPolicy(callback?: (err: IAM.NoSuchEntityException|IAM.LimitExceededException|IAM.ServiceFailureException|any, data: any) => void): Request;
    deleteGroup(params: IAM.DeleteGroupRequest, callback?: (err: IAM.NoSuchEntityException|IAM.DeleteConflictException|IAM.LimitExceededException|IAM.ServiceFailureException|any, data: any) => void): Request;
    deleteGroupPolicy(params: IAM.DeleteGroupPolicyRequest, callback?: (err: IAM.NoSuchEntityException|IAM.LimitExceededException|IAM.ServiceFailureException|any, data: any) => void): Request;
    deleteInstanceProfile(params: IAM.DeleteInstanceProfileRequest, callback?: (err: IAM.NoSuchEntityException|IAM.DeleteConflictException|IAM.LimitExceededException|IAM.ServiceFailureException|any, data: any) => void): Request;
    deleteLoginProfile(params: IAM.DeleteLoginProfileRequest, callback?: (err: IAM.EntityTemporarilyUnmodifiableException|IAM.NoSuchEntityException|IAM.LimitExceededException|IAM.ServiceFailureException|any, data: any) => void): Request;
    deleteOpenIDConnectProvider(params: IAM.DeleteOpenIDConnectProviderRequest, callback?: (err: IAM.InvalidInputException|IAM.NoSuchEntityException|IAM.ServiceFailureException|any, data: any) => void): Request;
    deletePolicy(params: IAM.DeletePolicyRequest, callback?: (err: IAM.NoSuchEntityException|IAM.LimitExceededException|IAM.InvalidInputException|IAM.DeleteConflictException|IAM.ServiceFailureException|any, data: any) => void): Request;
    deletePolicyVersion(params: IAM.DeletePolicyVersionRequest, callback?: (err: IAM.NoSuchEntityException|IAM.LimitExceededException|IAM.InvalidInputException|IAM.DeleteConflictException|IAM.ServiceFailureException|any, data: any) => void): Request;
    deleteRole(params: IAM.DeleteRoleRequest, callback?: (err: IAM.NoSuchEntityException|IAM.DeleteConflictException|IAM.LimitExceededException|IAM.ServiceFailureException|any, data: any) => void): Request;
    deleteRolePolicy(params: IAM.DeleteRolePolicyRequest, callback?: (err: IAM.NoSuchEntityException|IAM.LimitExceededException|IAM.ServiceFailureException|any, data: any) => void): Request;
    deleteSAMLProvider(params: IAM.DeleteSAMLProviderRequest, callback?: (err: IAM.InvalidInputException|IAM.LimitExceededException|IAM.NoSuchEntityException|IAM.ServiceFailureException|any, data: any) => void): Request;
    deleteSSHPublicKey(params: IAM.DeleteSSHPublicKeyRequest, callback?: (err: IAM.NoSuchEntityException|any, data: any) => void): Request;
    deleteServerCertificate(params: IAM.DeleteServerCertificateRequest, callback?: (err: IAM.NoSuchEntityException|IAM.DeleteConflictException|IAM.LimitExceededException|IAM.ServiceFailureException|any, data: any) => void): Request;
    deleteSigningCertificate(params: IAM.DeleteSigningCertificateRequest, callback?: (err: IAM.NoSuchEntityException|IAM.LimitExceededException|IAM.ServiceFailureException|any, data: any) => void): Request;
    deleteUser(params: IAM.DeleteUserRequest, callback?: (err: IAM.LimitExceededException|IAM.NoSuchEntityException|IAM.DeleteConflictException|IAM.ServiceFailureException|any, data: any) => void): Request;
    deleteUserPolicy(params: IAM.DeleteUserPolicyRequest, callback?: (err: IAM.NoSuchEntityException|IAM.LimitExceededException|IAM.ServiceFailureException|any, data: any) => void): Request;
    deleteVirtualMFADevice(params: IAM.DeleteVirtualMFADeviceRequest, callback?: (err: IAM.NoSuchEntityException|IAM.DeleteConflictException|IAM.LimitExceededException|IAM.ServiceFailureException|any, data: any) => void): Request;
    detachGroupPolicy(params: IAM.DetachGroupPolicyRequest, callback?: (err: IAM.NoSuchEntityException|IAM.LimitExceededException|IAM.InvalidInputException|IAM.ServiceFailureException|any, data: any) => void): Request;
    detachRolePolicy(params: IAM.DetachRolePolicyRequest, callback?: (err: IAM.NoSuchEntityException|IAM.LimitExceededException|IAM.InvalidInputException|IAM.ServiceFailureException|any, data: any) => void): Request;
    detachUserPolicy(params: IAM.DetachUserPolicyRequest, callback?: (err: IAM.NoSuchEntityException|IAM.LimitExceededException|IAM.InvalidInputException|IAM.ServiceFailureException|any, data: any) => void): Request;
    enableMFADevice(params: IAM.EnableMFADeviceRequest, callback?: (err: IAM.EntityAlreadyExistsException|IAM.EntityTemporarilyUnmodifiableException|IAM.InvalidAuthenticationCodeException|IAM.LimitExceededException|IAM.NoSuchEntityException|IAM.ServiceFailureException|any, data: any) => void): Request;
    generateCredentialReport(callback?: (err: IAM.LimitExceededException|IAM.ServiceFailureException|any, data: IAM.GenerateCredentialReportResponse|any) => void): Request;
    getAccessKeyLastUsed(params: IAM.GetAccessKeyLastUsedRequest, callback?: (err: IAM.NoSuchEntityException|any, data: IAM.GetAccessKeyLastUsedResponse|any) => void): Request;
    getAccountAuthorizationDetails(params: IAM.GetAccountAuthorizationDetailsRequest, callback?: (err: IAM.ServiceFailureException|any, data: IAM.GetAccountAuthorizationDetailsResponse|any) => void): Request;
    getAccountPasswordPolicy(callback?: (err: IAM.NoSuchEntityException|IAM.ServiceFailureException|any, data: IAM.GetAccountPasswordPolicyResponse|any) => void): Request;
    getAccountSummary(callback?: (err: IAM.ServiceFailureException|any, data: IAM.GetAccountSummaryResponse|any) => void): Request;
    getContextKeysForCustomPolicy(params: IAM.GetContextKeysForCustomPolicyRequest, callback?: (err: IAM.InvalidInputException|any, data: IAM.GetContextKeysForPolicyResponse|any) => void): Request;
    getContextKeysForPrincipalPolicy(params: IAM.GetContextKeysForPrincipalPolicyRequest, callback?: (err: IAM.NoSuchEntityException|IAM.InvalidInputException|any, data: IAM.GetContextKeysForPolicyResponse|any) => void): Request;
    getCredentialReport(callback?: (err: IAM.CredentialReportNotPresentException|IAM.CredentialReportExpiredException|IAM.CredentialReportNotReadyException|IAM.ServiceFailureException|any, data: IAM.GetCredentialReportResponse|any) => void): Request;
    getGroup(params: IAM.GetGroupRequest, callback?: (err: IAM.NoSuchEntityException|IAM.ServiceFailureException|any, data: IAM.GetGroupResponse|any) => void): Request;
    getGroupPolicy(params: IAM.GetGroupPolicyRequest, callback?: (err: IAM.NoSuchEntityException|IAM.ServiceFailureException|any, data: IAM.GetGroupPolicyResponse|any) => void): Request;
    getInstanceProfile(params: IAM.GetInstanceProfileRequest, callback?: (err: IAM.NoSuchEntityException|IAM.ServiceFailureException|any, data: IAM.GetInstanceProfileResponse|any) => void): Request;
    getLoginProfile(params: IAM.GetLoginProfileRequest, callback?: (err: IAM.NoSuchEntityException|IAM.ServiceFailureException|any, data: IAM.GetLoginProfileResponse|any) => void): Request;
    getOpenIDConnectProvider(params: IAM.GetOpenIDConnectProviderRequest, callback?: (err: IAM.InvalidInputException|IAM.NoSuchEntityException|IAM.ServiceFailureException|any, data: IAM.GetOpenIDConnectProviderResponse|any) => void): Request;
    getPolicy(params: IAM.GetPolicyRequest, callback?: (err: IAM.NoSuchEntityException|IAM.InvalidInputException|IAM.ServiceFailureException|any, data: IAM.GetPolicyResponse|any) => void): Request;
    getPolicyVersion(params: IAM.GetPolicyVersionRequest, callback?: (err: IAM.NoSuchEntityException|IAM.InvalidInputException|IAM.ServiceFailureException|any, data: IAM.GetPolicyVersionResponse|any) => void): Request;
    getRole(params: IAM.GetRoleRequest, callback?: (err: IAM.NoSuchEntityException|IAM.ServiceFailureException|any, data: IAM.GetRoleResponse|any) => void): Request;
    getRolePolicy(params: IAM.GetRolePolicyRequest, callback?: (err: IAM.NoSuchEntityException|IAM.ServiceFailureException|any, data: IAM.GetRolePolicyResponse|any) => void): Request;
    getSAMLProvider(params: IAM.GetSAMLProviderRequest, callback?: (err: IAM.NoSuchEntityException|IAM.InvalidInputException|IAM.ServiceFailureException|any, data: IAM.GetSAMLProviderResponse|any) => void): Request;
    getSSHPublicKey(params: IAM.GetSSHPublicKeyRequest, callback?: (err: IAM.NoSuchEntityException|IAM.UnrecognizedPublicKeyEncodingException|any, data: IAM.GetSSHPublicKeyResponse|any) => void): Request;
    getServerCertificate(params: IAM.GetServerCertificateRequest, callback?: (err: IAM.NoSuchEntityException|IAM.ServiceFailureException|any, data: IAM.GetServerCertificateResponse|any) => void): Request;
    getUser(params: IAM.GetUserRequest, callback?: (err: IAM.NoSuchEntityException|IAM.ServiceFailureException|any, data: IAM.GetUserResponse|any) => void): Request;
    getUserPolicy(params: IAM.GetUserPolicyRequest, callback?: (err: IAM.NoSuchEntityException|IAM.ServiceFailureException|any, data: IAM.GetUserPolicyResponse|any) => void): Request;
    listAccessKeys(params: IAM.ListAccessKeysRequest, callback?: (err: IAM.NoSuchEntityException|IAM.ServiceFailureException|any, data: IAM.ListAccessKeysResponse|any) => void): Request;
    listAccountAliases(params: IAM.ListAccountAliasesRequest, callback?: (err: IAM.ServiceFailureException|any, data: IAM.ListAccountAliasesResponse|any) => void): Request;
    listAttachedGroupPolicies(params: IAM.ListAttachedGroupPoliciesRequest, callback?: (err: IAM.NoSuchEntityException|IAM.InvalidInputException|IAM.ServiceFailureException|any, data: IAM.ListAttachedGroupPoliciesResponse|any) => void): Request;
    listAttachedRolePolicies(params: IAM.ListAttachedRolePoliciesRequest, callback?: (err: IAM.NoSuchEntityException|IAM.InvalidInputException|IAM.ServiceFailureException|any, data: IAM.ListAttachedRolePoliciesResponse|any) => void): Request;
    listAttachedUserPolicies(params: IAM.ListAttachedUserPoliciesRequest, callback?: (err: IAM.NoSuchEntityException|IAM.InvalidInputException|IAM.ServiceFailureException|any, data: IAM.ListAttachedUserPoliciesResponse|any) => void): Request;
    listEntitiesForPolicy(params: IAM.ListEntitiesForPolicyRequest, callback?: (err: IAM.NoSuchEntityException|IAM.InvalidInputException|IAM.ServiceFailureException|any, data: IAM.ListEntitiesForPolicyResponse|any) => void): Request;
    listGroupPolicies(params: IAM.ListGroupPoliciesRequest, callback?: (err: IAM.NoSuchEntityException|IAM.ServiceFailureException|any, data: IAM.ListGroupPoliciesResponse|any) => void): Request;
    listGroups(params: IAM.ListGroupsRequest, callback?: (err: IAM.ServiceFailureException|any, data: IAM.ListGroupsResponse|any) => void): Request;
    listGroupsForUser(params: IAM.ListGroupsForUserRequest, callback?: (err: IAM.NoSuchEntityException|IAM.ServiceFailureException|any, data: IAM.ListGroupsForUserResponse|any) => void): Request;
    listInstanceProfiles(params: IAM.ListInstanceProfilesRequest, callback?: (err: IAM.ServiceFailureException|any, data: IAM.ListInstanceProfilesResponse|any) => void): Request;
    listInstanceProfilesForRole(params: IAM.ListInstanceProfilesForRoleRequest, callback?: (err: IAM.NoSuchEntityException|IAM.ServiceFailureException|any, data: IAM.ListInstanceProfilesForRoleResponse|any) => void): Request;
    listMFADevices(params: IAM.ListMFADevicesRequest, callback?: (err: IAM.NoSuchEntityException|IAM.ServiceFailureException|any, data: IAM.ListMFADevicesResponse|any) => void): Request;
    listOpenIDConnectProviders(params: IAM.ListOpenIDConnectProvidersRequest, callback?: (err: IAM.ServiceFailureException|any, data: IAM.ListOpenIDConnectProvidersResponse|any) => void): Request;
    listPolicies(params: IAM.ListPoliciesRequest, callback?: (err: IAM.ServiceFailureException|any, data: IAM.ListPoliciesResponse|any) => void): Request;
    listPolicyVersions(params: IAM.ListPolicyVersionsRequest, callback?: (err: IAM.NoSuchEntityException|IAM.InvalidInputException|IAM.ServiceFailureException|any, data: IAM.ListPolicyVersionsResponse|any) => void): Request;
    listRolePolicies(params: IAM.ListRolePoliciesRequest, callback?: (err: IAM.NoSuchEntityException|IAM.ServiceFailureException|any, data: IAM.ListRolePoliciesResponse|any) => void): Request;
    listRoles(params: IAM.ListRolesRequest, callback?: (err: IAM.ServiceFailureException|any, data: IAM.ListRolesResponse|any) => void): Request;
    listSAMLProviders(params: IAM.ListSAMLProvidersRequest, callback?: (err: IAM.ServiceFailureException|any, data: IAM.ListSAMLProvidersResponse|any) => void): Request;
    listSSHPublicKeys(params: IAM.ListSSHPublicKeysRequest, callback?: (err: IAM.NoSuchEntityException|any, data: IAM.ListSSHPublicKeysResponse|any) => void): Request;
    listServerCertificates(params: IAM.ListServerCertificatesRequest, callback?: (err: IAM.ServiceFailureException|any, data: IAM.ListServerCertificatesResponse|any) => void): Request;
    listSigningCertificates(params: IAM.ListSigningCertificatesRequest, callback?: (err: IAM.NoSuchEntityException|IAM.ServiceFailureException|any, data: IAM.ListSigningCertificatesResponse|any) => void): Request;
    listUserPolicies(params: IAM.ListUserPoliciesRequest, callback?: (err: IAM.NoSuchEntityException|IAM.ServiceFailureException|any, data: IAM.ListUserPoliciesResponse|any) => void): Request;
    listUsers(params: IAM.ListUsersRequest, callback?: (err: IAM.ServiceFailureException|any, data: IAM.ListUsersResponse|any) => void): Request;
    listVirtualMFADevices(params: IAM.ListVirtualMFADevicesRequest, callback?: (err: any, data: IAM.ListVirtualMFADevicesResponse|any) => void): Request;
    putGroupPolicy(params: IAM.PutGroupPolicyRequest, callback?: (err: IAM.LimitExceededException|IAM.MalformedPolicyDocumentException|IAM.NoSuchEntityException|IAM.ServiceFailureException|any, data: any) => void): Request;
    putRolePolicy(params: IAM.PutRolePolicyRequest, callback?: (err: IAM.LimitExceededException|IAM.MalformedPolicyDocumentException|IAM.NoSuchEntityException|IAM.ServiceFailureException|any, data: any) => void): Request;
    putUserPolicy(params: IAM.PutUserPolicyRequest, callback?: (err: IAM.LimitExceededException|IAM.MalformedPolicyDocumentException|IAM.NoSuchEntityException|IAM.ServiceFailureException|any, data: any) => void): Request;
    removeClientIDFromOpenIDConnectProvider(params: IAM.RemoveClientIDFromOpenIDConnectProviderRequest, callback?: (err: IAM.InvalidInputException|IAM.NoSuchEntityException|IAM.ServiceFailureException|any, data: any) => void): Request;
    removeRoleFromInstanceProfile(params: IAM.RemoveRoleFromInstanceProfileRequest, callback?: (err: IAM.NoSuchEntityException|IAM.LimitExceededException|IAM.ServiceFailureException|any, data: any) => void): Request;
    removeUserFromGroup(params: IAM.RemoveUserFromGroupRequest, callback?: (err: IAM.NoSuchEntityException|IAM.LimitExceededException|IAM.ServiceFailureException|any, data: any) => void): Request;
    resyncMFADevice(params: IAM.ResyncMFADeviceRequest, callback?: (err: IAM.InvalidAuthenticationCodeException|IAM.NoSuchEntityException|IAM.LimitExceededException|IAM.ServiceFailureException|any, data: any) => void): Request;
    setDefaultPolicyVersion(params: IAM.SetDefaultPolicyVersionRequest, callback?: (err: IAM.NoSuchEntityException|IAM.InvalidInputException|IAM.LimitExceededException|IAM.ServiceFailureException|any, data: any) => void): Request;
    simulateCustomPolicy(params: IAM.SimulateCustomPolicyRequest, callback?: (err: IAM.InvalidInputException|IAM.PolicyEvaluationException|any, data: IAM.SimulatePolicyResponse|any) => void): Request;
    simulatePrincipalPolicy(params: IAM.SimulatePrincipalPolicyRequest, callback?: (err: IAM.NoSuchEntityException|IAM.InvalidInputException|IAM.PolicyEvaluationException|any, data: IAM.SimulatePolicyResponse|any) => void): Request;
    updateAccessKey(params: IAM.UpdateAccessKeyRequest, callback?: (err: IAM.NoSuchEntityException|IAM.LimitExceededException|IAM.ServiceFailureException|any, data: any) => void): Request;
    updateAccountPasswordPolicy(params: IAM.UpdateAccountPasswordPolicyRequest, callback?: (err: IAM.NoSuchEntityException|IAM.MalformedPolicyDocumentException|IAM.LimitExceededException|IAM.ServiceFailureException|any, data: any) => void): Request;
    updateAssumeRolePolicy(params: IAM.UpdateAssumeRolePolicyRequest, callback?: (err: IAM.NoSuchEntityException|IAM.MalformedPolicyDocumentException|IAM.LimitExceededException|IAM.ServiceFailureException|any, data: any) => void): Request;
    updateGroup(params: IAM.UpdateGroupRequest, callback?: (err: IAM.NoSuchEntityException|IAM.EntityAlreadyExistsException|IAM.LimitExceededException|IAM.ServiceFailureException|any, data: any) => void): Request;
    updateLoginProfile(params: IAM.UpdateLoginProfileRequest, callback?: (err: IAM.EntityTemporarilyUnmodifiableException|IAM.NoSuchEntityException|IAM.PasswordPolicyViolationException|IAM.LimitExceededException|IAM.ServiceFailureException|any, data: any) => void): Request;
    updateOpenIDConnectProviderThumbprint(params: IAM.UpdateOpenIDConnectProviderThumbprintRequest, callback?: (err: IAM.InvalidInputException|IAM.NoSuchEntityException|IAM.ServiceFailureException|any, data: any) => void): Request;
    updateSAMLProvider(params: IAM.UpdateSAMLProviderRequest, callback?: (err: IAM.NoSuchEntityException|IAM.InvalidInputException|IAM.LimitExceededException|IAM.ServiceFailureException|any, data: IAM.UpdateSAMLProviderResponse|any) => void): Request;
    updateSSHPublicKey(params: IAM.UpdateSSHPublicKeyRequest, callback?: (err: IAM.NoSuchEntityException|any, data: any) => void): Request;
    updateServerCertificate(params: IAM.UpdateServerCertificateRequest, callback?: (err: IAM.NoSuchEntityException|IAM.EntityAlreadyExistsException|IAM.LimitExceededException|IAM.ServiceFailureException|any, data: any) => void): Request;
    updateSigningCertificate(params: IAM.UpdateSigningCertificateRequest, callback?: (err: IAM.NoSuchEntityException|IAM.LimitExceededException|IAM.ServiceFailureException|any, data: any) => void): Request;
    updateUser(params: IAM.UpdateUserRequest, callback?: (err: IAM.NoSuchEntityException|IAM.LimitExceededException|IAM.EntityAlreadyExistsException|IAM.EntityTemporarilyUnmodifiableException|IAM.ServiceFailureException|any, data: any) => void): Request;
    uploadSSHPublicKey(params: IAM.UploadSSHPublicKeyRequest, callback?: (err: IAM.LimitExceededException|IAM.NoSuchEntityException|IAM.InvalidPublicKeyException|IAM.DuplicateSSHPublicKeyException|IAM.UnrecognizedPublicKeyEncodingException|any, data: IAM.UploadSSHPublicKeyResponse|any) => void): Request;
    uploadServerCertificate(params: IAM.UploadServerCertificateRequest, callback?: (err: IAM.LimitExceededException|IAM.EntityAlreadyExistsException|IAM.MalformedCertificateException|IAM.KeyPairMismatchException|IAM.ServiceFailureException|any, data: IAM.UploadServerCertificateResponse|any) => void): Request;
    uploadSigningCertificate(params: IAM.UploadSigningCertificateRequest, callback?: (err: IAM.LimitExceededException|IAM.EntityAlreadyExistsException|IAM.MalformedCertificateException|IAM.InvalidCertificateException|IAM.DuplicateCertificateException|IAM.NoSuchEntityException|IAM.ServiceFailureException|any, data: IAM.UploadSigningCertificateResponse|any) => void): Request;

  }

  export module IAM {
    export type ActionNameListType = ActionNameType[];
    export type ActionNameType = string;    // max: 128, min: 3
    export type BootstrapDatum = any;    // type: blob
    export type ColumnNumber = number;
    export type ContextEntryListType = ContextEntry[];
    export type ContextKeyNameType = string;    // max: 256, min: 5
    export type ContextKeyNamesResultListType = ContextKeyNameType[];
    export type ContextKeyTypeEnum = string;
    export type ContextKeyValueListType = ContextKeyValueType[];
    export type ContextKeyValueType = string;
    export type EntityType = string;
    export type EvalDecisionDetailsType = {[key:string]: PolicyEvaluationDecisionType};
    export type EvalDecisionSourceType = string;    // max: 256, min: 3
    export type EvaluationResultsListType = EvaluationResult[];
    export type LineNumber = number;
    export type ManagedPolicyDetailListType = ManagedPolicyDetail[];
    export type OpenIDConnectProviderListType = OpenIDConnectProviderListEntry[];
    export type OpenIDConnectProviderUrlType = string;    // max: 255, min: 1
    export type PolicyEvaluationDecisionType = string;
    export type PolicyGroupListType = PolicyGroup[];
    export type PolicyIdentifierType = string;
    export type PolicyRoleListType = PolicyRole[];
    export type PolicySourceType = string;
    export type PolicyUserListType = PolicyUser[];
    export type ReportContentType = any;    // type: blob
    export type ReportFormatType = string;
    export type ReportStateDescriptionType = string;
    export type ReportStateType = string;
    export type ResourceHandlingOptionType = string;    // max: 64, min: 1
    export type ResourceNameListType = ResourceNameType[];
    export type ResourceNameType = string;    // max: 2048, min: 1
    export type ResourceSpecificResultListType = ResourceSpecificResult[];
    export type SAMLMetadataDocumentType = string;    // max: 10000000, min: 1000
    export type SAMLProviderListType = SAMLProviderListEntry[];
    export type SAMLProviderNameType = string;    // pattern: &quot;[\w._-]+&quot;, max: 128, min: 1
    export type SSHPublicKeyListType = SSHPublicKeyMetadata[];
    export type SimulationPolicyListType = policyDocumentType[];
    export type StatementListType = Statement[];
    export type accessKeyIdType = string;    // pattern: &quot;[\w]+&quot;, max: 32, min: 16
    export type accessKeyMetadataListType = AccessKeyMetadata[];
    export type accessKeySecretType = string;
    export type accountAliasListType = accountAliasType[];
    export type accountAliasType = string;    // pattern: &quot;^[a-z0-9](([a-z0-9]|-(?!-))*[a-z0-9])?$&quot;, max: 63, min: 3
    export type arnType = string;    // max: 2048, min: 20
    export type assignmentStatusType = string;
    export type attachedPoliciesListType = AttachedPolicy[];
    export type attachmentCountType = number;
    export type authenticationCodeType = string;    // pattern: &quot;[\d]+&quot;, max: 6, min: 6
    export type booleanObjectType = boolean;
    export type booleanType = boolean;
    export type certificateBodyType = string;    // pattern: &quot;[\u0009\u000A\u000D\u0020-\u00FF]+&quot;, max: 16384, min: 1
    export type certificateChainType = string;    // pattern: &quot;[\u0009\u000A\u000D\u0020-\u00FF]+&quot;, max: 2097152, min: 1
    export type certificateIdType = string;    // pattern: &quot;[\w]+&quot;, max: 128, min: 24
    export type certificateListType = SigningCertificate[];
    export type clientIDListType = clientIDType[];
    export type clientIDType = string;    // max: 255, min: 1
    export type credentialReportExpiredExceptionMessage = string;
    export type credentialReportNotPresentExceptionMessage = string;
    export type credentialReportNotReadyExceptionMessage = string;
    export type dateType = number;
    export type deleteConflictMessage = string;
    export type duplicateCertificateMessage = string;
    export type duplicateSSHPublicKeyMessage = string;
    export type encodingType = string;
    export type entityAlreadyExistsMessage = string;
    export type entityListType = EntityType[];
    export type entityTemporarilyUnmodifiableMessage = string;
    export type existingUserNameType = string;    // pattern: &quot;[\w+=,.@-]+&quot;, max: 128, min: 1
    export type groupDetailListType = GroupDetail[];
    export type groupListType = Group[];
    export type groupNameListType = groupNameType[];
    export type groupNameType = string;    // pattern: &quot;[\w+=,.@-]+&quot;, max: 128, min: 1
    export type idType = string;    // pattern: &quot;[\w]+&quot;, max: 32, min: 16
    export type instanceProfileListType = InstanceProfile[];
    export type instanceProfileNameType = string;    // pattern: &quot;[\w+=,.@-]+&quot;, max: 128, min: 1
    export type invalidAuthenticationCodeMessage = string;
    export type invalidCertificateMessage = string;
    export type invalidInputMessage = string;
    export type invalidPublicKeyMessage = string;
    export type invalidUserTypeMessage = string;
    export type keyPairMismatchMessage = string;
    export type limitExceededMessage = string;
    export type malformedCertificateMessage = string;
    export type malformedPolicyDocumentMessage = string;
    export type markerType = string;    // pattern: &quot;[\u0020-\u00FF]+&quot;, max: 320, min: 1
    export type maxItemsType = number;    // max: 1000, min: 1
    export type maxPasswordAgeType = number;    // max: 1095, min: 1
    export type mfaDeviceListType = MFADevice[];
    export type minimumPasswordLengthType = number;    // max: 128, min: 6
    export type noSuchEntityMessage = string;
    export type passwordPolicyViolationMessage = string;
    export type passwordReusePreventionType = number;    // max: 24, min: 1
    export type passwordType = string;    // pattern: &quot;[\u0009\u000A\u000D\u0020-\u00FF]+&quot;, max: 128, min: 1
    export type pathPrefixType = string;    // pattern: &quot;\u002F[\u0021-\u007F]*&quot;, max: 512, min: 1
    export type pathType = string;    // pattern: &quot;(\u002F)|(\u002F[\u0021-\u007F]+\u002F)&quot;, max: 512, min: 1
    export type policyDescriptionType = string;    // max: 1000
    export type policyDetailListType = PolicyDetail[];
    export type policyDocumentType = string;    // pattern: &quot;[\u0009\u000A\u000D\u0020-\u00FF]+&quot;, max: 131072, min: 1
    export type policyDocumentVersionListType = PolicyVersion[];
    export type policyEvaluationErrorMessage = string;
    export type policyListType = Policy[];
    export type policyNameListType = policyNameType[];
    export type policyNameType = string;    // pattern: &quot;[\w+=,.@-]+&quot;, max: 128, min: 1
    export type policyPathType = string;    // pattern: &quot;((/[A-Za-z0-9\.,\+@=_-]+)*)/&quot;
    export type policyScopeType = string;
    export type policyVersionIdType = string;    // pattern: &quot;v[1-9][0-9]*(\.[A-Za-z0-9-]*)?&quot;
    export type privateKeyType = string;    // pattern: &quot;[\u0009\u000A\u000D\u0020-\u00FF]+&quot;, max: 16384, min: 1
    export type publicKeyFingerprintType = string;    // pattern: &quot;[:\w]+&quot;, max: 48, min: 48
    export type publicKeyIdType = string;    // pattern: &quot;[\w]+&quot;, max: 128, min: 20
    export type publicKeyMaterialType = string;    // pattern: &quot;[\u0009\u000A\u000D\u0020-\u00FF]+&quot;, max: 16384, min: 1
    export type roleDetailListType = RoleDetail[];
    export type roleListType = Role[];
    export type roleNameType = string;    // pattern: &quot;[\w+=,.@-]+&quot;, max: 64, min: 1
    export type serialNumberType = string;    // pattern: &quot;[\w+=/:,.@-]+&quot;, max: 256, min: 9
    export type serverCertificateMetadataListType = ServerCertificateMetadata[];
    export type serverCertificateNameType = string;    // pattern: &quot;[\w+=,.@-]+&quot;, max: 128, min: 1
    export type serviceFailureExceptionMessage = string;
    export type statusType = string;
    export type stringType = string;
    export type summaryKeyType = string;
    export type summaryMapType = {[key:string]: summaryValueType};
    export type summaryValueType = number;
    export type thumbprintListType = thumbprintType[];
    export type thumbprintType = string;    // max: 40, min: 40
    export type unrecognizedPublicKeyEncodingMessage = string;
    export type userDetailListType = UserDetail[];
    export type userListType = User[];
    export type userNameType = string;    // pattern: &quot;[\w+=,.@-]+&quot;, max: 64, min: 1
    export type virtualMFADeviceListType = VirtualMFADevice[];
    export type virtualMFADeviceName = string;    // pattern: &quot;[\w+=,.@-]+&quot;, min: 1

    export interface AccessKey {
        UserName: userNameType;
        AccessKeyId: accessKeyIdType;
        Status: statusType;
        SecretAccessKey: accessKeySecretType;
        CreateDate?: dateType;
    }
    export interface AccessKeyLastUsed {
        LastUsedDate: dateType;
        ServiceName: stringType;
        Region: stringType;
    }
    export interface AccessKeyMetadata {
        UserName?: userNameType;
        AccessKeyId?: accessKeyIdType;
        Status?: statusType;
        CreateDate?: dateType;
    }
    export interface AddClientIDToOpenIDConnectProviderRequest {
        OpenIDConnectProviderArn: arnType;
        ClientID: clientIDType;
    }
    export interface AddRoleToInstanceProfileRequest {
        InstanceProfileName: instanceProfileNameType;
        RoleName: roleNameType;
    }
    export interface AddUserToGroupRequest {
        GroupName: groupNameType;
        UserName: existingUserNameType;
    }
    export interface AttachGroupPolicyRequest {
        GroupName: groupNameType;
        PolicyArn: arnType;
    }
    export interface AttachRolePolicyRequest {
        RoleName: roleNameType;
        PolicyArn: arnType;
    }
    export interface AttachUserPolicyRequest {
        UserName: userNameType;
        PolicyArn: arnType;
    }
    export interface AttachedPolicy {
        PolicyName?: policyNameType;
        PolicyArn?: arnType;
    }
    export interface ChangePasswordRequest {
        OldPassword: passwordType;
        NewPassword: passwordType;
    }
    export interface ContextEntry {
        ContextKeyName?: ContextKeyNameType;
        ContextKeyValues?: ContextKeyValueListType;
        ContextKeyType?: ContextKeyTypeEnum;
    }
    export interface CreateAccessKeyRequest {
        UserName?: existingUserNameType;
    }
    export interface CreateAccessKeyResponse {
        AccessKey: AccessKey;
    }
    export interface CreateAccountAliasRequest {
        AccountAlias: accountAliasType;
    }
    export interface CreateGroupRequest {
        Path?: pathType;
        GroupName: groupNameType;
    }
    export interface CreateGroupResponse {
        Group: Group;
    }
    export interface CreateInstanceProfileRequest {
        InstanceProfileName: instanceProfileNameType;
        Path?: pathType;
    }
    export interface CreateInstanceProfileResponse {
        InstanceProfile: InstanceProfile;
    }
    export interface CreateLoginProfileRequest {
        UserName: userNameType;
        Password: passwordType;
        PasswordResetRequired?: booleanType;
    }
    export interface CreateLoginProfileResponse {
        LoginProfile: LoginProfile;
    }
    export interface CreateOpenIDConnectProviderRequest {
        Url: OpenIDConnectProviderUrlType;
        ClientIDList?: clientIDListType;
        ThumbprintList: thumbprintListType;
    }
    export interface CreateOpenIDConnectProviderResponse {
        OpenIDConnectProviderArn?: arnType;
    }
    export interface CreatePolicyRequest {
        PolicyName: policyNameType;
        Path?: policyPathType;
        PolicyDocument: policyDocumentType;
        Description?: policyDescriptionType;
    }
    export interface CreatePolicyResponse {
        Policy?: Policy;
    }
    export interface CreatePolicyVersionRequest {
        PolicyArn: arnType;
        PolicyDocument: policyDocumentType;
        SetAsDefault?: booleanType;
    }
    export interface CreatePolicyVersionResponse {
        PolicyVersion?: PolicyVersion;
    }
    export interface CreateRoleRequest {
        Path?: pathType;
        RoleName: roleNameType;
        AssumeRolePolicyDocument: policyDocumentType;
    }
    export interface CreateRoleResponse {
        Role: Role;
    }
    export interface CreateSAMLProviderRequest {
        SAMLMetadataDocument: SAMLMetadataDocumentType;
        Name: SAMLProviderNameType;
    }
    export interface CreateSAMLProviderResponse {
        SAMLProviderArn?: arnType;
    }
    export interface CreateUserRequest {
        Path?: pathType;
        UserName: userNameType;
    }
    export interface CreateUserResponse {
        User?: User;
    }
    export interface CreateVirtualMFADeviceRequest {
        Path?: pathType;
        VirtualMFADeviceName: virtualMFADeviceName;
    }
    export interface CreateVirtualMFADeviceResponse {
        VirtualMFADevice: VirtualMFADevice;
    }
    export interface CredentialReportExpiredException {
        message?: credentialReportExpiredExceptionMessage;
    }
    export interface CredentialReportNotPresentException {
        message?: credentialReportNotPresentExceptionMessage;
    }
    export interface CredentialReportNotReadyException {
        message?: credentialReportNotReadyExceptionMessage;
    }
    export interface DeactivateMFADeviceRequest {
        UserName: existingUserNameType;
        SerialNumber: serialNumberType;
    }
    export interface DeleteAccessKeyRequest {
        UserName?: existingUserNameType;
        AccessKeyId: accessKeyIdType;
    }
    export interface DeleteAccountAliasRequest {
        AccountAlias: accountAliasType;
    }
    export interface DeleteConflictException {
        message?: deleteConflictMessage;
    }
    export interface DeleteGroupPolicyRequest {
        GroupName: groupNameType;
        PolicyName: policyNameType;
    }
    export interface DeleteGroupRequest {
        GroupName: groupNameType;
    }
    export interface DeleteInstanceProfileRequest {
        InstanceProfileName: instanceProfileNameType;
    }
    export interface DeleteLoginProfileRequest {
        UserName: userNameType;
    }
    export interface DeleteOpenIDConnectProviderRequest {
        OpenIDConnectProviderArn: arnType;
    }
    export interface DeletePolicyRequest {
        PolicyArn: arnType;
    }
    export interface DeletePolicyVersionRequest {
        PolicyArn: arnType;
        VersionId: policyVersionIdType;
    }
    export interface DeleteRolePolicyRequest {
        RoleName: roleNameType;
        PolicyName: policyNameType;
    }
    export interface DeleteRoleRequest {
        RoleName: roleNameType;
    }
    export interface DeleteSAMLProviderRequest {
        SAMLProviderArn: arnType;
    }
    export interface DeleteSSHPublicKeyRequest {
        UserName: userNameType;
        SSHPublicKeyId: publicKeyIdType;
    }
    export interface DeleteServerCertificateRequest {
        ServerCertificateName: serverCertificateNameType;
    }
    export interface DeleteSigningCertificateRequest {
        UserName?: existingUserNameType;
        CertificateId: certificateIdType;
    }
    export interface DeleteUserPolicyRequest {
        UserName: existingUserNameType;
        PolicyName: policyNameType;
    }
    export interface DeleteUserRequest {
        UserName: existingUserNameType;
    }
    export interface DeleteVirtualMFADeviceRequest {
        SerialNumber: serialNumberType;
    }
    export interface DetachGroupPolicyRequest {
        GroupName: groupNameType;
        PolicyArn: arnType;
    }
    export interface DetachRolePolicyRequest {
        RoleName: roleNameType;
        PolicyArn: arnType;
    }
    export interface DetachUserPolicyRequest {
        UserName: userNameType;
        PolicyArn: arnType;
    }
    export interface DuplicateCertificateException {
        message?: duplicateCertificateMessage;
    }
    export interface DuplicateSSHPublicKeyException {
        message?: duplicateSSHPublicKeyMessage;
    }
    export interface EnableMFADeviceRequest {
        UserName: existingUserNameType;
        SerialNumber: serialNumberType;
        AuthenticationCode1: authenticationCodeType;
        AuthenticationCode2: authenticationCodeType;
    }
    export interface EntityAlreadyExistsException {
        message?: entityAlreadyExistsMessage;
    }
    export interface EntityTemporarilyUnmodifiableException {
        message?: entityTemporarilyUnmodifiableMessage;
    }
    export interface EvaluationResult {
        EvalActionName: ActionNameType;
        EvalResourceName?: ResourceNameType;
        EvalDecision: PolicyEvaluationDecisionType;
        MatchedStatements?: StatementListType;
        MissingContextValues?: ContextKeyNamesResultListType;
        EvalDecisionDetails?: EvalDecisionDetailsType;
        ResourceSpecificResults?: ResourceSpecificResultListType;
    }
    export interface GenerateCredentialReportResponse {
        State?: ReportStateType;
        Description?: ReportStateDescriptionType;
    }
    export interface GetAccessKeyLastUsedRequest {
        AccessKeyId: accessKeyIdType;
    }
    export interface GetAccessKeyLastUsedResponse {
        UserName?: existingUserNameType;
        AccessKeyLastUsed?: AccessKeyLastUsed;
    }
    export interface GetAccountAuthorizationDetailsRequest {
        Filter?: entityListType;
        MaxItems?: maxItemsType;
        Marker?: markerType;
    }
    export interface GetAccountAuthorizationDetailsResponse {
        UserDetailList?: userDetailListType;
        GroupDetailList?: groupDetailListType;
        RoleDetailList?: roleDetailListType;
        Policies?: ManagedPolicyDetailListType;
        IsTruncated?: booleanType;
        Marker?: markerType;
    }
    export interface GetAccountPasswordPolicyResponse {
        PasswordPolicy: PasswordPolicy;
    }
    export interface GetAccountSummaryResponse {
        SummaryMap?: summaryMapType;
    }
    export interface GetContextKeysForCustomPolicyRequest {
        PolicyInputList: SimulationPolicyListType;
    }
    export interface GetContextKeysForPolicyResponse {
        ContextKeyNames?: ContextKeyNamesResultListType;
    }
    export interface GetContextKeysForPrincipalPolicyRequest {
        PolicySourceArn: arnType;
        PolicyInputList?: SimulationPolicyListType;
    }
    export interface GetCredentialReportResponse {
        Content?: ReportContentType;
        ReportFormat?: ReportFormatType;
        GeneratedTime?: dateType;
    }
    export interface GetGroupPolicyRequest {
        GroupName: groupNameType;
        PolicyName: policyNameType;
    }
    export interface GetGroupPolicyResponse {
        GroupName: groupNameType;
        PolicyName: policyNameType;
        PolicyDocument: policyDocumentType;
    }
    export interface GetGroupRequest {
        GroupName: groupNameType;
        Marker?: markerType;
        MaxItems?: maxItemsType;
    }
    export interface GetGroupResponse {
        Group: Group;
        Users: userListType;
        IsTruncated?: booleanType;
        Marker?: markerType;
    }
    export interface GetInstanceProfileRequest {
        InstanceProfileName: instanceProfileNameType;
    }
    export interface GetInstanceProfileResponse {
        InstanceProfile: InstanceProfile;
    }
    export interface GetLoginProfileRequest {
        UserName: userNameType;
    }
    export interface GetLoginProfileResponse {
        LoginProfile: LoginProfile;
    }
    export interface GetOpenIDConnectProviderRequest {
        OpenIDConnectProviderArn: arnType;
    }
    export interface GetOpenIDConnectProviderResponse {
        Url?: OpenIDConnectProviderUrlType;
        ClientIDList?: clientIDListType;
        ThumbprintList?: thumbprintListType;
        CreateDate?: dateType;
    }
    export interface GetPolicyRequest {
        PolicyArn: arnType;
    }
    export interface GetPolicyResponse {
        Policy?: Policy;
    }
    export interface GetPolicyVersionRequest {
        PolicyArn: arnType;
        VersionId: policyVersionIdType;
    }
    export interface GetPolicyVersionResponse {
        PolicyVersion?: PolicyVersion;
    }
    export interface GetRolePolicyRequest {
        RoleName: roleNameType;
        PolicyName: policyNameType;
    }
    export interface GetRolePolicyResponse {
        RoleName: roleNameType;
        PolicyName: policyNameType;
        PolicyDocument: policyDocumentType;
    }
    export interface GetRoleRequest {
        RoleName: roleNameType;
    }
    export interface GetRoleResponse {
        Role: Role;
    }
    export interface GetSAMLProviderRequest {
        SAMLProviderArn: arnType;
    }
    export interface GetSAMLProviderResponse {
        SAMLMetadataDocument?: SAMLMetadataDocumentType;
        CreateDate?: dateType;
        ValidUntil?: dateType;
    }
    export interface GetSSHPublicKeyRequest {
        UserName: userNameType;
        SSHPublicKeyId: publicKeyIdType;
        Encoding: encodingType;
    }
    export interface GetSSHPublicKeyResponse {
        SSHPublicKey?: SSHPublicKey;
    }
    export interface GetServerCertificateRequest {
        ServerCertificateName: serverCertificateNameType;
    }
    export interface GetServerCertificateResponse {
        ServerCertificate: ServerCertificate;
    }
    export interface GetUserPolicyRequest {
        UserName: existingUserNameType;
        PolicyName: policyNameType;
    }
    export interface GetUserPolicyResponse {
        UserName: existingUserNameType;
        PolicyName: policyNameType;
        PolicyDocument: policyDocumentType;
    }
    export interface GetUserRequest {
        UserName?: existingUserNameType;
    }
    export interface GetUserResponse {
        User: User;
    }
    export interface Group {
        Path: pathType;
        GroupName: groupNameType;
        GroupId: idType;
        Arn: arnType;
        CreateDate: dateType;
    }
    export interface GroupDetail {
        Path?: pathType;
        GroupName?: groupNameType;
        GroupId?: idType;
        Arn?: arnType;
        CreateDate?: dateType;
        GroupPolicyList?: policyDetailListType;
        AttachedManagedPolicies?: attachedPoliciesListType;
    }
    export interface InstanceProfile {
        Path: pathType;
        InstanceProfileName: instanceProfileNameType;
        InstanceProfileId: idType;
        Arn: arnType;
        CreateDate: dateType;
        Roles: roleListType;
    }
    export interface InvalidAuthenticationCodeException {
        message?: invalidAuthenticationCodeMessage;
    }
    export interface InvalidCertificateException {
        message?: invalidCertificateMessage;
    }
    export interface InvalidInputException {
        message?: invalidInputMessage;
    }
    export interface InvalidPublicKeyException {
        message?: invalidPublicKeyMessage;
    }
    export interface InvalidUserTypeException {
        message?: invalidUserTypeMessage;
    }
    export interface KeyPairMismatchException {
        message?: keyPairMismatchMessage;
    }
    export interface LimitExceededException {
        message?: limitExceededMessage;
    }
    export interface ListAccessKeysRequest {
        UserName?: existingUserNameType;
        Marker?: markerType;
        MaxItems?: maxItemsType;
    }
    export interface ListAccessKeysResponse {
        AccessKeyMetadata: accessKeyMetadataListType;
        IsTruncated?: booleanType;
        Marker?: markerType;
    }
    export interface ListAccountAliasesRequest {
        Marker?: markerType;
        MaxItems?: maxItemsType;
    }
    export interface ListAccountAliasesResponse {
        AccountAliases: accountAliasListType;
        IsTruncated?: booleanType;
        Marker?: markerType;
    }
    export interface ListAttachedGroupPoliciesRequest {
        GroupName: groupNameType;
        PathPrefix?: policyPathType;
        Marker?: markerType;
        MaxItems?: maxItemsType;
    }
    export interface ListAttachedGroupPoliciesResponse {
        AttachedPolicies?: attachedPoliciesListType;
        IsTruncated?: booleanType;
        Marker?: markerType;
    }
    export interface ListAttachedRolePoliciesRequest {
        RoleName: roleNameType;
        PathPrefix?: policyPathType;
        Marker?: markerType;
        MaxItems?: maxItemsType;
    }
    export interface ListAttachedRolePoliciesResponse {
        AttachedPolicies?: attachedPoliciesListType;
        IsTruncated?: booleanType;
        Marker?: markerType;
    }
    export interface ListAttachedUserPoliciesRequest {
        UserName: userNameType;
        PathPrefix?: policyPathType;
        Marker?: markerType;
        MaxItems?: maxItemsType;
    }
    export interface ListAttachedUserPoliciesResponse {
        AttachedPolicies?: attachedPoliciesListType;
        IsTruncated?: booleanType;
        Marker?: markerType;
    }
    export interface ListEntitiesForPolicyRequest {
        PolicyArn: arnType;
        EntityFilter?: EntityType;
        PathPrefix?: pathType;
        Marker?: markerType;
        MaxItems?: maxItemsType;
    }
    export interface ListEntitiesForPolicyResponse {
        PolicyGroups?: PolicyGroupListType;
        PolicyUsers?: PolicyUserListType;
        PolicyRoles?: PolicyRoleListType;
        IsTruncated?: booleanType;
        Marker?: markerType;
    }
    export interface ListGroupPoliciesRequest {
        GroupName: groupNameType;
        Marker?: markerType;
        MaxItems?: maxItemsType;
    }
    export interface ListGroupPoliciesResponse {
        PolicyNames: policyNameListType;
        IsTruncated?: booleanType;
        Marker?: markerType;
    }
    export interface ListGroupsForUserRequest {
        UserName: existingUserNameType;
        Marker?: markerType;
        MaxItems?: maxItemsType;
    }
    export interface ListGroupsForUserResponse {
        Groups: groupListType;
        IsTruncated?: booleanType;
        Marker?: markerType;
    }
    export interface ListGroupsRequest {
        PathPrefix?: pathPrefixType;
        Marker?: markerType;
        MaxItems?: maxItemsType;
    }
    export interface ListGroupsResponse {
        Groups: groupListType;
        IsTruncated?: booleanType;
        Marker?: markerType;
    }
    export interface ListInstanceProfilesForRoleRequest {
        RoleName: roleNameType;
        Marker?: markerType;
        MaxItems?: maxItemsType;
    }
    export interface ListInstanceProfilesForRoleResponse {
        InstanceProfiles: instanceProfileListType;
        IsTruncated?: booleanType;
        Marker?: markerType;
    }
    export interface ListInstanceProfilesRequest {
        PathPrefix?: pathPrefixType;
        Marker?: markerType;
        MaxItems?: maxItemsType;
    }
    export interface ListInstanceProfilesResponse {
        InstanceProfiles: instanceProfileListType;
        IsTruncated?: booleanType;
        Marker?: markerType;
    }
    export interface ListMFADevicesRequest {
        UserName?: existingUserNameType;
        Marker?: markerType;
        MaxItems?: maxItemsType;
    }
    export interface ListMFADevicesResponse {
        MFADevices: mfaDeviceListType;
        IsTruncated?: booleanType;
        Marker?: markerType;
    }
    export interface ListOpenIDConnectProvidersRequest {
    }
    export interface ListOpenIDConnectProvidersResponse {
        OpenIDConnectProviderList?: OpenIDConnectProviderListType;
    }
    export interface ListPoliciesRequest {
        Scope?: policyScopeType;
        OnlyAttached?: booleanType;
        PathPrefix?: policyPathType;
        Marker?: markerType;
        MaxItems?: maxItemsType;
    }
    export interface ListPoliciesResponse {
        Policies?: policyListType;
        IsTruncated?: booleanType;
        Marker?: markerType;
    }
    export interface ListPolicyVersionsRequest {
        PolicyArn: arnType;
        Marker?: markerType;
        MaxItems?: maxItemsType;
    }
    export interface ListPolicyVersionsResponse {
        Versions?: policyDocumentVersionListType;
        IsTruncated?: booleanType;
        Marker?: markerType;
    }
    export interface ListRolePoliciesRequest {
        RoleName: roleNameType;
        Marker?: markerType;
        MaxItems?: maxItemsType;
    }
    export interface ListRolePoliciesResponse {
        PolicyNames: policyNameListType;
        IsTruncated?: booleanType;
        Marker?: markerType;
    }
    export interface ListRolesRequest {
        PathPrefix?: pathPrefixType;
        Marker?: markerType;
        MaxItems?: maxItemsType;
    }
    export interface ListRolesResponse {
        Roles: roleListType;
        IsTruncated?: booleanType;
        Marker?: markerType;
    }
    export interface ListSAMLProvidersRequest {
    }
    export interface ListSAMLProvidersResponse {
        SAMLProviderList?: SAMLProviderListType;
    }
    export interface ListSSHPublicKeysRequest {
        UserName?: userNameType;
        Marker?: markerType;
        MaxItems?: maxItemsType;
    }
    export interface ListSSHPublicKeysResponse {
        SSHPublicKeys?: SSHPublicKeyListType;
        IsTruncated?: booleanType;
        Marker?: markerType;
    }
    export interface ListServerCertificatesRequest {
        PathPrefix?: pathPrefixType;
        Marker?: markerType;
        MaxItems?: maxItemsType;
    }
    export interface ListServerCertificatesResponse {
        ServerCertificateMetadataList: serverCertificateMetadataListType;
        IsTruncated?: booleanType;
        Marker?: markerType;
    }
    export interface ListSigningCertificatesRequest {
        UserName?: existingUserNameType;
        Marker?: markerType;
        MaxItems?: maxItemsType;
    }
    export interface ListSigningCertificatesResponse {
        Certificates: certificateListType;
        IsTruncated?: booleanType;
        Marker?: markerType;
    }
    export interface ListUserPoliciesRequest {
        UserName: existingUserNameType;
        Marker?: markerType;
        MaxItems?: maxItemsType;
    }
    export interface ListUserPoliciesResponse {
        PolicyNames: policyNameListType;
        IsTruncated?: booleanType;
        Marker?: markerType;
    }
    export interface ListUsersRequest {
        PathPrefix?: pathPrefixType;
        Marker?: markerType;
        MaxItems?: maxItemsType;
    }
    export interface ListUsersResponse {
        Users: userListType;
        IsTruncated?: booleanType;
        Marker?: markerType;
    }
    export interface ListVirtualMFADevicesRequest {
        AssignmentStatus?: assignmentStatusType;
        Marker?: markerType;
        MaxItems?: maxItemsType;
    }
    export interface ListVirtualMFADevicesResponse {
        VirtualMFADevices: virtualMFADeviceListType;
        IsTruncated?: booleanType;
        Marker?: markerType;
    }
    export interface LoginProfile {
        UserName: userNameType;
        CreateDate: dateType;
        PasswordResetRequired?: booleanType;
    }
    export interface MFADevice {
        UserName: userNameType;
        SerialNumber: serialNumberType;
        EnableDate: dateType;
    }
    export interface MalformedCertificateException {
        message?: malformedCertificateMessage;
    }
    export interface MalformedPolicyDocumentException {
        message?: malformedPolicyDocumentMessage;
    }
    export interface ManagedPolicyDetail {
        PolicyName?: policyNameType;
        PolicyId?: idType;
        Arn?: arnType;
        Path?: policyPathType;
        DefaultVersionId?: policyVersionIdType;
        AttachmentCount?: attachmentCountType;
        IsAttachable?: booleanType;
        Description?: policyDescriptionType;
        CreateDate?: dateType;
        UpdateDate?: dateType;
        PolicyVersionList?: policyDocumentVersionListType;
    }
    export interface NoSuchEntityException {
        message?: noSuchEntityMessage;
    }
    export interface OpenIDConnectProviderListEntry {
        Arn?: arnType;
    }
    export interface PasswordPolicy {
        MinimumPasswordLength?: minimumPasswordLengthType;
        RequireSymbols?: booleanType;
        RequireNumbers?: booleanType;
        RequireUppercaseCharacters?: booleanType;
        RequireLowercaseCharacters?: booleanType;
        AllowUsersToChangePassword?: booleanType;
        ExpirePasswords?: booleanType;
        MaxPasswordAge?: maxPasswordAgeType;
        PasswordReusePrevention?: passwordReusePreventionType;
        HardExpiry?: booleanObjectType;
    }
    export interface PasswordPolicyViolationException {
        message?: passwordPolicyViolationMessage;
    }
    export interface Policy {
        PolicyName?: policyNameType;
        PolicyId?: idType;
        Arn?: arnType;
        Path?: policyPathType;
        DefaultVersionId?: policyVersionIdType;
        AttachmentCount?: attachmentCountType;
        IsAttachable?: booleanType;
        Description?: policyDescriptionType;
        CreateDate?: dateType;
        UpdateDate?: dateType;
    }
    export interface PolicyDetail {
        PolicyName?: policyNameType;
        PolicyDocument?: policyDocumentType;
    }
    export interface PolicyEvaluationException {
        message?: policyEvaluationErrorMessage;
    }
    export interface PolicyGroup {
        GroupName?: groupNameType;
        GroupId?: idType;
    }
    export interface PolicyRole {
        RoleName?: roleNameType;
        RoleId?: idType;
    }
    export interface PolicyUser {
        UserName?: userNameType;
        UserId?: idType;
    }
    export interface PolicyVersion {
        Document?: policyDocumentType;
        VersionId?: policyVersionIdType;
        IsDefaultVersion?: booleanType;
        CreateDate?: dateType;
    }
    export interface Position {
        Line?: LineNumber;
        Column?: ColumnNumber;
    }
    export interface PutGroupPolicyRequest {
        GroupName: groupNameType;
        PolicyName: policyNameType;
        PolicyDocument: policyDocumentType;
    }
    export interface PutRolePolicyRequest {
        RoleName: roleNameType;
        PolicyName: policyNameType;
        PolicyDocument: policyDocumentType;
    }
    export interface PutUserPolicyRequest {
        UserName: existingUserNameType;
        PolicyName: policyNameType;
        PolicyDocument: policyDocumentType;
    }
    export interface RemoveClientIDFromOpenIDConnectProviderRequest {
        OpenIDConnectProviderArn: arnType;
        ClientID: clientIDType;
    }
    export interface RemoveRoleFromInstanceProfileRequest {
        InstanceProfileName: instanceProfileNameType;
        RoleName: roleNameType;
    }
    export interface RemoveUserFromGroupRequest {
        GroupName: groupNameType;
        UserName: existingUserNameType;
    }
    export interface ResourceSpecificResult {
        EvalResourceName: ResourceNameType;
        EvalResourceDecision: PolicyEvaluationDecisionType;
        MatchedStatements?: StatementListType;
        MissingContextValues?: ContextKeyNamesResultListType;
        EvalDecisionDetails?: EvalDecisionDetailsType;
    }
    export interface ResyncMFADeviceRequest {
        UserName: existingUserNameType;
        SerialNumber: serialNumberType;
        AuthenticationCode1: authenticationCodeType;
        AuthenticationCode2: authenticationCodeType;
    }
    export interface Role {
        Path: pathType;
        RoleName: roleNameType;
        RoleId: idType;
        Arn: arnType;
        CreateDate: dateType;
        AssumeRolePolicyDocument?: policyDocumentType;
    }
    export interface RoleDetail {
        Path?: pathType;
        RoleName?: roleNameType;
        RoleId?: idType;
        Arn?: arnType;
        CreateDate?: dateType;
        AssumeRolePolicyDocument?: policyDocumentType;
        InstanceProfileList?: instanceProfileListType;
        RolePolicyList?: policyDetailListType;
        AttachedManagedPolicies?: attachedPoliciesListType;
    }
    export interface SAMLProviderListEntry {
        Arn?: arnType;
        ValidUntil?: dateType;
        CreateDate?: dateType;
    }
    export interface SSHPublicKey {
        UserName: userNameType;
        SSHPublicKeyId: publicKeyIdType;
        Fingerprint: publicKeyFingerprintType;
        SSHPublicKeyBody: publicKeyMaterialType;
        Status: statusType;
        UploadDate?: dateType;
    }
    export interface SSHPublicKeyMetadata {
        UserName: userNameType;
        SSHPublicKeyId: publicKeyIdType;
        Status: statusType;
        UploadDate: dateType;
    }
    export interface ServerCertificate {
        ServerCertificateMetadata: ServerCertificateMetadata;
        CertificateBody: certificateBodyType;
        CertificateChain?: certificateChainType;
    }
    export interface ServerCertificateMetadata {
        Path: pathType;
        ServerCertificateName: serverCertificateNameType;
        ServerCertificateId: idType;
        Arn: arnType;
        UploadDate?: dateType;
        Expiration?: dateType;
    }
    export interface ServiceFailureException {
        message?: serviceFailureExceptionMessage;
    }
    export interface SetDefaultPolicyVersionRequest {
        PolicyArn: arnType;
        VersionId: policyVersionIdType;
    }
    export interface SigningCertificate {
        UserName: userNameType;
        CertificateId: certificateIdType;
        CertificateBody: certificateBodyType;
        Status: statusType;
        UploadDate?: dateType;
    }
    export interface SimulateCustomPolicyRequest {
        PolicyInputList: SimulationPolicyListType;
        ActionNames: ActionNameListType;
        ResourceArns?: ResourceNameListType;
        ResourcePolicy?: policyDocumentType;
        ResourceOwner?: ResourceNameType;
        CallerArn?: ResourceNameType;
        ContextEntries?: ContextEntryListType;
        ResourceHandlingOption?: ResourceHandlingOptionType;
        MaxItems?: maxItemsType;
        Marker?: markerType;
    }
    export interface SimulatePolicyResponse {
        EvaluationResults?: EvaluationResultsListType;
        IsTruncated?: booleanType;
        Marker?: markerType;
    }
    export interface SimulatePrincipalPolicyRequest {
        PolicySourceArn: arnType;
        PolicyInputList?: SimulationPolicyListType;
        ActionNames: ActionNameListType;
        ResourceArns?: ResourceNameListType;
        ResourcePolicy?: policyDocumentType;
        ResourceOwner?: ResourceNameType;
        CallerArn?: ResourceNameType;
        ContextEntries?: ContextEntryListType;
        ResourceHandlingOption?: ResourceHandlingOptionType;
        MaxItems?: maxItemsType;
        Marker?: markerType;
    }
    export interface Statement {
        SourcePolicyId?: PolicyIdentifierType;
        SourcePolicyType?: PolicySourceType;
        StartPosition?: Position;
        EndPosition?: Position;
    }
    export interface UnrecognizedPublicKeyEncodingException {
        message?: unrecognizedPublicKeyEncodingMessage;
    }
    export interface UpdateAccessKeyRequest {
        UserName?: existingUserNameType;
        AccessKeyId: accessKeyIdType;
        Status: statusType;
    }
    export interface UpdateAccountPasswordPolicyRequest {
        MinimumPasswordLength?: minimumPasswordLengthType;
        RequireSymbols?: booleanType;
        RequireNumbers?: booleanType;
        RequireUppercaseCharacters?: booleanType;
        RequireLowercaseCharacters?: booleanType;
        AllowUsersToChangePassword?: booleanType;
        MaxPasswordAge?: maxPasswordAgeType;
        PasswordReusePrevention?: passwordReusePreventionType;
        HardExpiry?: booleanObjectType;
    }
    export interface UpdateAssumeRolePolicyRequest {
        RoleName: roleNameType;
        PolicyDocument: policyDocumentType;
    }
    export interface UpdateGroupRequest {
        GroupName: groupNameType;
        NewPath?: pathType;
        NewGroupName?: groupNameType;
    }
    export interface UpdateLoginProfileRequest {
        UserName: userNameType;
        Password?: passwordType;
        PasswordResetRequired?: booleanObjectType;
    }
    export interface UpdateOpenIDConnectProviderThumbprintRequest {
        OpenIDConnectProviderArn: arnType;
        ThumbprintList: thumbprintListType;
    }
    export interface UpdateSAMLProviderRequest {
        SAMLMetadataDocument: SAMLMetadataDocumentType;
        SAMLProviderArn: arnType;
    }
    export interface UpdateSAMLProviderResponse {
        SAMLProviderArn?: arnType;
    }
    export interface UpdateSSHPublicKeyRequest {
        UserName: userNameType;
        SSHPublicKeyId: publicKeyIdType;
        Status: statusType;
    }
    export interface UpdateServerCertificateRequest {
        ServerCertificateName: serverCertificateNameType;
        NewPath?: pathType;
        NewServerCertificateName?: serverCertificateNameType;
    }
    export interface UpdateSigningCertificateRequest {
        UserName?: existingUserNameType;
        CertificateId: certificateIdType;
        Status: statusType;
    }
    export interface UpdateUserRequest {
        UserName: existingUserNameType;
        NewPath?: pathType;
        NewUserName?: userNameType;
    }
    export interface UploadSSHPublicKeyRequest {
        UserName: userNameType;
        SSHPublicKeyBody: publicKeyMaterialType;
    }
    export interface UploadSSHPublicKeyResponse {
        SSHPublicKey?: SSHPublicKey;
    }
    export interface UploadServerCertificateRequest {
        Path?: pathType;
        ServerCertificateName: serverCertificateNameType;
        CertificateBody: certificateBodyType;
        PrivateKey: privateKeyType;
        CertificateChain?: certificateChainType;
    }
    export interface UploadServerCertificateResponse {
        ServerCertificateMetadata?: ServerCertificateMetadata;
    }
    export interface UploadSigningCertificateRequest {
        UserName?: existingUserNameType;
        CertificateBody: certificateBodyType;
    }
    export interface UploadSigningCertificateResponse {
        Certificate: SigningCertificate;
    }
    export interface User {
        Path: pathType;
        UserName: userNameType;
        UserId: idType;
        Arn: arnType;
        CreateDate: dateType;
        PasswordLastUsed?: dateType;
    }
    export interface UserDetail {
        Path?: pathType;
        UserName?: userNameType;
        UserId?: idType;
        Arn?: arnType;
        CreateDate?: dateType;
        UserPolicyList?: policyDetailListType;
        GroupList?: groupNameListType;
        AttachedManagedPolicies?: attachedPoliciesListType;
    }
    export interface VirtualMFADevice {
        SerialNumber: serialNumberType;
        Base32StringSeed?: BootstrapDatum;
        QRCodePNG?: BootstrapDatum;
        User?: User;
        EnableDate?: dateType;
    }
  }

  /*
   * apiVersion: 2010-06-01
   * endpointPrefix: importexport
   * serviceAbbreviation: 
   * signatureVersion: v2
   * protocol: query
   */
  export class ImportExport extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    cancelJob(params: ImportExport.CancelJobInput, callback?: (err: ImportExport.InvalidJobIdException|ImportExport.ExpiredJobIdException|ImportExport.CanceledJobIdException|ImportExport.UnableToCancelJobIdException|ImportExport.InvalidAccessKeyIdException|ImportExport.InvalidVersionException|any, data: ImportExport.CancelJobOutput|any) => void): Request;
    createJob(params: ImportExport.CreateJobInput, callback?: (err: ImportExport.MissingParameterException|ImportExport.InvalidParameterException|ImportExport.InvalidAccessKeyIdException|ImportExport.InvalidAddressException|ImportExport.InvalidManifestFieldException|ImportExport.MissingManifestFieldException|ImportExport.NoSuchBucketException|ImportExport.MissingCustomsException|ImportExport.InvalidCustomsException|ImportExport.InvalidFileSystemException|ImportExport.MultipleRegionsException|ImportExport.BucketPermissionException|ImportExport.MalformedManifestException|ImportExport.CreateJobQuotaExceededException|ImportExport.InvalidJobIdException|ImportExport.InvalidVersionException|any, data: ImportExport.CreateJobOutput|any) => void): Request;
    getShippingLabel(params: ImportExport.GetShippingLabelInput, callback?: (err: ImportExport.InvalidJobIdException|ImportExport.ExpiredJobIdException|ImportExport.CanceledJobIdException|ImportExport.InvalidAccessKeyIdException|ImportExport.InvalidAddressException|ImportExport.InvalidVersionException|ImportExport.InvalidParameterException|any, data: ImportExport.GetShippingLabelOutput|any) => void): Request;
    getStatus(params: ImportExport.GetStatusInput, callback?: (err: ImportExport.InvalidJobIdException|ImportExport.ExpiredJobIdException|ImportExport.CanceledJobIdException|ImportExport.InvalidAccessKeyIdException|ImportExport.InvalidVersionException|any, data: ImportExport.GetStatusOutput|any) => void): Request;
    listJobs(params: ImportExport.ListJobsInput, callback?: (err: ImportExport.InvalidParameterException|ImportExport.InvalidAccessKeyIdException|ImportExport.InvalidVersionException|any, data: ImportExport.ListJobsOutput|any) => void): Request;
    updateJob(params: ImportExport.UpdateJobInput, callback?: (err: ImportExport.MissingParameterException|ImportExport.InvalidParameterException|ImportExport.InvalidAccessKeyIdException|ImportExport.InvalidAddressException|ImportExport.InvalidManifestFieldException|ImportExport.InvalidJobIdException|ImportExport.MissingManifestFieldException|ImportExport.NoSuchBucketException|ImportExport.ExpiredJobIdException|ImportExport.CanceledJobIdException|ImportExport.MissingCustomsException|ImportExport.InvalidCustomsException|ImportExport.InvalidFileSystemException|ImportExport.MultipleRegionsException|ImportExport.BucketPermissionException|ImportExport.MalformedManifestException|ImportExport.UnableToUpdateJobIdException|ImportExport.InvalidVersionException|any, data: ImportExport.UpdateJobOutput|any) => void): Request;

  }

  export module ImportExport {
    export type APIVersion = string;
    export type ArtifactList = Artifact[];
    export type Carrier = string;
    export type CreationDate = number;
    export type CurrentManifest = string;
    export type Description = string;
    export type ErrorCount = number;
    export type ErrorMessage = string;
    export type GenericString = string;
    export type IsCanceled = boolean;
    export type IsTruncated = boolean;
    export type JobId = string;
    export type JobIdList = GenericString[];
    export type JobType = string;
    export type JobsList = Job[];
    export type LocationCode = string;
    export type LocationMessage = string;
    export type LogBucket = string;
    export type LogKey = string;
    export type Manifest = string;
    export type ManifestAddendum = string;
    export type Marker = string;
    export type MaxJobs = number;
    export type ProgressCode = string;
    export type ProgressMessage = string;
    export type Signature = string;
    export type SignatureFileContents = string;
    export type Success = boolean;
    export type TrackingNumber = string;
    export type URL = string;
    export type ValidateOnly = boolean;
    export type WarningMessage = string;
    export type city = string;
    export type company = string;
    export type country = string;
    export type name = string;
    export type phoneNumber = string;
    export type postalCode = string;
    export type stateOrProvince = string;
    export type street1 = string;
    export type street2 = string;
    export type street3 = string;

    export interface Artifact {
        Description?: Description;
        URL?: URL;
    }
    export interface BucketPermissionException {
        message?: ErrorMessage;
    }
    export interface CancelJobInput {
        JobId: JobId;
        APIVersion?: APIVersion;
    }
    export interface CancelJobOutput {
        Success?: Success;
    }
    export interface CanceledJobIdException {
        message?: ErrorMessage;
    }
    export interface CreateJobInput {
        JobType: JobType;
        Manifest: Manifest;
        ManifestAddendum?: ManifestAddendum;
        ValidateOnly: ValidateOnly;
        APIVersion?: APIVersion;
    }
    export interface CreateJobOutput {
        JobId?: JobId;
        JobType?: JobType;
        Signature?: Signature;
        SignatureFileContents?: SignatureFileContents;
        WarningMessage?: WarningMessage;
        ArtifactList?: ArtifactList;
    }
    export interface CreateJobQuotaExceededException {
        message?: ErrorMessage;
    }
    export interface ExpiredJobIdException {
        message?: ErrorMessage;
    }
    export interface GetShippingLabelInput {
        jobIds: JobIdList;
        name?: name;
        company?: company;
        phoneNumber?: phoneNumber;
        country?: country;
        stateOrProvince?: stateOrProvince;
        city?: city;
        postalCode?: postalCode;
        street1?: street1;
        street2?: street2;
        street3?: street3;
        APIVersion?: APIVersion;
    }
    export interface GetShippingLabelOutput {
        ShippingLabelURL?: GenericString;
        Warning?: GenericString;
    }
    export interface GetStatusInput {
        JobId: JobId;
        APIVersion?: APIVersion;
    }
    export interface GetStatusOutput {
        JobId?: JobId;
        JobType?: JobType;
        LocationCode?: LocationCode;
        LocationMessage?: LocationMessage;
        ProgressCode?: ProgressCode;
        ProgressMessage?: ProgressMessage;
        Carrier?: Carrier;
        TrackingNumber?: TrackingNumber;
        LogBucket?: LogBucket;
        LogKey?: LogKey;
        ErrorCount?: ErrorCount;
        Signature?: Signature;
        SignatureFileContents?: Signature;
        CurrentManifest?: CurrentManifest;
        CreationDate?: CreationDate;
        ArtifactList?: ArtifactList;
    }
    export interface InvalidAccessKeyIdException {
        message?: ErrorMessage;
    }
    export interface InvalidAddressException {
        message?: ErrorMessage;
    }
    export interface InvalidCustomsException {
        message?: ErrorMessage;
    }
    export interface InvalidFileSystemException {
        message?: ErrorMessage;
    }
    export interface InvalidJobIdException {
        message?: ErrorMessage;
    }
    export interface InvalidManifestFieldException {
        message?: ErrorMessage;
    }
    export interface InvalidParameterException {
        message?: ErrorMessage;
    }
    export interface InvalidVersionException {
        message?: ErrorMessage;
    }
    export interface Job {
        JobId?: JobId;
        CreationDate?: CreationDate;
        IsCanceled?: IsCanceled;
        JobType?: JobType;
    }
    export interface ListJobsInput {
        MaxJobs?: MaxJobs;
        Marker?: Marker;
        APIVersion?: APIVersion;
    }
    export interface ListJobsOutput {
        Jobs?: JobsList;
        IsTruncated?: IsTruncated;
    }
    export interface MalformedManifestException {
        message?: ErrorMessage;
    }
    export interface MissingCustomsException {
        message?: ErrorMessage;
    }
    export interface MissingManifestFieldException {
        message?: ErrorMessage;
    }
    export interface MissingParameterException {
        message?: ErrorMessage;
    }
    export interface MultipleRegionsException {
        message?: ErrorMessage;
    }
    export interface NoSuchBucketException {
        message?: ErrorMessage;
    }
    export interface UnableToCancelJobIdException {
        message?: ErrorMessage;
    }
    export interface UnableToUpdateJobIdException {
        message?: ErrorMessage;
    }
    export interface UpdateJobInput {
        JobId: JobId;
        Manifest: Manifest;
        JobType: JobType;
        ValidateOnly: ValidateOnly;
        APIVersion?: APIVersion;
    }
    export interface UpdateJobOutput {
        Success?: Success;
        WarningMessage?: WarningMessage;
        ArtifactList?: ArtifactList;
    }
  }

  /*
   * apiVersion: 2015-08-18
   * endpointPrefix: inspector
   * serviceAbbreviation: 
   * signatureVersion: v4
   * protocol: json
   */
  export class Inspector extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    addAttributesToFindings(params: Inspector.AddAttributesToFindingsRequest, callback?: (err: Inspector.InternalException|Inspector.InvalidInputException|Inspector.AccessDeniedException|Inspector.NoSuchEntityException|any, data: Inspector.AddAttributesToFindingsResponse|any) => void): Request;
    attachAssessmentAndRulesPackage(params: Inspector.AttachAssessmentAndRulesPackageRequest, callback?: (err: Inspector.InternalException|Inspector.InvalidInputException|Inspector.AccessDeniedException|Inspector.NoSuchEntityException|any, data: Inspector.AttachAssessmentAndRulesPackageResponse|any) => void): Request;
    createApplication(params: Inspector.CreateApplicationRequest, callback?: (err: Inspector.InternalException|Inspector.InvalidInputException|Inspector.AccessDeniedException|Inspector.NoSuchEntityException|any, data: Inspector.CreateApplicationResponse|any) => void): Request;
    createAssessment(params: Inspector.CreateAssessmentRequest, callback?: (err: Inspector.InternalException|Inspector.InvalidInputException|Inspector.AccessDeniedException|Inspector.NoSuchEntityException|any, data: Inspector.CreateAssessmentResponse|any) => void): Request;
    createResourceGroup(params: Inspector.CreateResourceGroupRequest, callback?: (err: Inspector.InternalException|Inspector.InvalidInputException|Inspector.AccessDeniedException|any, data: Inspector.CreateResourceGroupResponse|any) => void): Request;
    deleteApplication(params: Inspector.DeleteApplicationRequest, callback?: (err: Inspector.InternalException|Inspector.InvalidInputException|Inspector.OperationInProgressException|Inspector.AccessDeniedException|Inspector.NoSuchEntityException|any, data: Inspector.DeleteApplicationResponse|any) => void): Request;
    deleteAssessment(params: Inspector.DeleteAssessmentRequest, callback?: (err: Inspector.InternalException|Inspector.InvalidInputException|Inspector.OperationInProgressException|Inspector.AccessDeniedException|Inspector.NoSuchEntityException|any, data: Inspector.DeleteAssessmentResponse|any) => void): Request;
    deleteRun(params: Inspector.DeleteRunRequest, callback?: (err: Inspector.InternalException|Inspector.InvalidInputException|Inspector.AccessDeniedException|Inspector.NoSuchEntityException|any, data: Inspector.DeleteRunResponse|any) => void): Request;
    describeApplication(params: Inspector.DescribeApplicationRequest, callback?: (err: Inspector.InternalException|Inspector.InvalidInputException|Inspector.AccessDeniedException|Inspector.NoSuchEntityException|any, data: Inspector.DescribeApplicationResponse|any) => void): Request;
    describeAssessment(params: Inspector.DescribeAssessmentRequest, callback?: (err: Inspector.InternalException|Inspector.InvalidInputException|Inspector.AccessDeniedException|Inspector.NoSuchEntityException|any, data: Inspector.DescribeAssessmentResponse|any) => void): Request;
    describeCrossAccountAccessRole(callback?: (err: Inspector.InternalException|Inspector.AccessDeniedException|any, data: Inspector.DescribeCrossAccountAccessRoleResponse|any) => void): Request;
    describeFinding(params: Inspector.DescribeFindingRequest, callback?: (err: Inspector.InternalException|Inspector.InvalidInputException|Inspector.AccessDeniedException|Inspector.NoSuchEntityException|any, data: Inspector.DescribeFindingResponse|any) => void): Request;
    describeResourceGroup(params: Inspector.DescribeResourceGroupRequest, callback?: (err: Inspector.InternalException|Inspector.InvalidInputException|Inspector.AccessDeniedException|Inspector.NoSuchEntityException|any, data: Inspector.DescribeResourceGroupResponse|any) => void): Request;
    describeRulesPackage(params: Inspector.DescribeRulesPackageRequest, callback?: (err: Inspector.InternalException|Inspector.InvalidInputException|Inspector.AccessDeniedException|Inspector.NoSuchEntityException|any, data: Inspector.DescribeRulesPackageResponse|any) => void): Request;
    describeRun(params: Inspector.DescribeRunRequest, callback?: (err: Inspector.InternalException|Inspector.InvalidInputException|Inspector.AccessDeniedException|Inspector.NoSuchEntityException|any, data: Inspector.DescribeRunResponse|any) => void): Request;
    detachAssessmentAndRulesPackage(params: Inspector.DetachAssessmentAndRulesPackageRequest, callback?: (err: Inspector.InternalException|Inspector.InvalidInputException|Inspector.AccessDeniedException|Inspector.NoSuchEntityException|any, data: Inspector.DetachAssessmentAndRulesPackageResponse|any) => void): Request;
    getAssessmentTelemetry(params: Inspector.GetAssessmentTelemetryRequest, callback?: (err: Inspector.InternalException|Inspector.InvalidInputException|Inspector.AccessDeniedException|Inspector.NoSuchEntityException|any, data: Inspector.GetAssessmentTelemetryResponse|any) => void): Request;
    listApplications(params: Inspector.ListApplicationsRequest, callback?: (err: Inspector.InternalException|Inspector.InvalidInputException|Inspector.AccessDeniedException|any, data: Inspector.ListApplicationsResponse|any) => void): Request;
    listAssessmentAgents(params: Inspector.ListAssessmentAgentsRequest, callback?: (err: Inspector.InternalException|Inspector.InvalidInputException|Inspector.AccessDeniedException|Inspector.NoSuchEntityException|any, data: Inspector.ListAssessmentAgentsResponse|any) => void): Request;
    listAssessments(params: Inspector.ListAssessmentsRequest, callback?: (err: Inspector.InternalException|Inspector.InvalidInputException|Inspector.AccessDeniedException|Inspector.NoSuchEntityException|any, data: Inspector.ListAssessmentsResponse|any) => void): Request;
    listAttachedAssessments(params: Inspector.ListAttachedAssessmentsRequest, callback?: (err: Inspector.InternalException|Inspector.InvalidInputException|Inspector.AccessDeniedException|Inspector.NoSuchEntityException|any, data: Inspector.ListAttachedAssessmentsResponse|any) => void): Request;
    listAttachedRulesPackages(params: Inspector.ListAttachedRulesPackagesRequest, callback?: (err: Inspector.InternalException|Inspector.InvalidInputException|Inspector.AccessDeniedException|Inspector.NoSuchEntityException|any, data: Inspector.ListAttachedRulesPackagesResponse|any) => void): Request;
    listFindings(params: Inspector.ListFindingsRequest, callback?: (err: Inspector.InternalException|Inspector.InvalidInputException|Inspector.AccessDeniedException|Inspector.NoSuchEntityException|any, data: Inspector.ListFindingsResponse|any) => void): Request;
    listRulesPackages(params: Inspector.ListRulesPackagesRequest, callback?: (err: Inspector.InternalException|Inspector.InvalidInputException|Inspector.AccessDeniedException|any, data: Inspector.ListRulesPackagesResponse|any) => void): Request;
    listRuns(params: Inspector.ListRunsRequest, callback?: (err: Inspector.InternalException|Inspector.InvalidInputException|Inspector.AccessDeniedException|Inspector.NoSuchEntityException|any, data: Inspector.ListRunsResponse|any) => void): Request;
    listTagsForResource(params: Inspector.ListTagsForResourceRequest, callback?: (err: Inspector.InternalException|Inspector.InvalidInputException|Inspector.AccessDeniedException|Inspector.NoSuchEntityException|any, data: Inspector.ListTagsForResourceResponse|any) => void): Request;
    localizeText(params: Inspector.LocalizeTextRequest, callback?: (err: Inspector.InternalException|Inspector.InvalidInputException|Inspector.AccessDeniedException|Inspector.NoSuchEntityException|any, data: Inspector.LocalizeTextResponse|any) => void): Request;
    previewAgentsForResourceGroup(params: Inspector.PreviewAgentsForResourceGroupRequest, callback?: (err: Inspector.InternalException|Inspector.InvalidInputException|Inspector.AccessDeniedException|Inspector.NoSuchEntityException|Inspector.InvalidCrossAccountRoleException|any, data: Inspector.PreviewAgentsForResourceGroupResponse|any) => void): Request;
    registerCrossAccountAccessRole(params: Inspector.RegisterCrossAccountAccessRoleRequest, callback?: (err: Inspector.InternalException|Inspector.InvalidInputException|Inspector.AccessDeniedException|Inspector.InvalidCrossAccountRoleException|any, data: Inspector.RegisterCrossAccountAccessRoleResponse|any) => void): Request;
    removeAttributesFromFindings(params: Inspector.RemoveAttributesFromFindingsRequest, callback?: (err: Inspector.InternalException|Inspector.InvalidInputException|Inspector.AccessDeniedException|Inspector.NoSuchEntityException|any, data: Inspector.RemoveAttributesFromFindingsResponse|any) => void): Request;
    runAssessment(params: Inspector.RunAssessmentRequest, callback?: (err: Inspector.InternalException|Inspector.InvalidInputException|Inspector.AccessDeniedException|Inspector.NoSuchEntityException|any, data: Inspector.RunAssessmentResponse|any) => void): Request;
    setTagsForResource(params: Inspector.SetTagsForResourceRequest, callback?: (err: Inspector.InternalException|Inspector.InvalidInputException|Inspector.AccessDeniedException|Inspector.NoSuchEntityException|any, data: Inspector.SetTagsForResourceResponse|any) => void): Request;
    startDataCollection(params: Inspector.StartDataCollectionRequest, callback?: (err: Inspector.InternalException|Inspector.InvalidInputException|Inspector.AccessDeniedException|Inspector.NoSuchEntityException|Inspector.InvalidCrossAccountRoleException|any, data: Inspector.StartDataCollectionResponse|any) => void): Request;
    stopDataCollection(params: Inspector.StopDataCollectionRequest, callback?: (err: Inspector.InternalException|Inspector.InvalidInputException|Inspector.AccessDeniedException|Inspector.NoSuchEntityException|any, data: Inspector.StopDataCollectionResponse|any) => void): Request;
    updateApplication(params: Inspector.UpdateApplicationRequest, callback?: (err: Inspector.InternalException|Inspector.InvalidInputException|Inspector.AccessDeniedException|Inspector.NoSuchEntityException|any, data: Inspector.UpdateApplicationResponse|any) => void): Request;
    updateAssessment(params: Inspector.UpdateAssessmentRequest, callback?: (err: Inspector.InternalException|Inspector.InvalidInputException|Inspector.AccessDeniedException|Inspector.NoSuchEntityException|any, data: Inspector.UpdateAssessmentResponse|any) => void): Request;

  }

  export module Inspector {
    export type AgentHealth = string;
    export type AgentHealthCode = string;
    export type AgentHealthDetails = string;
    export type AgentHealthList = AgentHealth[];
    export type AgentId = string;
    export type AgentList = Agent[];
    export type AgentPreviewList = AgentPreview[];
    export type Arn = string;
    export type ArnList = Arn[];
    export type AssessmentState = string;
    export type AssessmentStateList = AssessmentState[];
    export type AttributeKey = string;
    export type AttributeKeyList = AttributeKey[];
    export type AttributeList = Attribute[];
    export type AttributeValue = string;
    export type AutoScalingGroup = string;
    export type AwsAccount = string;
    export type Bool = boolean;
    export type Duration = number;
    export type FailureMessage = string;
    export type Integer = number;
    export type Locale = string;
    export type LocalizedFacility = string;
    export type LocalizedTextId = string;
    export type LocalizedTextList = LocalizedText[];
    export type Long = number;
    export type Message = string;
    export type MessageType = string;
    export type MessageTypeTelemetryList = MessageTypeTelemetry[];
    export type Name = string;
    export type NameList = Name[];
    export type NamePattern = string;
    export type NamePatternList = NamePattern[];
    export type PaginationToken = string;
    export type ParameterList = Parameter[];
    export type ParameterName = string;
    export type ParameterValue = string;
    export type ResourceGroupTags = string;
    export type RunState = string;
    export type RunStateList = RunState[];
    export type Severity = string;
    export type SeverityList = Severity[];
    export type TagKey = string;
    export type TagList = Tag[];
    export type TagValue = string;
    export type TelemetryList = Telemetry[];
    export type TelemetryStatus = string;
    export type Text = string;
    export type TextList = Text[];
    export type Timestamp = number;
    export type Version = string;

    export interface AccessDeniedException {
    }
    export interface AddAttributesToFindingsRequest {
        findingArns?: ArnList;
        attributes?: AttributeList;
    }
    export interface AddAttributesToFindingsResponse {
        message?: Message;
    }
    export interface Agent {
        agentId?: AgentId;
        assessmentArn?: Arn;
        agentHealth?: AgentHealth;
        agentHealthCode?: AgentHealthCode;
        agentHealthDetails?: AgentHealthDetails;
        autoScalingGroup?: AutoScalingGroup;
        accountId?: AwsAccount;
        telemetry?: TelemetryList;
    }
    export interface AgentPreview {
        agentId?: AgentId;
        autoScalingGroup?: AutoScalingGroup;
    }
    export interface AgentsFilter {
        agentHealthList?: AgentHealthList;
    }
    export interface Application {
        applicationArn?: Arn;
        applicationName?: Name;
        resourceGroupArn?: Arn;
    }
    export interface ApplicationsFilter {
        applicationNamePatterns?: NamePatternList;
    }
    export interface Assessment {
        assessmentArn?: Arn;
        assessmentName?: Name;
        applicationArn?: Arn;
        assessmentState?: AssessmentState;
        failureMessage?: FailureMessage;
        dataCollected?: Bool;
        startTime?: Timestamp;
        endTime?: Timestamp;
        durationInSeconds?: Duration;
        userAttributesForFindings?: AttributeList;
    }
    export interface AssessmentsFilter {
        assessmentNamePatterns?: NamePatternList;
        assessmentStates?: AssessmentStateList;
        dataCollected?: Bool;
        startTimeRange?: TimestampRange;
        endTimeRange?: TimestampRange;
        durationRange?: DurationRange;
    }
    export interface AttachAssessmentAndRulesPackageRequest {
        assessmentArn?: Arn;
        rulesPackageArn?: Arn;
    }
    export interface AttachAssessmentAndRulesPackageResponse {
        message?: Message;
    }
    export interface Attribute {
        key?: AttributeKey;
        value?: AttributeValue;
    }
    export interface CreateApplicationRequest {
        applicationName?: Name;
        resourceGroupArn?: Arn;
    }
    export interface CreateApplicationResponse {
        applicationArn?: Arn;
    }
    export interface CreateAssessmentRequest {
        applicationArn?: Arn;
        assessmentName?: Name;
        durationInSeconds?: Duration;
        userAttributesForFindings?: AttributeList;
    }
    export interface CreateAssessmentResponse {
        assessmentArn?: Arn;
    }
    export interface CreateResourceGroupRequest {
        resourceGroupTags?: ResourceGroupTags;
    }
    export interface CreateResourceGroupResponse {
        resourceGroupArn?: Arn;
    }
    export interface DeleteApplicationRequest {
        applicationArn?: Arn;
    }
    export interface DeleteApplicationResponse {
        message?: Message;
    }
    export interface DeleteAssessmentRequest {
        assessmentArn?: Arn;
    }
    export interface DeleteAssessmentResponse {
        message?: Message;
    }
    export interface DeleteRunRequest {
        runArn?: Arn;
    }
    export interface DeleteRunResponse {
        message?: Message;
    }
    export interface DescribeApplicationRequest {
        applicationArn?: Arn;
    }
    export interface DescribeApplicationResponse {
        application?: Application;
    }
    export interface DescribeAssessmentRequest {
        assessmentArn?: Arn;
    }
    export interface DescribeAssessmentResponse {
        assessment?: Assessment;
    }
    export interface DescribeCrossAccountAccessRoleResponse {
        roleArn?: Arn;
        valid?: Bool;
    }
    export interface DescribeFindingRequest {
        findingArn?: Arn;
    }
    export interface DescribeFindingResponse {
        finding?: Finding;
    }
    export interface DescribeResourceGroupRequest {
        resourceGroupArn?: Arn;
    }
    export interface DescribeResourceGroupResponse {
        resourceGroup?: ResourceGroup;
    }
    export interface DescribeRulesPackageRequest {
        rulesPackageArn?: Arn;
    }
    export interface DescribeRulesPackageResponse {
        rulesPackage?: RulesPackage;
    }
    export interface DescribeRunRequest {
        runArn?: Arn;
    }
    export interface DescribeRunResponse {
        run?: Run;
    }
    export interface DetachAssessmentAndRulesPackageRequest {
        assessmentArn?: Arn;
        rulesPackageArn?: Arn;
    }
    export interface DetachAssessmentAndRulesPackageResponse {
        message?: Message;
    }
    export interface DurationRange {
        minimum?: Duration;
        maximum?: Duration;
    }
    export interface Finding {
        findingArn?: Arn;
        runArn?: Arn;
        rulesPackageArn?: Arn;
        ruleName?: Name;
        agentId?: AgentId;
        autoScalingGroup?: AutoScalingGroup;
        severity?: Severity;
        finding?: LocalizedText;
        description?: LocalizedText;
        recommendation?: LocalizedText;
        attributes?: AttributeList;
        userAttributes?: AttributeList;
    }
    export interface FindingsFilter {
        rulesPackageArns?: ArnList;
        ruleNames?: NameList;
        severities?: SeverityList;
        attributes?: AttributeList;
        userAttributes?: AttributeList;
    }
    export interface GetAssessmentTelemetryRequest {
        assessmentArn?: Arn;
    }
    export interface GetAssessmentTelemetryResponse {
        telemetry?: TelemetryList;
    }
    export interface InternalException {
    }
    export interface InvalidCrossAccountRoleException {
    }
    export interface InvalidInputException {
    }
    export interface ListApplicationsRequest {
        filter?: ApplicationsFilter;
        nextToken?: PaginationToken;
        maxResults?: Integer;
    }
    export interface ListApplicationsResponse {
        applicationArnList?: ArnList;
        nextToken?: PaginationToken;
    }
    export interface ListAssessmentAgentsRequest {
        assessmentArn?: Arn;
        filter?: AgentsFilter;
        nextToken?: PaginationToken;
        maxResults?: Integer;
    }
    export interface ListAssessmentAgentsResponse {
        agentList?: AgentList;
        nextToken?: PaginationToken;
    }
    export interface ListAssessmentsRequest {
        applicationArns?: ArnList;
        filter?: AssessmentsFilter;
        nextToken?: PaginationToken;
        maxResults?: Integer;
    }
    export interface ListAssessmentsResponse {
        assessmentArnList?: ArnList;
        nextToken?: PaginationToken;
    }
    export interface ListAttachedAssessmentsRequest {
        rulesPackageArn?: Arn;
        filter?: AssessmentsFilter;
        nextToken?: PaginationToken;
        maxResults?: Integer;
    }
    export interface ListAttachedAssessmentsResponse {
        assessmentArnList?: ArnList;
        nextToken?: PaginationToken;
    }
    export interface ListAttachedRulesPackagesRequest {
        assessmentArn?: Arn;
        nextToken?: PaginationToken;
        maxResults?: Integer;
    }
    export interface ListAttachedRulesPackagesResponse {
        rulesPackageArnList?: ArnList;
        nextToken?: PaginationToken;
    }
    export interface ListFindingsRequest {
        runArns?: ArnList;
        filter?: FindingsFilter;
        nextToken?: PaginationToken;
        maxResults?: Integer;
    }
    export interface ListFindingsResponse {
        findingArnList?: ArnList;
        nextToken?: PaginationToken;
    }
    export interface ListRulesPackagesRequest {
        nextToken?: PaginationToken;
        maxResults?: Integer;
    }
    export interface ListRulesPackagesResponse {
        rulesPackageArnList?: ArnList;
        nextToken?: PaginationToken;
    }
    export interface ListRunsRequest {
        assessmentArns?: ArnList;
        filter?: RunsFilter;
        nextToken?: PaginationToken;
        maxResults?: Integer;
    }
    export interface ListRunsResponse {
        runArnList?: ArnList;
        nextToken?: PaginationToken;
    }
    export interface ListTagsForResourceRequest {
        resourceArn?: Arn;
    }
    export interface ListTagsForResourceResponse {
        tagList?: TagList;
    }
    export interface LocalizeTextRequest {
        localizedTexts?: LocalizedTextList;
        locale?: Locale;
    }
    export interface LocalizeTextResponse {
        message?: Message;
        results?: TextList;
    }
    export interface LocalizedText {
        key?: LocalizedTextKey;
        parameters?: ParameterList;
    }
    export interface LocalizedTextKey {
        facility?: LocalizedFacility;
        id?: LocalizedTextId;
    }
    export interface MessageTypeTelemetry {
        messageType?: MessageType;
        count?: Long;
        dataSize?: Long;
    }
    export interface NoSuchEntityException {
    }
    export interface OperationInProgressException {
    }
    export interface Parameter {
        name?: ParameterName;
        value?: ParameterValue;
    }
    export interface PreviewAgentsForResourceGroupRequest {
        resourceGroupArn?: Arn;
        nextToken?: PaginationToken;
        maxResults?: Integer;
    }
    export interface PreviewAgentsForResourceGroupResponse {
        agentPreviewList?: AgentPreviewList;
        nextToken?: PaginationToken;
    }
    export interface RegisterCrossAccountAccessRoleRequest {
        roleArn?: Arn;
    }
    export interface RegisterCrossAccountAccessRoleResponse {
        message?: Message;
    }
    export interface RemoveAttributesFromFindingsRequest {
        findingArns?: ArnList;
        attributeKeys?: AttributeKeyList;
    }
    export interface RemoveAttributesFromFindingsResponse {
        message?: Message;
    }
    export interface ResourceGroup {
        resourceGroupArn?: Arn;
        resourceGroupTags?: ResourceGroupTags;
    }
    export interface RulesPackage {
        rulesPackageArn?: Arn;
        rulesPackageName?: Name;
        version?: Version;
        provider?: Name;
        description?: LocalizedText;
    }
    export interface Run {
        runArn?: Arn;
        runName?: Name;
        assessmentArn?: Arn;
        runState?: RunState;
        rulesPackages?: ArnList;
        creationTime?: Timestamp;
        completionTime?: Timestamp;
    }
    export interface RunAssessmentRequest {
        assessmentArn?: Arn;
        runName?: Name;
    }
    export interface RunAssessmentResponse {
        runArn?: Arn;
    }
    export interface RunsFilter {
        runNamePatterns?: NamePatternList;
        runStates?: RunStateList;
        rulesPackages?: ArnList;
        creationTime?: TimestampRange;
        completionTime?: TimestampRange;
    }
    export interface SetTagsForResourceRequest {
        resourceArn?: Arn;
        tags?: TagList;
    }
    export interface SetTagsForResourceResponse {
        message?: Message;
    }
    export interface StartDataCollectionRequest {
        assessmentArn?: Arn;
    }
    export interface StartDataCollectionResponse {
        message?: Message;
    }
    export interface StopDataCollectionRequest {
        assessmentArn?: Arn;
    }
    export interface StopDataCollectionResponse {
        message?: Message;
    }
    export interface Tag {
        Key?: TagKey;
        Value?: TagValue;
    }
    export interface Telemetry {
        status?: TelemetryStatus;
        messageTypeTelemetries?: MessageTypeTelemetryList;
    }
    export interface TimestampRange {
        minimum?: Timestamp;
        maximum?: Timestamp;
    }
    export interface UpdateApplicationRequest {
        applicationArn?: Arn;
        applicationName?: Name;
        resourceGroupArn?: Arn;
    }
    export interface UpdateApplicationResponse {
        message?: Message;
    }
    export interface UpdateAssessmentRequest {
        assessmentArn?: Arn;
        assessmentName?: Name;
        durationInSeconds?: Duration;
    }
    export interface UpdateAssessmentResponse {
        message?: Message;
    }
  }

  /*
   * apiVersion: 2015-05-28
   * endpointPrefix: iot
   * serviceAbbreviation: 
   * signatureVersion: v4
   * protocol: rest-json
   */
  export class Iot extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    acceptCertificateTransfer(params: Iot.AcceptCertificateTransferRequest, callback?: (err: Iot.ResourceNotFoundException|Iot.TransferAlreadyCompletedException|Iot.InvalidRequestException|Iot.ThrottlingException|Iot.UnauthorizedException|Iot.ServiceUnavailableException|Iot.InternalFailureException|any, data: any) => void): Request;
    attachPrincipalPolicy(params: Iot.AttachPrincipalPolicyRequest, callback?: (err: Iot.ResourceNotFoundException|Iot.InvalidRequestException|Iot.ThrottlingException|Iot.UnauthorizedException|Iot.ServiceUnavailableException|Iot.InternalFailureException|Iot.LimitExceededException|any, data: any) => void): Request;
    attachThingPrincipal(params: Iot.AttachThingPrincipalRequest, callback?: (err: Iot.ResourceNotFoundException|Iot.InvalidRequestException|Iot.ThrottlingException|Iot.UnauthorizedException|Iot.ServiceUnavailableException|Iot.InternalFailureException|any, data: Iot.AttachThingPrincipalResponse|any) => void): Request;
    cancelCertificateTransfer(params: Iot.CancelCertificateTransferRequest, callback?: (err: Iot.ResourceNotFoundException|Iot.TransferAlreadyCompletedException|Iot.InvalidRequestException|Iot.ThrottlingException|Iot.UnauthorizedException|Iot.ServiceUnavailableException|Iot.InternalFailureException|any, data: any) => void): Request;
    createCertificateFromCsr(params: Iot.CreateCertificateFromCsrRequest, callback?: (err: Iot.InvalidRequestException|Iot.ThrottlingException|Iot.UnauthorizedException|Iot.ServiceUnavailableException|Iot.InternalFailureException|any, data: Iot.CreateCertificateFromCsrResponse|any) => void): Request;
    createKeysAndCertificate(params: Iot.CreateKeysAndCertificateRequest, callback?: (err: Iot.InvalidRequestException|Iot.ThrottlingException|Iot.UnauthorizedException|Iot.ServiceUnavailableException|Iot.InternalFailureException|any, data: Iot.CreateKeysAndCertificateResponse|any) => void): Request;
    createPolicy(params: Iot.CreatePolicyRequest, callback?: (err: Iot.ResourceAlreadyExistsException|Iot.MalformedPolicyException|Iot.InvalidRequestException|Iot.ThrottlingException|Iot.UnauthorizedException|Iot.ServiceUnavailableException|Iot.InternalFailureException|any, data: Iot.CreatePolicyResponse|any) => void): Request;
    createPolicyVersion(params: Iot.CreatePolicyVersionRequest, callback?: (err: Iot.ResourceNotFoundException|Iot.MalformedPolicyException|Iot.VersionsLimitExceededException|Iot.InvalidRequestException|Iot.ThrottlingException|Iot.UnauthorizedException|Iot.ServiceUnavailableException|Iot.InternalFailureException|any, data: Iot.CreatePolicyVersionResponse|any) => void): Request;
    createThing(params: Iot.CreateThingRequest, callback?: (err: Iot.InvalidRequestException|Iot.ThrottlingException|Iot.UnauthorizedException|Iot.ServiceUnavailableException|Iot.InternalFailureException|Iot.ResourceAlreadyExistsException|any, data: Iot.CreateThingResponse|any) => void): Request;
    createTopicRule(params: Iot.CreateTopicRuleRequest, callback?: (err: Iot.SqlParseException|Iot.InternalException|Iot.InvalidRequestException|Iot.ResourceAlreadyExistsException|Iot.ServiceUnavailableException|any, data: any) => void): Request;
    deleteCertificate(params: Iot.DeleteCertificateRequest, callback?: (err: Iot.DeleteConflictException|Iot.ResourceNotFoundException|Iot.CertificateStateException|any, data: any) => void): Request;
    deletePolicy(params: Iot.DeletePolicyRequest, callback?: (err: Iot.DeleteConflictException|Iot.ResourceNotFoundException|Iot.InvalidRequestException|Iot.ThrottlingException|Iot.UnauthorizedException|Iot.ServiceUnavailableException|Iot.InternalFailureException|any, data: any) => void): Request;
    deletePolicyVersion(params: Iot.DeletePolicyVersionRequest, callback?: (err: Iot.DeleteConflictException|Iot.ResourceNotFoundException|Iot.InvalidRequestException|Iot.ThrottlingException|Iot.UnauthorizedException|Iot.ServiceUnavailableException|Iot.InternalFailureException|any, data: any) => void): Request;
    deleteThing(params: Iot.DeleteThingRequest, callback?: (err: Iot.ResourceNotFoundException|Iot.InvalidRequestException|Iot.ThrottlingException|Iot.UnauthorizedException|Iot.ServiceUnavailableException|Iot.InternalFailureException|any, data: Iot.DeleteThingResponse|any) => void): Request;
    deleteTopicRule(params: Iot.DeleteTopicRuleRequest, callback?: (err: Iot.InternalException|Iot.InvalidRequestException|Iot.ServiceUnavailableException|Iot.UnauthorizedException|any, data: any) => void): Request;
    describeCertificate(params: Iot.DescribeCertificateRequest, callback?: (err: Iot.InvalidRequestException|Iot.ThrottlingException|Iot.UnauthorizedException|Iot.ServiceUnavailableException|Iot.InternalFailureException|Iot.ResourceNotFoundException|any, data: Iot.DescribeCertificateResponse|any) => void): Request;
    describeEndpoint(params: Iot.DescribeEndpointRequest, callback?: (err: Iot.InternalFailureException|Iot.UnauthorizedException|Iot.ThrottlingException|any, data: Iot.DescribeEndpointResponse|any) => void): Request;
    describeThing(params: Iot.DescribeThingRequest, callback?: (err: Iot.ResourceNotFoundException|Iot.InvalidRequestException|Iot.ThrottlingException|Iot.UnauthorizedException|Iot.ServiceUnavailableException|Iot.InternalFailureException|any, data: Iot.DescribeThingResponse|any) => void): Request;
    detachPrincipalPolicy(params: Iot.DetachPrincipalPolicyRequest, callback?: (err: Iot.ResourceNotFoundException|Iot.InvalidRequestException|Iot.ThrottlingException|Iot.UnauthorizedException|Iot.ServiceUnavailableException|Iot.InternalFailureException|any, data: any) => void): Request;
    detachThingPrincipal(params: Iot.DetachThingPrincipalRequest, callback?: (err: Iot.ResourceNotFoundException|Iot.InvalidRequestException|Iot.ThrottlingException|Iot.UnauthorizedException|Iot.ServiceUnavailableException|Iot.InternalFailureException|any, data: Iot.DetachThingPrincipalResponse|any) => void): Request;
    disableTopicRule(params: Iot.DisableTopicRuleRequest, callback?: (err: Iot.InternalException|Iot.InvalidRequestException|Iot.ServiceUnavailableException|Iot.UnauthorizedException|any, data: any) => void): Request;
    enableTopicRule(params: Iot.EnableTopicRuleRequest, callback?: (err: Iot.InternalException|Iot.InvalidRequestException|Iot.ServiceUnavailableException|Iot.UnauthorizedException|any, data: any) => void): Request;
    getLoggingOptions(params: Iot.GetLoggingOptionsRequest, callback?: (err: Iot.InternalException|Iot.InvalidRequestException|Iot.ServiceUnavailableException|any, data: Iot.GetLoggingOptionsResponse|any) => void): Request;
    getPolicy(params: Iot.GetPolicyRequest, callback?: (err: Iot.ResourceNotFoundException|Iot.InvalidRequestException|Iot.ThrottlingException|Iot.UnauthorizedException|Iot.ServiceUnavailableException|Iot.InternalFailureException|any, data: Iot.GetPolicyResponse|any) => void): Request;
    getPolicyVersion(params: Iot.GetPolicyVersionRequest, callback?: (err: Iot.ResourceNotFoundException|Iot.InvalidRequestException|Iot.ThrottlingException|Iot.UnauthorizedException|Iot.ServiceUnavailableException|Iot.InternalFailureException|any, data: Iot.GetPolicyVersionResponse|any) => void): Request;
    getTopicRule(params: Iot.GetTopicRuleRequest, callback?: (err: Iot.InternalException|Iot.InvalidRequestException|Iot.ServiceUnavailableException|Iot.UnauthorizedException|any, data: Iot.GetTopicRuleResponse|any) => void): Request;
    listCertificates(params: Iot.ListCertificatesRequest, callback?: (err: Iot.InvalidRequestException|Iot.ThrottlingException|Iot.UnauthorizedException|Iot.ServiceUnavailableException|Iot.InternalFailureException|any, data: Iot.ListCertificatesResponse|any) => void): Request;
    listPolicies(params: Iot.ListPoliciesRequest, callback?: (err: Iot.InvalidRequestException|Iot.ThrottlingException|Iot.UnauthorizedException|Iot.ServiceUnavailableException|Iot.InternalFailureException|any, data: Iot.ListPoliciesResponse|any) => void): Request;
    listPolicyVersions(params: Iot.ListPolicyVersionsRequest, callback?: (err: Iot.ResourceNotFoundException|Iot.InvalidRequestException|Iot.ThrottlingException|Iot.UnauthorizedException|Iot.ServiceUnavailableException|Iot.InternalFailureException|any, data: Iot.ListPolicyVersionsResponse|any) => void): Request;
    listPrincipalPolicies(params: Iot.ListPrincipalPoliciesRequest, callback?: (err: Iot.ResourceNotFoundException|Iot.InvalidRequestException|Iot.ThrottlingException|Iot.UnauthorizedException|Iot.ServiceUnavailableException|Iot.InternalFailureException|any, data: Iot.ListPrincipalPoliciesResponse|any) => void): Request;
    listPrincipalThings(params: Iot.ListPrincipalThingsRequest, callback?: (err: Iot.InvalidRequestException|Iot.ThrottlingException|Iot.UnauthorizedException|Iot.ServiceUnavailableException|Iot.InternalFailureException|any, data: Iot.ListPrincipalThingsResponse|any) => void): Request;
    listThingPrincipals(params: Iot.ListThingPrincipalsRequest, callback?: (err: Iot.InvalidRequestException|Iot.ThrottlingException|Iot.UnauthorizedException|Iot.ServiceUnavailableException|Iot.InternalFailureException|any, data: Iot.ListThingPrincipalsResponse|any) => void): Request;
    listThings(params: Iot.ListThingsRequest, callback?: (err: Iot.InvalidRequestException|Iot.ThrottlingException|Iot.UnauthorizedException|Iot.ServiceUnavailableException|Iot.InternalFailureException|any, data: Iot.ListThingsResponse|any) => void): Request;
    listTopicRules(params: Iot.ListTopicRulesRequest, callback?: (err: Iot.InternalException|Iot.InvalidRequestException|Iot.ServiceUnavailableException|any, data: Iot.ListTopicRulesResponse|any) => void): Request;
    rejectCertificateTransfer(params: Iot.RejectCertificateTransferRequest, callback?: (err: Iot.ResourceNotFoundException|Iot.TransferAlreadyCompletedException|Iot.InvalidRequestException|Iot.ThrottlingException|Iot.UnauthorizedException|Iot.ServiceUnavailableException|Iot.InternalFailureException|any, data: any) => void): Request;
    replaceTopicRule(params: Iot.ReplaceTopicRuleRequest, callback?: (err: Iot.SqlParseException|Iot.InternalException|Iot.InvalidRequestException|Iot.ServiceUnavailableException|Iot.UnauthorizedException|any, data: any) => void): Request;
    setDefaultPolicyVersion(params: Iot.SetDefaultPolicyVersionRequest, callback?: (err: Iot.ResourceNotFoundException|Iot.InvalidRequestException|Iot.ThrottlingException|Iot.UnauthorizedException|Iot.ServiceUnavailableException|Iot.InternalFailureException|any, data: any) => void): Request;
    setLoggingOptions(params: Iot.SetLoggingOptionsRequest, callback?: (err: Iot.InternalException|Iot.InvalidRequestException|Iot.ServiceUnavailableException|any, data: any) => void): Request;
    transferCertificate(params: Iot.TransferCertificateRequest, callback?: (err: Iot.InvalidRequestException|Iot.ResourceNotFoundException|Iot.CertificateStateException|Iot.TransferConflictException|Iot.ThrottlingException|Iot.UnauthorizedException|Iot.ServiceUnavailableException|Iot.InternalFailureException|any, data: Iot.TransferCertificateResponse|any) => void): Request;
    updateCertificate(params: Iot.UpdateCertificateRequest, callback?: (err: Iot.ResourceNotFoundException|Iot.CertificateStateException|Iot.InvalidRequestException|Iot.ThrottlingException|Iot.UnauthorizedException|Iot.ServiceUnavailableException|Iot.InternalFailureException|any, data: any) => void): Request;
    updateThing(params: Iot.UpdateThingRequest, callback?: (err: Iot.InvalidRequestException|Iot.ThrottlingException|Iot.UnauthorizedException|Iot.ServiceUnavailableException|Iot.InternalFailureException|Iot.ResourceNotFoundException|any, data: Iot.UpdateThingResponse|any) => void): Request;

  }

  export module Iot {
    export type ActionList = Action[];    // max: 10
    export type AlarmName = string;
    export type AscendingOrder = boolean;
    export type AttributeName = string;    // pattern: &quot;[a-zA-Z0-9_.,@/:#-]+&quot;, max: 128
    export type AttributeValue = string;    // pattern: &quot;[a-zA-Z0-9_.,@/:#-]+&quot;, max: 1024
    export type Attributes = {[key:string]: AttributeValue};
    export type AwsAccountId = string;    // pattern: &quot;[0-9]{12}&quot;
    export type AwsArn = string;
    export type BucketName = string;
    export type CertificateArn = string;
    export type CertificateId = string;    // pattern: &quot;(0x)?[a-fA-F0-9]+&quot;, max: 64, min: 64
    export type CertificatePem = string;    // min: 1
    export type CertificateSigningRequest = string;    // min: 1
    export type CertificateStatus = string;
    export type Certificates = Certificate[];
    export type ClientId = string;
    export type CreatedAtDate = number;
    export type DateType = number;
    export type DeliveryStreamName = string;
    export type Description = string;
    export type ElasticsearchEndpoint = string;    // pattern: &quot;https?://.*&quot;
    export type ElasticsearchId = string;
    export type ElasticsearchIndex = string;
    export type ElasticsearchType = string;
    export type EndpointAddress = string;
    export type FunctionArn = string;
    export type HashKeyField = string;
    export type HashKeyValue = string;
    export type IsDefaultVersion = boolean;
    export type IsDisabled = boolean;
    export type Key = string;
    export type LogLevel = string;
    export type Marker = string;
    export type MaxResults = number;    // max: 10000, min: 1
    export type MessageFormat = string;
    export type MetricName = string;
    export type MetricNamespace = string;
    export type MetricTimestamp = string;
    export type MetricUnit = string;
    export type MetricValue = string;
    export type NextToken = string;
    export type PageSize = number;    // max: 250, min: 1
    export type PartitionKey = string;
    export type PayloadField = string;
    export type Policies = Policy[];
    export type PolicyArn = string;
    export type PolicyDocument = string;
    export type PolicyName = string;    // pattern: &quot;[\w+=,.@-]+&quot;, max: 128, min: 1
    export type PolicyVersionId = string;    // pattern: &quot;[0-9]+&quot;
    export type PolicyVersions = PolicyVersion[];
    export type Principal = string;
    export type PrincipalArn = string;
    export type Principals = PrincipalArn[];
    export type PrivateKey = string;    // min: 1
    export type PublicKey = string;    // min: 1
    export type QueueUrl = string;
    export type RangeKeyField = string;
    export type RangeKeyValue = string;
    export type RuleArn = string;
    export type RuleName = string;    // pattern: &quot;^[a-zA-Z0-9_]+$&quot;, max: 128, min: 1
    export type SQL = string;
    export type SetAsActive = boolean;
    export type SetAsDefault = boolean;
    export type StateReason = string;
    export type StateValue = string;
    export type StreamName = string;
    export type TableName = string;
    export type ThingArn = string;
    export type ThingAttributeList = ThingAttribute[];
    export type ThingName = string;    // pattern: &quot;[a-zA-Z0-9_-]+&quot;, max: 128, min: 1
    export type ThingNameList = ThingName[];
    export type Topic = string;
    export type TopicPattern = string;
    export type TopicRuleList = TopicRuleListItem[];
    export type UseBase64 = boolean;
    export type errorMessage = string;

    export interface AcceptCertificateTransferRequest {
        certificateId: CertificateId;
        setAsActive?: SetAsActive;
    }
    export interface Action {
        dynamoDB?: DynamoDBAction;
        lambda?: LambdaAction;
        sns?: SnsAction;
        sqs?: SqsAction;
        kinesis?: KinesisAction;
        republish?: RepublishAction;
        s3?: S3Action;
        firehose?: FirehoseAction;
        cloudwatchMetric?: CloudwatchMetricAction;
        cloudwatchAlarm?: CloudwatchAlarmAction;
        elasticsearch?: ElasticsearchAction;
    }
    export interface AttachPrincipalPolicyRequest {
        policyName: PolicyName;
        principal: Principal;
    }
    export interface AttachThingPrincipalRequest {
        thingName: ThingName;
        principal: Principal;
    }
    export interface AttachThingPrincipalResponse {
    }
    export interface AttributePayload {
        attributes?: Attributes;
    }
    export interface CancelCertificateTransferRequest {
        certificateId: CertificateId;
    }
    export interface Certificate {
        certificateArn?: CertificateArn;
        certificateId?: CertificateId;
        status?: CertificateStatus;
        creationDate?: DateType;
    }
    export interface CertificateDescription {
        certificateArn?: CertificateArn;
        certificateId?: CertificateId;
        status?: CertificateStatus;
        certificatePem?: CertificatePem;
        ownedBy?: AwsAccountId;
        creationDate?: DateType;
        lastModifiedDate?: DateType;
    }
    export interface CertificateStateException {
        message?: errorMessage;
    }
    export interface CloudwatchAlarmAction {
        roleArn: AwsArn;
        alarmName: AlarmName;
        stateReason: StateReason;
        stateValue: StateValue;
    }
    export interface CloudwatchMetricAction {
        roleArn: AwsArn;
        metricNamespace: MetricNamespace;
        metricName: MetricName;
        metricValue: MetricValue;
        metricUnit: MetricUnit;
        metricTimestamp?: MetricTimestamp;
    }
    export interface CreateCertificateFromCsrRequest {
        certificateSigningRequest: CertificateSigningRequest;
        setAsActive?: SetAsActive;
    }
    export interface CreateCertificateFromCsrResponse {
        certificateArn?: CertificateArn;
        certificateId?: CertificateId;
        certificatePem?: CertificatePem;
    }
    export interface CreateKeysAndCertificateRequest {
        setAsActive?: SetAsActive;
    }
    export interface CreateKeysAndCertificateResponse {
        certificateArn?: CertificateArn;
        certificateId?: CertificateId;
        certificatePem?: CertificatePem;
        keyPair?: KeyPair;
    }
    export interface CreatePolicyRequest {
        policyName: PolicyName;
        policyDocument: PolicyDocument;
    }
    export interface CreatePolicyResponse {
        policyName?: PolicyName;
        policyArn?: PolicyArn;
        policyDocument?: PolicyDocument;
        policyVersionId?: PolicyVersionId;
    }
    export interface CreatePolicyVersionRequest {
        policyName: PolicyName;
        policyDocument: PolicyDocument;
        setAsDefault?: SetAsDefault;
    }
    export interface CreatePolicyVersionResponse {
        policyArn?: PolicyArn;
        policyDocument?: PolicyDocument;
        policyVersionId?: PolicyVersionId;
        isDefaultVersion?: IsDefaultVersion;
    }
    export interface CreateThingRequest {
        thingName: ThingName;
        attributePayload?: AttributePayload;
    }
    export interface CreateThingResponse {
        thingName?: ThingName;
        thingArn?: ThingArn;
    }
    export interface CreateTopicRuleRequest {
        ruleName: RuleName;
        topicRulePayload: TopicRulePayload;
    }
    export interface DeleteCertificateRequest {
        certificateId: CertificateId;
    }
    export interface DeleteConflictException {
        message?: errorMessage;
    }
    export interface DeletePolicyRequest {
        policyName: PolicyName;
    }
    export interface DeletePolicyVersionRequest {
        policyName: PolicyName;
        policyVersionId: PolicyVersionId;
    }
    export interface DeleteThingRequest {
        thingName: ThingName;
    }
    export interface DeleteThingResponse {
    }
    export interface DeleteTopicRuleRequest {
        ruleName: RuleName;
    }
    export interface DescribeCertificateRequest {
        certificateId: CertificateId;
    }
    export interface DescribeCertificateResponse {
        certificateDescription?: CertificateDescription;
    }
    export interface DescribeEndpointRequest {
    }
    export interface DescribeEndpointResponse {
        endpointAddress?: EndpointAddress;
    }
    export interface DescribeThingRequest {
        thingName: ThingName;
    }
    export interface DescribeThingResponse {
        defaultClientId?: ClientId;
        thingName?: ThingName;
        attributes?: Attributes;
    }
    export interface DetachPrincipalPolicyRequest {
        policyName: PolicyName;
        principal: Principal;
    }
    export interface DetachThingPrincipalRequest {
        thingName: ThingName;
        principal: Principal;
    }
    export interface DetachThingPrincipalResponse {
    }
    export interface DisableTopicRuleRequest {
        ruleName: RuleName;
    }
    export interface DynamoDBAction {
        tableName: TableName;
        roleArn: AwsArn;
        hashKeyField: HashKeyField;
        hashKeyValue: HashKeyValue;
        rangeKeyField: RangeKeyField;
        rangeKeyValue: RangeKeyValue;
        payloadField?: PayloadField;
    }
    export interface ElasticsearchAction {
        roleArn: AwsArn;
        endpoint: ElasticsearchEndpoint;
        index: ElasticsearchIndex;
        type: ElasticsearchType;
        id: ElasticsearchId;
    }
    export interface EnableTopicRuleRequest {
        ruleName: RuleName;
    }
    export interface FirehoseAction {
        roleArn: AwsArn;
        deliveryStreamName: DeliveryStreamName;
    }
    export interface GetLoggingOptionsRequest {
    }
    export interface GetLoggingOptionsResponse {
        roleArn?: AwsArn;
        logLevel?: LogLevel;
    }
    export interface GetPolicyRequest {
        policyName: PolicyName;
    }
    export interface GetPolicyResponse {
        policyName?: PolicyName;
        policyArn?: PolicyArn;
        policyDocument?: PolicyDocument;
        defaultVersionId?: PolicyVersionId;
    }
    export interface GetPolicyVersionRequest {
        policyName: PolicyName;
        policyVersionId: PolicyVersionId;
    }
    export interface GetPolicyVersionResponse {
        policyArn?: PolicyArn;
        policyName?: PolicyName;
        policyDocument?: PolicyDocument;
        policyVersionId?: PolicyVersionId;
        isDefaultVersion?: IsDefaultVersion;
    }
    export interface GetTopicRuleRequest {
        ruleName: RuleName;
    }
    export interface GetTopicRuleResponse {
        ruleArn?: RuleArn;
        rule?: TopicRule;
    }
    export interface InternalException {
        message?: errorMessage;
    }
    export interface InternalFailureException {
        message?: errorMessage;
    }
    export interface InvalidRequestException {
        message?: errorMessage;
    }
    export interface KeyPair {
        PublicKey?: PublicKey;
        PrivateKey?: PrivateKey;
    }
    export interface KinesisAction {
        roleArn: AwsArn;
        streamName: StreamName;
        partitionKey?: PartitionKey;
    }
    export interface LambdaAction {
        functionArn: FunctionArn;
    }
    export interface LimitExceededException {
        message?: errorMessage;
    }
    export interface ListCertificatesRequest {
        pageSize?: PageSize;
        marker?: Marker;
        ascendingOrder?: AscendingOrder;
    }
    export interface ListCertificatesResponse {
        certificates?: Certificates;
        nextMarker?: Marker;
    }
    export interface ListPoliciesRequest {
        marker?: Marker;
        pageSize?: PageSize;
        ascendingOrder?: AscendingOrder;
    }
    export interface ListPoliciesResponse {
        policies?: Policies;
        nextMarker?: Marker;
    }
    export interface ListPolicyVersionsRequest {
        policyName: PolicyName;
    }
    export interface ListPolicyVersionsResponse {
        policyVersions?: PolicyVersions;
    }
    export interface ListPrincipalPoliciesRequest {
        principal: Principal;
        marker?: Marker;
        pageSize?: PageSize;
        ascendingOrder?: AscendingOrder;
    }
    export interface ListPrincipalPoliciesResponse {
        policies?: Policies;
        nextMarker?: Marker;
    }
    export interface ListPrincipalThingsRequest {
        nextToken?: NextToken;
        maxResults?: MaxResults;
        principal: Principal;
    }
    export interface ListPrincipalThingsResponse {
        things?: ThingNameList;
        nextToken?: NextToken;
    }
    export interface ListThingPrincipalsRequest {
        thingName: ThingName;
    }
    export interface ListThingPrincipalsResponse {
        principals?: Principals;
    }
    export interface ListThingsRequest {
        nextToken?: NextToken;
        maxResults?: MaxResults;
        attributeName?: AttributeName;
        attributeValue?: AttributeValue;
    }
    export interface ListThingsResponse {
        things?: ThingAttributeList;
        nextToken?: NextToken;
    }
    export interface ListTopicRulesRequest {
        topic?: Topic;
        maxResults?: MaxResults;
        nextToken?: NextToken;
        ruleDisabled?: IsDisabled;
    }
    export interface ListTopicRulesResponse {
        rules?: TopicRuleList;
        nextToken?: NextToken;
    }
    export interface LoggingOptionsPayload {
        roleArn: AwsArn;
        logLevel?: LogLevel;
    }
    export interface MalformedPolicyException {
        message?: errorMessage;
    }
    export interface Policy {
        policyName?: PolicyName;
        policyArn?: PolicyArn;
    }
    export interface PolicyVersion {
        versionId?: PolicyVersionId;
        isDefaultVersion?: IsDefaultVersion;
        createDate?: DateType;
    }
    export interface RejectCertificateTransferRequest {
        certificateId: CertificateId;
    }
    export interface ReplaceTopicRuleRequest {
        ruleName: RuleName;
        topicRulePayload: TopicRulePayload;
    }
    export interface RepublishAction {
        roleArn: AwsArn;
        topic: TopicPattern;
    }
    export interface ResourceAlreadyExistsException {
        message?: errorMessage;
    }
    export interface ResourceNotFoundException {
        message?: errorMessage;
    }
    export interface S3Action {
        roleArn: AwsArn;
        bucketName: BucketName;
        key: Key;
    }
    export interface ServiceUnavailableException {
        message?: errorMessage;
    }
    export interface SetDefaultPolicyVersionRequest {
        policyName: PolicyName;
        policyVersionId: PolicyVersionId;
    }
    export interface SetLoggingOptionsRequest {
        loggingOptionsPayload: LoggingOptionsPayload;
    }
    export interface SnsAction {
        targetArn: AwsArn;
        roleArn: AwsArn;
        messageFormat?: MessageFormat;
    }
    export interface SqlParseException {
        message?: errorMessage;
    }
    export interface SqsAction {
        roleArn: AwsArn;
        queueUrl: QueueUrl;
        useBase64?: UseBase64;
    }
    export interface ThingAttribute {
        thingName?: ThingName;
        attributes?: Attributes;
    }
    export interface ThrottlingException {
        message?: errorMessage;
    }
    export interface TopicRule {
        ruleName?: RuleName;
        sql?: SQL;
        description?: Description;
        createdAt?: CreatedAtDate;
        actions?: ActionList;
        ruleDisabled?: IsDisabled;
    }
    export interface TopicRuleListItem {
        ruleArn?: RuleArn;
        ruleName?: RuleName;
        topicPattern?: TopicPattern;
        createdAt?: CreatedAtDate;
        ruleDisabled?: IsDisabled;
    }
    export interface TopicRulePayload {
        sql: SQL;
        description?: Description;
        actions: ActionList;
        ruleDisabled?: IsDisabled;
    }
    export interface TransferAlreadyCompletedException {
        message?: errorMessage;
    }
    export interface TransferCertificateRequest {
        certificateId: CertificateId;
        targetAwsAccount: AwsAccountId;
    }
    export interface TransferCertificateResponse {
        transferredCertificateArn?: CertificateArn;
    }
    export interface TransferConflictException {
        message?: errorMessage;
    }
    export interface UnauthorizedException {
        message?: errorMessage;
    }
    export interface UpdateCertificateRequest {
        certificateId: CertificateId;
        newStatus: CertificateStatus;
    }
    export interface UpdateThingRequest {
        thingName: ThingName;
        attributePayload: AttributePayload;
    }
    export interface UpdateThingResponse {
    }
    export interface VersionsLimitExceededException {
        message?: errorMessage;
    }
  }

  /*
   * apiVersion: 2015-05-28
   * endpointPrefix: data.iot
   * serviceAbbreviation: 
   * signatureVersion: v4
   * protocol: rest-json
   */
  export class IotData extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    deleteThingShadow(params: IotData.DeleteThingShadowRequest, callback?: (err: IotData.ResourceNotFoundException|IotData.InvalidRequestException|IotData.ThrottlingException|IotData.UnauthorizedException|IotData.ServiceUnavailableException|IotData.InternalFailureException|IotData.MethodNotAllowedException|IotData.UnsupportedDocumentEncodingException|any, data: IotData.DeleteThingShadowResponse|any) => void): Request;
    getThingShadow(params: IotData.GetThingShadowRequest, callback?: (err: IotData.InvalidRequestException|IotData.ResourceNotFoundException|IotData.ThrottlingException|IotData.UnauthorizedException|IotData.ServiceUnavailableException|IotData.InternalFailureException|IotData.MethodNotAllowedException|IotData.UnsupportedDocumentEncodingException|any, data: IotData.GetThingShadowResponse|any) => void): Request;
    publish(params: IotData.PublishRequest, callback?: (err: IotData.InternalFailureException|IotData.InvalidRequestException|IotData.UnauthorizedException|IotData.MethodNotAllowedException|any, data: any) => void): Request;
    updateThingShadow(params: IotData.UpdateThingShadowRequest, callback?: (err: IotData.ConflictException|IotData.RequestEntityTooLargeException|IotData.InvalidRequestException|IotData.ThrottlingException|IotData.UnauthorizedException|IotData.ServiceUnavailableException|IotData.InternalFailureException|IotData.MethodNotAllowedException|IotData.UnsupportedDocumentEncodingException|any, data: IotData.UpdateThingShadowResponse|any) => void): Request;

  }

  export module IotData {
    export type ErrorMessage = string;
    export type JsonDocument = any;    // type: blob
    export type Payload = any;    // type: blob
    export type Qos = number;    // max: 1
    export type ThingName = string;    // pattern: &quot;[a-zA-Z0-9_-]+&quot;, max: 128, min: 1
    export type Topic = string;
    export type errorMessage = string;

    export interface ConflictException {
        message?: ErrorMessage;
    }
    export interface DeleteThingShadowRequest {
        thingName: ThingName;
    }
    export interface DeleteThingShadowResponse {
        payload: JsonDocument;
    }
    export interface GetThingShadowRequest {
        thingName: ThingName;
    }
    export interface GetThingShadowResponse {
        payload?: JsonDocument;
    }
    export interface InternalFailureException {
        message?: errorMessage;
    }
    export interface InvalidRequestException {
        message?: errorMessage;
    }
    export interface MethodNotAllowedException {
        message?: ErrorMessage;
    }
    export interface PublishRequest {
        topic: Topic;
        qos?: Qos;
        payload?: Payload;
    }
    export interface RequestEntityTooLargeException {
        message?: ErrorMessage;
    }
    export interface ResourceNotFoundException {
        message?: errorMessage;
    }
    export interface ServiceUnavailableException {
        message?: errorMessage;
    }
    export interface ThrottlingException {
        message?: errorMessage;
    }
    export interface UnauthorizedException {
        message?: errorMessage;
    }
    export interface UnsupportedDocumentEncodingException {
        message?: errorMessage;
    }
    export interface UpdateThingShadowRequest {
        thingName: ThingName;
        payload: JsonDocument;
    }
    export interface UpdateThingShadowResponse {
        payload?: JsonDocument;
    }
  }

  /*
   * apiVersion: 2013-12-02
   * endpointPrefix: kinesis
   * serviceAbbreviation: Kinesis
   * signatureVersion: v4
   * protocol: json
   */
  export class Kinesis extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    addTagsToStream(params: Kinesis.AddTagsToStreamInput, callback?: (err: Kinesis.ResourceNotFoundException|Kinesis.ResourceInUseException|Kinesis.InvalidArgumentException|Kinesis.LimitExceededException|any, data: any) => void): Request;
    createStream(params: Kinesis.CreateStreamInput, callback?: (err: Kinesis.ResourceInUseException|Kinesis.LimitExceededException|Kinesis.InvalidArgumentException|any, data: any) => void): Request;
    decreaseStreamRetentionPeriod(params: Kinesis.DecreaseStreamRetentionPeriodInput, callback?: (err: Kinesis.ResourceInUseException|Kinesis.ResourceNotFoundException|Kinesis.LimitExceededException|Kinesis.InvalidArgumentException|any, data: any) => void): Request;
    deleteStream(params: Kinesis.DeleteStreamInput, callback?: (err: Kinesis.ResourceNotFoundException|Kinesis.LimitExceededException|any, data: any) => void): Request;
    describeStream(params: Kinesis.DescribeStreamInput, callback?: (err: Kinesis.ResourceNotFoundException|Kinesis.LimitExceededException|any, data: Kinesis.DescribeStreamOutput|any) => void): Request;
    getRecords(params: Kinesis.GetRecordsInput, callback?: (err: Kinesis.ResourceNotFoundException|Kinesis.InvalidArgumentException|Kinesis.ProvisionedThroughputExceededException|Kinesis.ExpiredIteratorException|any, data: Kinesis.GetRecordsOutput|any) => void): Request;
    getShardIterator(params: Kinesis.GetShardIteratorInput, callback?: (err: Kinesis.ResourceNotFoundException|Kinesis.InvalidArgumentException|Kinesis.ProvisionedThroughputExceededException|any, data: Kinesis.GetShardIteratorOutput|any) => void): Request;
    increaseStreamRetentionPeriod(params: Kinesis.IncreaseStreamRetentionPeriodInput, callback?: (err: Kinesis.ResourceInUseException|Kinesis.ResourceNotFoundException|Kinesis.LimitExceededException|Kinesis.InvalidArgumentException|any, data: any) => void): Request;
    listStreams(params: Kinesis.ListStreamsInput, callback?: (err: Kinesis.LimitExceededException|any, data: Kinesis.ListStreamsOutput|any) => void): Request;
    listTagsForStream(params: Kinesis.ListTagsForStreamInput, callback?: (err: Kinesis.ResourceNotFoundException|Kinesis.InvalidArgumentException|Kinesis.LimitExceededException|any, data: Kinesis.ListTagsForStreamOutput|any) => void): Request;
    mergeShards(params: Kinesis.MergeShardsInput, callback?: (err: Kinesis.ResourceNotFoundException|Kinesis.ResourceInUseException|Kinesis.InvalidArgumentException|Kinesis.LimitExceededException|any, data: any) => void): Request;
    putRecord(params: Kinesis.PutRecordInput, callback?: (err: Kinesis.ResourceNotFoundException|Kinesis.InvalidArgumentException|Kinesis.ProvisionedThroughputExceededException|any, data: Kinesis.PutRecordOutput|any) => void): Request;
    putRecords(params: Kinesis.PutRecordsInput, callback?: (err: Kinesis.ResourceNotFoundException|Kinesis.InvalidArgumentException|Kinesis.ProvisionedThroughputExceededException|any, data: Kinesis.PutRecordsOutput|any) => void): Request;
    removeTagsFromStream(params: Kinesis.RemoveTagsFromStreamInput, callback?: (err: Kinesis.ResourceNotFoundException|Kinesis.ResourceInUseException|Kinesis.InvalidArgumentException|Kinesis.LimitExceededException|any, data: any) => void): Request;
    splitShard(params: Kinesis.SplitShardInput, callback?: (err: Kinesis.ResourceNotFoundException|Kinesis.ResourceInUseException|Kinesis.InvalidArgumentException|Kinesis.LimitExceededException|any, data: any) => void): Request;

  }

  export module Kinesis {
    export type ApproximateArrivalTimestamp = number;
    export type BooleanObject = boolean;
    export type Data = any;    // max: 1048576, type: blob
    export type DescribeStreamInputLimit = number;    // max: 10000, min: 1
    export type ErrorCode = string;
    export type ErrorMessage = string;
    export type GetRecordsInputLimit = number;    // max: 10000, min: 1
    export type HashKey = string;    // pattern: &quot;0|([1-9]\d{0,38})&quot;
    export type ListStreamsInputLimit = number;    // max: 10000, min: 1
    export type ListTagsForStreamInputLimit = number;    // max: 10, min: 1
    export type MillisBehindLatest = number;
    export type PartitionKey = string;    // max: 256, min: 1
    export type PositiveIntegerObject = number;    // max: 100000, min: 1
    export type PutRecordsRequestEntryList = PutRecordsRequestEntry[];    // max: 500, min: 1
    export type PutRecordsResultEntryList = PutRecordsResultEntry[];    // max: 500, min: 1
    export type RecordList = Record[];
    export type RetentionPeriodHours = number;    // max: 168, min: 24
    export type SequenceNumber = string;    // pattern: &quot;0|([1-9]\d{0,128})&quot;
    export type ShardId = string;    // pattern: &quot;[a-zA-Z0-9_.-]+&quot;, max: 128, min: 1
    export type ShardIterator = string;    // max: 512, min: 1
    export type ShardIteratorType = string;
    export type ShardList = Shard[];
    export type StreamARN = string;
    export type StreamName = string;    // pattern: &quot;[a-zA-Z0-9_.-]+&quot;, max: 128, min: 1
    export type StreamNameList = StreamName[];
    export type StreamStatus = string;
    export type TagKey = string;    // max: 128, min: 1
    export type TagKeyList = TagKey[];    // max: 10, min: 1
    export type TagList = Tag[];
    export type TagMap = {[key:string]: TagValue};    // max: 10, min: 1
    export type TagValue = string;    // max: 256

    export interface AddTagsToStreamInput {
        StreamName: StreamName;
        Tags: TagMap;
    }
    export interface CreateStreamInput {
        StreamName: StreamName;
        ShardCount: PositiveIntegerObject;
    }
    export interface DecreaseStreamRetentionPeriodInput {
        StreamName: StreamName;
        RetentionPeriodHours: RetentionPeriodHours;
    }
    export interface DeleteStreamInput {
        StreamName: StreamName;
    }
    export interface DescribeStreamInput {
        StreamName: StreamName;
        Limit?: DescribeStreamInputLimit;
        ExclusiveStartShardId?: ShardId;
    }
    export interface DescribeStreamOutput {
        StreamDescription: StreamDescription;
    }
    export interface ExpiredIteratorException {
        message?: ErrorMessage;
    }
    export interface GetRecordsInput {
        ShardIterator: ShardIterator;
        Limit?: GetRecordsInputLimit;
    }
    export interface GetRecordsOutput {
        Records: RecordList;
        NextShardIterator?: ShardIterator;
        MillisBehindLatest?: MillisBehindLatest;
    }
    export interface GetShardIteratorInput {
        StreamName: StreamName;
        ShardId: ShardId;
        ShardIteratorType: ShardIteratorType;
        StartingSequenceNumber?: SequenceNumber;
    }
    export interface GetShardIteratorOutput {
        ShardIterator?: ShardIterator;
    }
    export interface HashKeyRange {
        StartingHashKey: HashKey;
        EndingHashKey: HashKey;
    }
    export interface IncreaseStreamRetentionPeriodInput {
        StreamName: StreamName;
        RetentionPeriodHours: RetentionPeriodHours;
    }
    export interface InvalidArgumentException {
        message?: ErrorMessage;
    }
    export interface LimitExceededException {
        message?: ErrorMessage;
    }
    export interface ListStreamsInput {
        Limit?: ListStreamsInputLimit;
        ExclusiveStartStreamName?: StreamName;
    }
    export interface ListStreamsOutput {
        StreamNames: StreamNameList;
        HasMoreStreams: BooleanObject;
    }
    export interface ListTagsForStreamInput {
        StreamName: StreamName;
        ExclusiveStartTagKey?: TagKey;
        Limit?: ListTagsForStreamInputLimit;
    }
    export interface ListTagsForStreamOutput {
        Tags: TagList;
        HasMoreTags: BooleanObject;
    }
    export interface MergeShardsInput {
        StreamName: StreamName;
        ShardToMerge: ShardId;
        AdjacentShardToMerge: ShardId;
    }
    export interface ProvisionedThroughputExceededException {
        message?: ErrorMessage;
    }
    export interface PutRecordInput {
        StreamName: StreamName;
        Data: Data;
        PartitionKey: PartitionKey;
        ExplicitHashKey?: HashKey;
        SequenceNumberForOrdering?: SequenceNumber;
    }
    export interface PutRecordOutput {
        ShardId: ShardId;
        SequenceNumber: SequenceNumber;
    }
    export interface PutRecordsInput {
        Records: PutRecordsRequestEntryList;
        StreamName: StreamName;
    }
    export interface PutRecordsOutput {
        FailedRecordCount?: PositiveIntegerObject;
        Records: PutRecordsResultEntryList;
    }
    export interface PutRecordsRequestEntry {
        Data: Data;
        ExplicitHashKey?: HashKey;
        PartitionKey: PartitionKey;
    }
    export interface PutRecordsResultEntry {
        SequenceNumber?: SequenceNumber;
        ShardId?: ShardId;
        ErrorCode?: ErrorCode;
        ErrorMessage?: ErrorMessage;
    }
    export interface Record {
        SequenceNumber: SequenceNumber;
        ApproximateArrivalTimestamp?: ApproximateArrivalTimestamp;
        Data: Data;
        PartitionKey: PartitionKey;
    }
    export interface RemoveTagsFromStreamInput {
        StreamName: StreamName;
        TagKeys: TagKeyList;
    }
    export interface ResourceInUseException {
        message?: ErrorMessage;
    }
    export interface ResourceNotFoundException {
        message?: ErrorMessage;
    }
    export interface SequenceNumberRange {
        StartingSequenceNumber: SequenceNumber;
        EndingSequenceNumber?: SequenceNumber;
    }
    export interface Shard {
        ShardId: ShardId;
        ParentShardId?: ShardId;
        AdjacentParentShardId?: ShardId;
        HashKeyRange: HashKeyRange;
        SequenceNumberRange: SequenceNumberRange;
    }
    export interface SplitShardInput {
        StreamName: StreamName;
        ShardToSplit: ShardId;
        NewStartingHashKey: HashKey;
    }
    export interface StreamDescription {
        StreamName: StreamName;
        StreamARN: StreamARN;
        StreamStatus: StreamStatus;
        Shards: ShardList;
        HasMoreShards: BooleanObject;
        RetentionPeriodHours: RetentionPeriodHours;
    }
    export interface Tag {
        Key: TagKey;
        Value?: TagValue;
    }
  }

  /*
   * apiVersion: 2014-11-01
   * endpointPrefix: kms
   * serviceAbbreviation: KMS
   * signatureVersion: v4
   * protocol: json
   */
  export class KMS extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    cancelKeyDeletion(params: KMS.CancelKeyDeletionRequest, callback?: (err: KMS.NotFoundException|KMS.InvalidArnException|KMS.DependencyTimeoutException|KMS.KMSInternalException|KMS.KMSInvalidStateException|any, data: KMS.CancelKeyDeletionResponse|any) => void): Request;
    createAlias(params: KMS.CreateAliasRequest, callback?: (err: KMS.DependencyTimeoutException|KMS.AlreadyExistsException|KMS.NotFoundException|KMS.InvalidAliasNameException|KMS.KMSInternalException|KMS.LimitExceededException|KMS.KMSInvalidStateException|any, data: any) => void): Request;
    createGrant(params: KMS.CreateGrantRequest, callback?: (err: KMS.NotFoundException|KMS.DisabledException|KMS.DependencyTimeoutException|KMS.InvalidArnException|KMS.KMSInternalException|KMS.InvalidGrantTokenException|KMS.LimitExceededException|KMS.KMSInvalidStateException|any, data: KMS.CreateGrantResponse|any) => void): Request;
    createKey(params: KMS.CreateKeyRequest, callback?: (err: KMS.MalformedPolicyDocumentException|KMS.DependencyTimeoutException|KMS.InvalidArnException|KMS.UnsupportedOperationException|KMS.KMSInternalException|KMS.LimitExceededException|any, data: KMS.CreateKeyResponse|any) => void): Request;
    decrypt(params: KMS.DecryptRequest, callback?: (err: KMS.NotFoundException|KMS.DisabledException|KMS.InvalidCiphertextException|KMS.KeyUnavailableException|KMS.DependencyTimeoutException|KMS.InvalidGrantTokenException|KMS.KMSInternalException|KMS.KMSInvalidStateException|any, data: KMS.DecryptResponse|any) => void): Request;
    deleteAlias(params: KMS.DeleteAliasRequest, callback?: (err: KMS.DependencyTimeoutException|KMS.NotFoundException|KMS.KMSInternalException|KMS.KMSInvalidStateException|any, data: any) => void): Request;
    describeKey(params: KMS.DescribeKeyRequest, callback?: (err: KMS.NotFoundException|KMS.InvalidArnException|KMS.DependencyTimeoutException|KMS.KMSInternalException|any, data: KMS.DescribeKeyResponse|any) => void): Request;
    disableKey(params: KMS.DisableKeyRequest, callback?: (err: KMS.NotFoundException|KMS.InvalidArnException|KMS.DependencyTimeoutException|KMS.KMSInternalException|KMS.KMSInvalidStateException|any, data: any) => void): Request;
    disableKeyRotation(params: KMS.DisableKeyRotationRequest, callback?: (err: KMS.NotFoundException|KMS.DisabledException|KMS.InvalidArnException|KMS.DependencyTimeoutException|KMS.KMSInternalException|KMS.KMSInvalidStateException|any, data: any) => void): Request;
    enableKey(params: KMS.EnableKeyRequest, callback?: (err: KMS.NotFoundException|KMS.InvalidArnException|KMS.DependencyTimeoutException|KMS.KMSInternalException|KMS.LimitExceededException|KMS.KMSInvalidStateException|any, data: any) => void): Request;
    enableKeyRotation(params: KMS.EnableKeyRotationRequest, callback?: (err: KMS.NotFoundException|KMS.DisabledException|KMS.InvalidArnException|KMS.DependencyTimeoutException|KMS.KMSInternalException|KMS.KMSInvalidStateException|any, data: any) => void): Request;
    encrypt(params: KMS.EncryptRequest, callback?: (err: KMS.NotFoundException|KMS.DisabledException|KMS.KeyUnavailableException|KMS.DependencyTimeoutException|KMS.InvalidKeyUsageException|KMS.InvalidGrantTokenException|KMS.KMSInternalException|KMS.KMSInvalidStateException|any, data: KMS.EncryptResponse|any) => void): Request;
    generateDataKey(params: KMS.GenerateDataKeyRequest, callback?: (err: KMS.NotFoundException|KMS.DisabledException|KMS.KeyUnavailableException|KMS.DependencyTimeoutException|KMS.InvalidKeyUsageException|KMS.InvalidGrantTokenException|KMS.KMSInternalException|KMS.KMSInvalidStateException|any, data: KMS.GenerateDataKeyResponse|any) => void): Request;
    generateDataKeyWithoutPlaintext(params: KMS.GenerateDataKeyWithoutPlaintextRequest, callback?: (err: KMS.NotFoundException|KMS.DisabledException|KMS.KeyUnavailableException|KMS.DependencyTimeoutException|KMS.InvalidKeyUsageException|KMS.InvalidGrantTokenException|KMS.KMSInternalException|KMS.KMSInvalidStateException|any, data: KMS.GenerateDataKeyWithoutPlaintextResponse|any) => void): Request;
    generateRandom(params: KMS.GenerateRandomRequest, callback?: (err: KMS.DependencyTimeoutException|KMS.KMSInternalException|any, data: KMS.GenerateRandomResponse|any) => void): Request;
    getKeyPolicy(params: KMS.GetKeyPolicyRequest, callback?: (err: KMS.NotFoundException|KMS.InvalidArnException|KMS.DependencyTimeoutException|KMS.KMSInternalException|KMS.KMSInvalidStateException|any, data: KMS.GetKeyPolicyResponse|any) => void): Request;
    getKeyRotationStatus(params: KMS.GetKeyRotationStatusRequest, callback?: (err: KMS.NotFoundException|KMS.InvalidArnException|KMS.DependencyTimeoutException|KMS.KMSInternalException|KMS.KMSInvalidStateException|any, data: KMS.GetKeyRotationStatusResponse|any) => void): Request;
    listAliases(params: KMS.ListAliasesRequest, callback?: (err: KMS.DependencyTimeoutException|KMS.InvalidMarkerException|KMS.KMSInternalException|any, data: KMS.ListAliasesResponse|any) => void): Request;
    listGrants(params: KMS.ListGrantsRequest, callback?: (err: KMS.NotFoundException|KMS.DependencyTimeoutException|KMS.InvalidMarkerException|KMS.InvalidArnException|KMS.KMSInternalException|KMS.KMSInvalidStateException|any, data: KMS.ListGrantsResponse|any) => void): Request;
    listKeyPolicies(params: KMS.ListKeyPoliciesRequest, callback?: (err: KMS.NotFoundException|KMS.InvalidArnException|KMS.DependencyTimeoutException|KMS.KMSInternalException|KMS.KMSInvalidStateException|any, data: KMS.ListKeyPoliciesResponse|any) => void): Request;
    listKeys(params: KMS.ListKeysRequest, callback?: (err: KMS.DependencyTimeoutException|KMS.KMSInternalException|any, data: KMS.ListKeysResponse|any) => void): Request;
    listRetirableGrants(params: KMS.ListRetirableGrantsRequest, callback?: (err: KMS.DependencyTimeoutException|KMS.InvalidMarkerException|KMS.InvalidArnException|KMS.NotFoundException|KMS.KMSInternalException|any, data: KMS.ListGrantsResponse|any) => void): Request;
    putKeyPolicy(params: KMS.PutKeyPolicyRequest, callback?: (err: KMS.NotFoundException|KMS.InvalidArnException|KMS.MalformedPolicyDocumentException|KMS.DependencyTimeoutException|KMS.InvalidArnException|KMS.UnsupportedOperationException|KMS.KMSInternalException|KMS.LimitExceededException|KMS.KMSInvalidStateException|any, data: any) => void): Request;
    reEncrypt(params: KMS.ReEncryptRequest, callback?: (err: KMS.NotFoundException|KMS.DisabledException|KMS.InvalidCiphertextException|KMS.KeyUnavailableException|KMS.DependencyTimeoutException|KMS.InvalidKeyUsageException|KMS.InvalidGrantTokenException|KMS.KMSInternalException|KMS.KMSInvalidStateException|any, data: KMS.ReEncryptResponse|any) => void): Request;
    retireGrant(params: KMS.RetireGrantRequest, callback?: (err: KMS.InvalidGrantTokenException|KMS.InvalidGrantIdException|KMS.NotFoundException|KMS.DependencyTimeoutException|KMS.KMSInternalException|KMS.KMSInvalidStateException|any, data: any) => void): Request;
    revokeGrant(params: KMS.RevokeGrantRequest, callback?: (err: KMS.NotFoundException|KMS.DependencyTimeoutException|KMS.InvalidArnException|KMS.InvalidGrantIdException|KMS.KMSInternalException|KMS.KMSInvalidStateException|any, data: any) => void): Request;
    scheduleKeyDeletion(params: KMS.ScheduleKeyDeletionRequest, callback?: (err: KMS.NotFoundException|KMS.InvalidArnException|KMS.DependencyTimeoutException|KMS.KMSInternalException|KMS.KMSInvalidStateException|any, data: KMS.ScheduleKeyDeletionResponse|any) => void): Request;
    updateAlias(params: KMS.UpdateAliasRequest, callback?: (err: KMS.DependencyTimeoutException|KMS.NotFoundException|KMS.KMSInternalException|KMS.KMSInvalidStateException|any, data: any) => void): Request;
    updateKeyDescription(params: KMS.UpdateKeyDescriptionRequest, callback?: (err: KMS.NotFoundException|KMS.InvalidArnException|KMS.DependencyTimeoutException|KMS.KMSInternalException|KMS.KMSInvalidStateException|any, data: any) => void): Request;

  }

  export module KMS {
    export type AWSAccountIdType = string;
    export type AliasList = AliasListEntry[];
    export type AliasNameType = string;    // pattern: &quot;^[a-zA-Z0-9:/_-]+$&quot;, max: 256, min: 1
    export type ArnType = string;    // max: 2048, min: 20
    export type BooleanType = boolean;
    export type CiphertextType = any;    // max: 6144, min: 1, type: blob
    export type DataKeySpec = string;
    export type DateType = number;
    export type DescriptionType = string;    // max: 8192
    export type EncryptionContextKey = string;
    export type EncryptionContextType = {[key:string]: EncryptionContextValue};
    export type EncryptionContextValue = string;
    export type ErrorMessageType = string;
    export type GrantIdType = string;    // max: 128, min: 1
    export type GrantList = GrantListEntry[];
    export type GrantNameType = string;    // pattern: &quot;^[a-zA-Z0-9:/_-]+$&quot;, max: 256, min: 1
    export type GrantOperation = string;
    export type GrantOperationList = GrantOperation[];
    export type GrantTokenList = GrantTokenType[];    // max: 10
    export type GrantTokenType = string;    // max: 8192, min: 1
    export type KeyIdType = string;    // max: 256, min: 1
    export type KeyList = KeyListEntry[];
    export type KeyState = string;
    export type KeyUsageType = string;
    export type LimitType = number;    // max: 1000, min: 1
    export type MarkerType = string;    // pattern: &quot;[\u0020-\u00FF]*&quot;, max: 320, min: 1
    export type NumberOfBytesType = number;    // max: 1024, min: 1
    export type PendingWindowInDaysType = number;    // max: 365, min: 1
    export type PlaintextType = any;    // max: 4096, min: 1, type: blob
    export type PolicyNameList = PolicyNameType[];
    export type PolicyNameType = string;    // pattern: &quot;[\w]+&quot;, max: 128, min: 1
    export type PolicyType = string;    // pattern: &quot;[\u0009\u000A\u000D\u0020-\u00FF]+&quot;, max: 131072, min: 1
    export type PrincipalIdType = string;    // max: 256, min: 1

    export interface AliasListEntry {
        AliasName?: AliasNameType;
        AliasArn?: ArnType;
        TargetKeyId?: KeyIdType;
    }
    export interface AlreadyExistsException {
        message?: ErrorMessageType;
    }
    export interface CancelKeyDeletionRequest {
        KeyId: KeyIdType;
    }
    export interface CancelKeyDeletionResponse {
        KeyId?: KeyIdType;
    }
    export interface CreateAliasRequest {
        AliasName: AliasNameType;
        TargetKeyId: KeyIdType;
    }
    export interface CreateGrantRequest {
        KeyId: KeyIdType;
        GranteePrincipal: PrincipalIdType;
        RetiringPrincipal?: PrincipalIdType;
        Operations?: GrantOperationList;
        Constraints?: GrantConstraints;
        GrantTokens?: GrantTokenList;
        Name?: GrantNameType;
    }
    export interface CreateGrantResponse {
        GrantToken?: GrantTokenType;
        GrantId?: GrantIdType;
    }
    export interface CreateKeyRequest {
        Policy?: PolicyType;
        Description?: DescriptionType;
        KeyUsage?: KeyUsageType;
    }
    export interface CreateKeyResponse {
        KeyMetadata?: KeyMetadata;
    }
    export interface DecryptRequest {
        CiphertextBlob: CiphertextType;
        EncryptionContext?: EncryptionContextType;
        GrantTokens?: GrantTokenList;
    }
    export interface DecryptResponse {
        KeyId?: KeyIdType;
        Plaintext?: PlaintextType;
    }
    export interface DeleteAliasRequest {
        AliasName: AliasNameType;
    }
    export interface DependencyTimeoutException {
        message?: ErrorMessageType;
    }
    export interface DescribeKeyRequest {
        KeyId: KeyIdType;
        GrantTokens?: GrantTokenList;
    }
    export interface DescribeKeyResponse {
        KeyMetadata?: KeyMetadata;
    }
    export interface DisableKeyRequest {
        KeyId: KeyIdType;
    }
    export interface DisableKeyRotationRequest {
        KeyId: KeyIdType;
    }
    export interface DisabledException {
        message?: ErrorMessageType;
    }
    export interface EnableKeyRequest {
        KeyId: KeyIdType;
    }
    export interface EnableKeyRotationRequest {
        KeyId: KeyIdType;
    }
    export interface EncryptRequest {
        KeyId: KeyIdType;
        Plaintext: PlaintextType;
        EncryptionContext?: EncryptionContextType;
        GrantTokens?: GrantTokenList;
    }
    export interface EncryptResponse {
        CiphertextBlob?: CiphertextType;
        KeyId?: KeyIdType;
    }
    export interface GenerateDataKeyRequest {
        KeyId: KeyIdType;
        EncryptionContext?: EncryptionContextType;
        NumberOfBytes?: NumberOfBytesType;
        KeySpec?: DataKeySpec;
        GrantTokens?: GrantTokenList;
    }
    export interface GenerateDataKeyResponse {
        CiphertextBlob?: CiphertextType;
        Plaintext?: PlaintextType;
        KeyId?: KeyIdType;
    }
    export interface GenerateDataKeyWithoutPlaintextRequest {
        KeyId: KeyIdType;
        EncryptionContext?: EncryptionContextType;
        KeySpec?: DataKeySpec;
        NumberOfBytes?: NumberOfBytesType;
        GrantTokens?: GrantTokenList;
    }
    export interface GenerateDataKeyWithoutPlaintextResponse {
        CiphertextBlob?: CiphertextType;
        KeyId?: KeyIdType;
    }
    export interface GenerateRandomRequest {
        NumberOfBytes?: NumberOfBytesType;
    }
    export interface GenerateRandomResponse {
        Plaintext?: PlaintextType;
    }
    export interface GetKeyPolicyRequest {
        KeyId: KeyIdType;
        PolicyName: PolicyNameType;
    }
    export interface GetKeyPolicyResponse {
        Policy?: PolicyType;
    }
    export interface GetKeyRotationStatusRequest {
        KeyId: KeyIdType;
    }
    export interface GetKeyRotationStatusResponse {
        KeyRotationEnabled?: BooleanType;
    }
    export interface GrantConstraints {
        EncryptionContextSubset?: EncryptionContextType;
        EncryptionContextEquals?: EncryptionContextType;
    }
    export interface GrantListEntry {
        KeyId?: KeyIdType;
        GrantId?: GrantIdType;
        Name?: GrantNameType;
        CreationDate?: DateType;
        GranteePrincipal?: PrincipalIdType;
        RetiringPrincipal?: PrincipalIdType;
        IssuingAccount?: PrincipalIdType;
        Operations?: GrantOperationList;
        Constraints?: GrantConstraints;
    }
    export interface InvalidAliasNameException {
        message?: ErrorMessageType;
    }
    export interface InvalidArnException {
        message?: ErrorMessageType;
    }
    export interface InvalidCiphertextException {
        message?: ErrorMessageType;
    }
    export interface InvalidGrantIdException {
        message?: ErrorMessageType;
    }
    export interface InvalidGrantTokenException {
        message?: ErrorMessageType;
    }
    export interface InvalidKeyUsageException {
        message?: ErrorMessageType;
    }
    export interface InvalidMarkerException {
        message?: ErrorMessageType;
    }
    export interface KMSInternalException {
        message?: ErrorMessageType;
    }
    export interface KMSInvalidStateException {
        message?: ErrorMessageType;
    }
    export interface KeyListEntry {
        KeyId?: KeyIdType;
        KeyArn?: ArnType;
    }
    export interface KeyMetadata {
        AWSAccountId?: AWSAccountIdType;
        KeyId: KeyIdType;
        Arn?: ArnType;
        CreationDate?: DateType;
        Enabled?: BooleanType;
        Description?: DescriptionType;
        KeyUsage?: KeyUsageType;
        KeyState?: KeyState;
        DeletionDate?: DateType;
    }
    export interface KeyUnavailableException {
        message?: ErrorMessageType;
    }
    export interface LimitExceededException {
        message?: ErrorMessageType;
    }
    export interface ListAliasesRequest {
        Limit?: LimitType;
        Marker?: MarkerType;
    }
    export interface ListAliasesResponse {
        Aliases?: AliasList;
        NextMarker?: MarkerType;
        Truncated?: BooleanType;
    }
    export interface ListGrantsRequest {
        Limit?: LimitType;
        Marker?: MarkerType;
        KeyId: KeyIdType;
    }
    export interface ListGrantsResponse {
        Grants?: GrantList;
        NextMarker?: MarkerType;
        Truncated?: BooleanType;
    }
    export interface ListKeyPoliciesRequest {
        KeyId: KeyIdType;
        Limit?: LimitType;
        Marker?: MarkerType;
    }
    export interface ListKeyPoliciesResponse {
        PolicyNames?: PolicyNameList;
        NextMarker?: MarkerType;
        Truncated?: BooleanType;
    }
    export interface ListKeysRequest {
        Limit?: LimitType;
        Marker?: MarkerType;
    }
    export interface ListKeysResponse {
        Keys?: KeyList;
        NextMarker?: MarkerType;
        Truncated?: BooleanType;
    }
    export interface ListRetirableGrantsRequest {
        Limit?: LimitType;
        Marker?: MarkerType;
        RetiringPrincipal: PrincipalIdType;
    }
    export interface MalformedPolicyDocumentException {
        message?: ErrorMessageType;
    }
    export interface NotFoundException {
        message?: ErrorMessageType;
    }
    export interface PutKeyPolicyRequest {
        KeyId: KeyIdType;
        PolicyName: PolicyNameType;
        Policy: PolicyType;
    }
    export interface ReEncryptRequest {
        CiphertextBlob: CiphertextType;
        SourceEncryptionContext?: EncryptionContextType;
        DestinationKeyId: KeyIdType;
        DestinationEncryptionContext?: EncryptionContextType;
        GrantTokens?: GrantTokenList;
    }
    export interface ReEncryptResponse {
        CiphertextBlob?: CiphertextType;
        SourceKeyId?: KeyIdType;
        KeyId?: KeyIdType;
    }
    export interface RetireGrantRequest {
        GrantToken?: GrantTokenType;
        KeyId?: KeyIdType;
        GrantId?: GrantIdType;
    }
    export interface RevokeGrantRequest {
        KeyId: KeyIdType;
        GrantId: GrantIdType;
    }
    export interface ScheduleKeyDeletionRequest {
        KeyId: KeyIdType;
        PendingWindowInDays?: PendingWindowInDaysType;
    }
    export interface ScheduleKeyDeletionResponse {
        KeyId?: KeyIdType;
        DeletionDate?: DateType;
    }
    export interface UnsupportedOperationException {
        message?: ErrorMessageType;
    }
    export interface UpdateAliasRequest {
        AliasName: AliasNameType;
        TargetKeyId: KeyIdType;
    }
    export interface UpdateKeyDescriptionRequest {
        KeyId: KeyIdType;
        Description: DescriptionType;
    }
  }

  /*
   * apiVersion: 2015-03-31
   * endpointPrefix: lambda
   * serviceAbbreviation: 
   * signatureVersion: v4
   * protocol: rest-json
   */
  export class Lambda extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    addPermission(params: Lambda.AddPermissionRequest, callback?: (err: Lambda.ServiceException|Lambda.ResourceNotFoundException|Lambda.ResourceConflictException|Lambda.InvalidParameterValueException|Lambda.PolicyLengthExceededException|Lambda.TooManyRequestsException|any, data: Lambda.AddPermissionResponse|any) => void): Request;
    createAlias(params: Lambda.CreateAliasRequest, callback?: (err: Lambda.ServiceException|Lambda.ResourceNotFoundException|Lambda.ResourceConflictException|Lambda.InvalidParameterValueException|Lambda.TooManyRequestsException|any, data: Lambda.AliasConfiguration|any) => void): Request;
    createEventSourceMapping(params: Lambda.CreateEventSourceMappingRequest, callback?: (err: Lambda.ServiceException|Lambda.InvalidParameterValueException|Lambda.ResourceConflictException|Lambda.TooManyRequestsException|any, data: Lambda.EventSourceMappingConfiguration|any) => void): Request;
    createFunction(params: Lambda.CreateFunctionRequest, callback?: (err: Lambda.ServiceException|Lambda.InvalidParameterValueException|Lambda.ResourceNotFoundException|Lambda.ResourceConflictException|Lambda.TooManyRequestsException|Lambda.CodeStorageExceededException|any, data: Lambda.FunctionConfiguration|any) => void): Request;
    deleteAlias(params: Lambda.DeleteAliasRequest, callback?: (err: Lambda.ServiceException|Lambda.InvalidParameterValueException|Lambda.TooManyRequestsException|any, data: any) => void): Request;
    deleteEventSourceMapping(params: Lambda.DeleteEventSourceMappingRequest, callback?: (err: Lambda.ServiceException|Lambda.ResourceNotFoundException|Lambda.InvalidParameterValueException|Lambda.TooManyRequestsException|any, data: Lambda.EventSourceMappingConfiguration|any) => void): Request;
    deleteFunction(params: Lambda.DeleteFunctionRequest, callback?: (err: Lambda.ServiceException|Lambda.ResourceNotFoundException|Lambda.TooManyRequestsException|Lambda.InvalidParameterValueException|Lambda.ResourceConflictException|any, data: any) => void): Request;
    getAlias(params: Lambda.GetAliasRequest, callback?: (err: Lambda.ServiceException|Lambda.ResourceNotFoundException|Lambda.InvalidParameterValueException|Lambda.TooManyRequestsException|any, data: Lambda.AliasConfiguration|any) => void): Request;
    getEventSourceMapping(params: Lambda.GetEventSourceMappingRequest, callback?: (err: Lambda.ServiceException|Lambda.ResourceNotFoundException|Lambda.InvalidParameterValueException|Lambda.TooManyRequestsException|any, data: Lambda.EventSourceMappingConfiguration|any) => void): Request;
    getFunction(params: Lambda.GetFunctionRequest, callback?: (err: Lambda.ServiceException|Lambda.ResourceNotFoundException|Lambda.TooManyRequestsException|Lambda.InvalidParameterValueException|any, data: Lambda.GetFunctionResponse|any) => void): Request;
    getFunctionConfiguration(params: Lambda.GetFunctionConfigurationRequest, callback?: (err: Lambda.ServiceException|Lambda.ResourceNotFoundException|Lambda.TooManyRequestsException|Lambda.InvalidParameterValueException|any, data: Lambda.FunctionConfiguration|any) => void): Request;
    getPolicy(params: Lambda.GetPolicyRequest, callback?: (err: Lambda.ServiceException|Lambda.ResourceNotFoundException|Lambda.TooManyRequestsException|Lambda.InvalidParameterValueException|any, data: Lambda.GetPolicyResponse|any) => void): Request;
    invoke(params: Lambda.InvocationRequest, callback?: (err: Lambda.ServiceException|Lambda.ResourceNotFoundException|Lambda.InvalidRequestContentException|Lambda.RequestTooLargeException|Lambda.UnsupportedMediaTypeException|Lambda.TooManyRequestsException|Lambda.InvalidParameterValueException|Lambda.EC2UnexpectedException|Lambda.SubnetIPAddressLimitReachedException|Lambda.ENILimitReachedException|Lambda.EC2ThrottledException|Lambda.EC2AccessDeniedException|Lambda.InvalidSubnetIDException|Lambda.InvalidSecurityGroupIDException|any, data: Lambda.InvocationResponse|any) => void): Request;
    invokeAsync(params: Lambda.InvokeAsyncRequest, callback?: (err: Lambda.ServiceException|Lambda.ResourceNotFoundException|Lambda.InvalidRequestContentException|any, data: Lambda.InvokeAsyncResponse|any) => void): Request;
    listAliases(params: Lambda.ListAliasesRequest, callback?: (err: Lambda.ServiceException|Lambda.ResourceNotFoundException|Lambda.InvalidParameterValueException|Lambda.TooManyRequestsException|any, data: Lambda.ListAliasesResponse|any) => void): Request;
    listEventSourceMappings(params: Lambda.ListEventSourceMappingsRequest, callback?: (err: Lambda.ServiceException|Lambda.ResourceNotFoundException|Lambda.InvalidParameterValueException|Lambda.TooManyRequestsException|any, data: Lambda.ListEventSourceMappingsResponse|any) => void): Request;
    listFunctions(params: Lambda.ListFunctionsRequest, callback?: (err: Lambda.ServiceException|Lambda.TooManyRequestsException|any, data: Lambda.ListFunctionsResponse|any) => void): Request;
    listVersionsByFunction(params: Lambda.ListVersionsByFunctionRequest, callback?: (err: Lambda.ServiceException|Lambda.ResourceNotFoundException|Lambda.InvalidParameterValueException|Lambda.TooManyRequestsException|any, data: Lambda.ListVersionsByFunctionResponse|any) => void): Request;
    publishVersion(params: Lambda.PublishVersionRequest, callback?: (err: Lambda.ServiceException|Lambda.ResourceNotFoundException|Lambda.InvalidParameterValueException|Lambda.TooManyRequestsException|Lambda.CodeStorageExceededException|any, data: Lambda.FunctionConfiguration|any) => void): Request;
    removePermission(params: Lambda.RemovePermissionRequest, callback?: (err: Lambda.ServiceException|Lambda.ResourceNotFoundException|Lambda.InvalidParameterValueException|Lambda.TooManyRequestsException|any, data: any) => void): Request;
    updateAlias(params: Lambda.UpdateAliasRequest, callback?: (err: Lambda.ServiceException|Lambda.ResourceNotFoundException|Lambda.InvalidParameterValueException|Lambda.TooManyRequestsException|any, data: Lambda.AliasConfiguration|any) => void): Request;
    updateEventSourceMapping(params: Lambda.UpdateEventSourceMappingRequest, callback?: (err: Lambda.ServiceException|Lambda.ResourceNotFoundException|Lambda.InvalidParameterValueException|Lambda.TooManyRequestsException|Lambda.ResourceConflictException|any, data: Lambda.EventSourceMappingConfiguration|any) => void): Request;
    updateFunctionCode(params: Lambda.UpdateFunctionCodeRequest, callback?: (err: Lambda.ServiceException|Lambda.ResourceNotFoundException|Lambda.InvalidParameterValueException|Lambda.TooManyRequestsException|Lambda.CodeStorageExceededException|any, data: Lambda.FunctionConfiguration|any) => void): Request;
    updateFunctionConfiguration(params: Lambda.UpdateFunctionConfigurationRequest, callback?: (err: Lambda.ServiceException|Lambda.ResourceNotFoundException|Lambda.InvalidParameterValueException|Lambda.TooManyRequestsException|any, data: Lambda.FunctionConfiguration|any) => void): Request;

  }

  export module Lambda {
    export type Action = string;    // pattern: &quot;(lambda:[*]|lambda:[a-zA-Z]+|[*])&quot;
    export type Alias = string;    // pattern: &quot;(?!^[0-9]+$)([a-zA-Z0-9-_]+)&quot;, max: 128, min: 1
    export type AliasList = AliasConfiguration[];
    export type Arn = string;    // pattern: &quot;arn:aws:([a-zA-Z0-9\-])+:([a-z]{2}-[a-z]+-\d{1})?:(\d{12})?:(.*)&quot;
    export type BatchSize = number;    // max: 10000, min: 1
    export type Blob = any;    // type: blob
    export type BlobStream = any;    // type: blob
    export type Boolean = boolean;
    export type Date = number;
    export type Description = string;    // max: 256
    export type Enabled = boolean;
    export type EventSourceMappingsList = EventSourceMappingConfiguration[];
    export type EventSourcePosition = string;
    export type FunctionArn = string;    // pattern: &quot;arn:aws:lambda:[a-z]{2}-[a-z]+-\d{1}:\d{12}:function:[a-zA-Z0-9-_]+(:(\$LATEST|[a-zA-Z0-9-_]+))?&quot;
    export type FunctionList = FunctionConfiguration[];
    export type FunctionName = string;    // pattern: &quot;(arn:aws:lambda:)?([a-z]{2}-[a-z]+-\d{1}:)?(\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?&quot;, max: 140, min: 1
    export type Handler = string;    // pattern: &quot;[^\s]+&quot;, max: 128
    export type HttpStatus = number;
    export type Integer = number;
    export type InvocationType = string;
    export type LogType = string;
    export type Long = number;
    export type MaxListItems = number;    // max: 10000, min: 1
    export type MemorySize = number;    // max: 1536, min: 128
    export type Principal = string;    // pattern: &quot;.*&quot;
    export type Qualifier = string;    // pattern: &quot;(|[a-zA-Z0-9$_-]+)&quot;, max: 128, min: 1
    export type RoleArn = string;    // pattern: &quot;arn:aws:iam::\d{12}:role/?[a-zA-Z_0-9+=,.@\-_/]+&quot;
    export type Runtime = string;
    export type S3Bucket = string;    // pattern: &quot;^[0-9A-Za-z\.\-_]*(?&lt;!\.)$&quot;, max: 63, min: 3
    export type S3Key = string;    // max: 1024, min: 1
    export type S3ObjectVersion = string;    // max: 1024, min: 1
    export type SecurityGroupId = string;
    export type SecurityGroupIds = SecurityGroupId[];    // max: 5
    export type SourceOwner = string;    // pattern: &quot;\d{12}&quot;
    export type StatementId = string;    // pattern: &quot;([a-zA-Z0-9-_]+)&quot;, max: 100, min: 1
    export type String = string;
    export type SubnetId = string;
    export type SubnetIds = SubnetId[];    // max: 16
    export type Timeout = number;    // min: 1
    export type Timestamp = string;
    export type Version = string;    // pattern: &quot;(\$LATEST|[0-9]+)&quot;, max: 1024, min: 1
    export type VpcId = string;

    export interface AddPermissionRequest {
        FunctionName: FunctionName;
        StatementId: StatementId;
        Action: Action;
        Principal: Principal;
        SourceArn?: Arn;
        SourceAccount?: SourceOwner;
        Qualifier?: Qualifier;
    }
    export interface AddPermissionResponse {
        Statement?: String;
    }
    export interface AliasConfiguration {
        AliasArn?: FunctionArn;
        Name?: Alias;
        FunctionVersion?: Version;
        Description?: Description;
    }
    export interface CodeStorageExceededException {
        Type?: String;
        message?: String;
    }
    export interface CreateAliasRequest {
        FunctionName: FunctionName;
        Name: Alias;
        FunctionVersion: Version;
        Description?: Description;
    }
    export interface CreateEventSourceMappingRequest {
        EventSourceArn: Arn;
        FunctionName: FunctionName;
        Enabled?: Enabled;
        BatchSize?: BatchSize;
        StartingPosition: EventSourcePosition;
    }
    export interface CreateFunctionRequest {
        FunctionName: FunctionName;
        Runtime: Runtime;
        Role: RoleArn;
        Handler: Handler;
        Code: FunctionCode;
        Description?: Description;
        Timeout?: Timeout;
        MemorySize?: MemorySize;
        Publish?: Boolean;
        VpcConfig?: VpcConfig;
    }
    export interface DeleteAliasRequest {
        FunctionName: FunctionName;
        Name: Alias;
    }
    export interface DeleteEventSourceMappingRequest {
        UUID: String;
    }
    export interface DeleteFunctionRequest {
        FunctionName: FunctionName;
        Qualifier?: Qualifier;
    }
    export interface EC2AccessDeniedException {
        Type?: String;
        Message?: String;
    }
    export interface EC2ThrottledException {
        Type?: String;
        Message?: String;
    }
    export interface EC2UnexpectedException {
        Type?: String;
        Message?: String;
        EC2ErrorCode?: String;
    }
    export interface ENILimitReachedException {
        Type?: String;
        Message?: String;
    }
    export interface EventSourceMappingConfiguration {
        UUID?: String;
        BatchSize?: BatchSize;
        EventSourceArn?: Arn;
        FunctionArn?: FunctionArn;
        LastModified?: Date;
        LastProcessingResult?: String;
        State?: String;
        StateTransitionReason?: String;
    }
    export interface FunctionCode {
        ZipFile?: Blob;
        S3Bucket?: S3Bucket;
        S3Key?: S3Key;
        S3ObjectVersion?: S3ObjectVersion;
    }
    export interface FunctionCodeLocation {
        RepositoryType?: String;
        Location?: String;
    }
    export interface FunctionConfiguration {
        FunctionName?: FunctionName;
        FunctionArn?: FunctionArn;
        Runtime?: Runtime;
        Role?: RoleArn;
        Handler?: Handler;
        CodeSize?: Long;
        Description?: Description;
        Timeout?: Timeout;
        MemorySize?: MemorySize;
        LastModified?: Timestamp;
        CodeSha256?: String;
        Version?: Version;
        VpcConfig?: VpcConfigResponse;
    }
    export interface GetAliasRequest {
        FunctionName: FunctionName;
        Name: Alias;
    }
    export interface GetEventSourceMappingRequest {
        UUID: String;
    }
    export interface GetFunctionConfigurationRequest {
        FunctionName: FunctionName;
        Qualifier?: Qualifier;
    }
    export interface GetFunctionRequest {
        FunctionName: FunctionName;
        Qualifier?: Qualifier;
    }
    export interface GetFunctionResponse {
        Configuration?: FunctionConfiguration;
        Code?: FunctionCodeLocation;
    }
    export interface GetPolicyRequest {
        FunctionName: FunctionName;
        Qualifier?: Qualifier;
    }
    export interface GetPolicyResponse {
        Policy?: String;
    }
    export interface InvalidParameterValueException {
        Type?: String;
        message?: String;
    }
    export interface InvalidRequestContentException {
        Type?: String;
        message?: String;
    }
    export interface InvalidSecurityGroupIDException {
        Type?: String;
        Message?: String;
    }
    export interface InvalidSubnetIDException {
        Type?: String;
        Message?: String;
    }
    export interface InvocationRequest {
        FunctionName: FunctionName;
        InvocationType?: InvocationType;
        LogType?: LogType;
        ClientContext?: String;
        Payload?: Blob;
        Qualifier?: Qualifier;
    }
    export interface InvocationResponse {
        StatusCode?: Integer;
        FunctionError?: String;
        LogResult?: String;
        Payload?: Blob;
    }
    export interface InvokeAsyncRequest {
        FunctionName: FunctionName;
        InvokeArgs: BlobStream;
    }
    export interface InvokeAsyncResponse {
        Status?: HttpStatus;
    }
    export interface ListAliasesRequest {
        FunctionName: FunctionName;
        FunctionVersion?: Version;
        Marker?: String;
        MaxItems?: MaxListItems;
    }
    export interface ListAliasesResponse {
        NextMarker?: String;
        Aliases?: AliasList;
    }
    export interface ListEventSourceMappingsRequest {
        EventSourceArn?: Arn;
        FunctionName?: FunctionName;
        Marker?: String;
        MaxItems?: MaxListItems;
    }
    export interface ListEventSourceMappingsResponse {
        NextMarker?: String;
        EventSourceMappings?: EventSourceMappingsList;
    }
    export interface ListFunctionsRequest {
        Marker?: String;
        MaxItems?: MaxListItems;
    }
    export interface ListFunctionsResponse {
        NextMarker?: String;
        Functions?: FunctionList;
    }
    export interface ListVersionsByFunctionRequest {
        FunctionName: FunctionName;
        Marker?: String;
        MaxItems?: MaxListItems;
    }
    export interface ListVersionsByFunctionResponse {
        NextMarker?: String;
        Versions?: FunctionList;
    }
    export interface PolicyLengthExceededException {
        Type?: String;
        message?: String;
    }
    export interface PublishVersionRequest {
        FunctionName: FunctionName;
        CodeSha256?: String;
        Description?: Description;
    }
    export interface RemovePermissionRequest {
        FunctionName: FunctionName;
        StatementId: StatementId;
        Qualifier?: Qualifier;
    }
    export interface RequestTooLargeException {
        Type?: String;
        message?: String;
    }
    export interface ResourceConflictException {
        Type?: String;
        message?: String;
    }
    export interface ResourceNotFoundException {
        Type?: String;
        Message?: String;
    }
    export interface ServiceException {
        Type?: String;
        Message?: String;
    }
    export interface SubnetIPAddressLimitReachedException {
        Type?: String;
        Message?: String;
    }
    export interface TooManyRequestsException {
        retryAfterSeconds?: String;
        Type?: String;
        message?: String;
    }
    export interface UnsupportedMediaTypeException {
        Type?: String;
        message?: String;
    }
    export interface UpdateAliasRequest {
        FunctionName: FunctionName;
        Name: Alias;
        FunctionVersion?: Version;
        Description?: Description;
    }
    export interface UpdateEventSourceMappingRequest {
        UUID: String;
        FunctionName?: FunctionName;
        Enabled?: Enabled;
        BatchSize?: BatchSize;
    }
    export interface UpdateFunctionCodeRequest {
        FunctionName: FunctionName;
        ZipFile?: Blob;
        S3Bucket?: S3Bucket;
        S3Key?: S3Key;
        S3ObjectVersion?: S3ObjectVersion;
        Publish?: Boolean;
    }
    export interface UpdateFunctionConfigurationRequest {
        FunctionName: FunctionName;
        Role?: RoleArn;
        Handler?: Handler;
        Description?: Description;
        Timeout?: Timeout;
        MemorySize?: MemorySize;
        VpcConfig?: VpcConfig;
    }
    export interface VpcConfig {
        SubnetIds?: SubnetIds;
        SecurityGroupIds?: SecurityGroupIds;
    }
    export interface VpcConfigResponse {
        SubnetIds?: SubnetIds;
        SecurityGroupIds?: SecurityGroupIds;
        VpcId?: VpcId;
    }
  }

  /*
   * apiVersion: 2014-12-12
   * endpointPrefix: machinelearning
   * serviceAbbreviation: 
   * signatureVersion: v4
   * protocol: json
   */
  export class MachineLearning extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    createBatchPrediction(params: MachineLearning.CreateBatchPredictionInput, callback?: (err: MachineLearning.InvalidInputException|MachineLearning.InternalServerException|MachineLearning.IdempotentParameterMismatchException|any, data: MachineLearning.CreateBatchPredictionOutput|any) => void): Request;
    createDataSourceFromRDS(params: MachineLearning.CreateDataSourceFromRDSInput, callback?: (err: MachineLearning.InvalidInputException|MachineLearning.InternalServerException|MachineLearning.IdempotentParameterMismatchException|any, data: MachineLearning.CreateDataSourceFromRDSOutput|any) => void): Request;
    createDataSourceFromRedshift(params: MachineLearning.CreateDataSourceFromRedshiftInput, callback?: (err: MachineLearning.InvalidInputException|MachineLearning.InternalServerException|MachineLearning.IdempotentParameterMismatchException|any, data: MachineLearning.CreateDataSourceFromRedshiftOutput|any) => void): Request;
    createDataSourceFromS3(params: MachineLearning.CreateDataSourceFromS3Input, callback?: (err: MachineLearning.InvalidInputException|MachineLearning.InternalServerException|MachineLearning.IdempotentParameterMismatchException|any, data: MachineLearning.CreateDataSourceFromS3Output|any) => void): Request;
    createEvaluation(params: MachineLearning.CreateEvaluationInput, callback?: (err: MachineLearning.InvalidInputException|MachineLearning.InternalServerException|MachineLearning.IdempotentParameterMismatchException|any, data: MachineLearning.CreateEvaluationOutput|any) => void): Request;
    createMLModel(params: MachineLearning.CreateMLModelInput, callback?: (err: MachineLearning.InvalidInputException|MachineLearning.InternalServerException|MachineLearning.IdempotentParameterMismatchException|any, data: MachineLearning.CreateMLModelOutput|any) => void): Request;
    createRealtimeEndpoint(params: MachineLearning.CreateRealtimeEndpointInput, callback?: (err: MachineLearning.InvalidInputException|MachineLearning.ResourceNotFoundException|MachineLearning.InternalServerException|any, data: MachineLearning.CreateRealtimeEndpointOutput|any) => void): Request;
    deleteBatchPrediction(params: MachineLearning.DeleteBatchPredictionInput, callback?: (err: MachineLearning.InvalidInputException|MachineLearning.ResourceNotFoundException|MachineLearning.InternalServerException|any, data: MachineLearning.DeleteBatchPredictionOutput|any) => void): Request;
    deleteDataSource(params: MachineLearning.DeleteDataSourceInput, callback?: (err: MachineLearning.InvalidInputException|MachineLearning.ResourceNotFoundException|MachineLearning.InternalServerException|any, data: MachineLearning.DeleteDataSourceOutput|any) => void): Request;
    deleteEvaluation(params: MachineLearning.DeleteEvaluationInput, callback?: (err: MachineLearning.InvalidInputException|MachineLearning.ResourceNotFoundException|MachineLearning.InternalServerException|any, data: MachineLearning.DeleteEvaluationOutput|any) => void): Request;
    deleteMLModel(params: MachineLearning.DeleteMLModelInput, callback?: (err: MachineLearning.InvalidInputException|MachineLearning.ResourceNotFoundException|MachineLearning.InternalServerException|any, data: MachineLearning.DeleteMLModelOutput|any) => void): Request;
    deleteRealtimeEndpoint(params: MachineLearning.DeleteRealtimeEndpointInput, callback?: (err: MachineLearning.InvalidInputException|MachineLearning.ResourceNotFoundException|MachineLearning.InternalServerException|any, data: MachineLearning.DeleteRealtimeEndpointOutput|any) => void): Request;
    describeBatchPredictions(params: MachineLearning.DescribeBatchPredictionsInput, callback?: (err: MachineLearning.InvalidInputException|MachineLearning.InternalServerException|any, data: MachineLearning.DescribeBatchPredictionsOutput|any) => void): Request;
    describeDataSources(params: MachineLearning.DescribeDataSourcesInput, callback?: (err: MachineLearning.InvalidInputException|MachineLearning.InternalServerException|any, data: MachineLearning.DescribeDataSourcesOutput|any) => void): Request;
    describeEvaluations(params: MachineLearning.DescribeEvaluationsInput, callback?: (err: MachineLearning.InvalidInputException|MachineLearning.InternalServerException|any, data: MachineLearning.DescribeEvaluationsOutput|any) => void): Request;
    describeMLModels(params: MachineLearning.DescribeMLModelsInput, callback?: (err: MachineLearning.InvalidInputException|MachineLearning.InternalServerException|any, data: MachineLearning.DescribeMLModelsOutput|any) => void): Request;
    getBatchPrediction(params: MachineLearning.GetBatchPredictionInput, callback?: (err: MachineLearning.InvalidInputException|MachineLearning.ResourceNotFoundException|MachineLearning.InternalServerException|any, data: MachineLearning.GetBatchPredictionOutput|any) => void): Request;
    getDataSource(params: MachineLearning.GetDataSourceInput, callback?: (err: MachineLearning.InvalidInputException|MachineLearning.ResourceNotFoundException|MachineLearning.InternalServerException|any, data: MachineLearning.GetDataSourceOutput|any) => void): Request;
    getEvaluation(params: MachineLearning.GetEvaluationInput, callback?: (err: MachineLearning.InvalidInputException|MachineLearning.ResourceNotFoundException|MachineLearning.InternalServerException|any, data: MachineLearning.GetEvaluationOutput|any) => void): Request;
    getMLModel(params: MachineLearning.GetMLModelInput, callback?: (err: MachineLearning.InvalidInputException|MachineLearning.ResourceNotFoundException|MachineLearning.InternalServerException|any, data: MachineLearning.GetMLModelOutput|any) => void): Request;
    predict(params: MachineLearning.PredictInput, callback?: (err: MachineLearning.InvalidInputException|MachineLearning.ResourceNotFoundException|MachineLearning.LimitExceededException|MachineLearning.InternalServerException|MachineLearning.PredictorNotMountedException|any, data: MachineLearning.PredictOutput|any) => void): Request;
    updateBatchPrediction(params: MachineLearning.UpdateBatchPredictionInput, callback?: (err: MachineLearning.InvalidInputException|MachineLearning.ResourceNotFoundException|MachineLearning.InternalServerException|any, data: MachineLearning.UpdateBatchPredictionOutput|any) => void): Request;
    updateDataSource(params: MachineLearning.UpdateDataSourceInput, callback?: (err: MachineLearning.InvalidInputException|MachineLearning.ResourceNotFoundException|MachineLearning.InternalServerException|any, data: MachineLearning.UpdateDataSourceOutput|any) => void): Request;
    updateEvaluation(params: MachineLearning.UpdateEvaluationInput, callback?: (err: MachineLearning.InvalidInputException|MachineLearning.ResourceNotFoundException|MachineLearning.InternalServerException|any, data: MachineLearning.UpdateEvaluationOutput|any) => void): Request;
    updateMLModel(params: MachineLearning.UpdateMLModelInput, callback?: (err: MachineLearning.InvalidInputException|MachineLearning.ResourceNotFoundException|MachineLearning.InternalServerException|any, data: MachineLearning.UpdateMLModelOutput|any) => void): Request;

  }

  export module MachineLearning {
    export type Algorithm = string;
    export type AwsUserArn = string;    // pattern: &quot;arn:aws:iam::[0-9]+:((user/.+)|(root))&quot;
    export type BatchPredictionFilterVariable = string;
    export type BatchPredictions = BatchPrediction[];
    export type ComparatorValue = string;    // pattern: &quot;.*\S.*|^$&quot;, max: 1024
    export type ComputeStatistics = boolean;
    export type DataRearrangement = string;
    export type DataSchema = string;    // max: 131071
    export type DataSourceFilterVariable = string;
    export type DataSources = DataSource[];
    export type DetailsAttributes = string;
    export type DetailsMap = {[key:string]: DetailsValue};
    export type DetailsValue = string;    // min: 1
    export type EDPPipelineId = string;    // max: 1024, min: 1
    export type EDPResourceRole = string;    // max: 64, min: 1
    export type EDPSecurityGroupId = string;    // max: 255, min: 1
    export type EDPSecurityGroupIds = EDPSecurityGroupId[];
    export type EDPServiceRole = string;    // max: 64, min: 1
    export type EDPSubnetId = string;    // max: 255, min: 1
    export type EntityId = string;    // pattern: &quot;[a-zA-Z0-9_.-]+&quot;, max: 64, min: 1
    export type EntityName = string;    // pattern: &quot;.*\S.*|^$&quot;, max: 1024
    export type EntityStatus = string;
    export type EpochTime = number;
    export type ErrorCode = number;
    export type ErrorMessage = string;    // max: 2048
    export type EvaluationFilterVariable = string;
    export type Evaluations = Evaluation[];
    export type IntegerType = number;
    export type Label = string;    // min: 1
    export type LongType = number;
    export type MLModelFilterVariable = string;
    export type MLModelName = string;    // max: 1024
    export type MLModelType = string;
    export type MLModels = MLModel[];
    export type Message = string;    // max: 10240
    export type PageLimit = number;    // max: 100, min: 1
    export type PerformanceMetricsProperties = {[key:string]: PerformanceMetricsPropertyValue};
    export type PerformanceMetricsPropertyKey = string;
    export type PerformanceMetricsPropertyValue = string;
    export type PresignedS3Url = string;
    export type RDSDatabaseName = string;    // max: 64, min: 1
    export type RDSDatabasePassword = string;    // max: 128, min: 8
    export type RDSDatabaseUsername = string;    // max: 128, min: 1
    export type RDSInstanceIdentifier = string;    // pattern: &quot;[a-z0-9-]+&quot;, max: 63, min: 1
    export type RDSSelectSqlQuery = string;    // max: 16777216, min: 1
    export type RealtimeEndpointStatus = string;
    export type Recipe = string;    // max: 131071
    export type Record = {[key:string]: VariableValue};
    export type RedshiftClusterIdentifier = string;    // pattern: &quot;[a-z0-9-]+&quot;, max: 63, min: 1
    export type RedshiftDatabaseName = string;    // pattern: &quot;[a-z0-9]+&quot;, max: 64, min: 1
    export type RedshiftDatabasePassword = string;    // max: 64, min: 8
    export type RedshiftDatabaseUsername = string;    // max: 128, min: 1
    export type RedshiftSelectSqlQuery = string;    // max: 16777216, min: 1
    export type RoleARN = string;    // max: 100, min: 1
    export type S3Url = string;    // pattern: &quot;s3://([^/]+)(/.*)?&quot;, max: 2048
    export type ScoreThreshold = number;
    export type ScoreValue = number;
    export type ScoreValuePerLabelMap = {[key:string]: ScoreValue};
    export type SortOrder = string;
    export type StringType = string;
    export type TrainingParameters = {[key:string]: StringType};
    export type VariableName = string;
    export type VariableValue = string;
    export type Verbose = boolean;
    export type VipURL = string;    // pattern: &quot;https://[a-zA-Z0-9-.]*\.amazon(aws)?\.com[/]?&quot;, max: 2048
    export type floatLabel = number;

    export interface BatchPrediction {
        BatchPredictionId?: EntityId;
        MLModelId?: EntityId;
        BatchPredictionDataSourceId?: EntityId;
        InputDataLocationS3?: S3Url;
        CreatedByIamUser?: AwsUserArn;
        CreatedAt?: EpochTime;
        LastUpdatedAt?: EpochTime;
        Name?: EntityName;
        Status?: EntityStatus;
        OutputUri?: S3Url;
        Message?: Message;
    }
    export interface CreateBatchPredictionInput {
        BatchPredictionId: EntityId;
        BatchPredictionName?: EntityName;
        MLModelId: EntityId;
        BatchPredictionDataSourceId: EntityId;
        OutputUri: S3Url;
    }
    export interface CreateBatchPredictionOutput {
        BatchPredictionId?: EntityId;
    }
    export interface CreateDataSourceFromRDSInput {
        DataSourceId: EntityId;
        DataSourceName?: EntityName;
        RDSData: RDSDataSpec;
        RoleARN: RoleARN;
        ComputeStatistics?: ComputeStatistics;
    }
    export interface CreateDataSourceFromRDSOutput {
        DataSourceId?: EntityId;
    }
    export interface CreateDataSourceFromRedshiftInput {
        DataSourceId: EntityId;
        DataSourceName?: EntityName;
        DataSpec: RedshiftDataSpec;
        RoleARN: RoleARN;
        ComputeStatistics?: ComputeStatistics;
    }
    export interface CreateDataSourceFromRedshiftOutput {
        DataSourceId?: EntityId;
    }
    export interface CreateDataSourceFromS3Input {
        DataSourceId: EntityId;
        DataSourceName?: EntityName;
        DataSpec: S3DataSpec;
        ComputeStatistics?: ComputeStatistics;
    }
    export interface CreateDataSourceFromS3Output {
        DataSourceId?: EntityId;
    }
    export interface CreateEvaluationInput {
        EvaluationId: EntityId;
        EvaluationName?: EntityName;
        MLModelId: EntityId;
        EvaluationDataSourceId: EntityId;
    }
    export interface CreateEvaluationOutput {
        EvaluationId?: EntityId;
    }
    export interface CreateMLModelInput {
        MLModelId: EntityId;
        MLModelName?: EntityName;
        MLModelType: MLModelType;
        Parameters?: TrainingParameters;
        TrainingDataSourceId: EntityId;
        Recipe?: Recipe;
        RecipeUri?: S3Url;
    }
    export interface CreateMLModelOutput {
        MLModelId?: EntityId;
    }
    export interface CreateRealtimeEndpointInput {
        MLModelId: EntityId;
    }
    export interface CreateRealtimeEndpointOutput {
        MLModelId?: EntityId;
        RealtimeEndpointInfo?: RealtimeEndpointInfo;
    }
    export interface DataSource {
        DataSourceId?: EntityId;
        DataLocationS3?: S3Url;
        DataRearrangement?: DataRearrangement;
        CreatedByIamUser?: AwsUserArn;
        CreatedAt?: EpochTime;
        LastUpdatedAt?: EpochTime;
        DataSizeInBytes?: LongType;
        NumberOfFiles?: LongType;
        Name?: EntityName;
        Status?: EntityStatus;
        Message?: Message;
        RedshiftMetadata?: RedshiftMetadata;
        RDSMetadata?: RDSMetadata;
        RoleARN?: RoleARN;
        ComputeStatistics?: ComputeStatistics;
    }
    export interface DeleteBatchPredictionInput {
        BatchPredictionId: EntityId;
    }
    export interface DeleteBatchPredictionOutput {
        BatchPredictionId?: EntityId;
    }
    export interface DeleteDataSourceInput {
        DataSourceId: EntityId;
    }
    export interface DeleteDataSourceOutput {
        DataSourceId?: EntityId;
    }
    export interface DeleteEvaluationInput {
        EvaluationId: EntityId;
    }
    export interface DeleteEvaluationOutput {
        EvaluationId?: EntityId;
    }
    export interface DeleteMLModelInput {
        MLModelId: EntityId;
    }
    export interface DeleteMLModelOutput {
        MLModelId?: EntityId;
    }
    export interface DeleteRealtimeEndpointInput {
        MLModelId: EntityId;
    }
    export interface DeleteRealtimeEndpointOutput {
        MLModelId?: EntityId;
        RealtimeEndpointInfo?: RealtimeEndpointInfo;
    }
    export interface DescribeBatchPredictionsInput {
        FilterVariable?: BatchPredictionFilterVariable;
        EQ?: ComparatorValue;
        GT?: ComparatorValue;
        LT?: ComparatorValue;
        GE?: ComparatorValue;
        LE?: ComparatorValue;
        NE?: ComparatorValue;
        Prefix?: ComparatorValue;
        SortOrder?: SortOrder;
        NextToken?: StringType;
        Limit?: PageLimit;
    }
    export interface DescribeBatchPredictionsOutput {
        Results?: BatchPredictions;
        NextToken?: StringType;
    }
    export interface DescribeDataSourcesInput {
        FilterVariable?: DataSourceFilterVariable;
        EQ?: ComparatorValue;
        GT?: ComparatorValue;
        LT?: ComparatorValue;
        GE?: ComparatorValue;
        LE?: ComparatorValue;
        NE?: ComparatorValue;
        Prefix?: ComparatorValue;
        SortOrder?: SortOrder;
        NextToken?: StringType;
        Limit?: PageLimit;
    }
    export interface DescribeDataSourcesOutput {
        Results?: DataSources;
        NextToken?: StringType;
    }
    export interface DescribeEvaluationsInput {
        FilterVariable?: EvaluationFilterVariable;
        EQ?: ComparatorValue;
        GT?: ComparatorValue;
        LT?: ComparatorValue;
        GE?: ComparatorValue;
        LE?: ComparatorValue;
        NE?: ComparatorValue;
        Prefix?: ComparatorValue;
        SortOrder?: SortOrder;
        NextToken?: StringType;
        Limit?: PageLimit;
    }
    export interface DescribeEvaluationsOutput {
        Results?: Evaluations;
        NextToken?: StringType;
    }
    export interface DescribeMLModelsInput {
        FilterVariable?: MLModelFilterVariable;
        EQ?: ComparatorValue;
        GT?: ComparatorValue;
        LT?: ComparatorValue;
        GE?: ComparatorValue;
        LE?: ComparatorValue;
        NE?: ComparatorValue;
        Prefix?: ComparatorValue;
        SortOrder?: SortOrder;
        NextToken?: StringType;
        Limit?: PageLimit;
    }
    export interface DescribeMLModelsOutput {
        Results?: MLModels;
        NextToken?: StringType;
    }
    export interface Evaluation {
        EvaluationId?: EntityId;
        MLModelId?: EntityId;
        EvaluationDataSourceId?: EntityId;
        InputDataLocationS3?: S3Url;
        CreatedByIamUser?: AwsUserArn;
        CreatedAt?: EpochTime;
        LastUpdatedAt?: EpochTime;
        Name?: EntityName;
        Status?: EntityStatus;
        PerformanceMetrics?: PerformanceMetrics;
        Message?: Message;
    }
    export interface GetBatchPredictionInput {
        BatchPredictionId: EntityId;
    }
    export interface GetBatchPredictionOutput {
        BatchPredictionId?: EntityId;
        MLModelId?: EntityId;
        BatchPredictionDataSourceId?: EntityId;
        InputDataLocationS3?: S3Url;
        CreatedByIamUser?: AwsUserArn;
        CreatedAt?: EpochTime;
        LastUpdatedAt?: EpochTime;
        Name?: EntityName;
        Status?: EntityStatus;
        OutputUri?: S3Url;
        LogUri?: PresignedS3Url;
        Message?: Message;
    }
    export interface GetDataSourceInput {
        DataSourceId: EntityId;
        Verbose?: Verbose;
    }
    export interface GetDataSourceOutput {
        DataSourceId?: EntityId;
        DataLocationS3?: S3Url;
        DataRearrangement?: DataRearrangement;
        CreatedByIamUser?: AwsUserArn;
        CreatedAt?: EpochTime;
        LastUpdatedAt?: EpochTime;
        DataSizeInBytes?: LongType;
        NumberOfFiles?: LongType;
        Name?: EntityName;
        Status?: EntityStatus;
        LogUri?: PresignedS3Url;
        Message?: Message;
        RedshiftMetadata?: RedshiftMetadata;
        RDSMetadata?: RDSMetadata;
        RoleARN?: RoleARN;
        ComputeStatistics?: ComputeStatistics;
        DataSourceSchema?: DataSchema;
    }
    export interface GetEvaluationInput {
        EvaluationId: EntityId;
    }
    export interface GetEvaluationOutput {
        EvaluationId?: EntityId;
        MLModelId?: EntityId;
        EvaluationDataSourceId?: EntityId;
        InputDataLocationS3?: S3Url;
        CreatedByIamUser?: AwsUserArn;
        CreatedAt?: EpochTime;
        LastUpdatedAt?: EpochTime;
        Name?: EntityName;
        Status?: EntityStatus;
        PerformanceMetrics?: PerformanceMetrics;
        LogUri?: PresignedS3Url;
        Message?: Message;
    }
    export interface GetMLModelInput {
        MLModelId: EntityId;
        Verbose?: Verbose;
    }
    export interface GetMLModelOutput {
        MLModelId?: EntityId;
        TrainingDataSourceId?: EntityId;
        CreatedByIamUser?: AwsUserArn;
        CreatedAt?: EpochTime;
        LastUpdatedAt?: EpochTime;
        Name?: MLModelName;
        Status?: EntityStatus;
        SizeInBytes?: LongType;
        EndpointInfo?: RealtimeEndpointInfo;
        TrainingParameters?: TrainingParameters;
        InputDataLocationS3?: S3Url;
        MLModelType?: MLModelType;
        ScoreThreshold?: ScoreThreshold;
        ScoreThresholdLastUpdatedAt?: EpochTime;
        LogUri?: PresignedS3Url;
        Message?: Message;
        Recipe?: Recipe;
        Schema?: DataSchema;
    }
    export interface IdempotentParameterMismatchException {
        message?: ErrorMessage;
        code?: ErrorCode;
    }
    export interface InternalServerException {
        message?: ErrorMessage;
        code?: ErrorCode;
    }
    export interface InvalidInputException {
        message?: ErrorMessage;
        code?: ErrorCode;
    }
    export interface LimitExceededException {
        message?: ErrorMessage;
        code?: ErrorCode;
    }
    export interface MLModel {
        MLModelId?: EntityId;
        TrainingDataSourceId?: EntityId;
        CreatedByIamUser?: AwsUserArn;
        CreatedAt?: EpochTime;
        LastUpdatedAt?: EpochTime;
        Name?: MLModelName;
        Status?: EntityStatus;
        SizeInBytes?: LongType;
        EndpointInfo?: RealtimeEndpointInfo;
        TrainingParameters?: TrainingParameters;
        InputDataLocationS3?: S3Url;
        Algorithm?: Algorithm;
        MLModelType?: MLModelType;
        ScoreThreshold?: ScoreThreshold;
        ScoreThresholdLastUpdatedAt?: EpochTime;
        Message?: Message;
    }
    export interface PerformanceMetrics {
        Properties?: PerformanceMetricsProperties;
    }
    export interface PredictInput {
        MLModelId: EntityId;
        Record: Record;
        PredictEndpoint: VipURL;
    }
    export interface PredictOutput {
        Prediction?: Prediction;
    }
    export interface Prediction {
        predictedLabel?: Label;
        predictedValue?: floatLabel;
        predictedScores?: ScoreValuePerLabelMap;
        details?: DetailsMap;
    }
    export interface PredictorNotMountedException {
        message?: ErrorMessage;
    }
    export interface RDSDataSpec {
        DatabaseInformation: RDSDatabase;
        SelectSqlQuery: RDSSelectSqlQuery;
        DatabaseCredentials: RDSDatabaseCredentials;
        S3StagingLocation: S3Url;
        DataRearrangement?: DataRearrangement;
        DataSchema?: DataSchema;
        DataSchemaUri?: S3Url;
        ResourceRole: EDPResourceRole;
        ServiceRole: EDPServiceRole;
        SubnetId: EDPSubnetId;
        SecurityGroupIds: EDPSecurityGroupIds;
    }
    export interface RDSDatabase {
        InstanceIdentifier: RDSInstanceIdentifier;
        DatabaseName: RDSDatabaseName;
    }
    export interface RDSDatabaseCredentials {
        Username: RDSDatabaseUsername;
        Password: RDSDatabasePassword;
    }
    export interface RDSMetadata {
        Database?: RDSDatabase;
        DatabaseUserName?: RDSDatabaseUsername;
        SelectSqlQuery?: RDSSelectSqlQuery;
        ResourceRole?: EDPResourceRole;
        ServiceRole?: EDPServiceRole;
        DataPipelineId?: EDPPipelineId;
    }
    export interface RealtimeEndpointInfo {
        PeakRequestsPerSecond?: IntegerType;
        CreatedAt?: EpochTime;
        EndpointUrl?: VipURL;
        EndpointStatus?: RealtimeEndpointStatus;
    }
    export interface RedshiftDataSpec {
        DatabaseInformation: RedshiftDatabase;
        SelectSqlQuery: RedshiftSelectSqlQuery;
        DatabaseCredentials: RedshiftDatabaseCredentials;
        S3StagingLocation: S3Url;
        DataRearrangement?: DataRearrangement;
        DataSchema?: DataSchema;
        DataSchemaUri?: S3Url;
    }
    export interface RedshiftDatabase {
        DatabaseName: RedshiftDatabaseName;
        ClusterIdentifier: RedshiftClusterIdentifier;
    }
    export interface RedshiftDatabaseCredentials {
        Username: RedshiftDatabaseUsername;
        Password: RedshiftDatabasePassword;
    }
    export interface RedshiftMetadata {
        RedshiftDatabase?: RedshiftDatabase;
        DatabaseUserName?: RedshiftDatabaseUsername;
        SelectSqlQuery?: RedshiftSelectSqlQuery;
    }
    export interface ResourceNotFoundException {
        message?: ErrorMessage;
        code?: ErrorCode;
    }
    export interface S3DataSpec {
        DataLocationS3: S3Url;
        DataRearrangement?: DataRearrangement;
        DataSchema?: DataSchema;
        DataSchemaLocationS3?: S3Url;
    }
    export interface UpdateBatchPredictionInput {
        BatchPredictionId: EntityId;
        BatchPredictionName: EntityName;
    }
    export interface UpdateBatchPredictionOutput {
        BatchPredictionId?: EntityId;
    }
    export interface UpdateDataSourceInput {
        DataSourceId: EntityId;
        DataSourceName: EntityName;
    }
    export interface UpdateDataSourceOutput {
        DataSourceId?: EntityId;
    }
    export interface UpdateEvaluationInput {
        EvaluationId: EntityId;
        EvaluationName: EntityName;
    }
    export interface UpdateEvaluationOutput {
        EvaluationId?: EntityId;
    }
    export interface UpdateMLModelInput {
        MLModelId: EntityId;
        MLModelName?: EntityName;
        ScoreThreshold?: ScoreThreshold;
    }
    export interface UpdateMLModelOutput {
        MLModelId?: EntityId;
    }
  }

  /*
   * apiVersion: 2015-07-01
   * endpointPrefix: marketplacecommerceanalytics
   * serviceAbbreviation: 
   * signatureVersion: v4
   * protocol: json
   */
  export class MarketplaceCommerceAnalytics extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    generateDataSet(params: MarketplaceCommerceAnalytics.GenerateDataSetRequest, callback?: (err: MarketplaceCommerceAnalytics.MarketplaceCommerceAnalyticsException|any, data: MarketplaceCommerceAnalytics.GenerateDataSetResult|any) => void): Request;

  }

  export module MarketplaceCommerceAnalytics {
    export type CustomerDefinedValues = {[key:string]: OptionalValue};    // max: 5, min: 1
    export type DataSetPublicationDate = number;
    export type DataSetRequestId = string;
    export type DataSetType = string;    // max: 255, min: 1
    export type DestinationS3BucketName = string;    // min: 1
    export type DestinationS3Prefix = string;
    export type ExceptionMessage = string;
    export type OptionalKey = string;    // max: 255, min: 1
    export type OptionalValue = string;    // max: 255, min: 1
    export type RoleNameArn = string;    // min: 1
    export type SnsTopicArn = string;    // min: 1

    export interface GenerateDataSetRequest {
        dataSetType: DataSetType;
        dataSetPublicationDate: DataSetPublicationDate;
        roleNameArn: RoleNameArn;
        destinationS3BucketName: DestinationS3BucketName;
        destinationS3Prefix?: DestinationS3Prefix;
        snsTopicArn: SnsTopicArn;
        customerDefinedValues?: CustomerDefinedValues;
    }
    export interface GenerateDataSetResult {
        dataSetRequestId?: DataSetRequestId;
    }
    export interface MarketplaceCommerceAnalyticsException {
        message?: ExceptionMessage;
    }
  }

  /*
   * apiVersion: 2016-01-14
   * endpointPrefix: metering.marketplace
   * serviceAbbreviation: 
   * signatureVersion: v4
   * protocol: json
   */
  export class MarketplaceMetering extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    meterUsage(params: MarketplaceMetering.MeterUsageRequest, callback?: (err: MarketplaceMetering.InternalServiceErrorException|MarketplaceMetering.InvalidProductCodeException|MarketplaceMetering.InvalidUsageDimensionException|MarketplaceMetering.InvalidEndpointRegionException|MarketplaceMetering.TimestampOutOfBoundsException|MarketplaceMetering.DuplicateRequestException|MarketplaceMetering.ThrottlingException|any, data: MarketplaceMetering.MeterUsageResult|any) => void): Request;

  }

  export module MarketplaceMetering {
    export type Boolean = boolean;
    export type ProductCode = string;    // max: 255, min: 1
    export type String = string;
    export type Timestamp = number;
    export type UsageDimension = string;    // max: 255, min: 1
    export type UsageQuantity = number;    // max: 10000
    export type errorMessage = string;

    export interface DuplicateRequestException {
        message?: errorMessage;
    }
    export interface InternalServiceErrorException {
        message?: errorMessage;
    }
    export interface InvalidEndpointRegionException {
        message?: errorMessage;
    }
    export interface InvalidProductCodeException {
        message?: errorMessage;
    }
    export interface InvalidUsageDimensionException {
        message?: errorMessage;
    }
    export interface MeterUsageRequest {
        ProductCode: ProductCode;
        Timestamp: Timestamp;
        UsageDimension: UsageDimension;
        UsageQuantity: UsageQuantity;
        DryRun: Boolean;
    }
    export interface MeterUsageResult {
        MeteringRecordId?: String;
    }
    export interface ThrottlingException {
        message?: errorMessage;
    }
    export interface TimestampOutOfBoundsException {
        message?: errorMessage;
    }
  }

  /*
   * apiVersion: 2014-06-05
   * endpointPrefix: mobileanalytics
   * serviceAbbreviation: 
   * signatureVersion: v4
   * protocol: rest-json
   */
  export class MobileAnalytics extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    putEvents(params: MobileAnalytics.PutEventsInput, callback?: (err: MobileAnalytics.BadRequestException|any, data: any) => void): Request;

  }

  export module MobileAnalytics {
    export type Double = number;
    export type EventListDefinition = Event[];
    export type ISO8601Timestamp = string;
    export type Long = number;
    export type MapOfStringToNumber = {[key:string]: Double};    // max: 50
    export type MapOfStringToString = {[key:string]: String0to1000Chars};    // max: 50
    export type String = string;
    export type String0to1000Chars = string;    // max: 1000
    export type String10Chars = string;    // max: 10, min: 1
    export type String50Chars = string;    // max: 50, min: 1

    export interface BadRequestException {
        message?: String;
    }
    export interface Event {
        eventType: String50Chars;
        timestamp: ISO8601Timestamp;
        session?: Session;
        version?: String10Chars;
        attributes?: MapOfStringToString;
        metrics?: MapOfStringToNumber;
    }
    export interface PutEventsInput {
        events: EventListDefinition;
        clientContext: String;
        clientContextEncoding?: String;
    }
    export interface Session {
        id?: String50Chars;
        duration?: Long;
        startTimestamp?: ISO8601Timestamp;
        stopTimestamp?: ISO8601Timestamp;
    }
  }

  /*
   * apiVersion: 2013-02-18
   * endpointPrefix: opsworks
   * serviceAbbreviation: 
   * signatureVersion: v4
   * protocol: json
   */
  export class OpsWorks extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    assignInstance(params: OpsWorks.AssignInstanceRequest, callback?: (err: OpsWorks.ValidationException|OpsWorks.ResourceNotFoundException|any, data: any) => void): Request;
    assignVolume(params: OpsWorks.AssignVolumeRequest, callback?: (err: OpsWorks.ValidationException|OpsWorks.ResourceNotFoundException|any, data: any) => void): Request;
    associateElasticIp(params: OpsWorks.AssociateElasticIpRequest, callback?: (err: OpsWorks.ValidationException|OpsWorks.ResourceNotFoundException|any, data: any) => void): Request;
    attachElasticLoadBalancer(params: OpsWorks.AttachElasticLoadBalancerRequest, callback?: (err: OpsWorks.ValidationException|OpsWorks.ResourceNotFoundException|any, data: any) => void): Request;
    cloneStack(params: OpsWorks.CloneStackRequest, callback?: (err: OpsWorks.ValidationException|OpsWorks.ResourceNotFoundException|any, data: OpsWorks.CloneStackResult|any) => void): Request;
    createApp(params: OpsWorks.CreateAppRequest, callback?: (err: OpsWorks.ValidationException|OpsWorks.ResourceNotFoundException|any, data: OpsWorks.CreateAppResult|any) => void): Request;
    createDeployment(params: OpsWorks.CreateDeploymentRequest, callback?: (err: OpsWorks.ValidationException|OpsWorks.ResourceNotFoundException|any, data: OpsWorks.CreateDeploymentResult|any) => void): Request;
    createInstance(params: OpsWorks.CreateInstanceRequest, callback?: (err: OpsWorks.ValidationException|OpsWorks.ResourceNotFoundException|any, data: OpsWorks.CreateInstanceResult|any) => void): Request;
    createLayer(params: OpsWorks.CreateLayerRequest, callback?: (err: OpsWorks.ValidationException|OpsWorks.ResourceNotFoundException|any, data: OpsWorks.CreateLayerResult|any) => void): Request;
    createStack(params: OpsWorks.CreateStackRequest, callback?: (err: OpsWorks.ValidationException|any, data: OpsWorks.CreateStackResult|any) => void): Request;
    createUserProfile(params: OpsWorks.CreateUserProfileRequest, callback?: (err: OpsWorks.ValidationException|any, data: OpsWorks.CreateUserProfileResult|any) => void): Request;
    deleteApp(params: OpsWorks.DeleteAppRequest, callback?: (err: OpsWorks.ValidationException|OpsWorks.ResourceNotFoundException|any, data: any) => void): Request;
    deleteInstance(params: OpsWorks.DeleteInstanceRequest, callback?: (err: OpsWorks.ValidationException|OpsWorks.ResourceNotFoundException|any, data: any) => void): Request;
    deleteLayer(params: OpsWorks.DeleteLayerRequest, callback?: (err: OpsWorks.ValidationException|OpsWorks.ResourceNotFoundException|any, data: any) => void): Request;
    deleteStack(params: OpsWorks.DeleteStackRequest, callback?: (err: OpsWorks.ValidationException|OpsWorks.ResourceNotFoundException|any, data: any) => void): Request;
    deleteUserProfile(params: OpsWorks.DeleteUserProfileRequest, callback?: (err: OpsWorks.ValidationException|OpsWorks.ResourceNotFoundException|any, data: any) => void): Request;
    deregisterEcsCluster(params: OpsWorks.DeregisterEcsClusterRequest, callback?: (err: OpsWorks.ValidationException|OpsWorks.ResourceNotFoundException|any, data: any) => void): Request;
    deregisterElasticIp(params: OpsWorks.DeregisterElasticIpRequest, callback?: (err: OpsWorks.ValidationException|OpsWorks.ResourceNotFoundException|any, data: any) => void): Request;
    deregisterInstance(params: OpsWorks.DeregisterInstanceRequest, callback?: (err: OpsWorks.ValidationException|OpsWorks.ResourceNotFoundException|any, data: any) => void): Request;
    deregisterRdsDbInstance(params: OpsWorks.DeregisterRdsDbInstanceRequest, callback?: (err: OpsWorks.ValidationException|OpsWorks.ResourceNotFoundException|any, data: any) => void): Request;
    deregisterVolume(params: OpsWorks.DeregisterVolumeRequest, callback?: (err: OpsWorks.ValidationException|OpsWorks.ResourceNotFoundException|any, data: any) => void): Request;
    describeAgentVersions(params: OpsWorks.DescribeAgentVersionsRequest, callback?: (err: OpsWorks.ValidationException|OpsWorks.ResourceNotFoundException|any, data: OpsWorks.DescribeAgentVersionsResult|any) => void): Request;
    describeApps(params: OpsWorks.DescribeAppsRequest, callback?: (err: OpsWorks.ValidationException|OpsWorks.ResourceNotFoundException|any, data: OpsWorks.DescribeAppsResult|any) => void): Request;
    describeCommands(params: OpsWorks.DescribeCommandsRequest, callback?: (err: OpsWorks.ValidationException|OpsWorks.ResourceNotFoundException|any, data: OpsWorks.DescribeCommandsResult|any) => void): Request;
    describeDeployments(params: OpsWorks.DescribeDeploymentsRequest, callback?: (err: OpsWorks.ValidationException|OpsWorks.ResourceNotFoundException|any, data: OpsWorks.DescribeDeploymentsResult|any) => void): Request;
    describeEcsClusters(params: OpsWorks.DescribeEcsClustersRequest, callback?: (err: OpsWorks.ValidationException|OpsWorks.ResourceNotFoundException|any, data: OpsWorks.DescribeEcsClustersResult|any) => void): Request;
    describeElasticIps(params: OpsWorks.DescribeElasticIpsRequest, callback?: (err: OpsWorks.ValidationException|OpsWorks.ResourceNotFoundException|any, data: OpsWorks.DescribeElasticIpsResult|any) => void): Request;
    describeElasticLoadBalancers(params: OpsWorks.DescribeElasticLoadBalancersRequest, callback?: (err: OpsWorks.ValidationException|OpsWorks.ResourceNotFoundException|any, data: OpsWorks.DescribeElasticLoadBalancersResult|any) => void): Request;
    describeInstances(params: OpsWorks.DescribeInstancesRequest, callback?: (err: OpsWorks.ValidationException|OpsWorks.ResourceNotFoundException|any, data: OpsWorks.DescribeInstancesResult|any) => void): Request;
    describeLayers(params: OpsWorks.DescribeLayersRequest, callback?: (err: OpsWorks.ValidationException|OpsWorks.ResourceNotFoundException|any, data: OpsWorks.DescribeLayersResult|any) => void): Request;
    describeLoadBasedAutoScaling(params: OpsWorks.DescribeLoadBasedAutoScalingRequest, callback?: (err: OpsWorks.ValidationException|OpsWorks.ResourceNotFoundException|any, data: OpsWorks.DescribeLoadBasedAutoScalingResult|any) => void): Request;
    describeMyUserProfile(callback?: (err: any, data: OpsWorks.DescribeMyUserProfileResult|any) => void): Request;
    describePermissions(params: OpsWorks.DescribePermissionsRequest, callback?: (err: OpsWorks.ValidationException|OpsWorks.ResourceNotFoundException|any, data: OpsWorks.DescribePermissionsResult|any) => void): Request;
    describeRaidArrays(params: OpsWorks.DescribeRaidArraysRequest, callback?: (err: OpsWorks.ValidationException|OpsWorks.ResourceNotFoundException|any, data: OpsWorks.DescribeRaidArraysResult|any) => void): Request;
    describeRdsDbInstances(params: OpsWorks.DescribeRdsDbInstancesRequest, callback?: (err: OpsWorks.ValidationException|OpsWorks.ResourceNotFoundException|any, data: OpsWorks.DescribeRdsDbInstancesResult|any) => void): Request;
    describeServiceErrors(params: OpsWorks.DescribeServiceErrorsRequest, callback?: (err: OpsWorks.ValidationException|OpsWorks.ResourceNotFoundException|any, data: OpsWorks.DescribeServiceErrorsResult|any) => void): Request;
    describeStackProvisioningParameters(params: OpsWorks.DescribeStackProvisioningParametersRequest, callback?: (err: OpsWorks.ValidationException|OpsWorks.ResourceNotFoundException|any, data: OpsWorks.DescribeStackProvisioningParametersResult|any) => void): Request;
    describeStackSummary(params: OpsWorks.DescribeStackSummaryRequest, callback?: (err: OpsWorks.ValidationException|OpsWorks.ResourceNotFoundException|any, data: OpsWorks.DescribeStackSummaryResult|any) => void): Request;
    describeStacks(params: OpsWorks.DescribeStacksRequest, callback?: (err: OpsWorks.ValidationException|OpsWorks.ResourceNotFoundException|any, data: OpsWorks.DescribeStacksResult|any) => void): Request;
    describeTimeBasedAutoScaling(params: OpsWorks.DescribeTimeBasedAutoScalingRequest, callback?: (err: OpsWorks.ValidationException|OpsWorks.ResourceNotFoundException|any, data: OpsWorks.DescribeTimeBasedAutoScalingResult|any) => void): Request;
    describeUserProfiles(params: OpsWorks.DescribeUserProfilesRequest, callback?: (err: OpsWorks.ValidationException|OpsWorks.ResourceNotFoundException|any, data: OpsWorks.DescribeUserProfilesResult|any) => void): Request;
    describeVolumes(params: OpsWorks.DescribeVolumesRequest, callback?: (err: OpsWorks.ValidationException|OpsWorks.ResourceNotFoundException|any, data: OpsWorks.DescribeVolumesResult|any) => void): Request;
    detachElasticLoadBalancer(params: OpsWorks.DetachElasticLoadBalancerRequest, callback?: (err: OpsWorks.ResourceNotFoundException|any, data: any) => void): Request;
    disassociateElasticIp(params: OpsWorks.DisassociateElasticIpRequest, callback?: (err: OpsWorks.ValidationException|OpsWorks.ResourceNotFoundException|any, data: any) => void): Request;
    getHostnameSuggestion(params: OpsWorks.GetHostnameSuggestionRequest, callback?: (err: OpsWorks.ValidationException|OpsWorks.ResourceNotFoundException|any, data: OpsWorks.GetHostnameSuggestionResult|any) => void): Request;
    grantAccess(params: OpsWorks.GrantAccessRequest, callback?: (err: OpsWorks.ValidationException|OpsWorks.ResourceNotFoundException|any, data: OpsWorks.GrantAccessResult|any) => void): Request;
    rebootInstance(params: OpsWorks.RebootInstanceRequest, callback?: (err: OpsWorks.ValidationException|OpsWorks.ResourceNotFoundException|any, data: any) => void): Request;
    registerEcsCluster(params: OpsWorks.RegisterEcsClusterRequest, callback?: (err: OpsWorks.ValidationException|OpsWorks.ResourceNotFoundException|any, data: OpsWorks.RegisterEcsClusterResult|any) => void): Request;
    registerElasticIp(params: OpsWorks.RegisterElasticIpRequest, callback?: (err: OpsWorks.ValidationException|OpsWorks.ResourceNotFoundException|any, data: OpsWorks.RegisterElasticIpResult|any) => void): Request;
    registerInstance(params: OpsWorks.RegisterInstanceRequest, callback?: (err: OpsWorks.ValidationException|OpsWorks.ResourceNotFoundException|any, data: OpsWorks.RegisterInstanceResult|any) => void): Request;
    registerRdsDbInstance(params: OpsWorks.RegisterRdsDbInstanceRequest, callback?: (err: OpsWorks.ValidationException|OpsWorks.ResourceNotFoundException|any, data: any) => void): Request;
    registerVolume(params: OpsWorks.RegisterVolumeRequest, callback?: (err: OpsWorks.ValidationException|OpsWorks.ResourceNotFoundException|any, data: OpsWorks.RegisterVolumeResult|any) => void): Request;
    setLoadBasedAutoScaling(params: OpsWorks.SetLoadBasedAutoScalingRequest, callback?: (err: OpsWorks.ValidationException|OpsWorks.ResourceNotFoundException|any, data: any) => void): Request;
    setPermission(params: OpsWorks.SetPermissionRequest, callback?: (err: OpsWorks.ValidationException|OpsWorks.ResourceNotFoundException|any, data: any) => void): Request;
    setTimeBasedAutoScaling(params: OpsWorks.SetTimeBasedAutoScalingRequest, callback?: (err: OpsWorks.ValidationException|OpsWorks.ResourceNotFoundException|any, data: any) => void): Request;
    startInstance(params: OpsWorks.StartInstanceRequest, callback?: (err: OpsWorks.ValidationException|OpsWorks.ResourceNotFoundException|any, data: any) => void): Request;
    startStack(params: OpsWorks.StartStackRequest, callback?: (err: OpsWorks.ValidationException|OpsWorks.ResourceNotFoundException|any, data: any) => void): Request;
    stopInstance(params: OpsWorks.StopInstanceRequest, callback?: (err: OpsWorks.ValidationException|OpsWorks.ResourceNotFoundException|any, data: any) => void): Request;
    stopStack(params: OpsWorks.StopStackRequest, callback?: (err: OpsWorks.ValidationException|OpsWorks.ResourceNotFoundException|any, data: any) => void): Request;
    unassignInstance(params: OpsWorks.UnassignInstanceRequest, callback?: (err: OpsWorks.ValidationException|OpsWorks.ResourceNotFoundException|any, data: any) => void): Request;
    unassignVolume(params: OpsWorks.UnassignVolumeRequest, callback?: (err: OpsWorks.ValidationException|OpsWorks.ResourceNotFoundException|any, data: any) => void): Request;
    updateApp(params: OpsWorks.UpdateAppRequest, callback?: (err: OpsWorks.ValidationException|OpsWorks.ResourceNotFoundException|any, data: any) => void): Request;
    updateElasticIp(params: OpsWorks.UpdateElasticIpRequest, callback?: (err: OpsWorks.ValidationException|OpsWorks.ResourceNotFoundException|any, data: any) => void): Request;
    updateInstance(params: OpsWorks.UpdateInstanceRequest, callback?: (err: OpsWorks.ValidationException|OpsWorks.ResourceNotFoundException|any, data: any) => void): Request;
    updateLayer(params: OpsWorks.UpdateLayerRequest, callback?: (err: OpsWorks.ValidationException|OpsWorks.ResourceNotFoundException|any, data: any) => void): Request;
    updateMyUserProfile(params: OpsWorks.UpdateMyUserProfileRequest, callback?: (err: OpsWorks.ValidationException|any, data: any) => void): Request;
    updateRdsDbInstance(params: OpsWorks.UpdateRdsDbInstanceRequest, callback?: (err: OpsWorks.ValidationException|OpsWorks.ResourceNotFoundException|any, data: any) => void): Request;
    updateStack(params: OpsWorks.UpdateStackRequest, callback?: (err: OpsWorks.ValidationException|OpsWorks.ResourceNotFoundException|any, data: any) => void): Request;
    updateUserProfile(params: OpsWorks.UpdateUserProfileRequest, callback?: (err: OpsWorks.ValidationException|OpsWorks.ResourceNotFoundException|any, data: any) => void): Request;
    updateVolume(params: OpsWorks.UpdateVolumeRequest, callback?: (err: OpsWorks.ValidationException|OpsWorks.ResourceNotFoundException|any, data: any) => void): Request;

  }

  export module OpsWorks {
    export type AgentVersions = AgentVersion[];
    export type AppAttributes = {[key:string]: String};
    export type AppAttributesKeys = string;
    export type AppType = string;
    export type Apps = App[];
    export type Architecture = string;
    export type AutoScalingType = string;
    export type BlockDeviceMappings = BlockDeviceMapping[];
    export type Boolean = boolean;
    export type Commands = Command[];
    export type DailyAutoScalingSchedule = {[key:string]: Switch};
    export type DataSources = DataSource[];
    export type DateTime = string;
    export type DeploymentCommandArgs = {[key:string]: Strings};
    export type DeploymentCommandName = string;
    export type Deployments = Deployment[];
    export type Double = number;
    export type EcsClusters = EcsCluster[];
    export type ElasticIps = ElasticIp[];
    export type ElasticLoadBalancers = ElasticLoadBalancer[];
    export type EnvironmentVariables = EnvironmentVariable[];
    export type Hour = string;
    export type Instances = Instance[];
    export type Integer = number;
    export type LayerAttributes = {[key:string]: String};
    export type LayerAttributesKeys = string;
    export type LayerType = string;
    export type Layers = Layer[];
    export type LoadBasedAutoScalingConfigurations = LoadBasedAutoScalingConfiguration[];
    export type Minute = number;    // max: 100, min: 1
    export type Parameters = {[key:string]: String};
    export type Permissions = Permission[];
    export type RaidArrays = RaidArray[];
    export type RdsDbInstances = RdsDbInstance[];
    export type RootDeviceType = string;
    export type ServiceErrors = ServiceError[];
    export type SourceType = string;
    export type StackAttributes = {[key:string]: String};
    export type StackAttributesKeys = string;
    export type Stacks = Stack[];
    export type String = string;
    export type Strings = String[];
    export type Switch = string;
    export type TimeBasedAutoScalingConfigurations = TimeBasedAutoScalingConfiguration[];
    export type UserProfiles = UserProfile[];
    export type ValidForInMinutes = number;    // max: 1440, min: 60
    export type VirtualizationType = string;
    export type VolumeConfigurations = VolumeConfiguration[];
    export type VolumeType = string;
    export type Volumes = Volume[];

    export interface AgentVersion {
        Version?: String;
        ConfigurationManager?: StackConfigurationManager;
    }
    export interface App {
        AppId?: String;
        StackId?: String;
        Shortname?: String;
        Name?: String;
        Description?: String;
        DataSources?: DataSources;
        Type?: AppType;
        AppSource?: Source;
        Domains?: Strings;
        EnableSsl?: Boolean;
        SslConfiguration?: SslConfiguration;
        Attributes?: AppAttributes;
        CreatedAt?: String;
        Environment?: EnvironmentVariables;
    }
    export interface AssignInstanceRequest {
        InstanceId: String;
        LayerIds: Strings;
    }
    export interface AssignVolumeRequest {
        VolumeId: String;
        InstanceId?: String;
    }
    export interface AssociateElasticIpRequest {
        ElasticIp: String;
        InstanceId?: String;
    }
    export interface AttachElasticLoadBalancerRequest {
        ElasticLoadBalancerName: String;
        LayerId: String;
    }
    export interface AutoScalingThresholds {
        InstanceCount?: Integer;
        ThresholdsWaitTime?: Minute;
        IgnoreMetricsTime?: Minute;
        CpuThreshold?: Double;
        MemoryThreshold?: Double;
        LoadThreshold?: Double;
        Alarms?: Strings;
    }
    export interface BlockDeviceMapping {
        DeviceName?: String;
        NoDevice?: String;
        VirtualName?: String;
        Ebs?: EbsBlockDevice;
    }
    export interface ChefConfiguration {
        ManageBerkshelf?: Boolean;
        BerkshelfVersion?: String;
    }
    export interface CloneStackRequest {
        SourceStackId: String;
        Name?: String;
        Region?: String;
        VpcId?: String;
        Attributes?: StackAttributes;
        ServiceRoleArn: String;
        DefaultInstanceProfileArn?: String;
        DefaultOs?: String;
        HostnameTheme?: String;
        DefaultAvailabilityZone?: String;
        DefaultSubnetId?: String;
        CustomJson?: String;
        ConfigurationManager?: StackConfigurationManager;
        ChefConfiguration?: ChefConfiguration;
        UseCustomCookbooks?: Boolean;
        UseOpsworksSecurityGroups?: Boolean;
        CustomCookbooksSource?: Source;
        DefaultSshKeyName?: String;
        ClonePermissions?: Boolean;
        CloneAppIds?: Strings;
        DefaultRootDeviceType?: RootDeviceType;
        AgentVersion?: String;
    }
    export interface CloneStackResult {
        StackId?: String;
    }
    export interface Command {
        CommandId?: String;
        InstanceId?: String;
        DeploymentId?: String;
        CreatedAt?: DateTime;
        AcknowledgedAt?: DateTime;
        CompletedAt?: DateTime;
        Status?: String;
        ExitCode?: Integer;
        LogUrl?: String;
        Type?: String;
    }
    export interface CreateAppRequest {
        StackId: String;
        Shortname?: String;
        Name: String;
        Description?: String;
        DataSources?: DataSources;
        Type: AppType;
        AppSource?: Source;
        Domains?: Strings;
        EnableSsl?: Boolean;
        SslConfiguration?: SslConfiguration;
        Attributes?: AppAttributes;
        Environment?: EnvironmentVariables;
    }
    export interface CreateAppResult {
        AppId?: String;
    }
    export interface CreateDeploymentRequest {
        StackId: String;
        AppId?: String;
        InstanceIds?: Strings;
        Command: DeploymentCommand;
        Comment?: String;
        CustomJson?: String;
    }
    export interface CreateDeploymentResult {
        DeploymentId?: String;
    }
    export interface CreateInstanceRequest {
        StackId: String;
        LayerIds: Strings;
        InstanceType: String;
        AutoScalingType?: AutoScalingType;
        Hostname?: String;
        Os?: String;
        AmiId?: String;
        SshKeyName?: String;
        AvailabilityZone?: String;
        VirtualizationType?: String;
        SubnetId?: String;
        Architecture?: Architecture;
        RootDeviceType?: RootDeviceType;
        BlockDeviceMappings?: BlockDeviceMappings;
        InstallUpdatesOnBoot?: Boolean;
        EbsOptimized?: Boolean;
        AgentVersion?: String;
    }
    export interface CreateInstanceResult {
        InstanceId?: String;
    }
    export interface CreateLayerRequest {
        StackId: String;
        Type: LayerType;
        Name: String;
        Shortname: String;
        Attributes?: LayerAttributes;
        CustomInstanceProfileArn?: String;
        CustomJson?: String;
        CustomSecurityGroupIds?: Strings;
        Packages?: Strings;
        VolumeConfigurations?: VolumeConfigurations;
        EnableAutoHealing?: Boolean;
        AutoAssignElasticIps?: Boolean;
        AutoAssignPublicIps?: Boolean;
        CustomRecipes?: Recipes;
        InstallUpdatesOnBoot?: Boolean;
        UseEbsOptimizedInstances?: Boolean;
        LifecycleEventConfiguration?: LifecycleEventConfiguration;
    }
    export interface CreateLayerResult {
        LayerId?: String;
    }
    export interface CreateStackRequest {
        Name: String;
        Region: String;
        VpcId?: String;
        Attributes?: StackAttributes;
        ServiceRoleArn: String;
        DefaultInstanceProfileArn: String;
        DefaultOs?: String;
        HostnameTheme?: String;
        DefaultAvailabilityZone?: String;
        DefaultSubnetId?: String;
        CustomJson?: String;
        ConfigurationManager?: StackConfigurationManager;
        ChefConfiguration?: ChefConfiguration;
        UseCustomCookbooks?: Boolean;
        UseOpsworksSecurityGroups?: Boolean;
        CustomCookbooksSource?: Source;
        DefaultSshKeyName?: String;
        DefaultRootDeviceType?: RootDeviceType;
        AgentVersion?: String;
    }
    export interface CreateStackResult {
        StackId?: String;
    }
    export interface CreateUserProfileRequest {
        IamUserArn: String;
        SshUsername?: String;
        SshPublicKey?: String;
        AllowSelfManagement?: Boolean;
    }
    export interface CreateUserProfileResult {
        IamUserArn?: String;
    }
    export interface DataSource {
        Type?: String;
        Arn?: String;
        DatabaseName?: String;
    }
    export interface DeleteAppRequest {
        AppId: String;
    }
    export interface DeleteInstanceRequest {
        InstanceId: String;
        DeleteElasticIp?: Boolean;
        DeleteVolumes?: Boolean;
    }
    export interface DeleteLayerRequest {
        LayerId: String;
    }
    export interface DeleteStackRequest {
        StackId: String;
    }
    export interface DeleteUserProfileRequest {
        IamUserArn: String;
    }
    export interface Deployment {
        DeploymentId?: String;
        StackId?: String;
        AppId?: String;
        CreatedAt?: DateTime;
        CompletedAt?: DateTime;
        Duration?: Integer;
        IamUserArn?: String;
        Comment?: String;
        Command?: DeploymentCommand;
        Status?: String;
        CustomJson?: String;
        InstanceIds?: Strings;
    }
    export interface DeploymentCommand {
        Name: DeploymentCommandName;
        Args?: DeploymentCommandArgs;
    }
    export interface DeregisterEcsClusterRequest {
        EcsClusterArn: String;
    }
    export interface DeregisterElasticIpRequest {
        ElasticIp: String;
    }
    export interface DeregisterInstanceRequest {
        InstanceId: String;
    }
    export interface DeregisterRdsDbInstanceRequest {
        RdsDbInstanceArn: String;
    }
    export interface DeregisterVolumeRequest {
        VolumeId: String;
    }
    export interface DescribeAgentVersionsRequest {
        StackId?: String;
        ConfigurationManager?: StackConfigurationManager;
    }
    export interface DescribeAgentVersionsResult {
        AgentVersions?: AgentVersions;
    }
    export interface DescribeAppsRequest {
        StackId?: String;
        AppIds?: Strings;
    }
    export interface DescribeAppsResult {
        Apps?: Apps;
    }
    export interface DescribeCommandsRequest {
        DeploymentId?: String;
        InstanceId?: String;
        CommandIds?: Strings;
    }
    export interface DescribeCommandsResult {
        Commands?: Commands;
    }
    export interface DescribeDeploymentsRequest {
        StackId?: String;
        AppId?: String;
        DeploymentIds?: Strings;
    }
    export interface DescribeDeploymentsResult {
        Deployments?: Deployments;
    }
    export interface DescribeEcsClustersRequest {
        EcsClusterArns?: Strings;
        StackId?: String;
        NextToken?: String;
        MaxResults?: Integer;
    }
    export interface DescribeEcsClustersResult {
        EcsClusters?: EcsClusters;
        NextToken?: String;
    }
    export interface DescribeElasticIpsRequest {
        InstanceId?: String;
        StackId?: String;
        Ips?: Strings;
    }
    export interface DescribeElasticIpsResult {
        ElasticIps?: ElasticIps;
    }
    export interface DescribeElasticLoadBalancersRequest {
        StackId?: String;
        LayerIds?: Strings;
    }
    export interface DescribeElasticLoadBalancersResult {
        ElasticLoadBalancers?: ElasticLoadBalancers;
    }
    export interface DescribeInstancesRequest {
        StackId?: String;
        LayerId?: String;
        InstanceIds?: Strings;
    }
    export interface DescribeInstancesResult {
        Instances?: Instances;
    }
    export interface DescribeLayersRequest {
        StackId?: String;
        LayerIds?: Strings;
    }
    export interface DescribeLayersResult {
        Layers?: Layers;
    }
    export interface DescribeLoadBasedAutoScalingRequest {
        LayerIds: Strings;
    }
    export interface DescribeLoadBasedAutoScalingResult {
        LoadBasedAutoScalingConfigurations?: LoadBasedAutoScalingConfigurations;
    }
    export interface DescribeMyUserProfileResult {
        UserProfile?: SelfUserProfile;
    }
    export interface DescribePermissionsRequest {
        IamUserArn?: String;
        StackId?: String;
    }
    export interface DescribePermissionsResult {
        Permissions?: Permissions;
    }
    export interface DescribeRaidArraysRequest {
        InstanceId?: String;
        StackId?: String;
        RaidArrayIds?: Strings;
    }
    export interface DescribeRaidArraysResult {
        RaidArrays?: RaidArrays;
    }
    export interface DescribeRdsDbInstancesRequest {
        StackId: String;
        RdsDbInstanceArns?: Strings;
    }
    export interface DescribeRdsDbInstancesResult {
        RdsDbInstances?: RdsDbInstances;
    }
    export interface DescribeServiceErrorsRequest {
        StackId?: String;
        InstanceId?: String;
        ServiceErrorIds?: Strings;
    }
    export interface DescribeServiceErrorsResult {
        ServiceErrors?: ServiceErrors;
    }
    export interface DescribeStackProvisioningParametersRequest {
        StackId: String;
    }
    export interface DescribeStackProvisioningParametersResult {
        AgentInstallerUrl?: String;
        Parameters?: Parameters;
    }
    export interface DescribeStackSummaryRequest {
        StackId: String;
    }
    export interface DescribeStackSummaryResult {
        StackSummary?: StackSummary;
    }
    export interface DescribeStacksRequest {
        StackIds?: Strings;
    }
    export interface DescribeStacksResult {
        Stacks?: Stacks;
    }
    export interface DescribeTimeBasedAutoScalingRequest {
        InstanceIds: Strings;
    }
    export interface DescribeTimeBasedAutoScalingResult {
        TimeBasedAutoScalingConfigurations?: TimeBasedAutoScalingConfigurations;
    }
    export interface DescribeUserProfilesRequest {
        IamUserArns?: Strings;
    }
    export interface DescribeUserProfilesResult {
        UserProfiles?: UserProfiles;
    }
    export interface DescribeVolumesRequest {
        InstanceId?: String;
        StackId?: String;
        RaidArrayId?: String;
        VolumeIds?: Strings;
    }
    export interface DescribeVolumesResult {
        Volumes?: Volumes;
    }
    export interface DetachElasticLoadBalancerRequest {
        ElasticLoadBalancerName: String;
        LayerId: String;
    }
    export interface DisassociateElasticIpRequest {
        ElasticIp: String;
    }
    export interface EbsBlockDevice {
        SnapshotId?: String;
        Iops?: Integer;
        VolumeSize?: Integer;
        VolumeType?: VolumeType;
        DeleteOnTermination?: Boolean;
    }
    export interface EcsCluster {
        EcsClusterArn?: String;
        EcsClusterName?: String;
        StackId?: String;
        RegisteredAt?: DateTime;
    }
    export interface ElasticIp {
        Ip?: String;
        Name?: String;
        Domain?: String;
        Region?: String;
        InstanceId?: String;
    }
    export interface ElasticLoadBalancer {
        ElasticLoadBalancerName?: String;
        Region?: String;
        DnsName?: String;
        StackId?: String;
        LayerId?: String;
        VpcId?: String;
        AvailabilityZones?: Strings;
        SubnetIds?: Strings;
        Ec2InstanceIds?: Strings;
    }
    export interface EnvironmentVariable {
        Key: String;
        Value: String;
        Secure?: Boolean;
    }
    export interface GetHostnameSuggestionRequest {
        LayerId: String;
    }
    export interface GetHostnameSuggestionResult {
        LayerId?: String;
        Hostname?: String;
    }
    export interface GrantAccessRequest {
        InstanceId: String;
        ValidForInMinutes?: ValidForInMinutes;
    }
    export interface GrantAccessResult {
        TemporaryCredential?: TemporaryCredential;
    }
    export interface Instance {
        AgentVersion?: String;
        AmiId?: String;
        Architecture?: Architecture;
        AutoScalingType?: AutoScalingType;
        AvailabilityZone?: String;
        BlockDeviceMappings?: BlockDeviceMappings;
        CreatedAt?: DateTime;
        EbsOptimized?: Boolean;
        Ec2InstanceId?: String;
        EcsClusterArn?: String;
        EcsContainerInstanceArn?: String;
        ElasticIp?: String;
        Hostname?: String;
        InfrastructureClass?: String;
        InstallUpdatesOnBoot?: Boolean;
        InstanceId?: String;
        InstanceProfileArn?: String;
        InstanceType?: String;
        LastServiceErrorId?: String;
        LayerIds?: Strings;
        Os?: String;
        Platform?: String;
        PrivateDns?: String;
        PrivateIp?: String;
        PublicDns?: String;
        PublicIp?: String;
        RegisteredBy?: String;
        ReportedAgentVersion?: String;
        ReportedOs?: ReportedOs;
        RootDeviceType?: RootDeviceType;
        RootDeviceVolumeId?: String;
        SecurityGroupIds?: Strings;
        SshHostDsaKeyFingerprint?: String;
        SshHostRsaKeyFingerprint?: String;
        SshKeyName?: String;
        StackId?: String;
        Status?: String;
        SubnetId?: String;
        VirtualizationType?: VirtualizationType;
    }
    export interface InstanceIdentity {
        Document?: String;
        Signature?: String;
    }
    export interface InstancesCount {
        Assigning?: Integer;
        Booting?: Integer;
        ConnectionLost?: Integer;
        Deregistering?: Integer;
        Online?: Integer;
        Pending?: Integer;
        Rebooting?: Integer;
        Registered?: Integer;
        Registering?: Integer;
        Requested?: Integer;
        RunningSetup?: Integer;
        SetupFailed?: Integer;
        ShuttingDown?: Integer;
        StartFailed?: Integer;
        Stopped?: Integer;
        Stopping?: Integer;
        Terminated?: Integer;
        Terminating?: Integer;
        Unassigning?: Integer;
    }
    export interface Layer {
        StackId?: String;
        LayerId?: String;
        Type?: LayerType;
        Name?: String;
        Shortname?: String;
        Attributes?: LayerAttributes;
        CustomInstanceProfileArn?: String;
        CustomJson?: String;
        CustomSecurityGroupIds?: Strings;
        DefaultSecurityGroupNames?: Strings;
        Packages?: Strings;
        VolumeConfigurations?: VolumeConfigurations;
        EnableAutoHealing?: Boolean;
        AutoAssignElasticIps?: Boolean;
        AutoAssignPublicIps?: Boolean;
        DefaultRecipes?: Recipes;
        CustomRecipes?: Recipes;
        CreatedAt?: DateTime;
        InstallUpdatesOnBoot?: Boolean;
        UseEbsOptimizedInstances?: Boolean;
        LifecycleEventConfiguration?: LifecycleEventConfiguration;
    }
    export interface LifecycleEventConfiguration {
        Shutdown?: ShutdownEventConfiguration;
    }
    export interface LoadBasedAutoScalingConfiguration {
        LayerId?: String;
        Enable?: Boolean;
        UpScaling?: AutoScalingThresholds;
        DownScaling?: AutoScalingThresholds;
    }
    export interface Permission {
        StackId?: String;
        IamUserArn?: String;
        AllowSsh?: Boolean;
        AllowSudo?: Boolean;
        Level?: String;
    }
    export interface RaidArray {
        RaidArrayId?: String;
        InstanceId?: String;
        Name?: String;
        RaidLevel?: Integer;
        NumberOfDisks?: Integer;
        Size?: Integer;
        Device?: String;
        MountPoint?: String;
        AvailabilityZone?: String;
        CreatedAt?: DateTime;
        StackId?: String;
        VolumeType?: String;
        Iops?: Integer;
    }
    export interface RdsDbInstance {
        RdsDbInstanceArn?: String;
        DbInstanceIdentifier?: String;
        DbUser?: String;
        DbPassword?: String;
        Region?: String;
        Address?: String;
        Engine?: String;
        StackId?: String;
        MissingOnRds?: Boolean;
    }
    export interface RebootInstanceRequest {
        InstanceId: String;
    }
    export interface Recipes {
        Setup?: Strings;
        Configure?: Strings;
        Deploy?: Strings;
        Undeploy?: Strings;
        Shutdown?: Strings;
    }
    export interface RegisterEcsClusterRequest {
        EcsClusterArn: String;
        StackId: String;
    }
    export interface RegisterEcsClusterResult {
        EcsClusterArn?: String;
    }
    export interface RegisterElasticIpRequest {
        ElasticIp: String;
        StackId: String;
    }
    export interface RegisterElasticIpResult {
        ElasticIp?: String;
    }
    export interface RegisterInstanceRequest {
        StackId: String;
        Hostname?: String;
        PublicIp?: String;
        PrivateIp?: String;
        RsaPublicKey?: String;
        RsaPublicKeyFingerprint?: String;
        InstanceIdentity?: InstanceIdentity;
    }
    export interface RegisterInstanceResult {
        InstanceId?: String;
    }
    export interface RegisterRdsDbInstanceRequest {
        StackId: String;
        RdsDbInstanceArn: String;
        DbUser: String;
        DbPassword: String;
    }
    export interface RegisterVolumeRequest {
        Ec2VolumeId?: String;
        StackId: String;
    }
    export interface RegisterVolumeResult {
        VolumeId?: String;
    }
    export interface ReportedOs {
        Family?: String;
        Name?: String;
        Version?: String;
    }
    export interface ResourceNotFoundException {
        message?: String;
    }
    export interface SelfUserProfile {
        IamUserArn?: String;
        Name?: String;
        SshUsername?: String;
        SshPublicKey?: String;
    }
    export interface ServiceError {
        ServiceErrorId?: String;
        StackId?: String;
        InstanceId?: String;
        Type?: String;
        Message?: String;
        CreatedAt?: DateTime;
    }
    export interface SetLoadBasedAutoScalingRequest {
        LayerId: String;
        Enable?: Boolean;
        UpScaling?: AutoScalingThresholds;
        DownScaling?: AutoScalingThresholds;
    }
    export interface SetPermissionRequest {
        StackId: String;
        IamUserArn: String;
        AllowSsh?: Boolean;
        AllowSudo?: Boolean;
        Level?: String;
    }
    export interface SetTimeBasedAutoScalingRequest {
        InstanceId: String;
        AutoScalingSchedule?: WeeklyAutoScalingSchedule;
    }
    export interface ShutdownEventConfiguration {
        ExecutionTimeout?: Integer;
        DelayUntilElbConnectionsDrained?: Boolean;
    }
    export interface Source {
        Type?: SourceType;
        Url?: String;
        Username?: String;
        Password?: String;
        SshKey?: String;
        Revision?: String;
    }
    export interface SslConfiguration {
        Certificate: String;
        PrivateKey: String;
        Chain?: String;
    }
    export interface Stack {
        StackId?: String;
        Name?: String;
        Arn?: String;
        Region?: String;
        VpcId?: String;
        Attributes?: StackAttributes;
        ServiceRoleArn?: String;
        DefaultInstanceProfileArn?: String;
        DefaultOs?: String;
        HostnameTheme?: String;
        DefaultAvailabilityZone?: String;
        DefaultSubnetId?: String;
        CustomJson?: String;
        ConfigurationManager?: StackConfigurationManager;
        ChefConfiguration?: ChefConfiguration;
        UseCustomCookbooks?: Boolean;
        UseOpsworksSecurityGroups?: Boolean;
        CustomCookbooksSource?: Source;
        DefaultSshKeyName?: String;
        CreatedAt?: DateTime;
        DefaultRootDeviceType?: RootDeviceType;
        AgentVersion?: String;
    }
    export interface StackConfigurationManager {
        Name?: String;
        Version?: String;
    }
    export interface StackSummary {
        StackId?: String;
        Name?: String;
        Arn?: String;
        LayersCount?: Integer;
        AppsCount?: Integer;
        InstancesCount?: InstancesCount;
    }
    export interface StartInstanceRequest {
        InstanceId: String;
    }
    export interface StartStackRequest {
        StackId: String;
    }
    export interface StopInstanceRequest {
        InstanceId: String;
    }
    export interface StopStackRequest {
        StackId: String;
    }
    export interface TemporaryCredential {
        Username?: String;
        Password?: String;
        ValidForInMinutes?: Integer;
        InstanceId?: String;
    }
    export interface TimeBasedAutoScalingConfiguration {
        InstanceId?: String;
        AutoScalingSchedule?: WeeklyAutoScalingSchedule;
    }
    export interface UnassignInstanceRequest {
        InstanceId: String;
    }
    export interface UnassignVolumeRequest {
        VolumeId: String;
    }
    export interface UpdateAppRequest {
        AppId: String;
        Name?: String;
        Description?: String;
        DataSources?: DataSources;
        Type?: AppType;
        AppSource?: Source;
        Domains?: Strings;
        EnableSsl?: Boolean;
        SslConfiguration?: SslConfiguration;
        Attributes?: AppAttributes;
        Environment?: EnvironmentVariables;
    }
    export interface UpdateElasticIpRequest {
        ElasticIp: String;
        Name?: String;
    }
    export interface UpdateInstanceRequest {
        InstanceId: String;
        LayerIds?: Strings;
        InstanceType?: String;
        AutoScalingType?: AutoScalingType;
        Hostname?: String;
        Os?: String;
        AmiId?: String;
        SshKeyName?: String;
        Architecture?: Architecture;
        InstallUpdatesOnBoot?: Boolean;
        EbsOptimized?: Boolean;
        AgentVersion?: String;
    }
    export interface UpdateLayerRequest {
        LayerId: String;
        Name?: String;
        Shortname?: String;
        Attributes?: LayerAttributes;
        CustomInstanceProfileArn?: String;
        CustomJson?: String;
        CustomSecurityGroupIds?: Strings;
        Packages?: Strings;
        VolumeConfigurations?: VolumeConfigurations;
        EnableAutoHealing?: Boolean;
        AutoAssignElasticIps?: Boolean;
        AutoAssignPublicIps?: Boolean;
        CustomRecipes?: Recipes;
        InstallUpdatesOnBoot?: Boolean;
        UseEbsOptimizedInstances?: Boolean;
        LifecycleEventConfiguration?: LifecycleEventConfiguration;
    }
    export interface UpdateMyUserProfileRequest {
        SshPublicKey?: String;
    }
    export interface UpdateRdsDbInstanceRequest {
        RdsDbInstanceArn: String;
        DbUser?: String;
        DbPassword?: String;
    }
    export interface UpdateStackRequest {
        StackId: String;
        Name?: String;
        Attributes?: StackAttributes;
        ServiceRoleArn?: String;
        DefaultInstanceProfileArn?: String;
        DefaultOs?: String;
        HostnameTheme?: String;
        DefaultAvailabilityZone?: String;
        DefaultSubnetId?: String;
        CustomJson?: String;
        ConfigurationManager?: StackConfigurationManager;
        ChefConfiguration?: ChefConfiguration;
        UseCustomCookbooks?: Boolean;
        CustomCookbooksSource?: Source;
        DefaultSshKeyName?: String;
        DefaultRootDeviceType?: RootDeviceType;
        UseOpsworksSecurityGroups?: Boolean;
        AgentVersion?: String;
    }
    export interface UpdateUserProfileRequest {
        IamUserArn: String;
        SshUsername?: String;
        SshPublicKey?: String;
        AllowSelfManagement?: Boolean;
    }
    export interface UpdateVolumeRequest {
        VolumeId: String;
        Name?: String;
        MountPoint?: String;
    }
    export interface UserProfile {
        IamUserArn?: String;
        Name?: String;
        SshUsername?: String;
        SshPublicKey?: String;
        AllowSelfManagement?: Boolean;
    }
    export interface ValidationException {
        message?: String;
    }
    export interface Volume {
        VolumeId?: String;
        Ec2VolumeId?: String;
        Name?: String;
        RaidArrayId?: String;
        InstanceId?: String;
        Status?: String;
        Size?: Integer;
        Device?: String;
        MountPoint?: String;
        Region?: String;
        AvailabilityZone?: String;
        VolumeType?: String;
        Iops?: Integer;
    }
    export interface VolumeConfiguration {
        MountPoint: String;
        RaidLevel?: Integer;
        NumberOfDisks: Integer;
        Size: Integer;
        VolumeType?: String;
        Iops?: Integer;
    }
    export interface WeeklyAutoScalingSchedule {
        Monday?: DailyAutoScalingSchedule;
        Tuesday?: DailyAutoScalingSchedule;
        Wednesday?: DailyAutoScalingSchedule;
        Thursday?: DailyAutoScalingSchedule;
        Friday?: DailyAutoScalingSchedule;
        Saturday?: DailyAutoScalingSchedule;
        Sunday?: DailyAutoScalingSchedule;
    }
  }

  /*
   * apiVersion: 2014-10-31
   * endpointPrefix: rds
   * serviceAbbreviation: Amazon RDS
   * signatureVersion: v4
   * protocol: query
   */
  export class RDS extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    addSourceIdentifierToSubscription(params: RDS.AddSourceIdentifierToSubscriptionMessage, callback?: (err: RDS.SubscriptionNotFoundFault|RDS.SourceNotFoundFault|any, data: RDS.AddSourceIdentifierToSubscriptionResult|any) => void): Request;
    addTagsToResource(params: RDS.AddTagsToResourceMessage, callback?: (err: RDS.DBInstanceNotFoundFault|RDS.DBSnapshotNotFoundFault|any, data: any) => void): Request;
    applyPendingMaintenanceAction(params: RDS.ApplyPendingMaintenanceActionMessage, callback?: (err: RDS.ResourceNotFoundFault|any, data: RDS.ApplyPendingMaintenanceActionResult|any) => void): Request;
    authorizeDBSecurityGroupIngress(params: RDS.AuthorizeDBSecurityGroupIngressMessage, callback?: (err: RDS.DBSecurityGroupNotFoundFault|RDS.InvalidDBSecurityGroupStateFault|RDS.AuthorizationAlreadyExistsFault|RDS.AuthorizationQuotaExceededFault|any, data: RDS.AuthorizeDBSecurityGroupIngressResult|any) => void): Request;
    copyDBClusterSnapshot(params: RDS.CopyDBClusterSnapshotMessage, callback?: (err: RDS.DBClusterSnapshotAlreadyExistsFault|RDS.DBClusterSnapshotNotFoundFault|RDS.InvalidDBClusterStateFault|any, data: RDS.CopyDBClusterSnapshotResult|any) => void): Request;
    copyDBParameterGroup(params: RDS.CopyDBParameterGroupMessage, callback?: (err: RDS.DBParameterGroupNotFoundFault|RDS.DBParameterGroupAlreadyExistsFault|RDS.DBParameterGroupQuotaExceededFault|any, data: RDS.CopyDBParameterGroupResult|any) => void): Request;
    copyDBSnapshot(params: RDS.CopyDBSnapshotMessage, callback?: (err: RDS.DBSnapshotAlreadyExistsFault|RDS.DBSnapshotNotFoundFault|RDS.InvalidDBSnapshotStateFault|RDS.SnapshotQuotaExceededFault|any, data: RDS.CopyDBSnapshotResult|any) => void): Request;
    copyOptionGroup(params: RDS.CopyOptionGroupMessage, callback?: (err: RDS.OptionGroupAlreadyExistsFault|RDS.OptionGroupNotFoundFault|RDS.OptionGroupQuotaExceededFault|any, data: RDS.CopyOptionGroupResult|any) => void): Request;
    createDBCluster(params: RDS.CreateDBClusterMessage, callback?: (err: RDS.DBClusterAlreadyExistsFault|RDS.InsufficientStorageClusterCapacityFault|RDS.DBClusterQuotaExceededFault|RDS.StorageQuotaExceededFault|RDS.DBSubnetGroupNotFoundFault|RDS.InvalidVPCNetworkStateFault|RDS.InvalidDBClusterStateFault|RDS.InvalidDBSubnetGroupStateFault|RDS.InvalidSubnet|RDS.DBClusterParameterGroupNotFoundFault|RDS.KMSKeyNotAccessibleFault|any, data: RDS.CreateDBClusterResult|any) => void): Request;
    createDBClusterParameterGroup(params: RDS.CreateDBClusterParameterGroupMessage, callback?: (err: RDS.DBParameterGroupQuotaExceededFault|RDS.DBParameterGroupAlreadyExistsFault|any, data: RDS.CreateDBClusterParameterGroupResult|any) => void): Request;
    createDBClusterSnapshot(params: RDS.CreateDBClusterSnapshotMessage, callback?: (err: RDS.DBClusterSnapshotAlreadyExistsFault|RDS.InvalidDBClusterStateFault|RDS.DBClusterNotFoundFault|RDS.SnapshotQuotaExceededFault|any, data: RDS.CreateDBClusterSnapshotResult|any) => void): Request;
    createDBInstance(params: RDS.CreateDBInstanceMessage, callback?: (err: RDS.DBInstanceAlreadyExistsFault|RDS.InsufficientDBInstanceCapacityFault|RDS.DBParameterGroupNotFoundFault|RDS.DBSecurityGroupNotFoundFault|RDS.InstanceQuotaExceededFault|RDS.StorageQuotaExceededFault|RDS.DBSubnetGroupNotFoundFault|RDS.DBSubnetGroupDoesNotCoverEnoughAZs|RDS.InvalidDBClusterStateFault|RDS.InvalidSubnet|RDS.InvalidVPCNetworkStateFault|RDS.ProvisionedIopsNotAvailableInAZFault|RDS.OptionGroupNotFoundFault|RDS.DBClusterNotFoundFault|RDS.StorageTypeNotSupportedFault|RDS.AuthorizationNotFoundFault|RDS.KMSKeyNotAccessibleFault|any, data: RDS.CreateDBInstanceResult|any) => void): Request;
    createDBInstanceReadReplica(params: RDS.CreateDBInstanceReadReplicaMessage, callback?: (err: RDS.DBInstanceAlreadyExistsFault|RDS.InsufficientDBInstanceCapacityFault|RDS.DBParameterGroupNotFoundFault|RDS.DBSecurityGroupNotFoundFault|RDS.InstanceQuotaExceededFault|RDS.StorageQuotaExceededFault|RDS.DBInstanceNotFoundFault|RDS.InvalidDBInstanceStateFault|RDS.DBSubnetGroupNotFoundFault|RDS.DBSubnetGroupDoesNotCoverEnoughAZs|RDS.InvalidSubnet|RDS.InvalidVPCNetworkStateFault|RDS.ProvisionedIopsNotAvailableInAZFault|RDS.OptionGroupNotFoundFault|RDS.DBSubnetGroupNotAllowedFault|RDS.InvalidDBSubnetGroupFault|RDS.StorageTypeNotSupportedFault|RDS.KMSKeyNotAccessibleFault|any, data: RDS.CreateDBInstanceReadReplicaResult|any) => void): Request;
    createDBParameterGroup(params: RDS.CreateDBParameterGroupMessage, callback?: (err: RDS.DBParameterGroupQuotaExceededFault|RDS.DBParameterGroupAlreadyExistsFault|any, data: RDS.CreateDBParameterGroupResult|any) => void): Request;
    createDBSecurityGroup(params: RDS.CreateDBSecurityGroupMessage, callback?: (err: RDS.DBSecurityGroupAlreadyExistsFault|RDS.DBSecurityGroupQuotaExceededFault|RDS.DBSecurityGroupNotSupportedFault|any, data: RDS.CreateDBSecurityGroupResult|any) => void): Request;
    createDBSnapshot(params: RDS.CreateDBSnapshotMessage, callback?: (err: RDS.DBSnapshotAlreadyExistsFault|RDS.InvalidDBInstanceStateFault|RDS.DBInstanceNotFoundFault|RDS.SnapshotQuotaExceededFault|any, data: RDS.CreateDBSnapshotResult|any) => void): Request;
    createDBSubnetGroup(params: RDS.CreateDBSubnetGroupMessage, callback?: (err: RDS.DBSubnetGroupAlreadyExistsFault|RDS.DBSubnetGroupQuotaExceededFault|RDS.DBSubnetQuotaExceededFault|RDS.DBSubnetGroupDoesNotCoverEnoughAZs|RDS.InvalidSubnet|any, data: RDS.CreateDBSubnetGroupResult|any) => void): Request;
    createEventSubscription(params: RDS.CreateEventSubscriptionMessage, callback?: (err: RDS.EventSubscriptionQuotaExceededFault|RDS.SubscriptionAlreadyExistFault|RDS.SNSInvalidTopicFault|RDS.SNSNoAuthorizationFault|RDS.SNSTopicArnNotFoundFault|RDS.SubscriptionCategoryNotFoundFault|RDS.SourceNotFoundFault|any, data: RDS.CreateEventSubscriptionResult|any) => void): Request;
    createOptionGroup(params: RDS.CreateOptionGroupMessage, callback?: (err: RDS.OptionGroupAlreadyExistsFault|RDS.OptionGroupQuotaExceededFault|any, data: RDS.CreateOptionGroupResult|any) => void): Request;
    deleteDBCluster(params: RDS.DeleteDBClusterMessage, callback?: (err: RDS.DBClusterNotFoundFault|RDS.InvalidDBClusterStateFault|any, data: RDS.DeleteDBClusterResult|any) => void): Request;
    deleteDBClusterParameterGroup(params: RDS.DeleteDBClusterParameterGroupMessage, callback?: (err: RDS.InvalidDBParameterGroupStateFault|RDS.DBParameterGroupNotFoundFault|any, data: any) => void): Request;
    deleteDBClusterSnapshot(params: RDS.DeleteDBClusterSnapshotMessage, callback?: (err: RDS.InvalidDBClusterSnapshotStateFault|RDS.DBClusterSnapshotNotFoundFault|any, data: RDS.DeleteDBClusterSnapshotResult|any) => void): Request;
    deleteDBInstance(params: RDS.DeleteDBInstanceMessage, callback?: (err: RDS.DBInstanceNotFoundFault|RDS.InvalidDBInstanceStateFault|RDS.DBSnapshotAlreadyExistsFault|RDS.SnapshotQuotaExceededFault|any, data: RDS.DeleteDBInstanceResult|any) => void): Request;
    deleteDBParameterGroup(params: RDS.DeleteDBParameterGroupMessage, callback?: (err: RDS.InvalidDBParameterGroupStateFault|RDS.DBParameterGroupNotFoundFault|any, data: any) => void): Request;
    deleteDBSecurityGroup(params: RDS.DeleteDBSecurityGroupMessage, callback?: (err: RDS.InvalidDBSecurityGroupStateFault|RDS.DBSecurityGroupNotFoundFault|any, data: any) => void): Request;
    deleteDBSnapshot(params: RDS.DeleteDBSnapshotMessage, callback?: (err: RDS.InvalidDBSnapshotStateFault|RDS.DBSnapshotNotFoundFault|any, data: RDS.DeleteDBSnapshotResult|any) => void): Request;
    deleteDBSubnetGroup(params: RDS.DeleteDBSubnetGroupMessage, callback?: (err: RDS.InvalidDBSubnetGroupStateFault|RDS.InvalidDBSubnetStateFault|RDS.DBSubnetGroupNotFoundFault|any, data: any) => void): Request;
    deleteEventSubscription(params: RDS.DeleteEventSubscriptionMessage, callback?: (err: RDS.SubscriptionNotFoundFault|RDS.InvalidEventSubscriptionStateFault|any, data: RDS.DeleteEventSubscriptionResult|any) => void): Request;
    deleteOptionGroup(params: RDS.DeleteOptionGroupMessage, callback?: (err: RDS.OptionGroupNotFoundFault|RDS.InvalidOptionGroupStateFault|any, data: any) => void): Request;
    describeAccountAttributes(params: RDS.DescribeAccountAttributesMessage, callback?: (err: any, data: RDS.AccountAttributesMessage|any) => void): Request;
    describeCertificates(params: RDS.DescribeCertificatesMessage, callback?: (err: RDS.CertificateNotFoundFault|any, data: RDS.CertificateMessage|any) => void): Request;
    describeDBClusterParameterGroups(params: RDS.DescribeDBClusterParameterGroupsMessage, callback?: (err: RDS.DBParameterGroupNotFoundFault|any, data: RDS.DBClusterParameterGroupsMessage|any) => void): Request;
    describeDBClusterParameters(params: RDS.DescribeDBClusterParametersMessage, callback?: (err: RDS.DBParameterGroupNotFoundFault|any, data: RDS.DBClusterParameterGroupDetails|any) => void): Request;
    describeDBClusterSnapshots(params: RDS.DescribeDBClusterSnapshotsMessage, callback?: (err: RDS.DBClusterSnapshotNotFoundFault|any, data: RDS.DBClusterSnapshotMessage|any) => void): Request;
    describeDBClusters(params: RDS.DescribeDBClustersMessage, callback?: (err: RDS.DBClusterNotFoundFault|any, data: RDS.DBClusterMessage|any) => void): Request;
    describeDBEngineVersions(params: RDS.DescribeDBEngineVersionsMessage, callback?: (err: any, data: RDS.DBEngineVersionMessage|any) => void): Request;
    describeDBInstances(params: RDS.DescribeDBInstancesMessage, callback?: (err: RDS.DBInstanceNotFoundFault|any, data: RDS.DBInstanceMessage|any) => void): Request;
    describeDBLogFiles(params: RDS.DescribeDBLogFilesMessage, callback?: (err: RDS.DBInstanceNotFoundFault|any, data: RDS.DescribeDBLogFilesResponse|any) => void): Request;
    describeDBParameterGroups(params: RDS.DescribeDBParameterGroupsMessage, callback?: (err: RDS.DBParameterGroupNotFoundFault|any, data: RDS.DBParameterGroupsMessage|any) => void): Request;
    describeDBParameters(params: RDS.DescribeDBParametersMessage, callback?: (err: RDS.DBParameterGroupNotFoundFault|any, data: RDS.DBParameterGroupDetails|any) => void): Request;
    describeDBSecurityGroups(params: RDS.DescribeDBSecurityGroupsMessage, callback?: (err: RDS.DBSecurityGroupNotFoundFault|any, data: RDS.DBSecurityGroupMessage|any) => void): Request;
    describeDBSnapshotAttributes(params: RDS.DescribeDBSnapshotAttributesMessage, callback?: (err: RDS.DBSnapshotNotFoundFault|any, data: RDS.DescribeDBSnapshotAttributesResult|any) => void): Request;
    describeDBSnapshots(params: RDS.DescribeDBSnapshotsMessage, callback?: (err: RDS.DBSnapshotNotFoundFault|any, data: RDS.DBSnapshotMessage|any) => void): Request;
    describeDBSubnetGroups(params: RDS.DescribeDBSubnetGroupsMessage, callback?: (err: RDS.DBSubnetGroupNotFoundFault|any, data: RDS.DBSubnetGroupMessage|any) => void): Request;
    describeEngineDefaultClusterParameters(params: RDS.DescribeEngineDefaultClusterParametersMessage, callback?: (err: any, data: RDS.DescribeEngineDefaultClusterParametersResult|any) => void): Request;
    describeEngineDefaultParameters(params: RDS.DescribeEngineDefaultParametersMessage, callback?: (err: any, data: RDS.DescribeEngineDefaultParametersResult|any) => void): Request;
    describeEventCategories(params: RDS.DescribeEventCategoriesMessage, callback?: (err: any, data: RDS.EventCategoriesMessage|any) => void): Request;
    describeEventSubscriptions(params: RDS.DescribeEventSubscriptionsMessage, callback?: (err: RDS.SubscriptionNotFoundFault|any, data: RDS.EventSubscriptionsMessage|any) => void): Request;
    describeEvents(params: RDS.DescribeEventsMessage, callback?: (err: any, data: RDS.EventsMessage|any) => void): Request;
    describeOptionGroupOptions(params: RDS.DescribeOptionGroupOptionsMessage, callback?: (err: any, data: RDS.OptionGroupOptionsMessage|any) => void): Request;
    describeOptionGroups(params: RDS.DescribeOptionGroupsMessage, callback?: (err: RDS.OptionGroupNotFoundFault|any, data: RDS.OptionGroups|any) => void): Request;
    describeOrderableDBInstanceOptions(params: RDS.DescribeOrderableDBInstanceOptionsMessage, callback?: (err: any, data: RDS.OrderableDBInstanceOptionsMessage|any) => void): Request;
    describePendingMaintenanceActions(params: RDS.DescribePendingMaintenanceActionsMessage, callback?: (err: RDS.ResourceNotFoundFault|any, data: RDS.PendingMaintenanceActionsMessage|any) => void): Request;
    describeReservedDBInstances(params: RDS.DescribeReservedDBInstancesMessage, callback?: (err: RDS.ReservedDBInstanceNotFoundFault|any, data: RDS.ReservedDBInstanceMessage|any) => void): Request;
    describeReservedDBInstancesOfferings(params: RDS.DescribeReservedDBInstancesOfferingsMessage, callback?: (err: RDS.ReservedDBInstancesOfferingNotFoundFault|any, data: RDS.ReservedDBInstancesOfferingMessage|any) => void): Request;
    downloadDBLogFilePortion(params: RDS.DownloadDBLogFilePortionMessage, callback?: (err: RDS.DBInstanceNotFoundFault|RDS.DBLogFileNotFoundFault|any, data: RDS.DownloadDBLogFilePortionDetails|any) => void): Request;
    failoverDBCluster(params: RDS.FailoverDBClusterMessage, callback?: (err: RDS.DBClusterNotFoundFault|RDS.InvalidDBClusterStateFault|any, data: RDS.FailoverDBClusterResult|any) => void): Request;
    listTagsForResource(params: RDS.ListTagsForResourceMessage, callback?: (err: RDS.DBInstanceNotFoundFault|RDS.DBSnapshotNotFoundFault|any, data: RDS.TagListMessage|any) => void): Request;
    modifyDBCluster(params: RDS.ModifyDBClusterMessage, callback?: (err: RDS.DBClusterNotFoundFault|RDS.InvalidDBClusterStateFault|RDS.StorageQuotaExceededFault|RDS.DBSubnetGroupNotFoundFault|RDS.InvalidVPCNetworkStateFault|RDS.InvalidDBSubnetGroupStateFault|RDS.InvalidSubnet|RDS.DBClusterParameterGroupNotFoundFault|RDS.InvalidDBSecurityGroupStateFault|RDS.InvalidDBInstanceStateFault|RDS.DBClusterAlreadyExistsFault|any, data: RDS.ModifyDBClusterResult|any) => void): Request;
    modifyDBClusterParameterGroup(params: RDS.ModifyDBClusterParameterGroupMessage, callback?: (err: RDS.DBParameterGroupNotFoundFault|RDS.InvalidDBParameterGroupStateFault|any, data: RDS.DBClusterParameterGroupNameMessage|any) => void): Request;
    modifyDBInstance(params: RDS.ModifyDBInstanceMessage, callback?: (err: RDS.InvalidDBInstanceStateFault|RDS.InvalidDBSecurityGroupStateFault|RDS.DBInstanceAlreadyExistsFault|RDS.DBInstanceNotFoundFault|RDS.DBSecurityGroupNotFoundFault|RDS.DBParameterGroupNotFoundFault|RDS.InsufficientDBInstanceCapacityFault|RDS.StorageQuotaExceededFault|RDS.InvalidVPCNetworkStateFault|RDS.ProvisionedIopsNotAvailableInAZFault|RDS.OptionGroupNotFoundFault|RDS.DBUpgradeDependencyFailureFault|RDS.StorageTypeNotSupportedFault|RDS.AuthorizationNotFoundFault|RDS.CertificateNotFoundFault|any, data: RDS.ModifyDBInstanceResult|any) => void): Request;
    modifyDBParameterGroup(params: RDS.ModifyDBParameterGroupMessage, callback?: (err: RDS.DBParameterGroupNotFoundFault|RDS.InvalidDBParameterGroupStateFault|any, data: RDS.DBParameterGroupNameMessage|any) => void): Request;
    modifyDBSnapshotAttribute(params: RDS.ModifyDBSnapshotAttributeMessage, callback?: (err: RDS.DBSnapshotNotFoundFault|RDS.InvalidDBSnapshotStateFault|RDS.SharedSnapshotQuotaExceededFault|any, data: RDS.ModifyDBSnapshotAttributeResult|any) => void): Request;
    modifyDBSubnetGroup(params: RDS.ModifyDBSubnetGroupMessage, callback?: (err: RDS.DBSubnetGroupNotFoundFault|RDS.DBSubnetQuotaExceededFault|RDS.SubnetAlreadyInUse|RDS.DBSubnetGroupDoesNotCoverEnoughAZs|RDS.InvalidSubnet|any, data: RDS.ModifyDBSubnetGroupResult|any) => void): Request;
    modifyEventSubscription(params: RDS.ModifyEventSubscriptionMessage, callback?: (err: RDS.EventSubscriptionQuotaExceededFault|RDS.SubscriptionNotFoundFault|RDS.SNSInvalidTopicFault|RDS.SNSNoAuthorizationFault|RDS.SNSTopicArnNotFoundFault|RDS.SubscriptionCategoryNotFoundFault|any, data: RDS.ModifyEventSubscriptionResult|any) => void): Request;
    modifyOptionGroup(params: RDS.ModifyOptionGroupMessage, callback?: (err: RDS.InvalidOptionGroupStateFault|RDS.OptionGroupNotFoundFault|any, data: RDS.ModifyOptionGroupResult|any) => void): Request;
    promoteReadReplica(params: RDS.PromoteReadReplicaMessage, callback?: (err: RDS.InvalidDBInstanceStateFault|RDS.DBInstanceNotFoundFault|any, data: RDS.PromoteReadReplicaResult|any) => void): Request;
    purchaseReservedDBInstancesOffering(params: RDS.PurchaseReservedDBInstancesOfferingMessage, callback?: (err: RDS.ReservedDBInstancesOfferingNotFoundFault|RDS.ReservedDBInstanceAlreadyExistsFault|RDS.ReservedDBInstanceQuotaExceededFault|any, data: RDS.PurchaseReservedDBInstancesOfferingResult|any) => void): Request;
    rebootDBInstance(params: RDS.RebootDBInstanceMessage, callback?: (err: RDS.InvalidDBInstanceStateFault|RDS.DBInstanceNotFoundFault|any, data: RDS.RebootDBInstanceResult|any) => void): Request;
    removeSourceIdentifierFromSubscription(params: RDS.RemoveSourceIdentifierFromSubscriptionMessage, callback?: (err: RDS.SubscriptionNotFoundFault|RDS.SourceNotFoundFault|any, data: RDS.RemoveSourceIdentifierFromSubscriptionResult|any) => void): Request;
    removeTagsFromResource(params: RDS.RemoveTagsFromResourceMessage, callback?: (err: RDS.DBInstanceNotFoundFault|RDS.DBSnapshotNotFoundFault|any, data: any) => void): Request;
    resetDBClusterParameterGroup(params: RDS.ResetDBClusterParameterGroupMessage, callback?: (err: RDS.InvalidDBParameterGroupStateFault|RDS.DBParameterGroupNotFoundFault|any, data: RDS.DBClusterParameterGroupNameMessage|any) => void): Request;
    resetDBParameterGroup(params: RDS.ResetDBParameterGroupMessage, callback?: (err: RDS.InvalidDBParameterGroupStateFault|RDS.DBParameterGroupNotFoundFault|any, data: RDS.DBParameterGroupNameMessage|any) => void): Request;
    restoreDBClusterFromSnapshot(params: RDS.RestoreDBClusterFromSnapshotMessage, callback?: (err: RDS.DBClusterAlreadyExistsFault|RDS.DBClusterQuotaExceededFault|RDS.StorageQuotaExceededFault|RDS.DBSubnetGroupNotFoundFault|RDS.DBSnapshotNotFoundFault|RDS.DBClusterSnapshotNotFoundFault|RDS.InsufficientDBClusterCapacityFault|RDS.InsufficientStorageClusterCapacityFault|RDS.InvalidDBSnapshotStateFault|RDS.InvalidDBClusterSnapshotStateFault|RDS.StorageQuotaExceededFault|RDS.InvalidVPCNetworkStateFault|RDS.InvalidRestoreFault|RDS.DBSubnetGroupNotFoundFault|RDS.InvalidSubnet|RDS.OptionGroupNotFoundFault|RDS.KMSKeyNotAccessibleFault|any, data: RDS.RestoreDBClusterFromSnapshotResult|any) => void): Request;
    restoreDBClusterToPointInTime(params: RDS.RestoreDBClusterToPointInTimeMessage, callback?: (err: RDS.DBClusterAlreadyExistsFault|RDS.DBClusterQuotaExceededFault|RDS.StorageQuotaExceededFault|RDS.DBSubnetGroupNotFoundFault|RDS.DBClusterNotFoundFault|RDS.DBClusterSnapshotNotFoundFault|RDS.InsufficientDBClusterCapacityFault|RDS.InvalidDBSnapshotStateFault|RDS.InvalidDBClusterSnapshotStateFault|RDS.StorageQuotaExceededFault|RDS.InvalidVPCNetworkStateFault|RDS.InvalidRestoreFault|RDS.DBSubnetGroupNotFoundFault|RDS.InvalidSubnet|RDS.OptionGroupNotFoundFault|RDS.KMSKeyNotAccessibleFault|any, data: RDS.RestoreDBClusterToPointInTimeResult|any) => void): Request;
    restoreDBInstanceFromDBSnapshot(params: RDS.RestoreDBInstanceFromDBSnapshotMessage, callback?: (err: RDS.DBInstanceAlreadyExistsFault|RDS.DBSnapshotNotFoundFault|RDS.InstanceQuotaExceededFault|RDS.InsufficientDBInstanceCapacityFault|RDS.InvalidDBSnapshotStateFault|RDS.StorageQuotaExceededFault|RDS.InvalidVPCNetworkStateFault|RDS.InvalidRestoreFault|RDS.DBSubnetGroupNotFoundFault|RDS.DBSubnetGroupDoesNotCoverEnoughAZs|RDS.InvalidSubnet|RDS.ProvisionedIopsNotAvailableInAZFault|RDS.OptionGroupNotFoundFault|RDS.StorageTypeNotSupportedFault|RDS.AuthorizationNotFoundFault|RDS.KMSKeyNotAccessibleFault|RDS.DBSecurityGroupNotFoundFault|any, data: RDS.RestoreDBInstanceFromDBSnapshotResult|any) => void): Request;
    restoreDBInstanceToPointInTime(params: RDS.RestoreDBInstanceToPointInTimeMessage, callback?: (err: RDS.DBInstanceAlreadyExistsFault|RDS.DBInstanceNotFoundFault|RDS.InstanceQuotaExceededFault|RDS.InsufficientDBInstanceCapacityFault|RDS.InvalidDBInstanceStateFault|RDS.PointInTimeRestoreNotEnabledFault|RDS.StorageQuotaExceededFault|RDS.InvalidVPCNetworkStateFault|RDS.InvalidRestoreFault|RDS.DBSubnetGroupNotFoundFault|RDS.DBSubnetGroupDoesNotCoverEnoughAZs|RDS.InvalidSubnet|RDS.ProvisionedIopsNotAvailableInAZFault|RDS.OptionGroupNotFoundFault|RDS.StorageTypeNotSupportedFault|RDS.AuthorizationNotFoundFault|RDS.KMSKeyNotAccessibleFault|RDS.DBSecurityGroupNotFoundFault|any, data: RDS.RestoreDBInstanceToPointInTimeResult|any) => void): Request;
    revokeDBSecurityGroupIngress(params: RDS.RevokeDBSecurityGroupIngressMessage, callback?: (err: RDS.DBSecurityGroupNotFoundFault|RDS.AuthorizationNotFoundFault|RDS.InvalidDBSecurityGroupStateFault|any, data: RDS.RevokeDBSecurityGroupIngressResult|any) => void): Request;

  }

  export module RDS {
    export type AccountQuotaList = AccountQuota[];
    export type ApplyMethod = string;
    export type AttributeValueList = String[];
    export type AvailabilityZoneList = AvailabilityZone[];
    export type AvailabilityZones = String[];
    export type Boolean = boolean;
    export type BooleanOptional = boolean;
    export type CertificateList = Certificate[];
    export type DBClusterList = DBCluster[];
    export type DBClusterMemberList = DBClusterMember[];
    export type DBClusterOptionGroupMemberships = DBClusterOptionGroupStatus[];
    export type DBClusterParameterGroupList = DBClusterParameterGroup[];
    export type DBClusterSnapshotList = DBClusterSnapshot[];
    export type DBEngineVersionList = DBEngineVersion[];
    export type DBInstanceList = DBInstance[];
    export type DBInstanceStatusInfoList = DBInstanceStatusInfo[];
    export type DBParameterGroupList = DBParameterGroup[];
    export type DBParameterGroupStatusList = DBParameterGroupStatus[];
    export type DBSecurityGroupMembershipList = DBSecurityGroupMembership[];
    export type DBSecurityGroupNameList = String[];
    export type DBSecurityGroups = DBSecurityGroup[];
    export type DBSnapshotAttributeList = DBSnapshotAttribute[];
    export type DBSnapshotList = DBSnapshot[];
    export type DBSubnetGroups = DBSubnetGroup[];
    export type DescribeDBLogFilesList = DescribeDBLogFilesDetails[];
    export type Double = number;
    export type EC2SecurityGroupList = EC2SecurityGroup[];
    export type EventCategoriesList = String[];
    export type EventCategoriesMapList = EventCategoriesMap[];
    export type EventList = Event[];
    export type EventSubscriptionsList = EventSubscription[];
    export type FilterList = Filter[];
    export type FilterValueList = String[];
    export type IPRangeList = IPRange[];
    export type Integer = number;
    export type IntegerOptional = number;
    export type KeyList = String[];
    export type Long = number;
    export type OptionConfigurationList = OptionConfiguration[];
    export type OptionGroupMembershipList = OptionGroupMembership[];
    export type OptionGroupOptionSettingsList = OptionGroupOptionSetting[];
    export type OptionGroupOptionsList = OptionGroupOption[];
    export type OptionGroupsList = OptionGroup[];
    export type OptionNamesList = String[];
    export type OptionSettingConfigurationList = OptionSetting[];
    export type OptionSettingsList = OptionSetting[];
    export type OptionsDependedOn = String[];
    export type OptionsList = Option[];
    export type OrderableDBInstanceOptionsList = OrderableDBInstanceOption[];
    export type ParametersList = Parameter[];
    export type PendingMaintenanceActionDetails = PendingMaintenanceAction[];
    export type PendingMaintenanceActions = ResourcePendingMaintenanceActions[];
    export type ReadReplicaDBInstanceIdentifierList = String[];
    export type RecurringChargeList = RecurringCharge[];
    export type ReservedDBInstanceList = ReservedDBInstance[];
    export type ReservedDBInstancesOfferingList = ReservedDBInstancesOffering[];
    export type SourceIdsList = String[];
    export type SourceType = string;
    export type String = string;
    export type SubnetIdentifierList = String[];
    export type SubnetList = Subnet[];
    export type SupportedCharacterSetsList = CharacterSet[];
    export type TStamp = number;
    export type TagList = Tag[];
    export type ValidUpgradeTargetList = UpgradeTarget[];
    export type VpcSecurityGroupIdList = String[];
    export type VpcSecurityGroupMembershipList = VpcSecurityGroupMembership[];

    export interface AccountAttributesMessage {
        AccountQuotas?: AccountQuotaList;
    }
    export interface AccountQuota {
        AccountQuotaName?: String;
        Used?: Long;
        Max?: Long;
    }
    export interface AddSourceIdentifierToSubscriptionMessage {
        SubscriptionName: String;
        SourceIdentifier: String;
    }
    export interface AddSourceIdentifierToSubscriptionResult {
        EventSubscription?: EventSubscription;
    }
    export interface AddTagsToResourceMessage {
        ResourceName: String;
        Tags: TagList;
    }
    export interface ApplyPendingMaintenanceActionMessage {
        ResourceIdentifier: String;
        ApplyAction: String;
        OptInType: String;
    }
    export interface ApplyPendingMaintenanceActionResult {
        ResourcePendingMaintenanceActions?: ResourcePendingMaintenanceActions;
    }
    export interface AuthorizationAlreadyExistsFault {
    }
    export interface AuthorizationNotFoundFault {
    }
    export interface AuthorizationQuotaExceededFault {
    }
    export interface AuthorizeDBSecurityGroupIngressMessage {
        DBSecurityGroupName: String;
        CIDRIP?: String;
        EC2SecurityGroupName?: String;
        EC2SecurityGroupId?: String;
        EC2SecurityGroupOwnerId?: String;
    }
    export interface AuthorizeDBSecurityGroupIngressResult {
        DBSecurityGroup?: DBSecurityGroup;
    }
    export interface AvailabilityZone {
        Name?: String;
    }
    export interface Certificate {
        CertificateIdentifier?: String;
        CertificateType?: String;
        Thumbprint?: String;
        ValidFrom?: TStamp;
        ValidTill?: TStamp;
    }
    export interface CertificateMessage {
        Certificates?: CertificateList;
        Marker?: String;
    }
    export interface CertificateNotFoundFault {
    }
    export interface CharacterSet {
        CharacterSetName?: String;
        CharacterSetDescription?: String;
    }
    export interface CopyDBClusterSnapshotMessage {
        SourceDBClusterSnapshotIdentifier: String;
        TargetDBClusterSnapshotIdentifier: String;
        Tags?: TagList;
    }
    export interface CopyDBClusterSnapshotResult {
        DBClusterSnapshot?: DBClusterSnapshot;
    }
    export interface CopyDBParameterGroupMessage {
        SourceDBParameterGroupIdentifier: String;
        TargetDBParameterGroupIdentifier: String;
        TargetDBParameterGroupDescription: String;
        Tags?: TagList;
    }
    export interface CopyDBParameterGroupResult {
        DBParameterGroup?: DBParameterGroup;
    }
    export interface CopyDBSnapshotMessage {
        SourceDBSnapshotIdentifier: String;
        TargetDBSnapshotIdentifier: String;
        KmsKeyId?: String;
        Tags?: TagList;
        CopyTags?: BooleanOptional;
    }
    export interface CopyDBSnapshotResult {
        DBSnapshot?: DBSnapshot;
    }
    export interface CopyOptionGroupMessage {
        SourceOptionGroupIdentifier: String;
        TargetOptionGroupIdentifier: String;
        TargetOptionGroupDescription: String;
        Tags?: TagList;
    }
    export interface CopyOptionGroupResult {
        OptionGroup?: OptionGroup;
    }
    export interface CreateDBClusterMessage {
        AvailabilityZones?: AvailabilityZones;
        BackupRetentionPeriod?: IntegerOptional;
        CharacterSetName?: String;
        DatabaseName?: String;
        DBClusterIdentifier: String;
        DBClusterParameterGroupName?: String;
        VpcSecurityGroupIds?: VpcSecurityGroupIdList;
        DBSubnetGroupName?: String;
        Engine: String;
        EngineVersion?: String;
        Port?: IntegerOptional;
        MasterUsername: String;
        MasterUserPassword: String;
        OptionGroupName?: String;
        PreferredBackupWindow?: String;
        PreferredMaintenanceWindow?: String;
        Tags?: TagList;
        StorageEncrypted?: BooleanOptional;
        KmsKeyId?: String;
    }
    export interface CreateDBClusterParameterGroupMessage {
        DBClusterParameterGroupName: String;
        DBParameterGroupFamily: String;
        Description: String;
        Tags?: TagList;
    }
    export interface CreateDBClusterParameterGroupResult {
        DBClusterParameterGroup?: DBClusterParameterGroup;
    }
    export interface CreateDBClusterResult {
        DBCluster?: DBCluster;
    }
    export interface CreateDBClusterSnapshotMessage {
        DBClusterSnapshotIdentifier: String;
        DBClusterIdentifier: String;
        Tags?: TagList;
    }
    export interface CreateDBClusterSnapshotResult {
        DBClusterSnapshot?: DBClusterSnapshot;
    }
    export interface CreateDBInstanceMessage {
        DBName?: String;
        DBInstanceIdentifier: String;
        AllocatedStorage?: IntegerOptional;
        DBInstanceClass: String;
        Engine: String;
        MasterUsername?: String;
        MasterUserPassword?: String;
        DBSecurityGroups?: DBSecurityGroupNameList;
        VpcSecurityGroupIds?: VpcSecurityGroupIdList;
        AvailabilityZone?: String;
        DBSubnetGroupName?: String;
        PreferredMaintenanceWindow?: String;
        DBParameterGroupName?: String;
        BackupRetentionPeriod?: IntegerOptional;
        PreferredBackupWindow?: String;
        Port?: IntegerOptional;
        MultiAZ?: BooleanOptional;
        EngineVersion?: String;
        AutoMinorVersionUpgrade?: BooleanOptional;
        LicenseModel?: String;
        Iops?: IntegerOptional;
        OptionGroupName?: String;
        CharacterSetName?: String;
        PubliclyAccessible?: BooleanOptional;
        Tags?: TagList;
        DBClusterIdentifier?: String;
        StorageType?: String;
        TdeCredentialArn?: String;
        TdeCredentialPassword?: String;
        StorageEncrypted?: BooleanOptional;
        KmsKeyId?: String;
        CopyTagsToSnapshot?: BooleanOptional;
        MonitoringInterval?: IntegerOptional;
        MonitoringRoleArn?: String;
        PromotionTier?: IntegerOptional;
    }
    export interface CreateDBInstanceReadReplicaMessage {
        DBInstanceIdentifier: String;
        SourceDBInstanceIdentifier: String;
        DBInstanceClass?: String;
        AvailabilityZone?: String;
        Port?: IntegerOptional;
        AutoMinorVersionUpgrade?: BooleanOptional;
        Iops?: IntegerOptional;
        OptionGroupName?: String;
        PubliclyAccessible?: BooleanOptional;
        Tags?: TagList;
        DBSubnetGroupName?: String;
        StorageType?: String;
        CopyTagsToSnapshot?: BooleanOptional;
        MonitoringInterval?: IntegerOptional;
        MonitoringRoleArn?: String;
    }
    export interface CreateDBInstanceReadReplicaResult {
        DBInstance?: DBInstance;
    }
    export interface CreateDBInstanceResult {
        DBInstance?: DBInstance;
    }
    export interface CreateDBParameterGroupMessage {
        DBParameterGroupName: String;
        DBParameterGroupFamily: String;
        Description: String;
        Tags?: TagList;
    }
    export interface CreateDBParameterGroupResult {
        DBParameterGroup?: DBParameterGroup;
    }
    export interface CreateDBSecurityGroupMessage {
        DBSecurityGroupName: String;
        DBSecurityGroupDescription: String;
        Tags?: TagList;
    }
    export interface CreateDBSecurityGroupResult {
        DBSecurityGroup?: DBSecurityGroup;
    }
    export interface CreateDBSnapshotMessage {
        DBSnapshotIdentifier: String;
        DBInstanceIdentifier: String;
        Tags?: TagList;
    }
    export interface CreateDBSnapshotResult {
        DBSnapshot?: DBSnapshot;
    }
    export interface CreateDBSubnetGroupMessage {
        DBSubnetGroupName: String;
        DBSubnetGroupDescription: String;
        SubnetIds: SubnetIdentifierList;
        Tags?: TagList;
    }
    export interface CreateDBSubnetGroupResult {
        DBSubnetGroup?: DBSubnetGroup;
    }
    export interface CreateEventSubscriptionMessage {
        SubscriptionName: String;
        SnsTopicArn: String;
        SourceType?: String;
        EventCategories?: EventCategoriesList;
        SourceIds?: SourceIdsList;
        Enabled?: BooleanOptional;
        Tags?: TagList;
    }
    export interface CreateEventSubscriptionResult {
        EventSubscription?: EventSubscription;
    }
    export interface CreateOptionGroupMessage {
        OptionGroupName: String;
        EngineName: String;
        MajorEngineVersion: String;
        OptionGroupDescription: String;
        Tags?: TagList;
    }
    export interface CreateOptionGroupResult {
        OptionGroup?: OptionGroup;
    }
    export interface DBCluster {
        AllocatedStorage?: IntegerOptional;
        AvailabilityZones?: AvailabilityZones;
        BackupRetentionPeriod?: IntegerOptional;
        CharacterSetName?: String;
        DatabaseName?: String;
        DBClusterIdentifier?: String;
        DBClusterParameterGroup?: String;
        DBSubnetGroup?: String;
        Status?: String;
        PercentProgress?: String;
        EarliestRestorableTime?: TStamp;
        Endpoint?: String;
        Engine?: String;
        EngineVersion?: String;
        LatestRestorableTime?: TStamp;
        Port?: IntegerOptional;
        MasterUsername?: String;
        DBClusterOptionGroupMemberships?: DBClusterOptionGroupMemberships;
        PreferredBackupWindow?: String;
        PreferredMaintenanceWindow?: String;
        DBClusterMembers?: DBClusterMemberList;
        VpcSecurityGroups?: VpcSecurityGroupMembershipList;
        HostedZoneId?: String;
        StorageEncrypted?: Boolean;
        KmsKeyId?: String;
        DbClusterResourceId?: String;
    }
    export interface DBClusterAlreadyExistsFault {
    }
    export interface DBClusterMember {
        DBInstanceIdentifier?: String;
        IsClusterWriter?: Boolean;
        DBClusterParameterGroupStatus?: String;
        PromotionTier?: IntegerOptional;
    }
    export interface DBClusterMessage {
        Marker?: String;
        DBClusters?: DBClusterList;
    }
    export interface DBClusterNotFoundFault {
    }
    export interface DBClusterOptionGroupStatus {
        DBClusterOptionGroupName?: String;
        Status?: String;
    }
    export interface DBClusterParameterGroup {
        DBClusterParameterGroupName?: String;
        DBParameterGroupFamily?: String;
        Description?: String;
    }
    export interface DBClusterParameterGroupDetails {
        Parameters?: ParametersList;
        Marker?: String;
    }
    export interface DBClusterParameterGroupNameMessage {
        DBClusterParameterGroupName?: String;
    }
    export interface DBClusterParameterGroupNotFoundFault {
    }
    export interface DBClusterParameterGroupsMessage {
        Marker?: String;
        DBClusterParameterGroups?: DBClusterParameterGroupList;
    }
    export interface DBClusterQuotaExceededFault {
    }
    export interface DBClusterSnapshot {
        AvailabilityZones?: AvailabilityZones;
        DBClusterSnapshotIdentifier?: String;
        DBClusterIdentifier?: String;
        SnapshotCreateTime?: TStamp;
        Engine?: String;
        AllocatedStorage?: Integer;
        Status?: String;
        Port?: Integer;
        VpcId?: String;
        ClusterCreateTime?: TStamp;
        MasterUsername?: String;
        EngineVersion?: String;
        LicenseModel?: String;
        SnapshotType?: String;
        PercentProgress?: Integer;
        StorageEncrypted?: Boolean;
        KmsKeyId?: String;
    }
    export interface DBClusterSnapshotAlreadyExistsFault {
    }
    export interface DBClusterSnapshotMessage {
        Marker?: String;
        DBClusterSnapshots?: DBClusterSnapshotList;
    }
    export interface DBClusterSnapshotNotFoundFault {
    }
    export interface DBEngineVersion {
        Engine?: String;
        EngineVersion?: String;
        DBParameterGroupFamily?: String;
        DBEngineDescription?: String;
        DBEngineVersionDescription?: String;
        DefaultCharacterSet?: CharacterSet;
        SupportedCharacterSets?: SupportedCharacterSetsList;
        ValidUpgradeTarget?: ValidUpgradeTargetList;
    }
    export interface DBEngineVersionMessage {
        Marker?: String;
        DBEngineVersions?: DBEngineVersionList;
    }
    export interface DBInstance {
        DBInstanceIdentifier?: String;
        DBInstanceClass?: String;
        Engine?: String;
        DBInstanceStatus?: String;
        MasterUsername?: String;
        DBName?: String;
        Endpoint?: Endpoint;
        AllocatedStorage?: Integer;
        InstanceCreateTime?: TStamp;
        PreferredBackupWindow?: String;
        BackupRetentionPeriod?: Integer;
        DBSecurityGroups?: DBSecurityGroupMembershipList;
        VpcSecurityGroups?: VpcSecurityGroupMembershipList;
        DBParameterGroups?: DBParameterGroupStatusList;
        AvailabilityZone?: String;
        DBSubnetGroup?: DBSubnetGroup;
        PreferredMaintenanceWindow?: String;
        PendingModifiedValues?: PendingModifiedValues;
        LatestRestorableTime?: TStamp;
        MultiAZ?: Boolean;
        EngineVersion?: String;
        AutoMinorVersionUpgrade?: Boolean;
        ReadReplicaSourceDBInstanceIdentifier?: String;
        ReadReplicaDBInstanceIdentifiers?: ReadReplicaDBInstanceIdentifierList;
        LicenseModel?: String;
        Iops?: IntegerOptional;
        OptionGroupMemberships?: OptionGroupMembershipList;
        CharacterSetName?: String;
        SecondaryAvailabilityZone?: String;
        PubliclyAccessible?: Boolean;
        StatusInfos?: DBInstanceStatusInfoList;
        StorageType?: String;
        TdeCredentialArn?: String;
        DbInstancePort?: Integer;
        DBClusterIdentifier?: String;
        StorageEncrypted?: Boolean;
        KmsKeyId?: String;
        DbiResourceId?: String;
        CACertificateIdentifier?: String;
        CopyTagsToSnapshot?: Boolean;
        MonitoringInterval?: IntegerOptional;
        EnhancedMonitoringResourceArn?: String;
        MonitoringRoleArn?: String;
        PromotionTier?: IntegerOptional;
    }
    export interface DBInstanceAlreadyExistsFault {
    }
    export interface DBInstanceMessage {
        Marker?: String;
        DBInstances?: DBInstanceList;
    }
    export interface DBInstanceNotFoundFault {
    }
    export interface DBInstanceStatusInfo {
        StatusType?: String;
        Normal?: Boolean;
        Status?: String;
        Message?: String;
    }
    export interface DBLogFileNotFoundFault {
    }
    export interface DBParameterGroup {
        DBParameterGroupName?: String;
        DBParameterGroupFamily?: String;
        Description?: String;
    }
    export interface DBParameterGroupAlreadyExistsFault {
    }
    export interface DBParameterGroupDetails {
        Parameters?: ParametersList;
        Marker?: String;
    }
    export interface DBParameterGroupNameMessage {
        DBParameterGroupName?: String;
    }
    export interface DBParameterGroupNotFoundFault {
    }
    export interface DBParameterGroupQuotaExceededFault {
    }
    export interface DBParameterGroupStatus {
        DBParameterGroupName?: String;
        ParameterApplyStatus?: String;
    }
    export interface DBParameterGroupsMessage {
        Marker?: String;
        DBParameterGroups?: DBParameterGroupList;
    }
    export interface DBSecurityGroup {
        OwnerId?: String;
        DBSecurityGroupName?: String;
        DBSecurityGroupDescription?: String;
        VpcId?: String;
        EC2SecurityGroups?: EC2SecurityGroupList;
        IPRanges?: IPRangeList;
    }
    export interface DBSecurityGroupAlreadyExistsFault {
    }
    export interface DBSecurityGroupMembership {
        DBSecurityGroupName?: String;
        Status?: String;
    }
    export interface DBSecurityGroupMessage {
        Marker?: String;
        DBSecurityGroups?: DBSecurityGroups;
    }
    export interface DBSecurityGroupNotFoundFault {
    }
    export interface DBSecurityGroupNotSupportedFault {
    }
    export interface DBSecurityGroupQuotaExceededFault {
    }
    export interface DBSnapshot {
        DBSnapshotIdentifier?: String;
        DBInstanceIdentifier?: String;
        SnapshotCreateTime?: TStamp;
        Engine?: String;
        AllocatedStorage?: Integer;
        Status?: String;
        Port?: Integer;
        AvailabilityZone?: String;
        VpcId?: String;
        InstanceCreateTime?: TStamp;
        MasterUsername?: String;
        EngineVersion?: String;
        LicenseModel?: String;
        SnapshotType?: String;
        Iops?: IntegerOptional;
        OptionGroupName?: String;
        PercentProgress?: Integer;
        SourceRegion?: String;
        SourceDBSnapshotIdentifier?: String;
        StorageType?: String;
        TdeCredentialArn?: String;
        Encrypted?: Boolean;
        KmsKeyId?: String;
    }
    export interface DBSnapshotAlreadyExistsFault {
    }
    export interface DBSnapshotAttribute {
        AttributeName?: String;
        AttributeValues?: AttributeValueList;
    }
    export interface DBSnapshotAttributesResult {
        DBSnapshotIdentifier?: String;
        DBSnapshotAttributes?: DBSnapshotAttributeList;
    }
    export interface DBSnapshotMessage {
        Marker?: String;
        DBSnapshots?: DBSnapshotList;
    }
    export interface DBSnapshotNotFoundFault {
    }
    export interface DBSubnetGroup {
        DBSubnetGroupName?: String;
        DBSubnetGroupDescription?: String;
        VpcId?: String;
        SubnetGroupStatus?: String;
        Subnets?: SubnetList;
    }
    export interface DBSubnetGroupAlreadyExistsFault {
    }
    export interface DBSubnetGroupDoesNotCoverEnoughAZs {
    }
    export interface DBSubnetGroupMessage {
        Marker?: String;
        DBSubnetGroups?: DBSubnetGroups;
    }
    export interface DBSubnetGroupNotAllowedFault {
    }
    export interface DBSubnetGroupNotFoundFault {
    }
    export interface DBSubnetGroupQuotaExceededFault {
    }
    export interface DBSubnetQuotaExceededFault {
    }
    export interface DBUpgradeDependencyFailureFault {
    }
    export interface DeleteDBClusterMessage {
        DBClusterIdentifier: String;
        SkipFinalSnapshot?: Boolean;
        FinalDBSnapshotIdentifier?: String;
    }
    export interface DeleteDBClusterParameterGroupMessage {
        DBClusterParameterGroupName: String;
    }
    export interface DeleteDBClusterResult {
        DBCluster?: DBCluster;
    }
    export interface DeleteDBClusterSnapshotMessage {
        DBClusterSnapshotIdentifier: String;
    }
    export interface DeleteDBClusterSnapshotResult {
        DBClusterSnapshot?: DBClusterSnapshot;
    }
    export interface DeleteDBInstanceMessage {
        DBInstanceIdentifier: String;
        SkipFinalSnapshot?: Boolean;
        FinalDBSnapshotIdentifier?: String;
    }
    export interface DeleteDBInstanceResult {
        DBInstance?: DBInstance;
    }
    export interface DeleteDBParameterGroupMessage {
        DBParameterGroupName: String;
    }
    export interface DeleteDBSecurityGroupMessage {
        DBSecurityGroupName: String;
    }
    export interface DeleteDBSnapshotMessage {
        DBSnapshotIdentifier: String;
    }
    export interface DeleteDBSnapshotResult {
        DBSnapshot?: DBSnapshot;
    }
    export interface DeleteDBSubnetGroupMessage {
        DBSubnetGroupName: String;
    }
    export interface DeleteEventSubscriptionMessage {
        SubscriptionName: String;
    }
    export interface DeleteEventSubscriptionResult {
        EventSubscription?: EventSubscription;
    }
    export interface DeleteOptionGroupMessage {
        OptionGroupName: String;
    }
    export interface DescribeAccountAttributesMessage {
    }
    export interface DescribeCertificatesMessage {
        CertificateIdentifier?: String;
        Filters?: FilterList;
        MaxRecords?: IntegerOptional;
        Marker?: String;
    }
    export interface DescribeDBClusterParameterGroupsMessage {
        DBClusterParameterGroupName?: String;
        Filters?: FilterList;
        MaxRecords?: IntegerOptional;
        Marker?: String;
    }
    export interface DescribeDBClusterParametersMessage {
        DBClusterParameterGroupName: String;
        Source?: String;
        Filters?: FilterList;
        MaxRecords?: IntegerOptional;
        Marker?: String;
    }
    export interface DescribeDBClusterSnapshotsMessage {
        DBClusterIdentifier?: String;
        DBClusterSnapshotIdentifier?: String;
        SnapshotType?: String;
        Filters?: FilterList;
        MaxRecords?: IntegerOptional;
        Marker?: String;
    }
    export interface DescribeDBClustersMessage {
        DBClusterIdentifier?: String;
        Filters?: FilterList;
        MaxRecords?: IntegerOptional;
        Marker?: String;
    }
    export interface DescribeDBEngineVersionsMessage {
        Engine?: String;
        EngineVersion?: String;
        DBParameterGroupFamily?: String;
        Filters?: FilterList;
        MaxRecords?: IntegerOptional;
        Marker?: String;
        DefaultOnly?: Boolean;
        ListSupportedCharacterSets?: BooleanOptional;
    }
    export interface DescribeDBInstancesMessage {
        DBInstanceIdentifier?: String;
        Filters?: FilterList;
        MaxRecords?: IntegerOptional;
        Marker?: String;
    }
    export interface DescribeDBLogFilesDetails {
        LogFileName?: String;
        LastWritten?: Long;
        Size?: Long;
    }
    export interface DescribeDBLogFilesMessage {
        DBInstanceIdentifier: String;
        FilenameContains?: String;
        FileLastWritten?: Long;
        FileSize?: Long;
        Filters?: FilterList;
        MaxRecords?: IntegerOptional;
        Marker?: String;
    }
    export interface DescribeDBLogFilesResponse {
        DescribeDBLogFiles?: DescribeDBLogFilesList;
        Marker?: String;
    }
    export interface DescribeDBParameterGroupsMessage {
        DBParameterGroupName?: String;
        Filters?: FilterList;
        MaxRecords?: IntegerOptional;
        Marker?: String;
    }
    export interface DescribeDBParametersMessage {
        DBParameterGroupName: String;
        Source?: String;
        Filters?: FilterList;
        MaxRecords?: IntegerOptional;
        Marker?: String;
    }
    export interface DescribeDBSecurityGroupsMessage {
        DBSecurityGroupName?: String;
        Filters?: FilterList;
        MaxRecords?: IntegerOptional;
        Marker?: String;
    }
    export interface DescribeDBSnapshotAttributesMessage {
        DBSnapshotIdentifier?: String;
    }
    export interface DescribeDBSnapshotAttributesResult {
        DBSnapshotAttributesResult?: DBSnapshotAttributesResult;
    }
    export interface DescribeDBSnapshotsMessage {
        DBInstanceIdentifier?: String;
        DBSnapshotIdentifier?: String;
        SnapshotType?: String;
        Filters?: FilterList;
        MaxRecords?: IntegerOptional;
        Marker?: String;
        IncludeShared?: Boolean;
        IncludePublic?: Boolean;
    }
    export interface DescribeDBSubnetGroupsMessage {
        DBSubnetGroupName?: String;
        Filters?: FilterList;
        MaxRecords?: IntegerOptional;
        Marker?: String;
    }
    export interface DescribeEngineDefaultClusterParametersMessage {
        DBParameterGroupFamily: String;
        Filters?: FilterList;
        MaxRecords?: IntegerOptional;
        Marker?: String;
    }
    export interface DescribeEngineDefaultClusterParametersResult {
        EngineDefaults?: EngineDefaults;
    }
    export interface DescribeEngineDefaultParametersMessage {
        DBParameterGroupFamily: String;
        Filters?: FilterList;
        MaxRecords?: IntegerOptional;
        Marker?: String;
    }
    export interface DescribeEngineDefaultParametersResult {
        EngineDefaults?: EngineDefaults;
    }
    export interface DescribeEventCategoriesMessage {
        SourceType?: String;
        Filters?: FilterList;
    }
    export interface DescribeEventSubscriptionsMessage {
        SubscriptionName?: String;
        Filters?: FilterList;
        MaxRecords?: IntegerOptional;
        Marker?: String;
    }
    export interface DescribeEventsMessage {
        SourceIdentifier?: String;
        SourceType?: SourceType;
        StartTime?: TStamp;
        EndTime?: TStamp;
        Duration?: IntegerOptional;
        EventCategories?: EventCategoriesList;
        Filters?: FilterList;
        MaxRecords?: IntegerOptional;
        Marker?: String;
    }
    export interface DescribeOptionGroupOptionsMessage {
        EngineName: String;
        MajorEngineVersion?: String;
        Filters?: FilterList;
        MaxRecords?: IntegerOptional;
        Marker?: String;
    }
    export interface DescribeOptionGroupsMessage {
        OptionGroupName?: String;
        Filters?: FilterList;
        Marker?: String;
        MaxRecords?: IntegerOptional;
        EngineName?: String;
        MajorEngineVersion?: String;
    }
    export interface DescribeOrderableDBInstanceOptionsMessage {
        Engine: String;
        EngineVersion?: String;
        DBInstanceClass?: String;
        LicenseModel?: String;
        Vpc?: BooleanOptional;
        Filters?: FilterList;
        MaxRecords?: IntegerOptional;
        Marker?: String;
    }
    export interface DescribePendingMaintenanceActionsMessage {
        ResourceIdentifier?: String;
        Filters?: FilterList;
        Marker?: String;
        MaxRecords?: IntegerOptional;
    }
    export interface DescribeReservedDBInstancesMessage {
        ReservedDBInstanceId?: String;
        ReservedDBInstancesOfferingId?: String;
        DBInstanceClass?: String;
        Duration?: String;
        ProductDescription?: String;
        OfferingType?: String;
        MultiAZ?: BooleanOptional;
        Filters?: FilterList;
        MaxRecords?: IntegerOptional;
        Marker?: String;
    }
    export interface DescribeReservedDBInstancesOfferingsMessage {
        ReservedDBInstancesOfferingId?: String;
        DBInstanceClass?: String;
        Duration?: String;
        ProductDescription?: String;
        OfferingType?: String;
        MultiAZ?: BooleanOptional;
        Filters?: FilterList;
        MaxRecords?: IntegerOptional;
        Marker?: String;
    }
    export interface DownloadDBLogFilePortionDetails {
        LogFileData?: String;
        Marker?: String;
        AdditionalDataPending?: Boolean;
    }
    export interface DownloadDBLogFilePortionMessage {
        DBInstanceIdentifier: String;
        LogFileName: String;
        Marker?: String;
        NumberOfLines?: Integer;
    }
    export interface EC2SecurityGroup {
        Status?: String;
        EC2SecurityGroupName?: String;
        EC2SecurityGroupId?: String;
        EC2SecurityGroupOwnerId?: String;
    }
    export interface Endpoint {
        Address?: String;
        Port?: Integer;
        HostedZoneId?: String;
    }
    export interface EngineDefaults {
        DBParameterGroupFamily?: String;
        Marker?: String;
        Parameters?: ParametersList;
    }
    export interface Event {
        SourceIdentifier?: String;
        SourceType?: SourceType;
        Message?: String;
        EventCategories?: EventCategoriesList;
        Date?: TStamp;
    }
    export interface EventCategoriesMap {
        SourceType?: String;
        EventCategories?: EventCategoriesList;
    }
    export interface EventCategoriesMessage {
        EventCategoriesMapList?: EventCategoriesMapList;
    }
    export interface EventSubscription {
        CustomerAwsId?: String;
        CustSubscriptionId?: String;
        SnsTopicArn?: String;
        Status?: String;
        SubscriptionCreationTime?: String;
        SourceType?: String;
        SourceIdsList?: SourceIdsList;
        EventCategoriesList?: EventCategoriesList;
        Enabled?: Boolean;
    }
    export interface EventSubscriptionQuotaExceededFault {
    }
    export interface EventSubscriptionsMessage {
        Marker?: String;
        EventSubscriptionsList?: EventSubscriptionsList;
    }
    export interface EventsMessage {
        Marker?: String;
        Events?: EventList;
    }
    export interface FailoverDBClusterMessage {
        DBClusterIdentifier?: String;
    }
    export interface FailoverDBClusterResult {
        DBCluster?: DBCluster;
    }
    export interface Filter {
        Name: String;
        Values: FilterValueList;
    }
    export interface IPRange {
        Status?: String;
        CIDRIP?: String;
    }
    export interface InstanceQuotaExceededFault {
    }
    export interface InsufficientDBClusterCapacityFault {
    }
    export interface InsufficientDBInstanceCapacityFault {
    }
    export interface InsufficientStorageClusterCapacityFault {
    }
    export interface InvalidDBClusterSnapshotStateFault {
    }
    export interface InvalidDBClusterStateFault {
    }
    export interface InvalidDBInstanceStateFault {
    }
    export interface InvalidDBParameterGroupStateFault {
    }
    export interface InvalidDBSecurityGroupStateFault {
    }
    export interface InvalidDBSnapshotStateFault {
    }
    export interface InvalidDBSubnetGroupFault {
    }
    export interface InvalidDBSubnetGroupStateFault {
    }
    export interface InvalidDBSubnetStateFault {
    }
    export interface InvalidEventSubscriptionStateFault {
    }
    export interface InvalidOptionGroupStateFault {
    }
    export interface InvalidRestoreFault {
    }
    export interface InvalidSubnet {
    }
    export interface InvalidVPCNetworkStateFault {
    }
    export interface KMSKeyNotAccessibleFault {
    }
    export interface ListTagsForResourceMessage {
        ResourceName: String;
        Filters?: FilterList;
    }
    export interface ModifyDBClusterMessage {
        DBClusterIdentifier: String;
        NewDBClusterIdentifier?: String;
        ApplyImmediately?: Boolean;
        BackupRetentionPeriod?: IntegerOptional;
        DBClusterParameterGroupName?: String;
        VpcSecurityGroupIds?: VpcSecurityGroupIdList;
        Port?: IntegerOptional;
        MasterUserPassword?: String;
        OptionGroupName?: String;
        PreferredBackupWindow?: String;
        PreferredMaintenanceWindow?: String;
    }
    export interface ModifyDBClusterParameterGroupMessage {
        DBClusterParameterGroupName: String;
        Parameters: ParametersList;
    }
    export interface ModifyDBClusterResult {
        DBCluster?: DBCluster;
    }
    export interface ModifyDBInstanceMessage {
        DBInstanceIdentifier: String;
        AllocatedStorage?: IntegerOptional;
        DBInstanceClass?: String;
        DBSecurityGroups?: DBSecurityGroupNameList;
        VpcSecurityGroupIds?: VpcSecurityGroupIdList;
        ApplyImmediately?: Boolean;
        MasterUserPassword?: String;
        DBParameterGroupName?: String;
        BackupRetentionPeriod?: IntegerOptional;
        PreferredBackupWindow?: String;
        PreferredMaintenanceWindow?: String;
        MultiAZ?: BooleanOptional;
        EngineVersion?: String;
        AllowMajorVersionUpgrade?: Boolean;
        AutoMinorVersionUpgrade?: BooleanOptional;
        Iops?: IntegerOptional;
        OptionGroupName?: String;
        NewDBInstanceIdentifier?: String;
        StorageType?: String;
        TdeCredentialArn?: String;
        TdeCredentialPassword?: String;
        CACertificateIdentifier?: String;
        CopyTagsToSnapshot?: BooleanOptional;
        MonitoringInterval?: IntegerOptional;
        DBPortNumber?: IntegerOptional;
        PubliclyAccessible?: BooleanOptional;
        MonitoringRoleArn?: String;
        PromotionTier?: IntegerOptional;
    }
    export interface ModifyDBInstanceResult {
        DBInstance?: DBInstance;
    }
    export interface ModifyDBParameterGroupMessage {
        DBParameterGroupName: String;
        Parameters: ParametersList;
    }
    export interface ModifyDBSnapshotAttributeMessage {
        DBSnapshotIdentifier: String;
        AttributeName?: String;
        ValuesToAdd?: AttributeValueList;
        ValuesToRemove?: AttributeValueList;
    }
    export interface ModifyDBSnapshotAttributeResult {
        DBSnapshotAttributesResult?: DBSnapshotAttributesResult;
    }
    export interface ModifyDBSubnetGroupMessage {
        DBSubnetGroupName: String;
        DBSubnetGroupDescription?: String;
        SubnetIds: SubnetIdentifierList;
    }
    export interface ModifyDBSubnetGroupResult {
        DBSubnetGroup?: DBSubnetGroup;
    }
    export interface ModifyEventSubscriptionMessage {
        SubscriptionName: String;
        SnsTopicArn?: String;
        SourceType?: String;
        EventCategories?: EventCategoriesList;
        Enabled?: BooleanOptional;
    }
    export interface ModifyEventSubscriptionResult {
        EventSubscription?: EventSubscription;
    }
    export interface ModifyOptionGroupMessage {
        OptionGroupName: String;
        OptionsToInclude?: OptionConfigurationList;
        OptionsToRemove?: OptionNamesList;
        ApplyImmediately?: Boolean;
    }
    export interface ModifyOptionGroupResult {
        OptionGroup?: OptionGroup;
    }
    export interface Option {
        OptionName?: String;
        OptionDescription?: String;
        Persistent?: Boolean;
        Permanent?: Boolean;
        Port?: IntegerOptional;
        OptionSettings?: OptionSettingConfigurationList;
        DBSecurityGroupMemberships?: DBSecurityGroupMembershipList;
        VpcSecurityGroupMemberships?: VpcSecurityGroupMembershipList;
    }
    export interface OptionConfiguration {
        OptionName: String;
        Port?: IntegerOptional;
        DBSecurityGroupMemberships?: DBSecurityGroupNameList;
        VpcSecurityGroupMemberships?: VpcSecurityGroupIdList;
        OptionSettings?: OptionSettingsList;
    }
    export interface OptionGroup {
        OptionGroupName?: String;
        OptionGroupDescription?: String;
        EngineName?: String;
        MajorEngineVersion?: String;
        Options?: OptionsList;
        AllowsVpcAndNonVpcInstanceMemberships?: Boolean;
        VpcId?: String;
    }
    export interface OptionGroupAlreadyExistsFault {
    }
    export interface OptionGroupMembership {
        OptionGroupName?: String;
        Status?: String;
    }
    export interface OptionGroupNotFoundFault {
    }
    export interface OptionGroupOption {
        Name?: String;
        Description?: String;
        EngineName?: String;
        MajorEngineVersion?: String;
        MinimumRequiredMinorEngineVersion?: String;
        PortRequired?: Boolean;
        DefaultPort?: IntegerOptional;
        OptionsDependedOn?: OptionsDependedOn;
        Persistent?: Boolean;
        Permanent?: Boolean;
        OptionGroupOptionSettings?: OptionGroupOptionSettingsList;
    }
    export interface OptionGroupOptionSetting {
        SettingName?: String;
        SettingDescription?: String;
        DefaultValue?: String;
        ApplyType?: String;
        AllowedValues?: String;
        IsModifiable?: Boolean;
    }
    export interface OptionGroupOptionsMessage {
        OptionGroupOptions?: OptionGroupOptionsList;
        Marker?: String;
    }
    export interface OptionGroupQuotaExceededFault {
    }
    export interface OptionGroups {
        OptionGroupsList?: OptionGroupsList;
        Marker?: String;
    }
    export interface OptionSetting {
        Name?: String;
        Value?: String;
        DefaultValue?: String;
        Description?: String;
        ApplyType?: String;
        DataType?: String;
        AllowedValues?: String;
        IsModifiable?: Boolean;
        IsCollection?: Boolean;
    }
    export interface OrderableDBInstanceOption {
        Engine?: String;
        EngineVersion?: String;
        DBInstanceClass?: String;
        LicenseModel?: String;
        AvailabilityZones?: AvailabilityZoneList;
        MultiAZCapable?: Boolean;
        ReadReplicaCapable?: Boolean;
        Vpc?: Boolean;
        SupportsStorageEncryption?: Boolean;
        StorageType?: String;
        SupportsIops?: Boolean;
        SupportsEnhancedMonitoring?: Boolean;
    }
    export interface OrderableDBInstanceOptionsMessage {
        OrderableDBInstanceOptions?: OrderableDBInstanceOptionsList;
        Marker?: String;
    }
    export interface Parameter {
        ParameterName?: String;
        ParameterValue?: String;
        Description?: String;
        Source?: String;
        ApplyType?: String;
        DataType?: String;
        AllowedValues?: String;
        IsModifiable?: Boolean;
        MinimumEngineVersion?: String;
        ApplyMethod?: ApplyMethod;
    }
    export interface PendingMaintenanceAction {
        Action?: String;
        AutoAppliedAfterDate?: TStamp;
        ForcedApplyDate?: TStamp;
        OptInStatus?: String;
        CurrentApplyDate?: TStamp;
        Description?: String;
    }
    export interface PendingMaintenanceActionsMessage {
        PendingMaintenanceActions?: PendingMaintenanceActions;
        Marker?: String;
    }
    export interface PendingModifiedValues {
        DBInstanceClass?: String;
        AllocatedStorage?: IntegerOptional;
        MasterUserPassword?: String;
        Port?: IntegerOptional;
        BackupRetentionPeriod?: IntegerOptional;
        MultiAZ?: BooleanOptional;
        EngineVersion?: String;
        Iops?: IntegerOptional;
        DBInstanceIdentifier?: String;
        StorageType?: String;
        CACertificateIdentifier?: String;
    }
    export interface PointInTimeRestoreNotEnabledFault {
    }
    export interface PromoteReadReplicaMessage {
        DBInstanceIdentifier: String;
        BackupRetentionPeriod?: IntegerOptional;
        PreferredBackupWindow?: String;
    }
    export interface PromoteReadReplicaResult {
        DBInstance?: DBInstance;
    }
    export interface ProvisionedIopsNotAvailableInAZFault {
    }
    export interface PurchaseReservedDBInstancesOfferingMessage {
        ReservedDBInstancesOfferingId: String;
        ReservedDBInstanceId?: String;
        DBInstanceCount?: IntegerOptional;
        Tags?: TagList;
    }
    export interface PurchaseReservedDBInstancesOfferingResult {
        ReservedDBInstance?: ReservedDBInstance;
    }
    export interface RebootDBInstanceMessage {
        DBInstanceIdentifier: String;
        ForceFailover?: BooleanOptional;
    }
    export interface RebootDBInstanceResult {
        DBInstance?: DBInstance;
    }
    export interface RecurringCharge {
        RecurringChargeAmount?: Double;
        RecurringChargeFrequency?: String;
    }
    export interface RemoveSourceIdentifierFromSubscriptionMessage {
        SubscriptionName: String;
        SourceIdentifier: String;
    }
    export interface RemoveSourceIdentifierFromSubscriptionResult {
        EventSubscription?: EventSubscription;
    }
    export interface RemoveTagsFromResourceMessage {
        ResourceName: String;
        TagKeys: KeyList;
    }
    export interface ReservedDBInstance {
        ReservedDBInstanceId?: String;
        ReservedDBInstancesOfferingId?: String;
        DBInstanceClass?: String;
        StartTime?: TStamp;
        Duration?: Integer;
        FixedPrice?: Double;
        UsagePrice?: Double;
        CurrencyCode?: String;
        DBInstanceCount?: Integer;
        ProductDescription?: String;
        OfferingType?: String;
        MultiAZ?: Boolean;
        State?: String;
        RecurringCharges?: RecurringChargeList;
    }
    export interface ReservedDBInstanceAlreadyExistsFault {
    }
    export interface ReservedDBInstanceMessage {
        Marker?: String;
        ReservedDBInstances?: ReservedDBInstanceList;
    }
    export interface ReservedDBInstanceNotFoundFault {
    }
    export interface ReservedDBInstanceQuotaExceededFault {
    }
    export interface ReservedDBInstancesOffering {
        ReservedDBInstancesOfferingId?: String;
        DBInstanceClass?: String;
        Duration?: Integer;
        FixedPrice?: Double;
        UsagePrice?: Double;
        CurrencyCode?: String;
        ProductDescription?: String;
        OfferingType?: String;
        MultiAZ?: Boolean;
        RecurringCharges?: RecurringChargeList;
    }
    export interface ReservedDBInstancesOfferingMessage {
        Marker?: String;
        ReservedDBInstancesOfferings?: ReservedDBInstancesOfferingList;
    }
    export interface ReservedDBInstancesOfferingNotFoundFault {
    }
    export interface ResetDBClusterParameterGroupMessage {
        DBClusterParameterGroupName: String;
        ResetAllParameters?: Boolean;
        Parameters?: ParametersList;
    }
    export interface ResetDBParameterGroupMessage {
        DBParameterGroupName: String;
        ResetAllParameters?: Boolean;
        Parameters?: ParametersList;
    }
    export interface ResourceNotFoundFault {
    }
    export interface ResourcePendingMaintenanceActions {
        ResourceIdentifier?: String;
        PendingMaintenanceActionDetails?: PendingMaintenanceActionDetails;
    }
    export interface RestoreDBClusterFromSnapshotMessage {
        AvailabilityZones?: AvailabilityZones;
        DBClusterIdentifier: String;
        SnapshotIdentifier: String;
        Engine: String;
        EngineVersion?: String;
        Port?: IntegerOptional;
        DBSubnetGroupName?: String;
        DatabaseName?: String;
        OptionGroupName?: String;
        VpcSecurityGroupIds?: VpcSecurityGroupIdList;
        Tags?: TagList;
        KmsKeyId?: String;
    }
    export interface RestoreDBClusterFromSnapshotResult {
        DBCluster?: DBCluster;
    }
    export interface RestoreDBClusterToPointInTimeMessage {
        DBClusterIdentifier: String;
        SourceDBClusterIdentifier: String;
        RestoreToTime?: TStamp;
        UseLatestRestorableTime?: Boolean;
        Port?: IntegerOptional;
        DBSubnetGroupName?: String;
        OptionGroupName?: String;
        VpcSecurityGroupIds?: VpcSecurityGroupIdList;
        Tags?: TagList;
        KmsKeyId?: String;
    }
    export interface RestoreDBClusterToPointInTimeResult {
        DBCluster?: DBCluster;
    }
    export interface RestoreDBInstanceFromDBSnapshotMessage {
        DBInstanceIdentifier: String;
        DBSnapshotIdentifier: String;
        DBInstanceClass?: String;
        Port?: IntegerOptional;
        AvailabilityZone?: String;
        DBSubnetGroupName?: String;
        MultiAZ?: BooleanOptional;
        PubliclyAccessible?: BooleanOptional;
        AutoMinorVersionUpgrade?: BooleanOptional;
        LicenseModel?: String;
        DBName?: String;
        Engine?: String;
        Iops?: IntegerOptional;
        OptionGroupName?: String;
        Tags?: TagList;
        StorageType?: String;
        TdeCredentialArn?: String;
        TdeCredentialPassword?: String;
        CopyTagsToSnapshot?: BooleanOptional;
    }
    export interface RestoreDBInstanceFromDBSnapshotResult {
        DBInstance?: DBInstance;
    }
    export interface RestoreDBInstanceToPointInTimeMessage {
        SourceDBInstanceIdentifier: String;
        TargetDBInstanceIdentifier: String;
        RestoreTime?: TStamp;
        UseLatestRestorableTime?: Boolean;
        DBInstanceClass?: String;
        Port?: IntegerOptional;
        AvailabilityZone?: String;
        DBSubnetGroupName?: String;
        MultiAZ?: BooleanOptional;
        PubliclyAccessible?: BooleanOptional;
        AutoMinorVersionUpgrade?: BooleanOptional;
        LicenseModel?: String;
        DBName?: String;
        Engine?: String;
        Iops?: IntegerOptional;
        OptionGroupName?: String;
        CopyTagsToSnapshot?: BooleanOptional;
        Tags?: TagList;
        StorageType?: String;
        TdeCredentialArn?: String;
        TdeCredentialPassword?: String;
    }
    export interface RestoreDBInstanceToPointInTimeResult {
        DBInstance?: DBInstance;
    }
    export interface RevokeDBSecurityGroupIngressMessage {
        DBSecurityGroupName: String;
        CIDRIP?: String;
        EC2SecurityGroupName?: String;
        EC2SecurityGroupId?: String;
        EC2SecurityGroupOwnerId?: String;
    }
    export interface RevokeDBSecurityGroupIngressResult {
        DBSecurityGroup?: DBSecurityGroup;
    }
    export interface SNSInvalidTopicFault {
    }
    export interface SNSNoAuthorizationFault {
    }
    export interface SNSTopicArnNotFoundFault {
    }
    export interface SharedSnapshotQuotaExceededFault {
    }
    export interface SnapshotQuotaExceededFault {
    }
    export interface SourceNotFoundFault {
    }
    export interface StorageQuotaExceededFault {
    }
    export interface StorageTypeNotSupportedFault {
    }
    export interface Subnet {
        SubnetIdentifier?: String;
        SubnetAvailabilityZone?: AvailabilityZone;
        SubnetStatus?: String;
    }
    export interface SubnetAlreadyInUse {
    }
    export interface SubscriptionAlreadyExistFault {
    }
    export interface SubscriptionCategoryNotFoundFault {
    }
    export interface SubscriptionNotFoundFault {
    }
    export interface Tag {
        Key?: String;
        Value?: String;
    }
    export interface TagListMessage {
        TagList?: TagList;
    }
    export interface UpgradeTarget {
        Engine?: String;
        EngineVersion?: String;
        Description?: String;
        AutoUpgrade?: Boolean;
        IsMajorVersionUpgrade?: Boolean;
    }
    export interface VpcSecurityGroupMembership {
        VpcSecurityGroupId?: String;
        Status?: String;
    }
  }

  /*
   * apiVersion: 2012-12-01
   * endpointPrefix: redshift
   * serviceAbbreviation: 
   * signatureVersion: v4
   * protocol: query
   */
  export class Redshift extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    authorizeClusterSecurityGroupIngress(params: Redshift.AuthorizeClusterSecurityGroupIngressMessage, callback?: (err: Redshift.ClusterSecurityGroupNotFoundFault|Redshift.InvalidClusterSecurityGroupStateFault|Redshift.AuthorizationAlreadyExistsFault|Redshift.AuthorizationQuotaExceededFault|any, data: Redshift.AuthorizeClusterSecurityGroupIngressResult|any) => void): Request;
    authorizeSnapshotAccess(params: Redshift.AuthorizeSnapshotAccessMessage, callback?: (err: Redshift.ClusterSnapshotNotFoundFault|Redshift.AuthorizationAlreadyExistsFault|Redshift.AuthorizationQuotaExceededFault|Redshift.DependentServiceRequestThrottlingFault|Redshift.InvalidClusterSnapshotStateFault|Redshift.LimitExceededFault|any, data: Redshift.AuthorizeSnapshotAccessResult|any) => void): Request;
    copyClusterSnapshot(params: Redshift.CopyClusterSnapshotMessage, callback?: (err: Redshift.ClusterSnapshotAlreadyExistsFault|Redshift.ClusterSnapshotNotFoundFault|Redshift.InvalidClusterSnapshotStateFault|Redshift.ClusterSnapshotQuotaExceededFault|any, data: Redshift.CopyClusterSnapshotResult|any) => void): Request;
    createCluster(params: Redshift.CreateClusterMessage, callback?: (err: Redshift.ClusterAlreadyExistsFault|Redshift.InsufficientClusterCapacityFault|Redshift.ClusterParameterGroupNotFoundFault|Redshift.ClusterSecurityGroupNotFoundFault|Redshift.ClusterQuotaExceededFault|Redshift.NumberOfNodesQuotaExceededFault|Redshift.NumberOfNodesPerClusterLimitExceededFault|Redshift.ClusterSubnetGroupNotFoundFault|Redshift.InvalidVPCNetworkStateFault|Redshift.InvalidClusterSubnetGroupStateFault|Redshift.InvalidSubnet|Redshift.UnauthorizedOperation|Redshift.HsmClientCertificateNotFoundFault|Redshift.HsmConfigurationNotFoundFault|Redshift.InvalidElasticIpFault|Redshift.TagLimitExceededFault|Redshift.InvalidTagFault|Redshift.LimitExceededFault|Redshift.DependentServiceRequestThrottlingFault|any, data: Redshift.CreateClusterResult|any) => void): Request;
    createClusterParameterGroup(params: Redshift.CreateClusterParameterGroupMessage, callback?: (err: Redshift.ClusterParameterGroupQuotaExceededFault|Redshift.ClusterParameterGroupAlreadyExistsFault|Redshift.TagLimitExceededFault|Redshift.InvalidTagFault|any, data: Redshift.CreateClusterParameterGroupResult|any) => void): Request;
    createClusterSecurityGroup(params: Redshift.CreateClusterSecurityGroupMessage, callback?: (err: Redshift.ClusterSecurityGroupAlreadyExistsFault|Redshift.ClusterSecurityGroupQuotaExceededFault|Redshift.TagLimitExceededFault|Redshift.InvalidTagFault|any, data: Redshift.CreateClusterSecurityGroupResult|any) => void): Request;
    createClusterSnapshot(params: Redshift.CreateClusterSnapshotMessage, callback?: (err: Redshift.ClusterSnapshotAlreadyExistsFault|Redshift.InvalidClusterStateFault|Redshift.ClusterNotFoundFault|Redshift.ClusterSnapshotQuotaExceededFault|Redshift.TagLimitExceededFault|Redshift.InvalidTagFault|any, data: Redshift.CreateClusterSnapshotResult|any) => void): Request;
    createClusterSubnetGroup(params: Redshift.CreateClusterSubnetGroupMessage, callback?: (err: Redshift.ClusterSubnetGroupAlreadyExistsFault|Redshift.ClusterSubnetGroupQuotaExceededFault|Redshift.ClusterSubnetQuotaExceededFault|Redshift.InvalidSubnet|Redshift.UnauthorizedOperation|Redshift.TagLimitExceededFault|Redshift.InvalidTagFault|Redshift.DependentServiceRequestThrottlingFault|any, data: Redshift.CreateClusterSubnetGroupResult|any) => void): Request;
    createEventSubscription(params: Redshift.CreateEventSubscriptionMessage, callback?: (err: Redshift.EventSubscriptionQuotaExceededFault|Redshift.SubscriptionAlreadyExistFault|Redshift.SNSInvalidTopicFault|Redshift.SNSNoAuthorizationFault|Redshift.SNSTopicArnNotFoundFault|Redshift.SubscriptionEventIdNotFoundFault|Redshift.SubscriptionCategoryNotFoundFault|Redshift.SubscriptionSeverityNotFoundFault|Redshift.SourceNotFoundFault|Redshift.TagLimitExceededFault|Redshift.InvalidTagFault|any, data: Redshift.CreateEventSubscriptionResult|any) => void): Request;
    createHsmClientCertificate(params: Redshift.CreateHsmClientCertificateMessage, callback?: (err: Redshift.HsmClientCertificateAlreadyExistsFault|Redshift.HsmClientCertificateQuotaExceededFault|Redshift.TagLimitExceededFault|Redshift.InvalidTagFault|any, data: Redshift.CreateHsmClientCertificateResult|any) => void): Request;
    createHsmConfiguration(params: Redshift.CreateHsmConfigurationMessage, callback?: (err: Redshift.HsmConfigurationAlreadyExistsFault|Redshift.HsmConfigurationQuotaExceededFault|Redshift.TagLimitExceededFault|Redshift.InvalidTagFault|any, data: Redshift.CreateHsmConfigurationResult|any) => void): Request;
    createSnapshotCopyGrant(params: Redshift.CreateSnapshotCopyGrantMessage, callback?: (err: Redshift.SnapshotCopyGrantAlreadyExistsFault|Redshift.SnapshotCopyGrantQuotaExceededFault|Redshift.LimitExceededFault|Redshift.TagLimitExceededFault|Redshift.InvalidTagFault|Redshift.DependentServiceRequestThrottlingFault|any, data: Redshift.CreateSnapshotCopyGrantResult|any) => void): Request;
    createTags(params: Redshift.CreateTagsMessage, callback?: (err: Redshift.TagLimitExceededFault|Redshift.ResourceNotFoundFault|Redshift.InvalidTagFault|any, data: any) => void): Request;
    deleteCluster(params: Redshift.DeleteClusterMessage, callback?: (err: Redshift.ClusterNotFoundFault|Redshift.InvalidClusterStateFault|Redshift.ClusterSnapshotAlreadyExistsFault|Redshift.ClusterSnapshotQuotaExceededFault|any, data: Redshift.DeleteClusterResult|any) => void): Request;
    deleteClusterParameterGroup(params: Redshift.DeleteClusterParameterGroupMessage, callback?: (err: Redshift.InvalidClusterParameterGroupStateFault|Redshift.ClusterParameterGroupNotFoundFault|any, data: any) => void): Request;
    deleteClusterSecurityGroup(params: Redshift.DeleteClusterSecurityGroupMessage, callback?: (err: Redshift.InvalidClusterSecurityGroupStateFault|Redshift.ClusterSecurityGroupNotFoundFault|any, data: any) => void): Request;
    deleteClusterSnapshot(params: Redshift.DeleteClusterSnapshotMessage, callback?: (err: Redshift.InvalidClusterSnapshotStateFault|Redshift.ClusterSnapshotNotFoundFault|any, data: Redshift.DeleteClusterSnapshotResult|any) => void): Request;
    deleteClusterSubnetGroup(params: Redshift.DeleteClusterSubnetGroupMessage, callback?: (err: Redshift.InvalidClusterSubnetGroupStateFault|Redshift.InvalidClusterSubnetStateFault|Redshift.ClusterSubnetGroupNotFoundFault|any, data: any) => void): Request;
    deleteEventSubscription(params: Redshift.DeleteEventSubscriptionMessage, callback?: (err: Redshift.SubscriptionNotFoundFault|Redshift.InvalidSubscriptionStateFault|any, data: any) => void): Request;
    deleteHsmClientCertificate(params: Redshift.DeleteHsmClientCertificateMessage, callback?: (err: Redshift.InvalidHsmClientCertificateStateFault|Redshift.HsmClientCertificateNotFoundFault|any, data: any) => void): Request;
    deleteHsmConfiguration(params: Redshift.DeleteHsmConfigurationMessage, callback?: (err: Redshift.InvalidHsmConfigurationStateFault|Redshift.HsmConfigurationNotFoundFault|any, data: any) => void): Request;
    deleteSnapshotCopyGrant(params: Redshift.DeleteSnapshotCopyGrantMessage, callback?: (err: Redshift.InvalidSnapshotCopyGrantStateFault|Redshift.SnapshotCopyGrantNotFoundFault|any, data: any) => void): Request;
    deleteTags(params: Redshift.DeleteTagsMessage, callback?: (err: Redshift.ResourceNotFoundFault|Redshift.InvalidTagFault|any, data: any) => void): Request;
    describeClusterParameterGroups(params: Redshift.DescribeClusterParameterGroupsMessage, callback?: (err: Redshift.ClusterParameterGroupNotFoundFault|Redshift.InvalidTagFault|any, data: Redshift.ClusterParameterGroupsMessage|any) => void): Request;
    describeClusterParameters(params: Redshift.DescribeClusterParametersMessage, callback?: (err: Redshift.ClusterParameterGroupNotFoundFault|any, data: Redshift.ClusterParameterGroupDetails|any) => void): Request;
    describeClusterSecurityGroups(params: Redshift.DescribeClusterSecurityGroupsMessage, callback?: (err: Redshift.ClusterSecurityGroupNotFoundFault|Redshift.InvalidTagFault|any, data: Redshift.ClusterSecurityGroupMessage|any) => void): Request;
    describeClusterSnapshots(params: Redshift.DescribeClusterSnapshotsMessage, callback?: (err: Redshift.ClusterSnapshotNotFoundFault|Redshift.InvalidTagFault|any, data: Redshift.SnapshotMessage|any) => void): Request;
    describeClusterSubnetGroups(params: Redshift.DescribeClusterSubnetGroupsMessage, callback?: (err: Redshift.ClusterSubnetGroupNotFoundFault|Redshift.InvalidTagFault|any, data: Redshift.ClusterSubnetGroupMessage|any) => void): Request;
    describeClusterVersions(params: Redshift.DescribeClusterVersionsMessage, callback?: (err: any, data: Redshift.ClusterVersionsMessage|any) => void): Request;
    describeClusters(params: Redshift.DescribeClustersMessage, callback?: (err: Redshift.ClusterNotFoundFault|Redshift.InvalidTagFault|any, data: Redshift.ClustersMessage|any) => void): Request;
    describeDefaultClusterParameters(params: Redshift.DescribeDefaultClusterParametersMessage, callback?: (err: any, data: Redshift.DescribeDefaultClusterParametersResult|any) => void): Request;
    describeEventCategories(params: Redshift.DescribeEventCategoriesMessage, callback?: (err: any, data: Redshift.EventCategoriesMessage|any) => void): Request;
    describeEventSubscriptions(params: Redshift.DescribeEventSubscriptionsMessage, callback?: (err: Redshift.SubscriptionNotFoundFault|any, data: Redshift.EventSubscriptionsMessage|any) => void): Request;
    describeEvents(params: Redshift.DescribeEventsMessage, callback?: (err: any, data: Redshift.EventsMessage|any) => void): Request;
    describeHsmClientCertificates(params: Redshift.DescribeHsmClientCertificatesMessage, callback?: (err: Redshift.HsmClientCertificateNotFoundFault|Redshift.InvalidTagFault|any, data: Redshift.HsmClientCertificateMessage|any) => void): Request;
    describeHsmConfigurations(params: Redshift.DescribeHsmConfigurationsMessage, callback?: (err: Redshift.HsmConfigurationNotFoundFault|Redshift.InvalidTagFault|any, data: Redshift.HsmConfigurationMessage|any) => void): Request;
    describeLoggingStatus(params: Redshift.DescribeLoggingStatusMessage, callback?: (err: Redshift.ClusterNotFoundFault|any, data: Redshift.LoggingStatus|any) => void): Request;
    describeOrderableClusterOptions(params: Redshift.DescribeOrderableClusterOptionsMessage, callback?: (err: any, data: Redshift.OrderableClusterOptionsMessage|any) => void): Request;
    describeReservedNodeOfferings(params: Redshift.DescribeReservedNodeOfferingsMessage, callback?: (err: Redshift.ReservedNodeOfferingNotFoundFault|Redshift.UnsupportedOperationFault|any, data: Redshift.ReservedNodeOfferingsMessage|any) => void): Request;
    describeReservedNodes(params: Redshift.DescribeReservedNodesMessage, callback?: (err: Redshift.ReservedNodeNotFoundFault|any, data: Redshift.ReservedNodesMessage|any) => void): Request;
    describeResize(params: Redshift.DescribeResizeMessage, callback?: (err: Redshift.ClusterNotFoundFault|Redshift.ResizeNotFoundFault|any, data: Redshift.ResizeProgressMessage|any) => void): Request;
    describeSnapshotCopyGrants(params: Redshift.DescribeSnapshotCopyGrantsMessage, callback?: (err: Redshift.SnapshotCopyGrantNotFoundFault|Redshift.InvalidTagFault|any, data: Redshift.SnapshotCopyGrantMessage|any) => void): Request;
    describeTableRestoreStatus(params: Redshift.DescribeTableRestoreStatusMessage, callback?: (err: Redshift.TableRestoreNotFoundFault|Redshift.ClusterNotFoundFault|any, data: Redshift.TableRestoreStatusMessage|any) => void): Request;
    describeTags(params: Redshift.DescribeTagsMessage, callback?: (err: Redshift.ResourceNotFoundFault|Redshift.InvalidTagFault|any, data: Redshift.TaggedResourceListMessage|any) => void): Request;
    disableLogging(params: Redshift.DisableLoggingMessage, callback?: (err: Redshift.ClusterNotFoundFault|any, data: Redshift.LoggingStatus|any) => void): Request;
    disableSnapshotCopy(params: Redshift.DisableSnapshotCopyMessage, callback?: (err: Redshift.ClusterNotFoundFault|Redshift.SnapshotCopyAlreadyDisabledFault|Redshift.InvalidClusterStateFault|Redshift.UnauthorizedOperation|any, data: Redshift.DisableSnapshotCopyResult|any) => void): Request;
    enableLogging(params: Redshift.EnableLoggingMessage, callback?: (err: Redshift.ClusterNotFoundFault|Redshift.BucketNotFoundFault|Redshift.InsufficientS3BucketPolicyFault|Redshift.InvalidS3KeyPrefixFault|Redshift.InvalidS3BucketNameFault|any, data: Redshift.LoggingStatus|any) => void): Request;
    enableSnapshotCopy(params: Redshift.EnableSnapshotCopyMessage, callback?: (err: Redshift.IncompatibleOrderableOptions|Redshift.InvalidClusterStateFault|Redshift.ClusterNotFoundFault|Redshift.CopyToRegionDisabledFault|Redshift.SnapshotCopyAlreadyEnabledFault|Redshift.UnknownSnapshotCopyRegionFault|Redshift.UnauthorizedOperation|Redshift.SnapshotCopyGrantNotFoundFault|Redshift.LimitExceededFault|Redshift.DependentServiceRequestThrottlingFault|any, data: Redshift.EnableSnapshotCopyResult|any) => void): Request;
    modifyCluster(params: Redshift.ModifyClusterMessage, callback?: (err: Redshift.InvalidClusterStateFault|Redshift.InvalidClusterSecurityGroupStateFault|Redshift.ClusterNotFoundFault|Redshift.NumberOfNodesQuotaExceededFault|Redshift.ClusterSecurityGroupNotFoundFault|Redshift.ClusterParameterGroupNotFoundFault|Redshift.InsufficientClusterCapacityFault|Redshift.UnsupportedOptionFault|Redshift.UnauthorizedOperation|Redshift.HsmClientCertificateNotFoundFault|Redshift.HsmConfigurationNotFoundFault|Redshift.ClusterAlreadyExistsFault|Redshift.LimitExceededFault|Redshift.DependentServiceRequestThrottlingFault|Redshift.InvalidElasticIpFault|any, data: Redshift.ModifyClusterResult|any) => void): Request;
    modifyClusterParameterGroup(params: Redshift.ModifyClusterParameterGroupMessage, callback?: (err: Redshift.ClusterParameterGroupNotFoundFault|Redshift.InvalidClusterParameterGroupStateFault|any, data: Redshift.ClusterParameterGroupNameMessage|any) => void): Request;
    modifyClusterSubnetGroup(params: Redshift.ModifyClusterSubnetGroupMessage, callback?: (err: Redshift.ClusterSubnetGroupNotFoundFault|Redshift.ClusterSubnetQuotaExceededFault|Redshift.SubnetAlreadyInUse|Redshift.InvalidSubnet|Redshift.UnauthorizedOperation|Redshift.DependentServiceRequestThrottlingFault|any, data: Redshift.ModifyClusterSubnetGroupResult|any) => void): Request;
    modifyEventSubscription(params: Redshift.ModifyEventSubscriptionMessage, callback?: (err: Redshift.SubscriptionNotFoundFault|Redshift.SNSInvalidTopicFault|Redshift.SNSNoAuthorizationFault|Redshift.SNSTopicArnNotFoundFault|Redshift.SubscriptionEventIdNotFoundFault|Redshift.SubscriptionCategoryNotFoundFault|Redshift.SubscriptionSeverityNotFoundFault|Redshift.SourceNotFoundFault|Redshift.InvalidSubscriptionStateFault|any, data: Redshift.ModifyEventSubscriptionResult|any) => void): Request;
    modifySnapshotCopyRetentionPeriod(params: Redshift.ModifySnapshotCopyRetentionPeriodMessage, callback?: (err: Redshift.ClusterNotFoundFault|Redshift.SnapshotCopyDisabledFault|Redshift.UnauthorizedOperation|Redshift.InvalidClusterStateFault|any, data: Redshift.ModifySnapshotCopyRetentionPeriodResult|any) => void): Request;
    purchaseReservedNodeOffering(params: Redshift.PurchaseReservedNodeOfferingMessage, callback?: (err: Redshift.ReservedNodeOfferingNotFoundFault|Redshift.ReservedNodeAlreadyExistsFault|Redshift.ReservedNodeQuotaExceededFault|Redshift.UnsupportedOperationFault|any, data: Redshift.PurchaseReservedNodeOfferingResult|any) => void): Request;
    rebootCluster(params: Redshift.RebootClusterMessage, callback?: (err: Redshift.InvalidClusterStateFault|Redshift.ClusterNotFoundFault|any, data: Redshift.RebootClusterResult|any) => void): Request;
    resetClusterParameterGroup(params: Redshift.ResetClusterParameterGroupMessage, callback?: (err: Redshift.InvalidClusterParameterGroupStateFault|Redshift.ClusterParameterGroupNotFoundFault|any, data: Redshift.ClusterParameterGroupNameMessage|any) => void): Request;
    restoreFromClusterSnapshot(params: Redshift.RestoreFromClusterSnapshotMessage, callback?: (err: Redshift.AccessToSnapshotDeniedFault|Redshift.ClusterAlreadyExistsFault|Redshift.ClusterSnapshotNotFoundFault|Redshift.ClusterQuotaExceededFault|Redshift.InsufficientClusterCapacityFault|Redshift.InvalidClusterSnapshotStateFault|Redshift.InvalidRestoreFault|Redshift.NumberOfNodesQuotaExceededFault|Redshift.NumberOfNodesPerClusterLimitExceededFault|Redshift.InvalidVPCNetworkStateFault|Redshift.InvalidClusterSubnetGroupStateFault|Redshift.InvalidSubnet|Redshift.ClusterSubnetGroupNotFoundFault|Redshift.UnauthorizedOperation|Redshift.HsmClientCertificateNotFoundFault|Redshift.HsmConfigurationNotFoundFault|Redshift.InvalidElasticIpFault|Redshift.ClusterParameterGroupNotFoundFault|Redshift.ClusterSecurityGroupNotFoundFault|Redshift.LimitExceededFault|Redshift.DependentServiceRequestThrottlingFault|any, data: Redshift.RestoreFromClusterSnapshotResult|any) => void): Request;
    restoreTableFromClusterSnapshot(params: Redshift.RestoreTableFromClusterSnapshotMessage, callback?: (err: Redshift.ClusterSnapshotNotFoundFault|Redshift.InProgressTableRestoreQuotaExceededFault|Redshift.InvalidClusterSnapshotStateFault|Redshift.InvalidTableRestoreArgumentFault|Redshift.ClusterNotFoundFault|Redshift.InvalidClusterStateFault|Redshift.UnsupportedOperationFault|any, data: Redshift.RestoreTableFromClusterSnapshotResult|any) => void): Request;
    revokeClusterSecurityGroupIngress(params: Redshift.RevokeClusterSecurityGroupIngressMessage, callback?: (err: Redshift.ClusterSecurityGroupNotFoundFault|Redshift.AuthorizationNotFoundFault|Redshift.InvalidClusterSecurityGroupStateFault|any, data: Redshift.RevokeClusterSecurityGroupIngressResult|any) => void): Request;
    revokeSnapshotAccess(params: Redshift.RevokeSnapshotAccessMessage, callback?: (err: Redshift.AccessToSnapshotDeniedFault|Redshift.AuthorizationNotFoundFault|Redshift.ClusterSnapshotNotFoundFault|any, data: Redshift.RevokeSnapshotAccessResult|any) => void): Request;
    rotateEncryptionKey(params: Redshift.RotateEncryptionKeyMessage, callback?: (err: Redshift.ClusterNotFoundFault|Redshift.InvalidClusterStateFault|Redshift.DependentServiceRequestThrottlingFault|any, data: Redshift.RotateEncryptionKeyResult|any) => void): Request;

  }

  export module Redshift {
    export type AccountsWithRestoreAccessList = AccountWithRestoreAccess[];
    export type AvailabilityZoneList = AvailabilityZone[];
    export type Boolean = boolean;
    export type BooleanOptional = boolean;
    export type ClusterList = Cluster[];
    export type ClusterNodesList = ClusterNode[];
    export type ClusterParameterGroupStatusList = ClusterParameterGroupStatus[];
    export type ClusterParameterStatusList = ClusterParameterStatus[];
    export type ClusterSecurityGroupMembershipList = ClusterSecurityGroupMembership[];
    export type ClusterSecurityGroupNameList = String[];
    export type ClusterSecurityGroups = ClusterSecurityGroup[];
    export type ClusterSubnetGroups = ClusterSubnetGroup[];
    export type ClusterVersionList = ClusterVersion[];
    export type Double = number;
    export type DoubleOptional = number;
    export type EC2SecurityGroupList = EC2SecurityGroup[];
    export type EventCategoriesList = String[];
    export type EventCategoriesMapList = EventCategoriesMap[];
    export type EventInfoMapList = EventInfoMap[];
    export type EventList = Event[];
    export type EventSubscriptionsList = EventSubscription[];
    export type HsmClientCertificateList = HsmClientCertificate[];
    export type HsmConfigurationList = HsmConfiguration[];
    export type IPRangeList = IPRange[];
    export type ImportTablesCompleted = String[];
    export type ImportTablesInProgress = String[];
    export type ImportTablesNotStarted = String[];
    export type Integer = number;
    export type IntegerOptional = number;
    export type Long = number;
    export type LongOptional = number;
    export type OrderableClusterOptionsList = OrderableClusterOption[];
    export type ParameterApplyType = string;
    export type ParameterGroupList = ClusterParameterGroup[];
    export type ParametersList = Parameter[];
    export type RecurringChargeList = RecurringCharge[];
    export type ReservedNodeList = ReservedNode[];
    export type ReservedNodeOfferingList = ReservedNodeOffering[];
    export type RestorableNodeTypeList = String[];
    export type SnapshotCopyGrantList = SnapshotCopyGrant[];
    export type SnapshotList = Snapshot[];
    export type SourceIdsList = String[];
    export type SourceType = string;
    export type String = string;
    export type SubnetIdentifierList = String[];
    export type SubnetList = Subnet[];
    export type TStamp = number;
    export type TableRestoreStatusList = TableRestoreStatus[];
    export type TableRestoreStatusType = string;
    export type TagKeyList = String[];
    export type TagList = Tag[];
    export type TagValueList = String[];
    export type TaggedResourceList = TaggedResource[];
    export type VpcSecurityGroupIdList = String[];
    export type VpcSecurityGroupMembershipList = VpcSecurityGroupMembership[];

    export interface AccessToSnapshotDeniedFault {
    }
    export interface AccountWithRestoreAccess {
        AccountId?: String;
    }
    export interface AuthorizationAlreadyExistsFault {
    }
    export interface AuthorizationNotFoundFault {
    }
    export interface AuthorizationQuotaExceededFault {
    }
    export interface AuthorizeClusterSecurityGroupIngressMessage {
        ClusterSecurityGroupName: String;
        CIDRIP?: String;
        EC2SecurityGroupName?: String;
        EC2SecurityGroupOwnerId?: String;
    }
    export interface AuthorizeClusterSecurityGroupIngressResult {
        ClusterSecurityGroup?: ClusterSecurityGroup;
    }
    export interface AuthorizeSnapshotAccessMessage {
        SnapshotIdentifier: String;
        SnapshotClusterIdentifier?: String;
        AccountWithRestoreAccess: String;
    }
    export interface AuthorizeSnapshotAccessResult {
        Snapshot?: Snapshot;
    }
    export interface AvailabilityZone {
        Name?: String;
    }
    export interface BucketNotFoundFault {
    }
    export interface Cluster {
        ClusterIdentifier?: String;
        NodeType?: String;
        ClusterStatus?: String;
        ModifyStatus?: String;
        MasterUsername?: String;
        DBName?: String;
        Endpoint?: Endpoint;
        ClusterCreateTime?: TStamp;
        AutomatedSnapshotRetentionPeriod?: Integer;
        ClusterSecurityGroups?: ClusterSecurityGroupMembershipList;
        VpcSecurityGroups?: VpcSecurityGroupMembershipList;
        ClusterParameterGroups?: ClusterParameterGroupStatusList;
        ClusterSubnetGroupName?: String;
        VpcId?: String;
        AvailabilityZone?: String;
        PreferredMaintenanceWindow?: String;
        PendingModifiedValues?: PendingModifiedValues;
        ClusterVersion?: String;
        AllowVersionUpgrade?: Boolean;
        NumberOfNodes?: Integer;
        PubliclyAccessible?: Boolean;
        Encrypted?: Boolean;
        RestoreStatus?: RestoreStatus;
        HsmStatus?: HsmStatus;
        ClusterSnapshotCopyStatus?: ClusterSnapshotCopyStatus;
        ClusterPublicKey?: String;
        ClusterNodes?: ClusterNodesList;
        ElasticIpStatus?: ElasticIpStatus;
        ClusterRevisionNumber?: String;
        Tags?: TagList;
        KmsKeyId?: String;
    }
    export interface ClusterAlreadyExistsFault {
    }
    export interface ClusterNode {
        NodeRole?: String;
        PrivateIPAddress?: String;
        PublicIPAddress?: String;
    }
    export interface ClusterNotFoundFault {
    }
    export interface ClusterParameterGroup {
        ParameterGroupName?: String;
        ParameterGroupFamily?: String;
        Description?: String;
        Tags?: TagList;
    }
    export interface ClusterParameterGroupAlreadyExistsFault {
    }
    export interface ClusterParameterGroupDetails {
        Parameters?: ParametersList;
        Marker?: String;
    }
    export interface ClusterParameterGroupNameMessage {
        ParameterGroupName?: String;
        ParameterGroupStatus?: String;
    }
    export interface ClusterParameterGroupNotFoundFault {
    }
    export interface ClusterParameterGroupQuotaExceededFault {
    }
    export interface ClusterParameterGroupStatus {
        ParameterGroupName?: String;
        ParameterApplyStatus?: String;
        ClusterParameterStatusList?: ClusterParameterStatusList;
    }
    export interface ClusterParameterGroupsMessage {
        Marker?: String;
        ParameterGroups?: ParameterGroupList;
    }
    export interface ClusterParameterStatus {
        ParameterName?: String;
        ParameterApplyStatus?: String;
        ParameterApplyErrorDescription?: String;
    }
    export interface ClusterQuotaExceededFault {
    }
    export interface ClusterSecurityGroup {
        ClusterSecurityGroupName?: String;
        Description?: String;
        EC2SecurityGroups?: EC2SecurityGroupList;
        IPRanges?: IPRangeList;
        Tags?: TagList;
    }
    export interface ClusterSecurityGroupAlreadyExistsFault {
    }
    export interface ClusterSecurityGroupMembership {
        ClusterSecurityGroupName?: String;
        Status?: String;
    }
    export interface ClusterSecurityGroupMessage {
        Marker?: String;
        ClusterSecurityGroups?: ClusterSecurityGroups;
    }
    export interface ClusterSecurityGroupNotFoundFault {
    }
    export interface ClusterSecurityGroupQuotaExceededFault {
    }
    export interface ClusterSnapshotAlreadyExistsFault {
    }
    export interface ClusterSnapshotCopyStatus {
        DestinationRegion?: String;
        RetentionPeriod?: Long;
        SnapshotCopyGrantName?: String;
    }
    export interface ClusterSnapshotNotFoundFault {
    }
    export interface ClusterSnapshotQuotaExceededFault {
    }
    export interface ClusterSubnetGroup {
        ClusterSubnetGroupName?: String;
        Description?: String;
        VpcId?: String;
        SubnetGroupStatus?: String;
        Subnets?: SubnetList;
        Tags?: TagList;
    }
    export interface ClusterSubnetGroupAlreadyExistsFault {
    }
    export interface ClusterSubnetGroupMessage {
        Marker?: String;
        ClusterSubnetGroups?: ClusterSubnetGroups;
    }
    export interface ClusterSubnetGroupNotFoundFault {
    }
    export interface ClusterSubnetGroupQuotaExceededFault {
    }
    export interface ClusterSubnetQuotaExceededFault {
    }
    export interface ClusterVersion {
        ClusterVersion?: String;
        ClusterParameterGroupFamily?: String;
        Description?: String;
    }
    export interface ClusterVersionsMessage {
        Marker?: String;
        ClusterVersions?: ClusterVersionList;
    }
    export interface ClustersMessage {
        Marker?: String;
        Clusters?: ClusterList;
    }
    export interface CopyClusterSnapshotMessage {
        SourceSnapshotIdentifier: String;
        SourceSnapshotClusterIdentifier?: String;
        TargetSnapshotIdentifier: String;
    }
    export interface CopyClusterSnapshotResult {
        Snapshot?: Snapshot;
    }
    export interface CopyToRegionDisabledFault {
    }
    export interface CreateClusterMessage {
        DBName?: String;
        ClusterIdentifier: String;
        ClusterType?: String;
        NodeType: String;
        MasterUsername: String;
        MasterUserPassword: String;
        ClusterSecurityGroups?: ClusterSecurityGroupNameList;
        VpcSecurityGroupIds?: VpcSecurityGroupIdList;
        ClusterSubnetGroupName?: String;
        AvailabilityZone?: String;
        PreferredMaintenanceWindow?: String;
        ClusterParameterGroupName?: String;
        AutomatedSnapshotRetentionPeriod?: IntegerOptional;
        Port?: IntegerOptional;
        ClusterVersion?: String;
        AllowVersionUpgrade?: BooleanOptional;
        NumberOfNodes?: IntegerOptional;
        PubliclyAccessible?: BooleanOptional;
        Encrypted?: BooleanOptional;
        HsmClientCertificateIdentifier?: String;
        HsmConfigurationIdentifier?: String;
        ElasticIp?: String;
        Tags?: TagList;
        KmsKeyId?: String;
        AdditionalInfo?: String;
    }
    export interface CreateClusterParameterGroupMessage {
        ParameterGroupName: String;
        ParameterGroupFamily: String;
        Description: String;
        Tags?: TagList;
    }
    export interface CreateClusterParameterGroupResult {
        ClusterParameterGroup?: ClusterParameterGroup;
    }
    export interface CreateClusterResult {
        Cluster?: Cluster;
    }
    export interface CreateClusterSecurityGroupMessage {
        ClusterSecurityGroupName: String;
        Description: String;
        Tags?: TagList;
    }
    export interface CreateClusterSecurityGroupResult {
        ClusterSecurityGroup?: ClusterSecurityGroup;
    }
    export interface CreateClusterSnapshotMessage {
        SnapshotIdentifier: String;
        ClusterIdentifier: String;
        Tags?: TagList;
    }
    export interface CreateClusterSnapshotResult {
        Snapshot?: Snapshot;
    }
    export interface CreateClusterSubnetGroupMessage {
        ClusterSubnetGroupName: String;
        Description: String;
        SubnetIds: SubnetIdentifierList;
        Tags?: TagList;
    }
    export interface CreateClusterSubnetGroupResult {
        ClusterSubnetGroup?: ClusterSubnetGroup;
    }
    export interface CreateEventSubscriptionMessage {
        SubscriptionName: String;
        SnsTopicArn: String;
        SourceType?: String;
        SourceIds?: SourceIdsList;
        EventCategories?: EventCategoriesList;
        Severity?: String;
        Enabled?: BooleanOptional;
        Tags?: TagList;
    }
    export interface CreateEventSubscriptionResult {
        EventSubscription?: EventSubscription;
    }
    export interface CreateHsmClientCertificateMessage {
        HsmClientCertificateIdentifier: String;
        Tags?: TagList;
    }
    export interface CreateHsmClientCertificateResult {
        HsmClientCertificate?: HsmClientCertificate;
    }
    export interface CreateHsmConfigurationMessage {
        HsmConfigurationIdentifier: String;
        Description: String;
        HsmIpAddress: String;
        HsmPartitionName: String;
        HsmPartitionPassword: String;
        HsmServerPublicCertificate: String;
        Tags?: TagList;
    }
    export interface CreateHsmConfigurationResult {
        HsmConfiguration?: HsmConfiguration;
    }
    export interface CreateSnapshotCopyGrantMessage {
        SnapshotCopyGrantName: String;
        KmsKeyId?: String;
        Tags?: TagList;
    }
    export interface CreateSnapshotCopyGrantResult {
        SnapshotCopyGrant?: SnapshotCopyGrant;
    }
    export interface CreateTagsMessage {
        ResourceName: String;
        Tags: TagList;
    }
    export interface DefaultClusterParameters {
        ParameterGroupFamily?: String;
        Marker?: String;
        Parameters?: ParametersList;
    }
    export interface DeleteClusterMessage {
        ClusterIdentifier: String;
        SkipFinalClusterSnapshot?: Boolean;
        FinalClusterSnapshotIdentifier?: String;
    }
    export interface DeleteClusterParameterGroupMessage {
        ParameterGroupName: String;
    }
    export interface DeleteClusterResult {
        Cluster?: Cluster;
    }
    export interface DeleteClusterSecurityGroupMessage {
        ClusterSecurityGroupName: String;
    }
    export interface DeleteClusterSnapshotMessage {
        SnapshotIdentifier: String;
        SnapshotClusterIdentifier?: String;
    }
    export interface DeleteClusterSnapshotResult {
        Snapshot?: Snapshot;
    }
    export interface DeleteClusterSubnetGroupMessage {
        ClusterSubnetGroupName: String;
    }
    export interface DeleteEventSubscriptionMessage {
        SubscriptionName: String;
    }
    export interface DeleteHsmClientCertificateMessage {
        HsmClientCertificateIdentifier: String;
    }
    export interface DeleteHsmConfigurationMessage {
        HsmConfigurationIdentifier: String;
    }
    export interface DeleteSnapshotCopyGrantMessage {
        SnapshotCopyGrantName: String;
    }
    export interface DeleteTagsMessage {
        ResourceName: String;
        TagKeys: TagKeyList;
    }
    export interface DependentServiceRequestThrottlingFault {
    }
    export interface DescribeClusterParameterGroupsMessage {
        ParameterGroupName?: String;
        MaxRecords?: IntegerOptional;
        Marker?: String;
        TagKeys?: TagKeyList;
        TagValues?: TagValueList;
    }
    export interface DescribeClusterParametersMessage {
        ParameterGroupName: String;
        Source?: String;
        MaxRecords?: IntegerOptional;
        Marker?: String;
    }
    export interface DescribeClusterSecurityGroupsMessage {
        ClusterSecurityGroupName?: String;
        MaxRecords?: IntegerOptional;
        Marker?: String;
        TagKeys?: TagKeyList;
        TagValues?: TagValueList;
    }
    export interface DescribeClusterSnapshotsMessage {
        ClusterIdentifier?: String;
        SnapshotIdentifier?: String;
        SnapshotType?: String;
        StartTime?: TStamp;
        EndTime?: TStamp;
        MaxRecords?: IntegerOptional;
        Marker?: String;
        OwnerAccount?: String;
        TagKeys?: TagKeyList;
        TagValues?: TagValueList;
    }
    export interface DescribeClusterSubnetGroupsMessage {
        ClusterSubnetGroupName?: String;
        MaxRecords?: IntegerOptional;
        Marker?: String;
        TagKeys?: TagKeyList;
        TagValues?: TagValueList;
    }
    export interface DescribeClusterVersionsMessage {
        ClusterVersion?: String;
        ClusterParameterGroupFamily?: String;
        MaxRecords?: IntegerOptional;
        Marker?: String;
    }
    export interface DescribeClustersMessage {
        ClusterIdentifier?: String;
        MaxRecords?: IntegerOptional;
        Marker?: String;
        TagKeys?: TagKeyList;
        TagValues?: TagValueList;
    }
    export interface DescribeDefaultClusterParametersMessage {
        ParameterGroupFamily: String;
        MaxRecords?: IntegerOptional;
        Marker?: String;
    }
    export interface DescribeDefaultClusterParametersResult {
        DefaultClusterParameters?: DefaultClusterParameters;
    }
    export interface DescribeEventCategoriesMessage {
        SourceType?: String;
    }
    export interface DescribeEventSubscriptionsMessage {
        SubscriptionName?: String;
        MaxRecords?: IntegerOptional;
        Marker?: String;
    }
    export interface DescribeEventsMessage {
        SourceIdentifier?: String;
        SourceType?: SourceType;
        StartTime?: TStamp;
        EndTime?: TStamp;
        Duration?: IntegerOptional;
        MaxRecords?: IntegerOptional;
        Marker?: String;
    }
    export interface DescribeHsmClientCertificatesMessage {
        HsmClientCertificateIdentifier?: String;
        MaxRecords?: IntegerOptional;
        Marker?: String;
        TagKeys?: TagKeyList;
        TagValues?: TagValueList;
    }
    export interface DescribeHsmConfigurationsMessage {
        HsmConfigurationIdentifier?: String;
        MaxRecords?: IntegerOptional;
        Marker?: String;
        TagKeys?: TagKeyList;
        TagValues?: TagValueList;
    }
    export interface DescribeLoggingStatusMessage {
        ClusterIdentifier: String;
    }
    export interface DescribeOrderableClusterOptionsMessage {
        ClusterVersion?: String;
        NodeType?: String;
        MaxRecords?: IntegerOptional;
        Marker?: String;
    }
    export interface DescribeReservedNodeOfferingsMessage {
        ReservedNodeOfferingId?: String;
        MaxRecords?: IntegerOptional;
        Marker?: String;
    }
    export interface DescribeReservedNodesMessage {
        ReservedNodeId?: String;
        MaxRecords?: IntegerOptional;
        Marker?: String;
    }
    export interface DescribeResizeMessage {
        ClusterIdentifier: String;
    }
    export interface DescribeSnapshotCopyGrantsMessage {
        SnapshotCopyGrantName?: String;
        MaxRecords?: IntegerOptional;
        Marker?: String;
        TagKeys?: TagKeyList;
        TagValues?: TagValueList;
    }
    export interface DescribeTableRestoreStatusMessage {
        ClusterIdentifier?: String;
        TableRestoreRequestId?: String;
        MaxRecords?: IntegerOptional;
        Marker?: String;
    }
    export interface DescribeTagsMessage {
        ResourceName?: String;
        ResourceType?: String;
        MaxRecords?: IntegerOptional;
        Marker?: String;
        TagKeys?: TagKeyList;
        TagValues?: TagValueList;
    }
    export interface DisableLoggingMessage {
        ClusterIdentifier: String;
    }
    export interface DisableSnapshotCopyMessage {
        ClusterIdentifier: String;
    }
    export interface DisableSnapshotCopyResult {
        Cluster?: Cluster;
    }
    export interface EC2SecurityGroup {
        Status?: String;
        EC2SecurityGroupName?: String;
        EC2SecurityGroupOwnerId?: String;
        Tags?: TagList;
    }
    export interface ElasticIpStatus {
        ElasticIp?: String;
        Status?: String;
    }
    export interface EnableLoggingMessage {
        ClusterIdentifier: String;
        BucketName: String;
        S3KeyPrefix?: String;
    }
    export interface EnableSnapshotCopyMessage {
        ClusterIdentifier: String;
        DestinationRegion: String;
        RetentionPeriod?: IntegerOptional;
        SnapshotCopyGrantName?: String;
    }
    export interface EnableSnapshotCopyResult {
        Cluster?: Cluster;
    }
    export interface Endpoint {
        Address?: String;
        Port?: Integer;
    }
    export interface Event {
        SourceIdentifier?: String;
        SourceType?: SourceType;
        Message?: String;
        EventCategories?: EventCategoriesList;
        Severity?: String;
        Date?: TStamp;
        EventId?: String;
    }
    export interface EventCategoriesMap {
        SourceType?: String;
        Events?: EventInfoMapList;
    }
    export interface EventCategoriesMessage {
        EventCategoriesMapList?: EventCategoriesMapList;
    }
    export interface EventInfoMap {
        EventId?: String;
        EventCategories?: EventCategoriesList;
        EventDescription?: String;
        Severity?: String;
    }
    export interface EventSubscription {
        CustomerAwsId?: String;
        CustSubscriptionId?: String;
        SnsTopicArn?: String;
        Status?: String;
        SubscriptionCreationTime?: TStamp;
        SourceType?: String;
        SourceIdsList?: SourceIdsList;
        EventCategoriesList?: EventCategoriesList;
        Severity?: String;
        Enabled?: Boolean;
        Tags?: TagList;
    }
    export interface EventSubscriptionQuotaExceededFault {
    }
    export interface EventSubscriptionsMessage {
        Marker?: String;
        EventSubscriptionsList?: EventSubscriptionsList;
    }
    export interface EventsMessage {
        Marker?: String;
        Events?: EventList;
    }
    export interface HsmClientCertificate {
        HsmClientCertificateIdentifier?: String;
        HsmClientCertificatePublicKey?: String;
        Tags?: TagList;
    }
    export interface HsmClientCertificateAlreadyExistsFault {
    }
    export interface HsmClientCertificateMessage {
        Marker?: String;
        HsmClientCertificates?: HsmClientCertificateList;
    }
    export interface HsmClientCertificateNotFoundFault {
    }
    export interface HsmClientCertificateQuotaExceededFault {
    }
    export interface HsmConfiguration {
        HsmConfigurationIdentifier?: String;
        Description?: String;
        HsmIpAddress?: String;
        HsmPartitionName?: String;
        Tags?: TagList;
    }
    export interface HsmConfigurationAlreadyExistsFault {
    }
    export interface HsmConfigurationMessage {
        Marker?: String;
        HsmConfigurations?: HsmConfigurationList;
    }
    export interface HsmConfigurationNotFoundFault {
    }
    export interface HsmConfigurationQuotaExceededFault {
    }
    export interface HsmStatus {
        HsmClientCertificateIdentifier?: String;
        HsmConfigurationIdentifier?: String;
        Status?: String;
    }
    export interface IPRange {
        Status?: String;
        CIDRIP?: String;
        Tags?: TagList;
    }
    export interface InProgressTableRestoreQuotaExceededFault {
    }
    export interface IncompatibleOrderableOptions {
    }
    export interface InsufficientClusterCapacityFault {
    }
    export interface InsufficientS3BucketPolicyFault {
    }
    export interface InvalidClusterParameterGroupStateFault {
    }
    export interface InvalidClusterSecurityGroupStateFault {
    }
    export interface InvalidClusterSnapshotStateFault {
    }
    export interface InvalidClusterStateFault {
    }
    export interface InvalidClusterSubnetGroupStateFault {
    }
    export interface InvalidClusterSubnetStateFault {
    }
    export interface InvalidElasticIpFault {
    }
    export interface InvalidHsmClientCertificateStateFault {
    }
    export interface InvalidHsmConfigurationStateFault {
    }
    export interface InvalidRestoreFault {
    }
    export interface InvalidS3BucketNameFault {
    }
    export interface InvalidS3KeyPrefixFault {
    }
    export interface InvalidSnapshotCopyGrantStateFault {
    }
    export interface InvalidSubnet {
    }
    export interface InvalidSubscriptionStateFault {
    }
    export interface InvalidTableRestoreArgumentFault {
    }
    export interface InvalidTagFault {
    }
    export interface InvalidVPCNetworkStateFault {
    }
    export interface LimitExceededFault {
    }
    export interface LoggingStatus {
        LoggingEnabled?: Boolean;
        BucketName?: String;
        S3KeyPrefix?: String;
        LastSuccessfulDeliveryTime?: TStamp;
        LastFailureTime?: TStamp;
        LastFailureMessage?: String;
    }
    export interface ModifyClusterMessage {
        ClusterIdentifier: String;
        ClusterType?: String;
        NodeType?: String;
        NumberOfNodes?: IntegerOptional;
        ClusterSecurityGroups?: ClusterSecurityGroupNameList;
        VpcSecurityGroupIds?: VpcSecurityGroupIdList;
        MasterUserPassword?: String;
        ClusterParameterGroupName?: String;
        AutomatedSnapshotRetentionPeriod?: IntegerOptional;
        PreferredMaintenanceWindow?: String;
        ClusterVersion?: String;
        AllowVersionUpgrade?: BooleanOptional;
        HsmClientCertificateIdentifier?: String;
        HsmConfigurationIdentifier?: String;
        NewClusterIdentifier?: String;
        PubliclyAccessible?: BooleanOptional;
        ElasticIp?: String;
    }
    export interface ModifyClusterParameterGroupMessage {
        ParameterGroupName: String;
        Parameters: ParametersList;
    }
    export interface ModifyClusterResult {
        Cluster?: Cluster;
    }
    export interface ModifyClusterSubnetGroupMessage {
        ClusterSubnetGroupName: String;
        Description?: String;
        SubnetIds: SubnetIdentifierList;
    }
    export interface ModifyClusterSubnetGroupResult {
        ClusterSubnetGroup?: ClusterSubnetGroup;
    }
    export interface ModifyEventSubscriptionMessage {
        SubscriptionName: String;
        SnsTopicArn?: String;
        SourceType?: String;
        SourceIds?: SourceIdsList;
        EventCategories?: EventCategoriesList;
        Severity?: String;
        Enabled?: BooleanOptional;
    }
    export interface ModifyEventSubscriptionResult {
        EventSubscription?: EventSubscription;
    }
    export interface ModifySnapshotCopyRetentionPeriodMessage {
        ClusterIdentifier: String;
        RetentionPeriod: Integer;
    }
    export interface ModifySnapshotCopyRetentionPeriodResult {
        Cluster?: Cluster;
    }
    export interface NumberOfNodesPerClusterLimitExceededFault {
    }
    export interface NumberOfNodesQuotaExceededFault {
    }
    export interface OrderableClusterOption {
        ClusterVersion?: String;
        ClusterType?: String;
        NodeType?: String;
        AvailabilityZones?: AvailabilityZoneList;
    }
    export interface OrderableClusterOptionsMessage {
        OrderableClusterOptions?: OrderableClusterOptionsList;
        Marker?: String;
    }
    export interface Parameter {
        ParameterName?: String;
        ParameterValue?: String;
        Description?: String;
        Source?: String;
        DataType?: String;
        AllowedValues?: String;
        ApplyType?: ParameterApplyType;
        IsModifiable?: Boolean;
        MinimumEngineVersion?: String;
    }
    export interface PendingModifiedValues {
        MasterUserPassword?: String;
        NodeType?: String;
        NumberOfNodes?: IntegerOptional;
        ClusterType?: String;
        ClusterVersion?: String;
        AutomatedSnapshotRetentionPeriod?: IntegerOptional;
        ClusterIdentifier?: String;
        PubliclyAccessible?: BooleanOptional;
    }
    export interface PurchaseReservedNodeOfferingMessage {
        ReservedNodeOfferingId: String;
        NodeCount?: IntegerOptional;
    }
    export interface PurchaseReservedNodeOfferingResult {
        ReservedNode?: ReservedNode;
    }
    export interface RebootClusterMessage {
        ClusterIdentifier: String;
    }
    export interface RebootClusterResult {
        Cluster?: Cluster;
    }
    export interface RecurringCharge {
        RecurringChargeAmount?: Double;
        RecurringChargeFrequency?: String;
    }
    export interface ReservedNode {
        ReservedNodeId?: String;
        ReservedNodeOfferingId?: String;
        NodeType?: String;
        StartTime?: TStamp;
        Duration?: Integer;
        FixedPrice?: Double;
        UsagePrice?: Double;
        CurrencyCode?: String;
        NodeCount?: Integer;
        State?: String;
        OfferingType?: String;
        RecurringCharges?: RecurringChargeList;
    }
    export interface ReservedNodeAlreadyExistsFault {
    }
    export interface ReservedNodeNotFoundFault {
    }
    export interface ReservedNodeOffering {
        ReservedNodeOfferingId?: String;
        NodeType?: String;
        Duration?: Integer;
        FixedPrice?: Double;
        UsagePrice?: Double;
        CurrencyCode?: String;
        OfferingType?: String;
        RecurringCharges?: RecurringChargeList;
    }
    export interface ReservedNodeOfferingNotFoundFault {
    }
    export interface ReservedNodeOfferingsMessage {
        Marker?: String;
        ReservedNodeOfferings?: ReservedNodeOfferingList;
    }
    export interface ReservedNodeQuotaExceededFault {
    }
    export interface ReservedNodesMessage {
        Marker?: String;
        ReservedNodes?: ReservedNodeList;
    }
    export interface ResetClusterParameterGroupMessage {
        ParameterGroupName: String;
        ResetAllParameters?: Boolean;
        Parameters?: ParametersList;
    }
    export interface ResizeNotFoundFault {
    }
    export interface ResizeProgressMessage {
        TargetNodeType?: String;
        TargetNumberOfNodes?: IntegerOptional;
        TargetClusterType?: String;
        Status?: String;
        ImportTablesCompleted?: ImportTablesCompleted;
        ImportTablesInProgress?: ImportTablesInProgress;
        ImportTablesNotStarted?: ImportTablesNotStarted;
        AvgResizeRateInMegaBytesPerSecond?: DoubleOptional;
        TotalResizeDataInMegaBytes?: LongOptional;
        ProgressInMegaBytes?: LongOptional;
        ElapsedTimeInSeconds?: LongOptional;
        EstimatedTimeToCompletionInSeconds?: LongOptional;
    }
    export interface ResourceNotFoundFault {
    }
    export interface RestoreFromClusterSnapshotMessage {
        ClusterIdentifier: String;
        SnapshotIdentifier: String;
        SnapshotClusterIdentifier?: String;
        Port?: IntegerOptional;
        AvailabilityZone?: String;
        AllowVersionUpgrade?: BooleanOptional;
        ClusterSubnetGroupName?: String;
        PubliclyAccessible?: BooleanOptional;
        OwnerAccount?: String;
        HsmClientCertificateIdentifier?: String;
        HsmConfigurationIdentifier?: String;
        ElasticIp?: String;
        ClusterParameterGroupName?: String;
        ClusterSecurityGroups?: ClusterSecurityGroupNameList;
        VpcSecurityGroupIds?: VpcSecurityGroupIdList;
        PreferredMaintenanceWindow?: String;
        AutomatedSnapshotRetentionPeriod?: IntegerOptional;
        KmsKeyId?: String;
        NodeType?: String;
        AdditionalInfo?: String;
    }
    export interface RestoreFromClusterSnapshotResult {
        Cluster?: Cluster;
    }
    export interface RestoreStatus {
        Status?: String;
        CurrentRestoreRateInMegaBytesPerSecond?: Double;
        SnapshotSizeInMegaBytes?: Long;
        ProgressInMegaBytes?: Long;
        ElapsedTimeInSeconds?: Long;
        EstimatedTimeToCompletionInSeconds?: Long;
    }
    export interface RestoreTableFromClusterSnapshotMessage {
        ClusterIdentifier: String;
        SnapshotIdentifier: String;
        SourceDatabaseName: String;
        SourceSchemaName?: String;
        SourceTableName: String;
        TargetDatabaseName?: String;
        TargetSchemaName?: String;
        NewTableName: String;
    }
    export interface RestoreTableFromClusterSnapshotResult {
        TableRestoreStatus?: TableRestoreStatus;
    }
    export interface RevokeClusterSecurityGroupIngressMessage {
        ClusterSecurityGroupName: String;
        CIDRIP?: String;
        EC2SecurityGroupName?: String;
        EC2SecurityGroupOwnerId?: String;
    }
    export interface RevokeClusterSecurityGroupIngressResult {
        ClusterSecurityGroup?: ClusterSecurityGroup;
    }
    export interface RevokeSnapshotAccessMessage {
        SnapshotIdentifier: String;
        SnapshotClusterIdentifier?: String;
        AccountWithRestoreAccess: String;
    }
    export interface RevokeSnapshotAccessResult {
        Snapshot?: Snapshot;
    }
    export interface RotateEncryptionKeyMessage {
        ClusterIdentifier: String;
    }
    export interface RotateEncryptionKeyResult {
        Cluster?: Cluster;
    }
    export interface SNSInvalidTopicFault {
    }
    export interface SNSNoAuthorizationFault {
    }
    export interface SNSTopicArnNotFoundFault {
    }
    export interface Snapshot {
        SnapshotIdentifier?: String;
        ClusterIdentifier?: String;
        SnapshotCreateTime?: TStamp;
        Status?: String;
        Port?: Integer;
        AvailabilityZone?: String;
        ClusterCreateTime?: TStamp;
        MasterUsername?: String;
        ClusterVersion?: String;
        SnapshotType?: String;
        NodeType?: String;
        NumberOfNodes?: Integer;
        DBName?: String;
        VpcId?: String;
        Encrypted?: Boolean;
        KmsKeyId?: String;
        EncryptedWithHSM?: Boolean;
        AccountsWithRestoreAccess?: AccountsWithRestoreAccessList;
        OwnerAccount?: String;
        TotalBackupSizeInMegaBytes?: Double;
        ActualIncrementalBackupSizeInMegaBytes?: Double;
        BackupProgressInMegaBytes?: Double;
        CurrentBackupRateInMegaBytesPerSecond?: Double;
        EstimatedSecondsToCompletion?: Long;
        ElapsedTimeInSeconds?: Long;
        SourceRegion?: String;
        Tags?: TagList;
        RestorableNodeTypes?: RestorableNodeTypeList;
    }
    export interface SnapshotCopyAlreadyDisabledFault {
    }
    export interface SnapshotCopyAlreadyEnabledFault {
    }
    export interface SnapshotCopyDisabledFault {
    }
    export interface SnapshotCopyGrant {
        SnapshotCopyGrantName?: String;
        KmsKeyId?: String;
        Tags?: TagList;
    }
    export interface SnapshotCopyGrantAlreadyExistsFault {
    }
    export interface SnapshotCopyGrantMessage {
        Marker?: String;
        SnapshotCopyGrants?: SnapshotCopyGrantList;
    }
    export interface SnapshotCopyGrantNotFoundFault {
    }
    export interface SnapshotCopyGrantQuotaExceededFault {
    }
    export interface SnapshotMessage {
        Marker?: String;
        Snapshots?: SnapshotList;
    }
    export interface SourceNotFoundFault {
    }
    export interface Subnet {
        SubnetIdentifier?: String;
        SubnetAvailabilityZone?: AvailabilityZone;
        SubnetStatus?: String;
    }
    export interface SubnetAlreadyInUse {
    }
    export interface SubscriptionAlreadyExistFault {
    }
    export interface SubscriptionCategoryNotFoundFault {
    }
    export interface SubscriptionEventIdNotFoundFault {
    }
    export interface SubscriptionNotFoundFault {
    }
    export interface SubscriptionSeverityNotFoundFault {
    }
    export interface TableRestoreNotFoundFault {
    }
    export interface TableRestoreStatus {
        TableRestoreRequestId?: String;
        Status?: TableRestoreStatusType;
        Message?: String;
        RequestTime?: TStamp;
        ProgressInMegaBytes?: LongOptional;
        TotalDataInMegaBytes?: LongOptional;
        ClusterIdentifier?: String;
        SnapshotIdentifier?: String;
        SourceDatabaseName?: String;
        SourceSchemaName?: String;
        SourceTableName?: String;
        TargetDatabaseName?: String;
        TargetSchemaName?: String;
        NewTableName?: String;
    }
    export interface TableRestoreStatusMessage {
        TableRestoreStatusDetails?: TableRestoreStatusList;
        Marker?: String;
    }
    export interface Tag {
        Key?: String;
        Value?: String;
    }
    export interface TagLimitExceededFault {
    }
    export interface TaggedResource {
        Tag?: Tag;
        ResourceName?: String;
        ResourceType?: String;
    }
    export interface TaggedResourceListMessage {
        TaggedResources?: TaggedResourceList;
        Marker?: String;
    }
    export interface UnauthorizedOperation {
    }
    export interface UnknownSnapshotCopyRegionFault {
    }
    export interface UnsupportedOperationFault {
    }
    export interface UnsupportedOptionFault {
    }
    export interface VpcSecurityGroupMembership {
        VpcSecurityGroupId?: String;
        Status?: String;
    }
  }

  /*
   * apiVersion: 2013-04-01
   * endpointPrefix: route53
   * serviceAbbreviation: Route 53
   * signatureVersion: v4
   * protocol: rest-xml
   */
  export class Route53 extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    associateVPCWithHostedZone(params: Route53.AssociateVPCWithHostedZoneRequest, callback?: (err: Route53.NoSuchHostedZone|Route53.InvalidVPCId|Route53.InvalidInput|Route53.PublicZoneVPCAssociation|Route53.ConflictingDomainExists|Route53.LimitsExceeded|any, data: Route53.AssociateVPCWithHostedZoneResponse|any) => void): Request;
    changeResourceRecordSets(params: Route53.ChangeResourceRecordSetsRequest, callback?: (err: Route53.NoSuchHostedZone|Route53.NoSuchHealthCheck|Route53.InvalidChangeBatch|Route53.InvalidInput|Route53.PriorRequestNotComplete|any, data: Route53.ChangeResourceRecordSetsResponse|any) => void): Request;
    changeTagsForResource(params: Route53.ChangeTagsForResourceRequest, callback?: (err: Route53.InvalidInput|Route53.NoSuchHealthCheck|Route53.NoSuchHostedZone|Route53.PriorRequestNotComplete|Route53.ThrottlingException|any, data: Route53.ChangeTagsForResourceResponse|any) => void): Request;
    createHealthCheck(params: Route53.CreateHealthCheckRequest, callback?: (err: Route53.TooManyHealthChecks|Route53.HealthCheckAlreadyExists|Route53.InvalidInput|any, data: Route53.CreateHealthCheckResponse|any) => void): Request;
    createHostedZone(params: Route53.CreateHostedZoneRequest, callback?: (err: Route53.InvalidDomainName|Route53.HostedZoneAlreadyExists|Route53.TooManyHostedZones|Route53.InvalidVPCId|Route53.InvalidInput|Route53.DelegationSetNotAvailable|Route53.ConflictingDomainExists|Route53.NoSuchDelegationSet|Route53.DelegationSetNotReusable|any, data: Route53.CreateHostedZoneResponse|any) => void): Request;
    createReusableDelegationSet(params: Route53.CreateReusableDelegationSetRequest, callback?: (err: Route53.DelegationSetAlreadyCreated|Route53.LimitsExceeded|Route53.HostedZoneNotFound|Route53.InvalidArgument|Route53.InvalidInput|Route53.DelegationSetNotAvailable|Route53.DelegationSetAlreadyReusable|any, data: Route53.CreateReusableDelegationSetResponse|any) => void): Request;
    createTrafficPolicy(params: Route53.CreateTrafficPolicyRequest, callback?: (err: Route53.InvalidInput|Route53.TooManyTrafficPolicies|Route53.TrafficPolicyAlreadyExists|Route53.InvalidTrafficPolicyDocument|any, data: Route53.CreateTrafficPolicyResponse|any) => void): Request;
    createTrafficPolicyInstance(params: Route53.CreateTrafficPolicyInstanceRequest, callback?: (err: Route53.NoSuchHostedZone|Route53.InvalidInput|Route53.TooManyTrafficPolicyInstances|Route53.NoSuchTrafficPolicy|Route53.TrafficPolicyInstanceAlreadyExists|any, data: Route53.CreateTrafficPolicyInstanceResponse|any) => void): Request;
    createTrafficPolicyVersion(params: Route53.CreateTrafficPolicyVersionRequest, callback?: (err: Route53.NoSuchTrafficPolicy|Route53.InvalidInput|Route53.ConcurrentModification|Route53.InvalidTrafficPolicyDocument|any, data: Route53.CreateTrafficPolicyVersionResponse|any) => void): Request;
    deleteHealthCheck(params: Route53.DeleteHealthCheckRequest, callback?: (err: Route53.NoSuchHealthCheck|Route53.HealthCheckInUse|Route53.InvalidInput|any, data: Route53.DeleteHealthCheckResponse|any) => void): Request;
    deleteHostedZone(params: Route53.DeleteHostedZoneRequest, callback?: (err: Route53.NoSuchHostedZone|Route53.HostedZoneNotEmpty|Route53.PriorRequestNotComplete|Route53.InvalidInput|any, data: Route53.DeleteHostedZoneResponse|any) => void): Request;
    deleteReusableDelegationSet(params: Route53.DeleteReusableDelegationSetRequest, callback?: (err: Route53.NoSuchDelegationSet|Route53.DelegationSetInUse|Route53.DelegationSetNotReusable|Route53.InvalidInput|any, data: Route53.DeleteReusableDelegationSetResponse|any) => void): Request;
    deleteTrafficPolicy(params: Route53.DeleteTrafficPolicyRequest, callback?: (err: Route53.NoSuchTrafficPolicy|Route53.InvalidInput|Route53.TrafficPolicyInUse|Route53.ConcurrentModification|any, data: Route53.DeleteTrafficPolicyResponse|any) => void): Request;
    deleteTrafficPolicyInstance(params: Route53.DeleteTrafficPolicyInstanceRequest, callback?: (err: Route53.NoSuchTrafficPolicyInstance|Route53.InvalidInput|Route53.PriorRequestNotComplete|any, data: Route53.DeleteTrafficPolicyInstanceResponse|any) => void): Request;
    disassociateVPCFromHostedZone(params: Route53.DisassociateVPCFromHostedZoneRequest, callback?: (err: Route53.NoSuchHostedZone|Route53.InvalidVPCId|Route53.VPCAssociationNotFound|Route53.LastVPCAssociation|Route53.InvalidInput|any, data: Route53.DisassociateVPCFromHostedZoneResponse|any) => void): Request;
    getChange(params: Route53.GetChangeRequest, callback?: (err: Route53.NoSuchChange|Route53.InvalidInput|any, data: Route53.GetChangeResponse|any) => void): Request;
    getChangeDetails(params: Route53.GetChangeDetailsRequest, callback?: (err: Route53.NoSuchChange|Route53.InvalidInput|any, data: Route53.GetChangeDetailsResponse|any) => void): Request;
    getCheckerIpRanges(params: Route53.GetCheckerIpRangesRequest, callback?: (err: any, data: Route53.GetCheckerIpRangesResponse|any) => void): Request;
    getGeoLocation(params: Route53.GetGeoLocationRequest, callback?: (err: Route53.NoSuchGeoLocation|Route53.InvalidInput|any, data: Route53.GetGeoLocationResponse|any) => void): Request;
    getHealthCheck(params: Route53.GetHealthCheckRequest, callback?: (err: Route53.NoSuchHealthCheck|Route53.InvalidInput|Route53.IncompatibleVersion|any, data: Route53.GetHealthCheckResponse|any) => void): Request;
    getHealthCheckCount(params: Route53.GetHealthCheckCountRequest, callback?: (err: any, data: Route53.GetHealthCheckCountResponse|any) => void): Request;
    getHealthCheckLastFailureReason(params: Route53.GetHealthCheckLastFailureReasonRequest, callback?: (err: Route53.NoSuchHealthCheck|Route53.InvalidInput|any, data: Route53.GetHealthCheckLastFailureReasonResponse|any) => void): Request;
    getHealthCheckStatus(params: Route53.GetHealthCheckStatusRequest, callback?: (err: Route53.NoSuchHealthCheck|Route53.InvalidInput|any, data: Route53.GetHealthCheckStatusResponse|any) => void): Request;
    getHostedZone(params: Route53.GetHostedZoneRequest, callback?: (err: Route53.NoSuchHostedZone|Route53.InvalidInput|any, data: Route53.GetHostedZoneResponse|any) => void): Request;
    getHostedZoneCount(params: Route53.GetHostedZoneCountRequest, callback?: (err: Route53.InvalidInput|any, data: Route53.GetHostedZoneCountResponse|any) => void): Request;
    getReusableDelegationSet(params: Route53.GetReusableDelegationSetRequest, callback?: (err: Route53.NoSuchDelegationSet|Route53.DelegationSetNotReusable|Route53.InvalidInput|any, data: Route53.GetReusableDelegationSetResponse|any) => void): Request;
    getTrafficPolicy(params: Route53.GetTrafficPolicyRequest, callback?: (err: Route53.NoSuchTrafficPolicy|Route53.InvalidInput|any, data: Route53.GetTrafficPolicyResponse|any) => void): Request;
    getTrafficPolicyInstance(params: Route53.GetTrafficPolicyInstanceRequest, callback?: (err: Route53.NoSuchTrafficPolicyInstance|Route53.InvalidInput|any, data: Route53.GetTrafficPolicyInstanceResponse|any) => void): Request;
    getTrafficPolicyInstanceCount(params: Route53.GetTrafficPolicyInstanceCountRequest, callback?: (err: any, data: Route53.GetTrafficPolicyInstanceCountResponse|any) => void): Request;
    listChangeBatchesByHostedZone(params: Route53.ListChangeBatchesByHostedZoneRequest, callback?: (err: Route53.NoSuchHostedZone|Route53.InvalidInput|any, data: Route53.ListChangeBatchesByHostedZoneResponse|any) => void): Request;
    listChangeBatchesByRRSet(params: Route53.ListChangeBatchesByRRSetRequest, callback?: (err: Route53.NoSuchHostedZone|Route53.InvalidInput|any, data: Route53.ListChangeBatchesByRRSetResponse|any) => void): Request;
    listGeoLocations(params: Route53.ListGeoLocationsRequest, callback?: (err: Route53.InvalidInput|any, data: Route53.ListGeoLocationsResponse|any) => void): Request;
    listHealthChecks(params: Route53.ListHealthChecksRequest, callback?: (err: Route53.InvalidInput|Route53.IncompatibleVersion|any, data: Route53.ListHealthChecksResponse|any) => void): Request;
    listHostedZones(params: Route53.ListHostedZonesRequest, callback?: (err: Route53.InvalidInput|Route53.NoSuchDelegationSet|Route53.DelegationSetNotReusable|any, data: Route53.ListHostedZonesResponse|any) => void): Request;
    listHostedZonesByName(params: Route53.ListHostedZonesByNameRequest, callback?: (err: Route53.InvalidInput|Route53.InvalidDomainName|any, data: Route53.ListHostedZonesByNameResponse|any) => void): Request;
    listResourceRecordSets(params: Route53.ListResourceRecordSetsRequest, callback?: (err: Route53.NoSuchHostedZone|Route53.InvalidInput|any, data: Route53.ListResourceRecordSetsResponse|any) => void): Request;
    listReusableDelegationSets(params: Route53.ListReusableDelegationSetsRequest, callback?: (err: Route53.InvalidInput|any, data: Route53.ListReusableDelegationSetsResponse|any) => void): Request;
    listTagsForResource(params: Route53.ListTagsForResourceRequest, callback?: (err: Route53.InvalidInput|Route53.NoSuchHealthCheck|Route53.NoSuchHostedZone|Route53.PriorRequestNotComplete|Route53.ThrottlingException|any, data: Route53.ListTagsForResourceResponse|any) => void): Request;
    listTagsForResources(params: Route53.ListTagsForResourcesRequest, callback?: (err: Route53.InvalidInput|Route53.NoSuchHealthCheck|Route53.NoSuchHostedZone|Route53.PriorRequestNotComplete|Route53.ThrottlingException|any, data: Route53.ListTagsForResourcesResponse|any) => void): Request;
    listTrafficPolicies(params: Route53.ListTrafficPoliciesRequest, callback?: (err: Route53.InvalidInput|any, data: Route53.ListTrafficPoliciesResponse|any) => void): Request;
    listTrafficPolicyInstances(params: Route53.ListTrafficPolicyInstancesRequest, callback?: (err: Route53.InvalidInput|Route53.NoSuchTrafficPolicyInstance|any, data: Route53.ListTrafficPolicyInstancesResponse|any) => void): Request;
    listTrafficPolicyInstancesByHostedZone(params: Route53.ListTrafficPolicyInstancesByHostedZoneRequest, callback?: (err: Route53.InvalidInput|Route53.NoSuchTrafficPolicyInstance|Route53.NoSuchHostedZone|any, data: Route53.ListTrafficPolicyInstancesByHostedZoneResponse|any) => void): Request;
    listTrafficPolicyInstancesByPolicy(params: Route53.ListTrafficPolicyInstancesByPolicyRequest, callback?: (err: Route53.InvalidInput|Route53.NoSuchTrafficPolicyInstance|Route53.NoSuchTrafficPolicy|any, data: Route53.ListTrafficPolicyInstancesByPolicyResponse|any) => void): Request;
    listTrafficPolicyVersions(params: Route53.ListTrafficPolicyVersionsRequest, callback?: (err: Route53.InvalidInput|Route53.NoSuchTrafficPolicy|any, data: Route53.ListTrafficPolicyVersionsResponse|any) => void): Request;
    updateHealthCheck(params: Route53.UpdateHealthCheckRequest, callback?: (err: Route53.NoSuchHealthCheck|Route53.InvalidInput|Route53.HealthCheckVersionMismatch|any, data: Route53.UpdateHealthCheckResponse|any) => void): Request;
    updateHostedZoneComment(params: Route53.UpdateHostedZoneCommentRequest, callback?: (err: Route53.NoSuchHostedZone|Route53.InvalidInput|any, data: Route53.UpdateHostedZoneCommentResponse|any) => void): Request;
    updateTrafficPolicyComment(params: Route53.UpdateTrafficPolicyCommentRequest, callback?: (err: Route53.InvalidInput|Route53.NoSuchTrafficPolicy|Route53.ConcurrentModification|any, data: Route53.UpdateTrafficPolicyCommentResponse|any) => void): Request;
    updateTrafficPolicyInstance(params: Route53.UpdateTrafficPolicyInstanceRequest, callback?: (err: Route53.InvalidInput|Route53.NoSuchTrafficPolicy|Route53.NoSuchTrafficPolicyInstance|Route53.PriorRequestNotComplete|Route53.ConflictingTypes|any, data: Route53.UpdateTrafficPolicyInstanceResponse|any) => void): Request;

  }

  export module Route53 {
    export type AWSAccountID = string;
    export type AliasHealthEnabled = boolean;
    export type AssociateVPCComment = string;
    export type ChangeAction = string;
    export type ChangeBatchRecords = ChangeBatchRecord[];    // min: 1
    export type ChangeStatus = string;
    export type Changes = Change[];    // min: 1
    export type CheckerIpRanges = IPAddressCidr[];
    export type ChildHealthCheckList = HealthCheckId[];    // max: 256
    export type DNSName = string;    // max: 1024
    export type Date = string;    // max: 256
    export type DelegationSetNameServers = DNSName[];    // min: 1
    export type DelegationSets = DelegationSet[];
    export type DisassociateVPCComment = string;
    export type EnableSNI = boolean;
    export type ErrorMessage = string;
    export type ErrorMessages = ErrorMessage[];
    export type FailureThreshold = number;    // max: 10, min: 1
    export type FullyQualifiedDomainName = string;    // max: 255
    export type GeoLocationContinentCode = string;    // max: 2, min: 2
    export type GeoLocationContinentName = string;    // max: 32, min: 1
    export type GeoLocationCountryCode = string;    // max: 2, min: 1
    export type GeoLocationCountryName = string;    // max: 64, min: 1
    export type GeoLocationDetailsList = GeoLocationDetails[];
    export type GeoLocationSubdivisionCode = string;    // max: 3, min: 1
    export type GeoLocationSubdivisionName = string;    // max: 64, min: 1
    export type HealthCheckCount = number;
    export type HealthCheckId = string;    // max: 64
    export type HealthCheckNonce = string;    // max: 64, min: 1
    export type HealthCheckObservations = HealthCheckObservation[];
    export type HealthCheckType = string;
    export type HealthCheckVersion = number;    // min: 1
    export type HealthChecks = HealthCheck[];
    export type HealthThreshold = number;    // max: 256
    export type HostedZoneCount = number;
    export type HostedZoneRRSetCount = number;
    export type HostedZones = HostedZone[];
    export type IPAddress = string;    // pattern: &quot;^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$&quot;, max: 15
    export type IPAddressCidr = string;
    export type Inverted = boolean;
    export type IsPrivateZone = boolean;
    export type MeasureLatency = boolean;
    export type Message = string;    // max: 1024
    export type Nonce = string;    // max: 128, min: 1
    export type PageMarker = string;    // max: 64
    export type PageMaxItems = string;
    export type PageTruncated = boolean;
    export type Port = number;    // max: 65535, min: 1
    export type RData = string;    // max: 4000
    export type RRType = string;
    export type RequestInterval = number;    // max: 30, min: 10
    export type ResourceDescription = string;    // max: 256
    export type ResourceId = string;    // max: 32
    export type ResourcePath = string;    // max: 255
    export type ResourceRecordSetFailover = string;
    export type ResourceRecordSetIdentifier = string;    // max: 128, min: 1
    export type ResourceRecordSetRegion = string;    // max: 64, min: 1
    export type ResourceRecordSetWeight = number;    // max: 255
    export type ResourceRecordSets = ResourceRecordSet[];
    export type ResourceRecords = ResourceRecord[];    // min: 1
    export type ResourceTagSetList = ResourceTagSet[];
    export type ResourceURI = string;    // max: 1024
    export type SearchString = string;    // max: 255
    export type Status = string;
    export type TTL = number;    // max: 2147483647
    export type TagKey = string;    // max: 128
    export type TagKeyList = TagKey[];    // max: 10, min: 1
    export type TagList = Tag[];    // max: 10, min: 1
    export type TagResourceId = string;    // max: 64
    export type TagResourceIdList = TagResourceId[];    // max: 10, min: 1
    export type TagResourceType = string;
    export type TagValue = string;    // max: 256
    export type TimeStamp = number;
    export type TrafficPolicies = TrafficPolicy[];
    export type TrafficPolicyComment = string;    // max: 1024
    export type TrafficPolicyDocument = string;    // max: 102400
    export type TrafficPolicyId = string;    // max: 36
    export type TrafficPolicyInstanceCount = number;
    export type TrafficPolicyInstanceId = string;    // max: 36
    export type TrafficPolicyInstanceState = string;
    export type TrafficPolicyInstances = TrafficPolicyInstance[];
    export type TrafficPolicyName = string;    // max: 512
    export type TrafficPolicySummaries = TrafficPolicySummary[];
    export type TrafficPolicyVersion = number;    // max: 1000, min: 1
    export type TrafficPolicyVersionMarker = string;    // max: 4
    export type VPCId = string;    // max: 1024
    export type VPCRegion = string;    // max: 64, min: 1
    export type VPCs = VPC[];    // min: 1

    export interface AliasTarget {
        HostedZoneId: ResourceId;
        DNSName: DNSName;
        EvaluateTargetHealth: AliasHealthEnabled;
    }
    export interface AssociateVPCWithHostedZoneRequest {
        HostedZoneId: ResourceId;
        VPC: VPC;
        Comment?: AssociateVPCComment;
    }
    export interface AssociateVPCWithHostedZoneResponse {
        ChangeInfo: ChangeInfo;
    }
    export interface Change {
        Action: ChangeAction;
        ResourceRecordSet: ResourceRecordSet;
    }
    export interface ChangeBatch {
        Comment?: ResourceDescription;
        Changes: Changes;
    }
    export interface ChangeBatchRecord {
        Id: ResourceId;
        SubmittedAt?: TimeStamp;
        Status: ChangeStatus;
        Comment?: ResourceDescription;
        Submitter?: AWSAccountID;
        Changes?: Changes;
    }
    export interface ChangeInfo {
        Id: ResourceId;
        Status: ChangeStatus;
        SubmittedAt: TimeStamp;
        Comment?: ResourceDescription;
    }
    export interface ChangeResourceRecordSetsRequest {
        HostedZoneId: ResourceId;
        ChangeBatch: ChangeBatch;
    }
    export interface ChangeResourceRecordSetsResponse {
        ChangeInfo: ChangeInfo;
    }
    export interface ChangeTagsForResourceRequest {
        ResourceType: TagResourceType;
        ResourceId: TagResourceId;
        AddTags?: TagList;
        RemoveTagKeys?: TagKeyList;
    }
    export interface ChangeTagsForResourceResponse {
    }
    export interface ConcurrentModification {
        message?: ErrorMessage;
    }
    export interface ConflictingDomainExists {
        message?: ErrorMessage;
    }
    export interface ConflictingTypes {
        message?: ErrorMessage;
    }
    export interface CreateHealthCheckRequest {
        CallerReference: HealthCheckNonce;
        HealthCheckConfig: HealthCheckConfig;
    }
    export interface CreateHealthCheckResponse {
        HealthCheck: HealthCheck;
        Location: ResourceURI;
    }
    export interface CreateHostedZoneRequest {
        Name: DNSName;
        VPC?: VPC;
        CallerReference: Nonce;
        HostedZoneConfig?: HostedZoneConfig;
        DelegationSetId?: ResourceId;
    }
    export interface CreateHostedZoneResponse {
        HostedZone: HostedZone;
        ChangeInfo: ChangeInfo;
        DelegationSet: DelegationSet;
        VPC?: VPC;
        Location: ResourceURI;
    }
    export interface CreateReusableDelegationSetRequest {
        CallerReference: Nonce;
        HostedZoneId?: ResourceId;
    }
    export interface CreateReusableDelegationSetResponse {
        DelegationSet: DelegationSet;
        Location: ResourceURI;
    }
    export interface CreateTrafficPolicyInstanceRequest {
        HostedZoneId: ResourceId;
        Name: DNSName;
        TTL: TTL;
        TrafficPolicyId: TrafficPolicyId;
        TrafficPolicyVersion: TrafficPolicyVersion;
    }
    export interface CreateTrafficPolicyInstanceResponse {
        TrafficPolicyInstance: TrafficPolicyInstance;
        Location: ResourceURI;
    }
    export interface CreateTrafficPolicyRequest {
        Name: TrafficPolicyName;
        Document: TrafficPolicyDocument;
        Comment?: TrafficPolicyComment;
    }
    export interface CreateTrafficPolicyResponse {
        TrafficPolicy: TrafficPolicy;
        Location: ResourceURI;
    }
    export interface CreateTrafficPolicyVersionRequest {
        Id: TrafficPolicyId;
        Document: TrafficPolicyDocument;
        Comment?: TrafficPolicyComment;
    }
    export interface CreateTrafficPolicyVersionResponse {
        TrafficPolicy: TrafficPolicy;
        Location: ResourceURI;
    }
    export interface DelegationSet {
        Id?: ResourceId;
        CallerReference?: Nonce;
        NameServers: DelegationSetNameServers;
    }
    export interface DelegationSetAlreadyCreated {
        message?: ErrorMessage;
    }
    export interface DelegationSetAlreadyReusable {
        message?: ErrorMessage;
    }
    export interface DelegationSetInUse {
        message?: ErrorMessage;
    }
    export interface DelegationSetNotAvailable {
        message?: ErrorMessage;
    }
    export interface DelegationSetNotReusable {
        message?: ErrorMessage;
    }
    export interface DeleteHealthCheckRequest {
        HealthCheckId: HealthCheckId;
    }
    export interface DeleteHealthCheckResponse {
    }
    export interface DeleteHostedZoneRequest {
        Id: ResourceId;
    }
    export interface DeleteHostedZoneResponse {
        ChangeInfo: ChangeInfo;
    }
    export interface DeleteReusableDelegationSetRequest {
        Id: ResourceId;
    }
    export interface DeleteReusableDelegationSetResponse {
    }
    export interface DeleteTrafficPolicyInstanceRequest {
        Id: TrafficPolicyInstanceId;
    }
    export interface DeleteTrafficPolicyInstanceResponse {
    }
    export interface DeleteTrafficPolicyRequest {
        Id: TrafficPolicyId;
        Version: TrafficPolicyVersion;
    }
    export interface DeleteTrafficPolicyResponse {
    }
    export interface DisassociateVPCFromHostedZoneRequest {
        HostedZoneId: ResourceId;
        VPC: VPC;
        Comment?: DisassociateVPCComment;
    }
    export interface DisassociateVPCFromHostedZoneResponse {
        ChangeInfo: ChangeInfo;
    }
    export interface GeoLocation {
        ContinentCode?: GeoLocationContinentCode;
        CountryCode?: GeoLocationCountryCode;
        SubdivisionCode?: GeoLocationSubdivisionCode;
    }
    export interface GeoLocationDetails {
        ContinentCode?: GeoLocationContinentCode;
        ContinentName?: GeoLocationContinentName;
        CountryCode?: GeoLocationCountryCode;
        CountryName?: GeoLocationCountryName;
        SubdivisionCode?: GeoLocationSubdivisionCode;
        SubdivisionName?: GeoLocationSubdivisionName;
    }
    export interface GetChangeDetailsRequest {
        Id: ResourceId;
    }
    export interface GetChangeDetailsResponse {
        ChangeBatchRecord: ChangeBatchRecord;
    }
    export interface GetChangeRequest {
        Id: ResourceId;
    }
    export interface GetChangeResponse {
        ChangeInfo: ChangeInfo;
    }
    export interface GetCheckerIpRangesRequest {
    }
    export interface GetCheckerIpRangesResponse {
        CheckerIpRanges: CheckerIpRanges;
    }
    export interface GetGeoLocationRequest {
        ContinentCode?: GeoLocationContinentCode;
        CountryCode?: GeoLocationCountryCode;
        SubdivisionCode?: GeoLocationSubdivisionCode;
    }
    export interface GetGeoLocationResponse {
        GeoLocationDetails: GeoLocationDetails;
    }
    export interface GetHealthCheckCountRequest {
    }
    export interface GetHealthCheckCountResponse {
        HealthCheckCount: HealthCheckCount;
    }
    export interface GetHealthCheckLastFailureReasonRequest {
        HealthCheckId: HealthCheckId;
    }
    export interface GetHealthCheckLastFailureReasonResponse {
        HealthCheckObservations: HealthCheckObservations;
    }
    export interface GetHealthCheckRequest {
        HealthCheckId: HealthCheckId;
    }
    export interface GetHealthCheckResponse {
        HealthCheck: HealthCheck;
    }
    export interface GetHealthCheckStatusRequest {
        HealthCheckId: HealthCheckId;
    }
    export interface GetHealthCheckStatusResponse {
        HealthCheckObservations: HealthCheckObservations;
    }
    export interface GetHostedZoneCountRequest {
    }
    export interface GetHostedZoneCountResponse {
        HostedZoneCount: HostedZoneCount;
    }
    export interface GetHostedZoneRequest {
        Id: ResourceId;
    }
    export interface GetHostedZoneResponse {
        HostedZone: HostedZone;
        DelegationSet?: DelegationSet;
        VPCs?: VPCs;
    }
    export interface GetReusableDelegationSetRequest {
        Id: ResourceId;
    }
    export interface GetReusableDelegationSetResponse {
        DelegationSet: DelegationSet;
    }
    export interface GetTrafficPolicyInstanceCountRequest {
    }
    export interface GetTrafficPolicyInstanceCountResponse {
        TrafficPolicyInstanceCount: TrafficPolicyInstanceCount;
    }
    export interface GetTrafficPolicyInstanceRequest {
        Id: TrafficPolicyInstanceId;
    }
    export interface GetTrafficPolicyInstanceResponse {
        TrafficPolicyInstance: TrafficPolicyInstance;
    }
    export interface GetTrafficPolicyRequest {
        Id: TrafficPolicyId;
        Version: TrafficPolicyVersion;
    }
    export interface GetTrafficPolicyResponse {
        TrafficPolicy: TrafficPolicy;
    }
    export interface HealthCheck {
        Id: HealthCheckId;
        CallerReference: HealthCheckNonce;
        HealthCheckConfig: HealthCheckConfig;
        HealthCheckVersion: HealthCheckVersion;
    }
    export interface HealthCheckAlreadyExists {
        message?: ErrorMessage;
    }
    export interface HealthCheckConfig {
        IPAddress?: IPAddress;
        Port?: Port;
        Type: HealthCheckType;
        ResourcePath?: ResourcePath;
        FullyQualifiedDomainName?: FullyQualifiedDomainName;
        SearchString?: SearchString;
        RequestInterval?: RequestInterval;
        FailureThreshold?: FailureThreshold;
        MeasureLatency?: MeasureLatency;
        Inverted?: Inverted;
        HealthThreshold?: HealthThreshold;
        ChildHealthChecks?: ChildHealthCheckList;
        EnableSNI?: EnableSNI;
    }
    export interface HealthCheckInUse {
        message?: ErrorMessage;
    }
    export interface HealthCheckObservation {
        IPAddress?: IPAddress;
        StatusReport?: StatusReport;
    }
    export interface HealthCheckVersionMismatch {
        message?: ErrorMessage;
    }
    export interface HostedZone {
        Id: ResourceId;
        Name: DNSName;
        CallerReference: Nonce;
        Config?: HostedZoneConfig;
        ResourceRecordSetCount?: HostedZoneRRSetCount;
    }
    export interface HostedZoneAlreadyExists {
        message?: ErrorMessage;
    }
    export interface HostedZoneConfig {
        Comment?: ResourceDescription;
        PrivateZone?: IsPrivateZone;
    }
    export interface HostedZoneNotEmpty {
        message?: ErrorMessage;
    }
    export interface HostedZoneNotFound {
        message?: ErrorMessage;
    }
    export interface IncompatibleVersion {
        message?: ErrorMessage;
    }
    export interface InvalidArgument {
        message?: ErrorMessage;
    }
    export interface InvalidChangeBatch {
        messages?: ErrorMessages;
    }
    export interface InvalidDomainName {
        message?: ErrorMessage;
    }
    export interface InvalidInput {
        message?: ErrorMessage;
    }
    export interface InvalidTrafficPolicyDocument {
        message?: ErrorMessage;
    }
    export interface InvalidVPCId {
        message?: ErrorMessage;
    }
    export interface LastVPCAssociation {
        message?: ErrorMessage;
    }
    export interface LimitsExceeded {
        message?: ErrorMessage;
    }
    export interface ListChangeBatchesByHostedZoneRequest {
        HostedZoneId: ResourceId;
        StartDate: Date;
        EndDate: Date;
        MaxItems?: PageMaxItems;
        Marker?: PageMarker;
    }
    export interface ListChangeBatchesByHostedZoneResponse {
        MaxItems: PageMaxItems;
        Marker: PageMarker;
        IsTruncated?: PageTruncated;
        ChangeBatchRecords: ChangeBatchRecords;
        NextMarker?: PageMarker;
    }
    export interface ListChangeBatchesByRRSetRequest {
        HostedZoneId: ResourceId;
        Name: DNSName;
        Type: RRType;
        SetIdentifier?: ResourceRecordSetIdentifier;
        StartDate: Date;
        EndDate: Date;
        MaxItems?: PageMaxItems;
        Marker?: PageMarker;
    }
    export interface ListChangeBatchesByRRSetResponse {
        MaxItems: PageMaxItems;
        Marker: PageMarker;
        IsTruncated?: PageTruncated;
        ChangeBatchRecords: ChangeBatchRecords;
        NextMarker?: PageMarker;
    }
    export interface ListGeoLocationsRequest {
        StartContinentCode?: GeoLocationContinentCode;
        StartCountryCode?: GeoLocationCountryCode;
        StartSubdivisionCode?: GeoLocationSubdivisionCode;
        MaxItems?: PageMaxItems;
    }
    export interface ListGeoLocationsResponse {
        GeoLocationDetailsList: GeoLocationDetailsList;
        IsTruncated: PageTruncated;
        NextContinentCode?: GeoLocationContinentCode;
        NextCountryCode?: GeoLocationCountryCode;
        NextSubdivisionCode?: GeoLocationSubdivisionCode;
        MaxItems: PageMaxItems;
    }
    export interface ListHealthChecksRequest {
        Marker?: PageMarker;
        MaxItems?: PageMaxItems;
    }
    export interface ListHealthChecksResponse {
        HealthChecks: HealthChecks;
        Marker: PageMarker;
        IsTruncated: PageTruncated;
        NextMarker?: PageMarker;
        MaxItems: PageMaxItems;
    }
    export interface ListHostedZonesByNameRequest {
        DNSName?: DNSName;
        HostedZoneId?: ResourceId;
        MaxItems?: PageMaxItems;
    }
    export interface ListHostedZonesByNameResponse {
        HostedZones: HostedZones;
        DNSName?: DNSName;
        HostedZoneId?: ResourceId;
        IsTruncated: PageTruncated;
        NextDNSName?: DNSName;
        NextHostedZoneId?: ResourceId;
        MaxItems: PageMaxItems;
    }
    export interface ListHostedZonesRequest {
        Marker?: PageMarker;
        MaxItems?: PageMaxItems;
        DelegationSetId?: ResourceId;
    }
    export interface ListHostedZonesResponse {
        HostedZones: HostedZones;
        Marker: PageMarker;
        IsTruncated: PageTruncated;
        NextMarker?: PageMarker;
        MaxItems: PageMaxItems;
    }
    export interface ListResourceRecordSetsRequest {
        HostedZoneId: ResourceId;
        StartRecordName?: DNSName;
        StartRecordType?: RRType;
        StartRecordIdentifier?: ResourceRecordSetIdentifier;
        MaxItems?: PageMaxItems;
    }
    export interface ListResourceRecordSetsResponse {
        ResourceRecordSets: ResourceRecordSets;
        IsTruncated: PageTruncated;
        NextRecordName?: DNSName;
        NextRecordType?: RRType;
        NextRecordIdentifier?: ResourceRecordSetIdentifier;
        MaxItems: PageMaxItems;
    }
    export interface ListReusableDelegationSetsRequest {
        Marker?: PageMarker;
        MaxItems?: PageMaxItems;
    }
    export interface ListReusableDelegationSetsResponse {
        DelegationSets: DelegationSets;
        Marker: PageMarker;
        IsTruncated: PageTruncated;
        NextMarker?: PageMarker;
        MaxItems: PageMaxItems;
    }
    export interface ListTagsForResourceRequest {
        ResourceType: TagResourceType;
        ResourceId: TagResourceId;
    }
    export interface ListTagsForResourceResponse {
        ResourceTagSet: ResourceTagSet;
    }
    export interface ListTagsForResourcesRequest {
        ResourceType: TagResourceType;
        ResourceIds: TagResourceIdList;
    }
    export interface ListTagsForResourcesResponse {
        ResourceTagSets: ResourceTagSetList;
    }
    export interface ListTrafficPoliciesRequest {
        TrafficPolicyIdMarker?: TrafficPolicyId;
        MaxItems?: PageMaxItems;
    }
    export interface ListTrafficPoliciesResponse {
        TrafficPolicySummaries: TrafficPolicySummaries;
        IsTruncated: PageTruncated;
        TrafficPolicyIdMarker: TrafficPolicyId;
        MaxItems: PageMaxItems;
    }
    export interface ListTrafficPolicyInstancesByHostedZoneRequest {
        HostedZoneId: ResourceId;
        TrafficPolicyInstanceNameMarker?: DNSName;
        TrafficPolicyInstanceTypeMarker?: RRType;
        MaxItems?: PageMaxItems;
    }
    export interface ListTrafficPolicyInstancesByHostedZoneResponse {
        TrafficPolicyInstances: TrafficPolicyInstances;
        TrafficPolicyInstanceNameMarker?: DNSName;
        TrafficPolicyInstanceTypeMarker?: RRType;
        IsTruncated: PageTruncated;
        MaxItems: PageMaxItems;
    }
    export interface ListTrafficPolicyInstancesByPolicyRequest {
        TrafficPolicyId: TrafficPolicyId;
        TrafficPolicyVersion: TrafficPolicyVersion;
        HostedZoneIdMarker?: ResourceId;
        TrafficPolicyInstanceNameMarker?: DNSName;
        TrafficPolicyInstanceTypeMarker?: RRType;
        MaxItems?: PageMaxItems;
    }
    export interface ListTrafficPolicyInstancesByPolicyResponse {
        TrafficPolicyInstances: TrafficPolicyInstances;
        HostedZoneIdMarker?: ResourceId;
        TrafficPolicyInstanceNameMarker?: DNSName;
        TrafficPolicyInstanceTypeMarker?: RRType;
        IsTruncated: PageTruncated;
        MaxItems: PageMaxItems;
    }
    export interface ListTrafficPolicyInstancesRequest {
        HostedZoneIdMarker?: ResourceId;
        TrafficPolicyInstanceNameMarker?: DNSName;
        TrafficPolicyInstanceTypeMarker?: RRType;
        MaxItems?: PageMaxItems;
    }
    export interface ListTrafficPolicyInstancesResponse {
        TrafficPolicyInstances: TrafficPolicyInstances;
        HostedZoneIdMarker?: ResourceId;
        TrafficPolicyInstanceNameMarker?: DNSName;
        TrafficPolicyInstanceTypeMarker?: RRType;
        IsTruncated: PageTruncated;
        MaxItems: PageMaxItems;
    }
    export interface ListTrafficPolicyVersionsRequest {
        Id: TrafficPolicyId;
        TrafficPolicyVersionMarker?: TrafficPolicyVersionMarker;
        MaxItems?: PageMaxItems;
    }
    export interface ListTrafficPolicyVersionsResponse {
        TrafficPolicies: TrafficPolicies;
        IsTruncated: PageTruncated;
        TrafficPolicyVersionMarker: TrafficPolicyVersionMarker;
        MaxItems: PageMaxItems;
    }
    export interface NoSuchChange {
        message?: ErrorMessage;
    }
    export interface NoSuchDelegationSet {
        message?: ErrorMessage;
    }
    export interface NoSuchGeoLocation {
        message?: ErrorMessage;
    }
    export interface NoSuchHealthCheck {
        message?: ErrorMessage;
    }
    export interface NoSuchHostedZone {
        message?: ErrorMessage;
    }
    export interface NoSuchTrafficPolicy {
        message?: ErrorMessage;
    }
    export interface NoSuchTrafficPolicyInstance {
        message?: ErrorMessage;
    }
    export interface PriorRequestNotComplete {
        message?: ErrorMessage;
    }
    export interface PublicZoneVPCAssociation {
        message?: ErrorMessage;
    }
    export interface ResourceRecord {
        Value: RData;
    }
    export interface ResourceRecordSet {
        Name: DNSName;
        Type: RRType;
        SetIdentifier?: ResourceRecordSetIdentifier;
        Weight?: ResourceRecordSetWeight;
        Region?: ResourceRecordSetRegion;
        GeoLocation?: GeoLocation;
        Failover?: ResourceRecordSetFailover;
        TTL?: TTL;
        ResourceRecords?: ResourceRecords;
        AliasTarget?: AliasTarget;
        HealthCheckId?: HealthCheckId;
        TrafficPolicyInstanceId?: TrafficPolicyInstanceId;
    }
    export interface ResourceTagSet {
        ResourceType?: TagResourceType;
        ResourceId?: TagResourceId;
        Tags?: TagList;
    }
    export interface StatusReport {
        Status?: Status;
        CheckedTime?: TimeStamp;
    }
    export interface Tag {
        Key?: TagKey;
        Value?: TagValue;
    }
    export interface ThrottlingException {
        message?: ErrorMessage;
    }
    export interface TooManyHealthChecks {
        message?: ErrorMessage;
    }
    export interface TooManyHostedZones {
        message?: ErrorMessage;
    }
    export interface TooManyTrafficPolicies {
        message?: ErrorMessage;
    }
    export interface TooManyTrafficPolicyInstances {
        message?: ErrorMessage;
    }
    export interface TrafficPolicy {
        Id: TrafficPolicyId;
        Version: TrafficPolicyVersion;
        Name: TrafficPolicyName;
        Type: RRType;
        Document: TrafficPolicyDocument;
        Comment?: TrafficPolicyComment;
    }
    export interface TrafficPolicyAlreadyExists {
        message?: ErrorMessage;
    }
    export interface TrafficPolicyInUse {
        message?: ErrorMessage;
    }
    export interface TrafficPolicyInstance {
        Id: TrafficPolicyInstanceId;
        HostedZoneId: ResourceId;
        Name: DNSName;
        TTL: TTL;
        State: TrafficPolicyInstanceState;
        Message: Message;
        TrafficPolicyId: TrafficPolicyId;
        TrafficPolicyVersion: TrafficPolicyVersion;
        TrafficPolicyType: RRType;
    }
    export interface TrafficPolicyInstanceAlreadyExists {
        message?: ErrorMessage;
    }
    export interface TrafficPolicySummary {
        Id: TrafficPolicyId;
        Name: TrafficPolicyName;
        Type: RRType;
        LatestVersion: TrafficPolicyVersion;
        TrafficPolicyCount: TrafficPolicyVersion;
    }
    export interface UpdateHealthCheckRequest {
        HealthCheckId: HealthCheckId;
        HealthCheckVersion?: HealthCheckVersion;
        IPAddress?: IPAddress;
        Port?: Port;
        ResourcePath?: ResourcePath;
        FullyQualifiedDomainName?: FullyQualifiedDomainName;
        SearchString?: SearchString;
        FailureThreshold?: FailureThreshold;
        Inverted?: Inverted;
        HealthThreshold?: HealthThreshold;
        ChildHealthChecks?: ChildHealthCheckList;
        EnableSNI?: EnableSNI;
    }
    export interface UpdateHealthCheckResponse {
        HealthCheck: HealthCheck;
    }
    export interface UpdateHostedZoneCommentRequest {
        Id: ResourceId;
        Comment?: ResourceDescription;
    }
    export interface UpdateHostedZoneCommentResponse {
        HostedZone: HostedZone;
    }
    export interface UpdateTrafficPolicyCommentRequest {
        Id: TrafficPolicyId;
        Version: TrafficPolicyVersion;
        Comment: TrafficPolicyComment;
    }
    export interface UpdateTrafficPolicyCommentResponse {
        TrafficPolicy: TrafficPolicy;
    }
    export interface UpdateTrafficPolicyInstanceRequest {
        Id: TrafficPolicyInstanceId;
        TTL: TTL;
        TrafficPolicyId: TrafficPolicyId;
        TrafficPolicyVersion: TrafficPolicyVersion;
    }
    export interface UpdateTrafficPolicyInstanceResponse {
        TrafficPolicyInstance: TrafficPolicyInstance;
    }
    export interface VPC {
        VPCRegion?: VPCRegion;
        VPCId?: VPCId;
    }
    export interface VPCAssociationNotFound {
        message?: ErrorMessage;
    }
  }

  /*
   * apiVersion: 2014-05-15
   * endpointPrefix: route53domains
   * serviceAbbreviation: 
   * signatureVersion: v4
   * protocol: json
   */
  export class Route53Domains extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    checkDomainAvailability(params: Route53Domains.CheckDomainAvailabilityRequest, callback?: (err: Route53Domains.InvalidInput|Route53Domains.UnsupportedTLD|any, data: Route53Domains.CheckDomainAvailabilityResponse|any) => void): Request;
    deleteTagsForDomain(params: Route53Domains.DeleteTagsForDomainRequest, callback?: (err: Route53Domains.InvalidInput|Route53Domains.OperationLimitExceeded|Route53Domains.UnsupportedTLD|any, data: Route53Domains.DeleteTagsForDomainResponse|any) => void): Request;
    disableDomainAutoRenew(params: Route53Domains.DisableDomainAutoRenewRequest, callback?: (err: Route53Domains.InvalidInput|Route53Domains.UnsupportedTLD|any, data: Route53Domains.DisableDomainAutoRenewResponse|any) => void): Request;
    disableDomainTransferLock(params: Route53Domains.DisableDomainTransferLockRequest, callback?: (err: Route53Domains.InvalidInput|Route53Domains.DuplicateRequest|Route53Domains.TLDRulesViolation|Route53Domains.OperationLimitExceeded|Route53Domains.UnsupportedTLD|any, data: Route53Domains.DisableDomainTransferLockResponse|any) => void): Request;
    enableDomainAutoRenew(params: Route53Domains.EnableDomainAutoRenewRequest, callback?: (err: Route53Domains.InvalidInput|Route53Domains.UnsupportedTLD|any, data: Route53Domains.EnableDomainAutoRenewResponse|any) => void): Request;
    enableDomainTransferLock(params: Route53Domains.EnableDomainTransferLockRequest, callback?: (err: Route53Domains.InvalidInput|Route53Domains.DuplicateRequest|Route53Domains.TLDRulesViolation|Route53Domains.OperationLimitExceeded|Route53Domains.UnsupportedTLD|any, data: Route53Domains.EnableDomainTransferLockResponse|any) => void): Request;
    getDomainDetail(params: Route53Domains.GetDomainDetailRequest, callback?: (err: Route53Domains.InvalidInput|Route53Domains.UnsupportedTLD|any, data: Route53Domains.GetDomainDetailResponse|any) => void): Request;
    getOperationDetail(params: Route53Domains.GetOperationDetailRequest, callback?: (err: Route53Domains.InvalidInput|any, data: Route53Domains.GetOperationDetailResponse|any) => void): Request;
    listDomains(params: Route53Domains.ListDomainsRequest, callback?: (err: Route53Domains.InvalidInput|any, data: Route53Domains.ListDomainsResponse|any) => void): Request;
    listOperations(params: Route53Domains.ListOperationsRequest, callback?: (err: Route53Domains.InvalidInput|any, data: Route53Domains.ListOperationsResponse|any) => void): Request;
    listTagsForDomain(params: Route53Domains.ListTagsForDomainRequest, callback?: (err: Route53Domains.InvalidInput|Route53Domains.OperationLimitExceeded|Route53Domains.UnsupportedTLD|any, data: Route53Domains.ListTagsForDomainResponse|any) => void): Request;
    registerDomain(params: Route53Domains.RegisterDomainRequest, callback?: (err: Route53Domains.InvalidInput|Route53Domains.UnsupportedTLD|Route53Domains.DuplicateRequest|Route53Domains.TLDRulesViolation|Route53Domains.DomainLimitExceeded|Route53Domains.OperationLimitExceeded|any, data: Route53Domains.RegisterDomainResponse|any) => void): Request;
    retrieveDomainAuthCode(params: Route53Domains.RetrieveDomainAuthCodeRequest, callback?: (err: Route53Domains.InvalidInput|Route53Domains.UnsupportedTLD|any, data: Route53Domains.RetrieveDomainAuthCodeResponse|any) => void): Request;
    transferDomain(params: Route53Domains.TransferDomainRequest, callback?: (err: Route53Domains.InvalidInput|Route53Domains.UnsupportedTLD|Route53Domains.DuplicateRequest|Route53Domains.TLDRulesViolation|Route53Domains.DomainLimitExceeded|Route53Domains.OperationLimitExceeded|any, data: Route53Domains.TransferDomainResponse|any) => void): Request;
    updateDomainContact(params: Route53Domains.UpdateDomainContactRequest, callback?: (err: Route53Domains.InvalidInput|Route53Domains.DuplicateRequest|Route53Domains.TLDRulesViolation|Route53Domains.OperationLimitExceeded|Route53Domains.UnsupportedTLD|any, data: Route53Domains.UpdateDomainContactResponse|any) => void): Request;
    updateDomainContactPrivacy(params: Route53Domains.UpdateDomainContactPrivacyRequest, callback?: (err: Route53Domains.InvalidInput|Route53Domains.DuplicateRequest|Route53Domains.TLDRulesViolation|Route53Domains.OperationLimitExceeded|Route53Domains.UnsupportedTLD|any, data: Route53Domains.UpdateDomainContactPrivacyResponse|any) => void): Request;
    updateDomainNameservers(params: Route53Domains.UpdateDomainNameserversRequest, callback?: (err: Route53Domains.InvalidInput|Route53Domains.DuplicateRequest|Route53Domains.TLDRulesViolation|Route53Domains.OperationLimitExceeded|Route53Domains.UnsupportedTLD|any, data: Route53Domains.UpdateDomainNameserversResponse|any) => void): Request;
    updateTagsForDomain(params: Route53Domains.UpdateTagsForDomainRequest, callback?: (err: Route53Domains.InvalidInput|Route53Domains.OperationLimitExceeded|Route53Domains.UnsupportedTLD|any, data: Route53Domains.UpdateTagsForDomainResponse|any) => void): Request;

  }

  export module Route53Domains {
    export type AddressLine = string;    // max: 255
    export type Boolean = boolean;
    export type City = string;    // max: 255
    export type ContactName = string;    // max: 255
    export type ContactNumber = string;    // max: 30
    export type ContactType = string;
    export type CountryCode = string;
    export type DNSSec = string;
    export type DomainAuthCode = string;    // max: 1024
    export type DomainAvailability = string;
    export type DomainName = string;    // pattern: &quot;[a-zA-Z0-9_\-.]*&quot;, max: 255
    export type DomainStatus = string;
    export type DomainStatusList = DomainStatus[];
    export type DomainSummaryList = DomainSummary[];
    export type DurationInYears = number;    // max: 10, min: 1
    export type Email = string;    // max: 254
    export type ErrorMessage = string;
    export type ExtraParamList = ExtraParam[];
    export type ExtraParamName = string;
    export type ExtraParamValue = string;    // max: 2048
    export type FIAuthKey = string;
    export type GlueIp = string;    // max: 45
    export type GlueIpList = GlueIp[];
    export type HostName = string;    // pattern: &quot;[a-zA-Z0-9_\-.]*&quot;, max: 255
    export type LangCode = string;    // max: 3
    export type NameserverList = Nameserver[];
    export type OperationId = string;    // max: 255
    export type OperationStatus = string;
    export type OperationSummaryList = OperationSummary[];
    export type OperationType = string;
    export type PageMarker = string;    // max: 4096
    export type PageMaxItems = number;    // max: 100
    export type RegistrarName = string;
    export type RegistrarUrl = string;
    export type RegistrarWhoIsServer = string;
    export type RegistryDomainId = string;
    export type Reseller = string;
    export type State = string;    // max: 255
    export type TagKey = string;
    export type TagKeyList = TagKey[];
    export type TagList = Tag[];
    export type TagValue = string;
    export type Timestamp = number;
    export type ZipCode = string;    // max: 255

    export interface CheckDomainAvailabilityRequest {
        DomainName: DomainName;
        IdnLangCode?: LangCode;
    }
    export interface CheckDomainAvailabilityResponse {
        Availability: DomainAvailability;
    }
    export interface ContactDetail {
        FirstName?: ContactName;
        LastName?: ContactName;
        ContactType?: ContactType;
        OrganizationName?: ContactName;
        AddressLine1?: AddressLine;
        AddressLine2?: AddressLine;
        City?: City;
        State?: State;
        CountryCode?: CountryCode;
        ZipCode?: ZipCode;
        PhoneNumber?: ContactNumber;
        Email?: Email;
        Fax?: ContactNumber;
        ExtraParams?: ExtraParamList;
    }
    export interface DeleteTagsForDomainRequest {
        DomainName: DomainName;
        TagsToDelete: TagKeyList;
    }
    export interface DeleteTagsForDomainResponse {
    }
    export interface DisableDomainAutoRenewRequest {
        DomainName: DomainName;
    }
    export interface DisableDomainAutoRenewResponse {
    }
    export interface DisableDomainTransferLockRequest {
        DomainName: DomainName;
    }
    export interface DisableDomainTransferLockResponse {
        OperationId: OperationId;
    }
    export interface DomainLimitExceeded {
        message?: ErrorMessage;
    }
    export interface DomainSummary {
        DomainName: DomainName;
        AutoRenew?: Boolean;
        TransferLock?: Boolean;
        Expiry?: Timestamp;
    }
    export interface DuplicateRequest {
        message?: ErrorMessage;
    }
    export interface EnableDomainAutoRenewRequest {
        DomainName: DomainName;
    }
    export interface EnableDomainAutoRenewResponse {
    }
    export interface EnableDomainTransferLockRequest {
        DomainName: DomainName;
    }
    export interface EnableDomainTransferLockResponse {
        OperationId: OperationId;
    }
    export interface ExtraParam {
        Name: ExtraParamName;
        Value: ExtraParamValue;
    }
    export interface GetDomainDetailRequest {
        DomainName: DomainName;
    }
    export interface GetDomainDetailResponse {
        DomainName: DomainName;
        Nameservers: NameserverList;
        AutoRenew?: Boolean;
        AdminContact: ContactDetail;
        RegistrantContact: ContactDetail;
        TechContact: ContactDetail;
        AdminPrivacy?: Boolean;
        RegistrantPrivacy?: Boolean;
        TechPrivacy?: Boolean;
        RegistrarName?: RegistrarName;
        WhoIsServer?: RegistrarWhoIsServer;
        RegistrarUrl?: RegistrarUrl;
        AbuseContactEmail?: Email;
        AbuseContactPhone?: ContactNumber;
        RegistryDomainId?: RegistryDomainId;
        CreationDate?: Timestamp;
        UpdatedDate?: Timestamp;
        ExpirationDate?: Timestamp;
        Reseller?: Reseller;
        DnsSec?: DNSSec;
        StatusList?: DomainStatusList;
    }
    export interface GetOperationDetailRequest {
        OperationId: OperationId;
    }
    export interface GetOperationDetailResponse {
        OperationId?: OperationId;
        Status?: OperationStatus;
        Message?: ErrorMessage;
        DomainName?: DomainName;
        Type?: OperationType;
        SubmittedDate?: Timestamp;
    }
    export interface InvalidInput {
        message?: ErrorMessage;
    }
    export interface ListDomainsRequest {
        Marker?: PageMarker;
        MaxItems?: PageMaxItems;
    }
    export interface ListDomainsResponse {
        Domains: DomainSummaryList;
        NextPageMarker?: PageMarker;
    }
    export interface ListOperationsRequest {
        Marker?: PageMarker;
        MaxItems?: PageMaxItems;
    }
    export interface ListOperationsResponse {
        Operations: OperationSummaryList;
        NextPageMarker?: PageMarker;
    }
    export interface ListTagsForDomainRequest {
        DomainName: DomainName;
    }
    export interface ListTagsForDomainResponse {
        TagList: TagList;
    }
    export interface Nameserver {
        Name: HostName;
        GlueIps?: GlueIpList;
    }
    export interface OperationLimitExceeded {
        message?: ErrorMessage;
    }
    export interface OperationSummary {
        OperationId: OperationId;
        Status: OperationStatus;
        Type: OperationType;
        SubmittedDate: Timestamp;
    }
    export interface RegisterDomainRequest {
        DomainName: DomainName;
        IdnLangCode?: LangCode;
        DurationInYears: DurationInYears;
        AutoRenew?: Boolean;
        AdminContact: ContactDetail;
        RegistrantContact: ContactDetail;
        TechContact: ContactDetail;
        PrivacyProtectAdminContact?: Boolean;
        PrivacyProtectRegistrantContact?: Boolean;
        PrivacyProtectTechContact?: Boolean;
    }
    export interface RegisterDomainResponse {
        OperationId: OperationId;
    }
    export interface RetrieveDomainAuthCodeRequest {
        DomainName: DomainName;
    }
    export interface RetrieveDomainAuthCodeResponse {
        AuthCode: DomainAuthCode;
    }
    export interface TLDRulesViolation {
        message?: ErrorMessage;
    }
    export interface Tag {
        Key?: TagKey;
        Value?: TagValue;
    }
    export interface TransferDomainRequest {
        DomainName: DomainName;
        IdnLangCode?: LangCode;
        DurationInYears: DurationInYears;
        Nameservers?: NameserverList;
        AuthCode?: DomainAuthCode;
        AutoRenew?: Boolean;
        AdminContact: ContactDetail;
        RegistrantContact: ContactDetail;
        TechContact: ContactDetail;
        PrivacyProtectAdminContact?: Boolean;
        PrivacyProtectRegistrantContact?: Boolean;
        PrivacyProtectTechContact?: Boolean;
    }
    export interface TransferDomainResponse {
        OperationId: OperationId;
    }
    export interface UnsupportedTLD {
        message?: ErrorMessage;
    }
    export interface UpdateDomainContactPrivacyRequest {
        DomainName: DomainName;
        AdminPrivacy?: Boolean;
        RegistrantPrivacy?: Boolean;
        TechPrivacy?: Boolean;
    }
    export interface UpdateDomainContactPrivacyResponse {
        OperationId: OperationId;
    }
    export interface UpdateDomainContactRequest {
        DomainName: DomainName;
        AdminContact?: ContactDetail;
        RegistrantContact?: ContactDetail;
        TechContact?: ContactDetail;
    }
    export interface UpdateDomainContactResponse {
        OperationId: OperationId;
    }
    export interface UpdateDomainNameserversRequest {
        DomainName: DomainName;
        FIAuthKey?: FIAuthKey;
        Nameservers: NameserverList;
    }
    export interface UpdateDomainNameserversResponse {
        OperationId: OperationId;
    }
    export interface UpdateTagsForDomainRequest {
        DomainName: DomainName;
        TagsToUpdate?: TagList;
    }
    export interface UpdateTagsForDomainResponse {
    }
  }

  /*
   * apiVersion: 2006-03-01
   * endpointPrefix: s3
   * serviceAbbreviation: Amazon S3
   * signatureVersion: s3
   * protocol: rest-xml
   */
  export class S3 extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    abortMultipartUpload(params: S3.AbortMultipartUploadRequest, callback?: (err: S3.NoSuchUpload|any, data: S3.AbortMultipartUploadOutput|any) => void): Request;
    completeMultipartUpload(params: S3.CompleteMultipartUploadRequest, callback?: (err: any, data: S3.CompleteMultipartUploadOutput|any) => void): Request;
    copyObject(params: S3.CopyObjectRequest, callback?: (err: S3.ObjectNotInActiveTierError|any, data: S3.CopyObjectOutput|any) => void): Request;
    createBucket(params: S3.CreateBucketRequest, callback?: (err: S3.BucketAlreadyExists|S3.BucketAlreadyOwnedByYou|any, data: S3.CreateBucketOutput|any) => void): Request;
    createMultipartUpload(params: S3.CreateMultipartUploadRequest, callback?: (err: any, data: S3.CreateMultipartUploadOutput|any) => void): Request;
    deleteBucket(params: S3.DeleteBucketRequest, callback?: (err: any, data: any) => void): Request;
    deleteBucketCors(params: S3.DeleteBucketCorsRequest, callback?: (err: any, data: any) => void): Request;
    deleteBucketLifecycle(params: S3.DeleteBucketLifecycleRequest, callback?: (err: any, data: any) => void): Request;
    deleteBucketPolicy(params: S3.DeleteBucketPolicyRequest, callback?: (err: any, data: any) => void): Request;
    deleteBucketReplication(params: S3.DeleteBucketReplicationRequest, callback?: (err: any, data: any) => void): Request;
    deleteBucketTagging(params: S3.DeleteBucketTaggingRequest, callback?: (err: any, data: any) => void): Request;
    deleteBucketWebsite(params: S3.DeleteBucketWebsiteRequest, callback?: (err: any, data: any) => void): Request;
    deleteObject(params: S3.DeleteObjectRequest, callback?: (err: any, data: S3.DeleteObjectOutput|any) => void): Request;
    deleteObjects(params: S3.DeleteObjectsRequest, callback?: (err: any, data: S3.DeleteObjectsOutput|any) => void): Request;
    getBucketAcl(params: S3.GetBucketAclRequest, callback?: (err: any, data: S3.GetBucketAclOutput|any) => void): Request;
    getBucketCors(params: S3.GetBucketCorsRequest, callback?: (err: any, data: S3.GetBucketCorsOutput|any) => void): Request;
    getBucketLifecycle(params: S3.GetBucketLifecycleRequest, callback?: (err: any, data: S3.GetBucketLifecycleOutput|any) => void): Request;
    getBucketLifecycleConfiguration(params: S3.GetBucketLifecycleConfigurationRequest, callback?: (err: any, data: S3.GetBucketLifecycleConfigurationOutput|any) => void): Request;
    getBucketLocation(params: S3.GetBucketLocationRequest, callback?: (err: any, data: S3.GetBucketLocationOutput|any) => void): Request;
    getBucketLogging(params: S3.GetBucketLoggingRequest, callback?: (err: any, data: S3.GetBucketLoggingOutput|any) => void): Request;
    getBucketNotification(params: S3.GetBucketNotificationConfigurationRequest, callback?: (err: any, data: S3.NotificationConfigurationDeprecated|any) => void): Request;
    getBucketNotificationConfiguration(params: S3.GetBucketNotificationConfigurationRequest, callback?: (err: any, data: S3.NotificationConfiguration|any) => void): Request;
    getBucketPolicy(params: S3.GetBucketPolicyRequest, callback?: (err: any, data: S3.GetBucketPolicyOutput|any) => void): Request;
    getBucketReplication(params: S3.GetBucketReplicationRequest, callback?: (err: any, data: S3.GetBucketReplicationOutput|any) => void): Request;
    getBucketRequestPayment(params: S3.GetBucketRequestPaymentRequest, callback?: (err: any, data: S3.GetBucketRequestPaymentOutput|any) => void): Request;
    getBucketTagging(params: S3.GetBucketTaggingRequest, callback?: (err: any, data: S3.GetBucketTaggingOutput|any) => void): Request;
    getBucketVersioning(params: S3.GetBucketVersioningRequest, callback?: (err: any, data: S3.GetBucketVersioningOutput|any) => void): Request;
    getBucketWebsite(params: S3.GetBucketWebsiteRequest, callback?: (err: any, data: S3.GetBucketWebsiteOutput|any) => void): Request;
    getObject(params: S3.GetObjectRequest, callback?: (err: S3.NoSuchKey|any, data: S3.GetObjectOutput|any) => void): Request;
    getObjectAcl(params: S3.GetObjectAclRequest, callback?: (err: S3.NoSuchKey|any, data: S3.GetObjectAclOutput|any) => void): Request;
    getObjectTorrent(params: S3.GetObjectTorrentRequest, callback?: (err: any, data: S3.GetObjectTorrentOutput|any) => void): Request;
    headBucket(params: S3.HeadBucketRequest, callback?: (err: S3.NoSuchBucket|any, data: any) => void): Request;
    headObject(params: S3.HeadObjectRequest, callback?: (err: S3.NoSuchKey|any, data: S3.HeadObjectOutput|any) => void): Request;
    listBuckets(callback?: (err: any, data: S3.ListBucketsOutput|any) => void): Request;
    listMultipartUploads(params: S3.ListMultipartUploadsRequest, callback?: (err: any, data: S3.ListMultipartUploadsOutput|any) => void): Request;
    listObjectVersions(params: S3.ListObjectVersionsRequest, callback?: (err: any, data: S3.ListObjectVersionsOutput|any) => void): Request;
    listObjects(params: S3.ListObjectsRequest, callback?: (err: S3.NoSuchBucket|any, data: S3.ListObjectsOutput|any) => void): Request;
    listParts(params: S3.ListPartsRequest, callback?: (err: any, data: S3.ListPartsOutput|any) => void): Request;
    putBucketAcl(params: S3.PutBucketAclRequest, callback?: (err: any, data: any) => void): Request;
    putBucketCors(params: S3.PutBucketCorsRequest, callback?: (err: any, data: any) => void): Request;
    putBucketLifecycle(params: S3.PutBucketLifecycleRequest, callback?: (err: any, data: any) => void): Request;
    putBucketLifecycleConfiguration(params: S3.PutBucketLifecycleConfigurationRequest, callback?: (err: any, data: any) => void): Request;
    putBucketLogging(params: S3.PutBucketLoggingRequest, callback?: (err: any, data: any) => void): Request;
    putBucketNotification(params: S3.PutBucketNotificationRequest, callback?: (err: any, data: any) => void): Request;
    putBucketNotificationConfiguration(params: S3.PutBucketNotificationConfigurationRequest, callback?: (err: any, data: any) => void): Request;
    putBucketPolicy(params: S3.PutBucketPolicyRequest, callback?: (err: any, data: any) => void): Request;
    putBucketReplication(params: S3.PutBucketReplicationRequest, callback?: (err: any, data: any) => void): Request;
    putBucketRequestPayment(params: S3.PutBucketRequestPaymentRequest, callback?: (err: any, data: any) => void): Request;
    putBucketTagging(params: S3.PutBucketTaggingRequest, callback?: (err: any, data: any) => void): Request;
    putBucketVersioning(params: S3.PutBucketVersioningRequest, callback?: (err: any, data: any) => void): Request;
    putBucketWebsite(params: S3.PutBucketWebsiteRequest, callback?: (err: any, data: any) => void): Request;
    putObject(params: S3.PutObjectRequest, callback?: (err: any, data: S3.PutObjectOutput|any) => void): Request;
    putObjectAcl(params: S3.PutObjectAclRequest, callback?: (err: S3.NoSuchKey|any, data: S3.PutObjectAclOutput|any) => void): Request;
    restoreObject(params: S3.RestoreObjectRequest, callback?: (err: S3.ObjectAlreadyInActiveTierError|any, data: S3.RestoreObjectOutput|any) => void): Request;
    uploadPart(params: S3.UploadPartRequest, callback?: (err: any, data: S3.UploadPartOutput|any) => void): Request;
    uploadPartCopy(params: S3.UploadPartCopyRequest, callback?: (err: any, data: S3.UploadPartCopyOutput|any) => void): Request;

    /***
     * Found on JS Sources - Sorry for the inconvenience :)
     * *
     * Get a pre-signed URL for a given operation name.
     *
     * @note You must ensure that you have static or previously resolved
     *   credentials if you call this method synchronously (with no callback),
     *   otherwise it may not properly sign the request. If you cannot guarantee
     *   this (you are using an asynchronous credential provider, i.e., EC2
     *   IAM roles), you should always call this method with an asynchronous
     *   callback.
     * @param operation [String] the name of the operation to call
     * @param params [map] parameters to pass to the operation. See the given
     *   operation for the expected operation parameters. In addition, you can
     *   also pass the "Expires" parameter to inform S3 how long the URL should
     *   work for.
     * @option params Expires [Integer] (900) the number of seconds to expire
     *   the pre-signed URL operation in. Defaults to 15 minutes.
     * @param callback [Function] if a callback is provided, this function will
     *   pass the URL as the second parameter (after the error parameter) to
     *   the callback function.
     * @return [String] if called synchronously (with no callback), returns the
     *   signed URL.
     * @return [null] nothing is returned if a callback is provided.
     * @example Pre-signing a getObject operation (synchronously)
     *   var params = {Bucket: 'bucket', Key: 'key'};
     *   var url = s3.getSignedUrl('getObject', params);
     *   console.log('The URL is', url);
     * @example Pre-signing a putObject (asynchronously)
     *   var params = {Bucket: 'bucket', Key: 'key'};
     *   s3.getSignedUrl('putObject', params, function (err, url) {
     *     console.log('The URL is', url);
     *   });
     * @example Pre-signing a putObject operation with a specific payload
     *   var params = {Bucket: 'bucket', Key: 'key', Body: 'body'};
     *   var url = s3.getSignedUrl('putObject', params);
     *   console.log('The URL is', url);
     * @example Passing in a 1-minute expiry time for a pre-signed URL
     *   var params = {Bucket: 'bucket', Key: 'key', Expires: 60};
     *   var url = s3.getSignedUrl('getObject', params);
     *   console.log('The URL is', url); // expires in 60 seconds
   
     **/
    getSignedUrl(...args: any[]): any
    /***
     * Found on JS Sources - Sorry for the inconvenience :)
     * 
     **/
    noPresignedContentLength(...args: any[]): any
    /***
     * Found on JS Sources - Sorry for the inconvenience :)
     * 
     **/
    createBucket(...args: any[]): any
    /***
     * Found on JS Sources - Sorry for the inconvenience :)
     * *
     * @overload upload(params = {}, [options], [callback])
     *   Uploads an arbitrarily sized buffer, blob, or stream, using intelligent
     *   concurrent handling of parts if the payload is large enough. You can
     *   configure the concurrent queue size by setting `options`.
     *
     *   @param (see AWS.S3.putObject)
     *   @option (see AWS.S3.ManagedUpload.constructor)
     *   @return [AWS.S3.ManagedUpload] the managed upload object that can call
     *     `send()` or track progress.
     *   @example Uploading a stream object
     *     var params = {Bucket: 'bucket', Key: 'key', Body: stream};
     *     s3.upload(params, function(err, data) {
     *       console.log(err, data);
     *     });
     *   @example Uploading a stream with concurrency of 1 and partSize of 10mb
     *     var params = {Bucket: 'bucket', Key: 'key', Body: stream};
     *     var options = {partSize: 10 * 1024 * 1024, queueSize: 1};
     *     s3.upload(params, options, function(err, data) {
     *       console.log(err, data);
     *     });
     * @callback callback function(err, data)
     *   @param err [Error] an error or null if no error occurred.
     *   @param data [map] The response data from the successful upload:
     *     * `Location` (String) the URL of the uploaded object
     *     * `ETag` (String) the ETag of the uploaded object
     *   @see AWS.S3.ManagedUpload
   
     **/
    upload(...args: any[]): any
  }

  export module S3 {
    export type AbortDate = number;
    export type AbortRuleId = string;
    export type AcceptRanges = string;
    export type AllowedHeader = string;
    export type AllowedHeaders = AllowedHeader[];
    export type AllowedMethod = string;
    export type AllowedMethods = AllowedMethod[];
    export type AllowedOrigin = string;
    export type AllowedOrigins = AllowedOrigin[];
    export type Body = any;    // type: blob
    export type BucketCannedACL = string;
    export type BucketLocationConstraint = string;
    export type BucketLogsPermission = string;
    export type BucketName = string;
    export type BucketVersioningStatus = string;
    export type Buckets = Bucket[];
    export type CORSRules = CORSRule[];
    export type CacheControl = string;
    export type CloudFunction = string;
    export type CloudFunctionInvocationRole = string;
    export type Code = string;
    export type CommonPrefixList = CommonPrefix[];
    export type CompletedPartList = CompletedPart[];
    export type ContentDisposition = string;
    export type ContentEncoding = string;
    export type ContentLanguage = string;
    export type ContentLength = number;
    export type ContentMD5 = string;
    export type ContentRange = string;
    export type ContentType = string;
    export type CopySource = string;    // pattern: &quot;\/.+\/.+&quot;
    export type CopySourceIfMatch = string;
    export type CopySourceIfModifiedSince = number;
    export type CopySourceIfNoneMatch = string;
    export type CopySourceIfUnmodifiedSince = number;
    export type CopySourceRange = string;
    export type CopySourceSSECustomerAlgorithm = string;
    export type CopySourceSSECustomerKey = any;    // type: blob
    export type CopySourceSSECustomerKeyMD5 = string;
    export type CopySourceVersionId = string;
    export type CreationDate = number;
    export type Date = number;
    export type Days = number;
    export type DaysAfterInitiation = number;
    export type DeleteMarker = boolean;
    export type DeleteMarkerVersionId = string;
    export type DeleteMarkers = DeleteMarkerEntry[];
    export type DeletedObjects = DeletedObject[];
    export type Delimiter = string;
    export type DisplayName = string;
    export type ETag = string;
    export type EmailAddress = string;
    export type EncodingType = string;
    export type Errors = Error[];
    export type Event = string;
    export type EventList = Event[];
    export type Expiration = string;
    export type ExpirationStatus = string;
    export type ExpiredObjectDeleteMarker = boolean;
    export type Expires = number;
    export type ExposeHeader = string;
    export type ExposeHeaders = ExposeHeader[];
    export type FilterRuleList = FilterRule[];
    export type FilterRuleName = string;
    export type FilterRuleValue = string;
    export type GrantFullControl = string;
    export type GrantRead = string;
    export type GrantReadACP = string;
    export type GrantWrite = string;
    export type GrantWriteACP = string;
    export type Grants = Grant[];
    export type HostName = string;
    export type HttpErrorCodeReturnedEquals = string;
    export type HttpRedirectCode = string;
    export type ID = string;
    export type IfMatch = string;
    export type IfModifiedSince = number;
    export type IfNoneMatch = string;
    export type IfUnmodifiedSince = number;
    export type Initiated = number;
    export type IsLatest = boolean;
    export type IsTruncated = boolean;
    export type KeyMarker = string;
    export type KeyPrefixEquals = string;
    export type LambdaFunctionArn = string;
    export type LambdaFunctionConfigurationList = LambdaFunctionConfiguration[];
    export type LastModified = number;
    export type LifecycleRules = LifecycleRule[];
    export type Location = string;
    export type MFA = string;
    export type MFADelete = string;
    export type MFADeleteStatus = string;
    export type Marker = string;
    export type MaxAgeSeconds = number;
    export type MaxKeys = number;
    export type MaxParts = number;
    export type MaxUploads = number;
    export type Message = string;
    export type Metadata = {[key:string]: MetadataValue};
    export type MetadataDirective = string;
    export type MetadataKey = string;
    export type MetadataValue = string;
    export type MissingMeta = number;
    export type MultipartUploadId = string;
    export type MultipartUploadList = MultipartUpload[];
    export type NextKeyMarker = string;
    export type NextMarker = string;
    export type NextPartNumberMarker = number;
    export type NextUploadIdMarker = string;
    export type NextVersionIdMarker = string;
    export type NoncurrentVersionTransitionList = NoncurrentVersionTransition[];
    export type NotificationId = string;
    export type ObjectCannedACL = string;
    export type ObjectIdentifierList = ObjectIdentifier[];
    export type ObjectKey = string;    // min: 1
    export type ObjectList = Object[];
    export type ObjectStorageClass = string;
    export type ObjectVersionId = string;
    export type ObjectVersionList = ObjectVersion[];
    export type ObjectVersionStorageClass = string;
    export type PartNumber = number;
    export type PartNumberMarker = number;
    export type Parts = Part[];
    export type Payer = string;
    export type Permission = string;
    export type Policy = string;
    export type Prefix = string;
    export type Protocol = string;
    export type QueueArn = string;
    export type QueueConfigurationList = QueueConfiguration[];
    export type Quiet = boolean;
    export type Range = string;
    export type ReplaceKeyPrefixWith = string;
    export type ReplaceKeyWith = string;
    export type ReplicationRuleStatus = string;
    export type ReplicationRules = ReplicationRule[];
    export type ReplicationStatus = string;
    export type RequestCharged = string;
    export type RequestPayer = string;
    export type ResponseCacheControl = string;
    export type ResponseContentDisposition = string;
    export type ResponseContentEncoding = string;
    export type ResponseContentLanguage = string;
    export type ResponseContentType = string;
    export type ResponseExpires = number;
    export type Restore = string;
    export type Role = string;
    export type RoutingRules = RoutingRule[];
    export type Rules = Rule[];
    export type SSECustomerAlgorithm = string;
    export type SSECustomerKey = any;    // type: blob
    export type SSECustomerKeyMD5 = string;
    export type SSEKMSKeyId = string;
    export type ServerSideEncryption = string;
    export type Size = number;
    export type StorageClass = string;
    export type Suffix = string;
    export type TagSet = Tag[];
    export type TargetBucket = string;
    export type TargetGrants = TargetGrant[];
    export type TargetPrefix = string;
    export type TopicArn = string;
    export type TopicConfigurationList = TopicConfiguration[];
    export type TransitionList = Transition[];
    export type TransitionStorageClass = string;
    export type Type = string;
    export type URI = string;
    export type UploadIdMarker = string;
    export type Value = string;
    export type VersionIdMarker = string;
    export type WebsiteRedirectLocation = string;

    export interface AbortIncompleteMultipartUpload {
        DaysAfterInitiation?: DaysAfterInitiation;
    }
    export interface AbortMultipartUploadOutput {
        RequestCharged?: RequestCharged;
    }
    export interface AbortMultipartUploadRequest {
        Bucket: BucketName;
        Key: ObjectKey;
        UploadId: MultipartUploadId;
        RequestPayer?: RequestPayer;
    }
    export interface AccessControlPolicy {
        Grants?: Grants;
        Owner?: Owner;
    }
    export interface Bucket {
        Name?: BucketName;
        CreationDate?: CreationDate;
    }
    export interface BucketAlreadyExists {
    }
    export interface BucketAlreadyOwnedByYou {
    }
    export interface BucketLifecycleConfiguration {
        Rules: LifecycleRules;
    }
    export interface BucketLoggingStatus {
        LoggingEnabled?: LoggingEnabled;
    }
    export interface CORSConfiguration {
        CORSRules: CORSRules;
    }
    export interface CORSRule {
        AllowedHeaders?: AllowedHeaders;
        AllowedMethods: AllowedMethods;
        AllowedOrigins: AllowedOrigins;
        ExposeHeaders?: ExposeHeaders;
        MaxAgeSeconds?: MaxAgeSeconds;
    }
    export interface CloudFunctionConfiguration {
        Id?: NotificationId;
        Event?: Event;
        Events?: EventList;
        CloudFunction?: CloudFunction;
        InvocationRole?: CloudFunctionInvocationRole;
    }
    export interface CommonPrefix {
        Prefix?: Prefix;
    }
    export interface CompleteMultipartUploadOutput {
        Location?: Location;
        Bucket?: BucketName;
        Key?: ObjectKey;
        Expiration?: Expiration;
        ETag?: ETag;
        ServerSideEncryption?: ServerSideEncryption;
        VersionId?: ObjectVersionId;
        SSEKMSKeyId?: SSEKMSKeyId;
        RequestCharged?: RequestCharged;
    }
    export interface CompleteMultipartUploadRequest {
        Bucket: BucketName;
        Key: ObjectKey;
        MultipartUpload?: CompletedMultipartUpload;
        UploadId: MultipartUploadId;
        RequestPayer?: RequestPayer;
    }
    export interface CompletedMultipartUpload {
        Parts?: CompletedPartList;
    }
    export interface CompletedPart {
        ETag?: ETag;
        PartNumber?: PartNumber;
    }
    export interface Condition {
        HttpErrorCodeReturnedEquals?: HttpErrorCodeReturnedEquals;
        KeyPrefixEquals?: KeyPrefixEquals;
    }
    export interface CopyObjectOutput {
        CopyObjectResult?: CopyObjectResult;
        Expiration?: Expiration;
        CopySourceVersionId?: CopySourceVersionId;
        VersionId?: ObjectVersionId;
        ServerSideEncryption?: ServerSideEncryption;
        SSECustomerAlgorithm?: SSECustomerAlgorithm;
        SSECustomerKeyMD5?: SSECustomerKeyMD5;
        SSEKMSKeyId?: SSEKMSKeyId;
        RequestCharged?: RequestCharged;
    }
    export interface CopyObjectRequest {
        ACL?: ObjectCannedACL;
        Bucket: BucketName;
        CacheControl?: CacheControl;
        ContentDisposition?: ContentDisposition;
        ContentEncoding?: ContentEncoding;
        ContentLanguage?: ContentLanguage;
        ContentType?: ContentType;
        CopySource: CopySource;
        CopySourceIfMatch?: CopySourceIfMatch;
        CopySourceIfModifiedSince?: CopySourceIfModifiedSince;
        CopySourceIfNoneMatch?: CopySourceIfNoneMatch;
        CopySourceIfUnmodifiedSince?: CopySourceIfUnmodifiedSince;
        Expires?: Expires;
        GrantFullControl?: GrantFullControl;
        GrantRead?: GrantRead;
        GrantReadACP?: GrantReadACP;
        GrantWriteACP?: GrantWriteACP;
        Key: ObjectKey;
        Metadata?: Metadata;
        MetadataDirective?: MetadataDirective;
        ServerSideEncryption?: ServerSideEncryption;
        StorageClass?: StorageClass;
        WebsiteRedirectLocation?: WebsiteRedirectLocation;
        SSECustomerAlgorithm?: SSECustomerAlgorithm;
        SSECustomerKey?: SSECustomerKey;
        SSECustomerKeyMD5?: SSECustomerKeyMD5;
        SSEKMSKeyId?: SSEKMSKeyId;
        CopySourceSSECustomerAlgorithm?: CopySourceSSECustomerAlgorithm;
        CopySourceSSECustomerKey?: CopySourceSSECustomerKey;
        CopySourceSSECustomerKeyMD5?: CopySourceSSECustomerKeyMD5;
        RequestPayer?: RequestPayer;
    }
    export interface CopyObjectResult {
        ETag?: ETag;
        LastModified?: LastModified;
    }
    export interface CopyPartResult {
        ETag?: ETag;
        LastModified?: LastModified;
    }
    export interface CreateBucketConfiguration {
        LocationConstraint?: BucketLocationConstraint;
    }
    export interface CreateBucketOutput {
        Location?: Location;
    }
    export interface CreateBucketRequest {
        ACL?: BucketCannedACL;
        Bucket: BucketName;
        CreateBucketConfiguration?: CreateBucketConfiguration;
        GrantFullControl?: GrantFullControl;
        GrantRead?: GrantRead;
        GrantReadACP?: GrantReadACP;
        GrantWrite?: GrantWrite;
        GrantWriteACP?: GrantWriteACP;
    }
    export interface CreateMultipartUploadOutput {
        AbortDate?: AbortDate;
        AbortRuleId?: AbortRuleId;
        Bucket?: BucketName;
        Key?: ObjectKey;
        UploadId?: MultipartUploadId;
        ServerSideEncryption?: ServerSideEncryption;
        SSECustomerAlgorithm?: SSECustomerAlgorithm;
        SSECustomerKeyMD5?: SSECustomerKeyMD5;
        SSEKMSKeyId?: SSEKMSKeyId;
        RequestCharged?: RequestCharged;
    }
    export interface CreateMultipartUploadRequest {
        ACL?: ObjectCannedACL;
        Bucket: BucketName;
        CacheControl?: CacheControl;
        ContentDisposition?: ContentDisposition;
        ContentEncoding?: ContentEncoding;
        ContentLanguage?: ContentLanguage;
        ContentType?: ContentType;
        Expires?: Expires;
        GrantFullControl?: GrantFullControl;
        GrantRead?: GrantRead;
        GrantReadACP?: GrantReadACP;
        GrantWriteACP?: GrantWriteACP;
        Key: ObjectKey;
        Metadata?: Metadata;
        ServerSideEncryption?: ServerSideEncryption;
        StorageClass?: StorageClass;
        WebsiteRedirectLocation?: WebsiteRedirectLocation;
        SSECustomerAlgorithm?: SSECustomerAlgorithm;
        SSECustomerKey?: SSECustomerKey;
        SSECustomerKeyMD5?: SSECustomerKeyMD5;
        SSEKMSKeyId?: SSEKMSKeyId;
        RequestPayer?: RequestPayer;
    }
    export interface Delete {
        Objects: ObjectIdentifierList;
        Quiet?: Quiet;
    }
    export interface DeleteBucketCorsRequest {
        Bucket: BucketName;
    }
    export interface DeleteBucketLifecycleRequest {
        Bucket: BucketName;
    }
    export interface DeleteBucketPolicyRequest {
        Bucket: BucketName;
    }
    export interface DeleteBucketReplicationRequest {
        Bucket: BucketName;
    }
    export interface DeleteBucketRequest {
        Bucket: BucketName;
    }
    export interface DeleteBucketTaggingRequest {
        Bucket: BucketName;
    }
    export interface DeleteBucketWebsiteRequest {
        Bucket: BucketName;
    }
    export interface DeleteMarkerEntry {
        Owner?: Owner;
        Key?: ObjectKey;
        VersionId?: ObjectVersionId;
        IsLatest?: IsLatest;
        LastModified?: LastModified;
    }
    export interface DeleteObjectOutput {
        DeleteMarker?: DeleteMarker;
        VersionId?: ObjectVersionId;
        RequestCharged?: RequestCharged;
    }
    export interface DeleteObjectRequest {
        Bucket: BucketName;
        Key: ObjectKey;
        MFA?: MFA;
        VersionId?: ObjectVersionId;
        RequestPayer?: RequestPayer;
    }
    export interface DeleteObjectsOutput {
        Deleted?: DeletedObjects;
        RequestCharged?: RequestCharged;
        Errors?: Errors;
    }
    export interface DeleteObjectsRequest {
        Bucket: BucketName;
        Delete: Delete;
        MFA?: MFA;
        RequestPayer?: RequestPayer;
    }
    export interface DeletedObject {
        Key?: ObjectKey;
        VersionId?: ObjectVersionId;
        DeleteMarker?: DeleteMarker;
        DeleteMarkerVersionId?: DeleteMarkerVersionId;
    }
    export interface Destination {
        Bucket: BucketName;
        StorageClass?: StorageClass;
    }
    export interface Error {
        Key?: ObjectKey;
        VersionId?: ObjectVersionId;
        Code?: Code;
        Message?: Message;
    }
    export interface ErrorDocument {
        Key: ObjectKey;
    }
    export interface FilterRule {
        Name?: FilterRuleName;
        Value?: FilterRuleValue;
    }
    export interface GetBucketAclOutput {
        Owner?: Owner;
        Grants?: Grants;
    }
    export interface GetBucketAclRequest {
        Bucket: BucketName;
    }
    export interface GetBucketCorsOutput {
        CORSRules?: CORSRules;
    }
    export interface GetBucketCorsRequest {
        Bucket: BucketName;
    }
    export interface GetBucketLifecycleConfigurationOutput {
        Rules?: LifecycleRules;
    }
    export interface GetBucketLifecycleConfigurationRequest {
        Bucket: BucketName;
    }
    export interface GetBucketLifecycleOutput {
        Rules?: Rules;
    }
    export interface GetBucketLifecycleRequest {
        Bucket: BucketName;
    }
    export interface GetBucketLocationOutput {
        LocationConstraint?: BucketLocationConstraint;
    }
    export interface GetBucketLocationRequest {
        Bucket: BucketName;
    }
    export interface GetBucketLoggingOutput {
        LoggingEnabled?: LoggingEnabled;
    }
    export interface GetBucketLoggingRequest {
        Bucket: BucketName;
    }
    export interface GetBucketNotificationConfigurationRequest {
        Bucket: BucketName;
    }
    export interface GetBucketPolicyOutput {
        Policy?: Policy;
    }
    export interface GetBucketPolicyRequest {
        Bucket: BucketName;
    }
    export interface GetBucketReplicationOutput {
        ReplicationConfiguration?: ReplicationConfiguration;
    }
    export interface GetBucketReplicationRequest {
        Bucket: BucketName;
    }
    export interface GetBucketRequestPaymentOutput {
        Payer?: Payer;
    }
    export interface GetBucketRequestPaymentRequest {
        Bucket: BucketName;
    }
    export interface GetBucketTaggingOutput {
        TagSet: TagSet;
    }
    export interface GetBucketTaggingRequest {
        Bucket: BucketName;
    }
    export interface GetBucketVersioningOutput {
        Status?: BucketVersioningStatus;
        MFADelete?: MFADeleteStatus;
    }
    export interface GetBucketVersioningRequest {
        Bucket: BucketName;
    }
    export interface GetBucketWebsiteOutput {
        RedirectAllRequestsTo?: RedirectAllRequestsTo;
        IndexDocument?: IndexDocument;
        ErrorDocument?: ErrorDocument;
        RoutingRules?: RoutingRules;
    }
    export interface GetBucketWebsiteRequest {
        Bucket: BucketName;
    }
    export interface GetObjectAclOutput {
        Owner?: Owner;
        Grants?: Grants;
        RequestCharged?: RequestCharged;
    }
    export interface GetObjectAclRequest {
        Bucket: BucketName;
        Key: ObjectKey;
        VersionId?: ObjectVersionId;
        RequestPayer?: RequestPayer;
    }
    export interface GetObjectOutput {
        Body?: Body;
        DeleteMarker?: DeleteMarker;
        AcceptRanges?: AcceptRanges;
        Expiration?: Expiration;
        Restore?: Restore;
        LastModified?: LastModified;
        ContentLength?: ContentLength;
        ETag?: ETag;
        MissingMeta?: MissingMeta;
        VersionId?: ObjectVersionId;
        CacheControl?: CacheControl;
        ContentDisposition?: ContentDisposition;
        ContentEncoding?: ContentEncoding;
        ContentLanguage?: ContentLanguage;
        ContentRange?: ContentRange;
        ContentType?: ContentType;
        Expires?: Expires;
        WebsiteRedirectLocation?: WebsiteRedirectLocation;
        ServerSideEncryption?: ServerSideEncryption;
        Metadata?: Metadata;
        SSECustomerAlgorithm?: SSECustomerAlgorithm;
        SSECustomerKeyMD5?: SSECustomerKeyMD5;
        SSEKMSKeyId?: SSEKMSKeyId;
        StorageClass?: StorageClass;
        RequestCharged?: RequestCharged;
        ReplicationStatus?: ReplicationStatus;
    }
    export interface GetObjectRequest {
        Bucket: BucketName;
        IfMatch?: IfMatch;
        IfModifiedSince?: IfModifiedSince;
        IfNoneMatch?: IfNoneMatch;
        IfUnmodifiedSince?: IfUnmodifiedSince;
        Key: ObjectKey;
        Range?: Range;
        ResponseCacheControl?: ResponseCacheControl;
        ResponseContentDisposition?: ResponseContentDisposition;
        ResponseContentEncoding?: ResponseContentEncoding;
        ResponseContentLanguage?: ResponseContentLanguage;
        ResponseContentType?: ResponseContentType;
        ResponseExpires?: ResponseExpires;
        VersionId?: ObjectVersionId;
        SSECustomerAlgorithm?: SSECustomerAlgorithm;
        SSECustomerKey?: SSECustomerKey;
        SSECustomerKeyMD5?: SSECustomerKeyMD5;
        RequestPayer?: RequestPayer;
    }
    export interface GetObjectTorrentOutput {
        Body?: Body;
        RequestCharged?: RequestCharged;
    }
    export interface GetObjectTorrentRequest {
        Bucket: BucketName;
        Key: ObjectKey;
        RequestPayer?: RequestPayer;
    }
    export interface Grant {
        Grantee?: Grantee;
        Permission?: Permission;
    }
    export interface Grantee {
        DisplayName?: DisplayName;
        EmailAddress?: EmailAddress;
        ID?: ID;
        Type: Type;
        URI?: URI;
    }
    export interface HeadBucketRequest {
        Bucket: BucketName;
    }
    export interface HeadObjectOutput {
        DeleteMarker?: DeleteMarker;
        AcceptRanges?: AcceptRanges;
        Expiration?: Expiration;
        Restore?: Restore;
        LastModified?: LastModified;
        ContentLength?: ContentLength;
        ETag?: ETag;
        MissingMeta?: MissingMeta;
        VersionId?: ObjectVersionId;
        CacheControl?: CacheControl;
        ContentDisposition?: ContentDisposition;
        ContentEncoding?: ContentEncoding;
        ContentLanguage?: ContentLanguage;
        ContentType?: ContentType;
        Expires?: Expires;
        WebsiteRedirectLocation?: WebsiteRedirectLocation;
        ServerSideEncryption?: ServerSideEncryption;
        Metadata?: Metadata;
        SSECustomerAlgorithm?: SSECustomerAlgorithm;
        SSECustomerKeyMD5?: SSECustomerKeyMD5;
        SSEKMSKeyId?: SSEKMSKeyId;
        StorageClass?: StorageClass;
        RequestCharged?: RequestCharged;
        ReplicationStatus?: ReplicationStatus;
    }
    export interface HeadObjectRequest {
        Bucket: BucketName;
        IfMatch?: IfMatch;
        IfModifiedSince?: IfModifiedSince;
        IfNoneMatch?: IfNoneMatch;
        IfUnmodifiedSince?: IfUnmodifiedSince;
        Key: ObjectKey;
        Range?: Range;
        VersionId?: ObjectVersionId;
        SSECustomerAlgorithm?: SSECustomerAlgorithm;
        SSECustomerKey?: SSECustomerKey;
        SSECustomerKeyMD5?: SSECustomerKeyMD5;
        RequestPayer?: RequestPayer;
    }
    export interface IndexDocument {
        Suffix: Suffix;
    }
    export interface Initiator {
        ID?: ID;
        DisplayName?: DisplayName;
    }
    export interface LambdaFunctionConfiguration {
        Id?: NotificationId;
        LambdaFunctionArn: LambdaFunctionArn;
        Events: EventList;
        Filter?: NotificationConfigurationFilter;
    }
    export interface LifecycleConfiguration {
        Rules: Rules;
    }
    export interface LifecycleExpiration {
        Date?: Date;
        Days?: Days;
        ExpiredObjectDeleteMarker?: ExpiredObjectDeleteMarker;
    }
    export interface LifecycleRule {
        Expiration?: LifecycleExpiration;
        ID?: ID;
        Prefix: Prefix;
        Status: ExpirationStatus;
        Transitions?: TransitionList;
        NoncurrentVersionTransitions?: NoncurrentVersionTransitionList;
        NoncurrentVersionExpiration?: NoncurrentVersionExpiration;
        AbortIncompleteMultipartUpload?: AbortIncompleteMultipartUpload;
    }
    export interface ListBucketsOutput {
        Buckets?: Buckets;
        Owner?: Owner;
    }
    export interface ListMultipartUploadsOutput {
        Bucket?: BucketName;
        KeyMarker?: KeyMarker;
        UploadIdMarker?: UploadIdMarker;
        NextKeyMarker?: NextKeyMarker;
        Prefix?: Prefix;
        Delimiter?: Delimiter;
        NextUploadIdMarker?: NextUploadIdMarker;
        MaxUploads?: MaxUploads;
        IsTruncated?: IsTruncated;
        Uploads?: MultipartUploadList;
        CommonPrefixes?: CommonPrefixList;
        EncodingType?: EncodingType;
    }
    export interface ListMultipartUploadsRequest {
        Bucket: BucketName;
        Delimiter?: Delimiter;
        EncodingType?: EncodingType;
        KeyMarker?: KeyMarker;
        MaxUploads?: MaxUploads;
        Prefix?: Prefix;
        UploadIdMarker?: UploadIdMarker;
    }
    export interface ListObjectVersionsOutput {
        IsTruncated?: IsTruncated;
        KeyMarker?: KeyMarker;
        VersionIdMarker?: VersionIdMarker;
        NextKeyMarker?: NextKeyMarker;
        NextVersionIdMarker?: NextVersionIdMarker;
        Versions?: ObjectVersionList;
        DeleteMarkers?: DeleteMarkers;
        Name?: BucketName;
        Prefix?: Prefix;
        Delimiter?: Delimiter;
        MaxKeys?: MaxKeys;
        CommonPrefixes?: CommonPrefixList;
        EncodingType?: EncodingType;
    }
    export interface ListObjectVersionsRequest {
        Bucket: BucketName;
        Delimiter?: Delimiter;
        EncodingType?: EncodingType;
        KeyMarker?: KeyMarker;
        MaxKeys?: MaxKeys;
        Prefix?: Prefix;
        VersionIdMarker?: VersionIdMarker;
    }
    export interface ListObjectsOutput {
        IsTruncated?: IsTruncated;
        Marker?: Marker;
        NextMarker?: NextMarker;
        Contents?: ObjectList;
        Name?: BucketName;
        Prefix?: Prefix;
        Delimiter?: Delimiter;
        MaxKeys?: MaxKeys;
        CommonPrefixes?: CommonPrefixList;
        EncodingType?: EncodingType;
    }
    export interface ListObjectsRequest {
        Bucket: BucketName;
        Delimiter?: Delimiter;
        EncodingType?: EncodingType;
        Marker?: Marker;
        MaxKeys?: MaxKeys;
        Prefix?: Prefix;
    }
    export interface ListPartsOutput {
        AbortDate?: AbortDate;
        AbortRuleId?: AbortRuleId;
        Bucket?: BucketName;
        Key?: ObjectKey;
        UploadId?: MultipartUploadId;
        PartNumberMarker?: PartNumberMarker;
        NextPartNumberMarker?: NextPartNumberMarker;
        MaxParts?: MaxParts;
        IsTruncated?: IsTruncated;
        Parts?: Parts;
        Initiator?: Initiator;
        Owner?: Owner;
        StorageClass?: StorageClass;
        RequestCharged?: RequestCharged;
    }
    export interface ListPartsRequest {
        Bucket: BucketName;
        Key: ObjectKey;
        MaxParts?: MaxParts;
        PartNumberMarker?: PartNumberMarker;
        UploadId: MultipartUploadId;
        RequestPayer?: RequestPayer;
    }
    export interface LoggingEnabled {
        TargetBucket?: TargetBucket;
        TargetGrants?: TargetGrants;
        TargetPrefix?: TargetPrefix;
    }
    export interface MultipartUpload {
        UploadId?: MultipartUploadId;
        Key?: ObjectKey;
        Initiated?: Initiated;
        StorageClass?: StorageClass;
        Owner?: Owner;
        Initiator?: Initiator;
    }
    export interface NoSuchBucket {
    }
    export interface NoSuchKey {
    }
    export interface NoSuchUpload {
    }
    export interface NoncurrentVersionExpiration {
        NoncurrentDays?: Days;
    }
    export interface NoncurrentVersionTransition {
        NoncurrentDays?: Days;
        StorageClass?: TransitionStorageClass;
    }
    export interface NotificationConfiguration {
        TopicConfigurations?: TopicConfigurationList;
        QueueConfigurations?: QueueConfigurationList;
        LambdaFunctionConfigurations?: LambdaFunctionConfigurationList;
    }
    export interface NotificationConfigurationDeprecated {
        TopicConfiguration?: TopicConfigurationDeprecated;
        QueueConfiguration?: QueueConfigurationDeprecated;
        CloudFunctionConfiguration?: CloudFunctionConfiguration;
    }
    export interface NotificationConfigurationFilter {
        Key?: S3KeyFilter;
    }
    export interface Object {
        Key?: ObjectKey;
        LastModified?: LastModified;
        ETag?: ETag;
        Size?: Size;
        StorageClass?: ObjectStorageClass;
        Owner?: Owner;
    }
    export interface ObjectAlreadyInActiveTierError {
    }
    export interface ObjectIdentifier {
        Key: ObjectKey;
        VersionId?: ObjectVersionId;
    }
    export interface ObjectNotInActiveTierError {
    }
    export interface ObjectVersion {
        ETag?: ETag;
        Size?: Size;
        StorageClass?: ObjectVersionStorageClass;
        Key?: ObjectKey;
        VersionId?: ObjectVersionId;
        IsLatest?: IsLatest;
        LastModified?: LastModified;
        Owner?: Owner;
    }
    export interface Owner {
        DisplayName?: DisplayName;
        ID?: ID;
    }
    export interface Part {
        PartNumber?: PartNumber;
        LastModified?: LastModified;
        ETag?: ETag;
        Size?: Size;
    }
    export interface PutBucketAclRequest {
        ACL?: BucketCannedACL;
        AccessControlPolicy?: AccessControlPolicy;
        Bucket: BucketName;
        ContentMD5?: ContentMD5;
        GrantFullControl?: GrantFullControl;
        GrantRead?: GrantRead;
        GrantReadACP?: GrantReadACP;
        GrantWrite?: GrantWrite;
        GrantWriteACP?: GrantWriteACP;
    }
    export interface PutBucketCorsRequest {
        Bucket: BucketName;
        CORSConfiguration: CORSConfiguration;
        ContentMD5?: ContentMD5;
    }
    export interface PutBucketLifecycleConfigurationRequest {
        Bucket: BucketName;
        LifecycleConfiguration?: BucketLifecycleConfiguration;
    }
    export interface PutBucketLifecycleRequest {
        Bucket: BucketName;
        ContentMD5?: ContentMD5;
        LifecycleConfiguration?: LifecycleConfiguration;
    }
    export interface PutBucketLoggingRequest {
        Bucket: BucketName;
        BucketLoggingStatus: BucketLoggingStatus;
        ContentMD5?: ContentMD5;
    }
    export interface PutBucketNotificationConfigurationRequest {
        Bucket: BucketName;
        NotificationConfiguration: NotificationConfiguration;
    }
    export interface PutBucketNotificationRequest {
        Bucket: BucketName;
        ContentMD5?: ContentMD5;
        NotificationConfiguration: NotificationConfigurationDeprecated;
    }
    export interface PutBucketPolicyRequest {
        Bucket: BucketName;
        ContentMD5?: ContentMD5;
        Policy: Policy;
    }
    export interface PutBucketReplicationRequest {
        Bucket: BucketName;
        ContentMD5?: ContentMD5;
        ReplicationConfiguration: ReplicationConfiguration;
    }
    export interface PutBucketRequestPaymentRequest {
        Bucket: BucketName;
        ContentMD5?: ContentMD5;
        RequestPaymentConfiguration: RequestPaymentConfiguration;
    }
    export interface PutBucketTaggingRequest {
        Bucket: BucketName;
        ContentMD5?: ContentMD5;
        Tagging: Tagging;
    }
    export interface PutBucketVersioningRequest {
        Bucket: BucketName;
        ContentMD5?: ContentMD5;
        MFA?: MFA;
        VersioningConfiguration: VersioningConfiguration;
    }
    export interface PutBucketWebsiteRequest {
        Bucket: BucketName;
        ContentMD5?: ContentMD5;
        WebsiteConfiguration: WebsiteConfiguration;
    }
    export interface PutObjectAclOutput {
        RequestCharged?: RequestCharged;
    }
    export interface PutObjectAclRequest {
        ACL?: ObjectCannedACL;
        AccessControlPolicy?: AccessControlPolicy;
        Bucket: BucketName;
        ContentMD5?: ContentMD5;
        GrantFullControl?: GrantFullControl;
        GrantRead?: GrantRead;
        GrantReadACP?: GrantReadACP;
        GrantWrite?: GrantWrite;
        GrantWriteACP?: GrantWriteACP;
        Key: ObjectKey;
        RequestPayer?: RequestPayer;
    }
    export interface PutObjectOutput {
        Expiration?: Expiration;
        ETag?: ETag;
        ServerSideEncryption?: ServerSideEncryption;
        VersionId?: ObjectVersionId;
        SSECustomerAlgorithm?: SSECustomerAlgorithm;
        SSECustomerKeyMD5?: SSECustomerKeyMD5;
        SSEKMSKeyId?: SSEKMSKeyId;
        RequestCharged?: RequestCharged;
    }
    export interface PutObjectRequest {
        ACL?: ObjectCannedACL;
        Body?: Body;
        Bucket: BucketName;
        CacheControl?: CacheControl;
        ContentDisposition?: ContentDisposition;
        ContentEncoding?: ContentEncoding;
        ContentLanguage?: ContentLanguage;
        ContentLength?: ContentLength;
        ContentMD5?: ContentMD5;
        ContentType?: ContentType;
        Expires?: Expires;
        GrantFullControl?: GrantFullControl;
        GrantRead?: GrantRead;
        GrantReadACP?: GrantReadACP;
        GrantWriteACP?: GrantWriteACP;
        Key: ObjectKey;
        Metadata?: Metadata;
        ServerSideEncryption?: ServerSideEncryption;
        StorageClass?: StorageClass;
        WebsiteRedirectLocation?: WebsiteRedirectLocation;
        SSECustomerAlgorithm?: SSECustomerAlgorithm;
        SSECustomerKey?: SSECustomerKey;
        SSECustomerKeyMD5?: SSECustomerKeyMD5;
        SSEKMSKeyId?: SSEKMSKeyId;
        RequestPayer?: RequestPayer;
    }
    export interface QueueConfiguration {
        Id?: NotificationId;
        QueueArn: QueueArn;
        Events: EventList;
        Filter?: NotificationConfigurationFilter;
    }
    export interface QueueConfigurationDeprecated {
        Id?: NotificationId;
        Event?: Event;
        Events?: EventList;
        Queue?: QueueArn;
    }
    export interface Redirect {
        HostName?: HostName;
        HttpRedirectCode?: HttpRedirectCode;
        Protocol?: Protocol;
        ReplaceKeyPrefixWith?: ReplaceKeyPrefixWith;
        ReplaceKeyWith?: ReplaceKeyWith;
    }
    export interface RedirectAllRequestsTo {
        HostName: HostName;
        Protocol?: Protocol;
    }
    export interface ReplicationConfiguration {
        Role: Role;
        Rules: ReplicationRules;
    }
    export interface ReplicationRule {
        ID?: ID;
        Prefix: Prefix;
        Status: ReplicationRuleStatus;
        Destination: Destination;
    }
    export interface RequestPaymentConfiguration {
        Payer: Payer;
    }
    export interface RestoreObjectOutput {
        RequestCharged?: RequestCharged;
    }
    export interface RestoreObjectRequest {
        Bucket: BucketName;
        Key: ObjectKey;
        VersionId?: ObjectVersionId;
        RestoreRequest?: RestoreRequest;
        RequestPayer?: RequestPayer;
    }
    export interface RestoreRequest {
        Days: Days;
    }
    export interface RoutingRule {
        Condition?: Condition;
        Redirect: Redirect;
    }
    export interface Rule {
        Expiration?: LifecycleExpiration;
        ID?: ID;
        Prefix: Prefix;
        Status: ExpirationStatus;
        Transition?: Transition;
        NoncurrentVersionTransition?: NoncurrentVersionTransition;
        NoncurrentVersionExpiration?: NoncurrentVersionExpiration;
        AbortIncompleteMultipartUpload?: AbortIncompleteMultipartUpload;
    }
    export interface S3KeyFilter {
        FilterRules?: FilterRuleList;
    }
    export interface Tag {
        Key: ObjectKey;
        Value: Value;
    }
    export interface Tagging {
        TagSet: TagSet;
    }
    export interface TargetGrant {
        Grantee?: Grantee;
        Permission?: BucketLogsPermission;
    }
    export interface TopicConfiguration {
        Id?: NotificationId;
        TopicArn: TopicArn;
        Events: EventList;
        Filter?: NotificationConfigurationFilter;
    }
    export interface TopicConfigurationDeprecated {
        Id?: NotificationId;
        Events?: EventList;
        Event?: Event;
        Topic?: TopicArn;
    }
    export interface Transition {
        Date?: Date;
        Days?: Days;
        StorageClass?: TransitionStorageClass;
    }
    export interface UploadPartCopyOutput {
        CopySourceVersionId?: CopySourceVersionId;
        CopyPartResult?: CopyPartResult;
        ServerSideEncryption?: ServerSideEncryption;
        SSECustomerAlgorithm?: SSECustomerAlgorithm;
        SSECustomerKeyMD5?: SSECustomerKeyMD5;
        SSEKMSKeyId?: SSEKMSKeyId;
        RequestCharged?: RequestCharged;
    }
    export interface UploadPartCopyRequest {
        Bucket: BucketName;
        CopySource: CopySource;
        CopySourceIfMatch?: CopySourceIfMatch;
        CopySourceIfModifiedSince?: CopySourceIfModifiedSince;
        CopySourceIfNoneMatch?: CopySourceIfNoneMatch;
        CopySourceIfUnmodifiedSince?: CopySourceIfUnmodifiedSince;
        CopySourceRange?: CopySourceRange;
        Key: ObjectKey;
        PartNumber: PartNumber;
        UploadId: MultipartUploadId;
        SSECustomerAlgorithm?: SSECustomerAlgorithm;
        SSECustomerKey?: SSECustomerKey;
        SSECustomerKeyMD5?: SSECustomerKeyMD5;
        CopySourceSSECustomerAlgorithm?: CopySourceSSECustomerAlgorithm;
        CopySourceSSECustomerKey?: CopySourceSSECustomerKey;
        CopySourceSSECustomerKeyMD5?: CopySourceSSECustomerKeyMD5;
        RequestPayer?: RequestPayer;
    }
    export interface UploadPartOutput {
        ServerSideEncryption?: ServerSideEncryption;
        ETag?: ETag;
        SSECustomerAlgorithm?: SSECustomerAlgorithm;
        SSECustomerKeyMD5?: SSECustomerKeyMD5;
        SSEKMSKeyId?: SSEKMSKeyId;
        RequestCharged?: RequestCharged;
    }
    export interface UploadPartRequest {
        Body?: Body;
        Bucket: BucketName;
        ContentLength?: ContentLength;
        ContentMD5?: ContentMD5;
        Key: ObjectKey;
        PartNumber: PartNumber;
        UploadId: MultipartUploadId;
        SSECustomerAlgorithm?: SSECustomerAlgorithm;
        SSECustomerKey?: SSECustomerKey;
        SSECustomerKeyMD5?: SSECustomerKeyMD5;
        RequestPayer?: RequestPayer;
    }
    export interface VersioningConfiguration {
        MFADelete?: MFADelete;
        Status?: BucketVersioningStatus;
    }
    export interface WebsiteConfiguration {
        ErrorDocument?: ErrorDocument;
        IndexDocument?: IndexDocument;
        RedirectAllRequestsTo?: RedirectAllRequestsTo;
        RoutingRules?: RoutingRules;
    }
  }

  /*
   * apiVersion: 2010-12-01
   * endpointPrefix: email
   * serviceAbbreviation: Amazon SES
   * signatureVersion: v4
   * protocol: query
   */
  export class SES extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    cloneReceiptRuleSet(params: SES.CloneReceiptRuleSetRequest, callback?: (err: SES.RuleSetDoesNotExistException|SES.AlreadyExistsException|SES.LimitExceededException|any, data: SES.CloneReceiptRuleSetResponse|any) => void): Request;
    createReceiptFilter(params: SES.CreateReceiptFilterRequest, callback?: (err: SES.LimitExceededException|SES.AlreadyExistsException|any, data: SES.CreateReceiptFilterResponse|any) => void): Request;
    createReceiptRule(params: SES.CreateReceiptRuleRequest, callback?: (err: SES.InvalidSnsTopicException|SES.InvalidS3ConfigurationException|SES.InvalidLambdaFunctionException|SES.AlreadyExistsException|SES.RuleDoesNotExistException|SES.RuleSetDoesNotExistException|SES.LimitExceededException|any, data: SES.CreateReceiptRuleResponse|any) => void): Request;
    createReceiptRuleSet(params: SES.CreateReceiptRuleSetRequest, callback?: (err: SES.AlreadyExistsException|SES.LimitExceededException|any, data: SES.CreateReceiptRuleSetResponse|any) => void): Request;
    deleteIdentity(params: SES.DeleteIdentityRequest, callback?: (err: any, data: SES.DeleteIdentityResponse|any) => void): Request;
    deleteIdentityPolicy(params: SES.DeleteIdentityPolicyRequest, callback?: (err: any, data: SES.DeleteIdentityPolicyResponse|any) => void): Request;
    deleteReceiptFilter(params: SES.DeleteReceiptFilterRequest, callback?: (err: any, data: SES.DeleteReceiptFilterResponse|any) => void): Request;
    deleteReceiptRule(params: SES.DeleteReceiptRuleRequest, callback?: (err: SES.RuleSetDoesNotExistException|any, data: SES.DeleteReceiptRuleResponse|any) => void): Request;
    deleteReceiptRuleSet(params: SES.DeleteReceiptRuleSetRequest, callback?: (err: SES.CannotDeleteException|any, data: SES.DeleteReceiptRuleSetResponse|any) => void): Request;
    deleteVerifiedEmailAddress(params: SES.DeleteVerifiedEmailAddressRequest, callback?: (err: any, data: any) => void): Request;
    describeActiveReceiptRuleSet(params: SES.DescribeActiveReceiptRuleSetRequest, callback?: (err: any, data: SES.DescribeActiveReceiptRuleSetResponse|any) => void): Request;
    describeReceiptRule(params: SES.DescribeReceiptRuleRequest, callback?: (err: SES.RuleDoesNotExistException|SES.RuleSetDoesNotExistException|any, data: SES.DescribeReceiptRuleResponse|any) => void): Request;
    describeReceiptRuleSet(params: SES.DescribeReceiptRuleSetRequest, callback?: (err: SES.RuleSetDoesNotExistException|any, data: SES.DescribeReceiptRuleSetResponse|any) => void): Request;
    getIdentityDkimAttributes(params: SES.GetIdentityDkimAttributesRequest, callback?: (err: any, data: SES.GetIdentityDkimAttributesResponse|any) => void): Request;
    getIdentityMailFromDomainAttributes(params: SES.GetIdentityMailFromDomainAttributesRequest, callback?: (err: any, data: SES.GetIdentityMailFromDomainAttributesResponse|any) => void): Request;
    getIdentityNotificationAttributes(params: SES.GetIdentityNotificationAttributesRequest, callback?: (err: any, data: SES.GetIdentityNotificationAttributesResponse|any) => void): Request;
    getIdentityPolicies(params: SES.GetIdentityPoliciesRequest, callback?: (err: any, data: SES.GetIdentityPoliciesResponse|any) => void): Request;
    getIdentityVerificationAttributes(params: SES.GetIdentityVerificationAttributesRequest, callback?: (err: any, data: SES.GetIdentityVerificationAttributesResponse|any) => void): Request;
    getSendQuota(callback?: (err: any, data: SES.GetSendQuotaResponse|any) => void): Request;
    getSendStatistics(callback?: (err: any, data: SES.GetSendStatisticsResponse|any) => void): Request;
    listIdentities(params: SES.ListIdentitiesRequest, callback?: (err: any, data: SES.ListIdentitiesResponse|any) => void): Request;
    listIdentityPolicies(params: SES.ListIdentityPoliciesRequest, callback?: (err: any, data: SES.ListIdentityPoliciesResponse|any) => void): Request;
    listReceiptFilters(params: SES.ListReceiptFiltersRequest, callback?: (err: any, data: SES.ListReceiptFiltersResponse|any) => void): Request;
    listReceiptRuleSets(params: SES.ListReceiptRuleSetsRequest, callback?: (err: any, data: SES.ListReceiptRuleSetsResponse|any) => void): Request;
    listVerifiedEmailAddresses(callback?: (err: any, data: SES.ListVerifiedEmailAddressesResponse|any) => void): Request;
    putIdentityPolicy(params: SES.PutIdentityPolicyRequest, callback?: (err: SES.InvalidPolicyException|any, data: SES.PutIdentityPolicyResponse|any) => void): Request;
    reorderReceiptRuleSet(params: SES.ReorderReceiptRuleSetRequest, callback?: (err: SES.RuleSetDoesNotExistException|SES.RuleDoesNotExistException|any, data: SES.ReorderReceiptRuleSetResponse|any) => void): Request;
    sendBounce(params: SES.SendBounceRequest, callback?: (err: SES.MessageRejected|any, data: SES.SendBounceResponse|any) => void): Request;
    sendEmail(params: SES.SendEmailRequest, callback?: (err: SES.MessageRejected|SES.MailFromDomainNotVerifiedException|any, data: SES.SendEmailResponse|any) => void): Request;
    sendRawEmail(params: SES.SendRawEmailRequest, callback?: (err: SES.MessageRejected|SES.MailFromDomainNotVerifiedException|any, data: SES.SendRawEmailResponse|any) => void): Request;
    setActiveReceiptRuleSet(params: SES.SetActiveReceiptRuleSetRequest, callback?: (err: SES.RuleSetDoesNotExistException|any, data: SES.SetActiveReceiptRuleSetResponse|any) => void): Request;
    setIdentityDkimEnabled(params: SES.SetIdentityDkimEnabledRequest, callback?: (err: any, data: SES.SetIdentityDkimEnabledResponse|any) => void): Request;
    setIdentityFeedbackForwardingEnabled(params: SES.SetIdentityFeedbackForwardingEnabledRequest, callback?: (err: any, data: SES.SetIdentityFeedbackForwardingEnabledResponse|any) => void): Request;
    setIdentityMailFromDomain(params: SES.SetIdentityMailFromDomainRequest, callback?: (err: any, data: SES.SetIdentityMailFromDomainResponse|any) => void): Request;
    setIdentityNotificationTopic(params: SES.SetIdentityNotificationTopicRequest, callback?: (err: any, data: SES.SetIdentityNotificationTopicResponse|any) => void): Request;
    setReceiptRulePosition(params: SES.SetReceiptRulePositionRequest, callback?: (err: SES.RuleSetDoesNotExistException|SES.RuleDoesNotExistException|any, data: SES.SetReceiptRulePositionResponse|any) => void): Request;
    updateReceiptRule(params: SES.UpdateReceiptRuleRequest, callback?: (err: SES.InvalidSnsTopicException|SES.InvalidS3ConfigurationException|SES.InvalidLambdaFunctionException|SES.RuleSetDoesNotExistException|SES.RuleDoesNotExistException|SES.LimitExceededException|any, data: SES.UpdateReceiptRuleResponse|any) => void): Request;
    verifyDomainDkim(params: SES.VerifyDomainDkimRequest, callback?: (err: any, data: SES.VerifyDomainDkimResponse|any) => void): Request;
    verifyDomainIdentity(params: SES.VerifyDomainIdentityRequest, callback?: (err: any, data: SES.VerifyDomainIdentityResponse|any) => void): Request;
    verifyEmailAddress(params: SES.VerifyEmailAddressRequest, callback?: (err: any, data: any) => void): Request;
    verifyEmailIdentity(params: SES.VerifyEmailIdentityRequest, callback?: (err: any, data: SES.VerifyEmailIdentityResponse|any) => void): Request;

  }

  export module SES {
    export type Address = string;
    export type AddressList = Address[];
    export type AmazonResourceName = string;
    export type ArrivalDate = number;
    export type BehaviorOnMXFailure = string;
    export type BounceMessage = string;
    export type BounceSmtpReplyCode = string;
    export type BounceStatusCode = string;
    export type BounceType = string;
    export type BouncedRecipientInfoList = BouncedRecipientInfo[];
    export type Charset = string;
    export type Cidr = string;
    export type Counter = number;
    export type CustomMailFromStatus = string;
    export type DiagnosticCode = string;
    export type DkimAttributes = {[key:string]: IdentityDkimAttributes};
    export type Domain = string;
    export type DsnAction = string;
    export type DsnStatus = string;
    export type Enabled = boolean;
    export type Explanation = string;
    export type ExtensionFieldList = ExtensionField[];
    export type ExtensionFieldName = string;
    export type ExtensionFieldValue = string;
    export type HeaderName = string;
    export type HeaderValue = string;
    export type Identity = string;
    export type IdentityList = Identity[];
    export type IdentityType = string;
    export type InvocationType = string;
    export type LastAttemptDate = number;
    export type MailFromDomainAttributes = {[key:string]: IdentityMailFromDomainAttributes};
    export type MailFromDomainName = string;
    export type Max24HourSend = number;
    export type MaxItems = number;
    export type MaxSendRate = number;
    export type MessageData = string;
    export type MessageId = string;
    export type NextToken = string;
    export type NotificationAttributes = {[key:string]: IdentityNotificationAttributes};
    export type NotificationTopic = string;
    export type NotificationType = string;
    export type Policy = string;    // min: 1
    export type PolicyMap = {[key:string]: Policy};
    export type PolicyName = string;    // max: 64, min: 1
    export type PolicyNameList = PolicyName[];
    export type RawMessageData = any;    // type: blob
    export type ReceiptActionsList = ReceiptAction[];
    export type ReceiptFilterList = ReceiptFilter[];
    export type ReceiptFilterName = string;
    export type ReceiptFilterPolicy = string;
    export type ReceiptRuleName = string;
    export type ReceiptRuleNamesList = ReceiptRuleName[];
    export type ReceiptRuleSetName = string;
    export type ReceiptRuleSetsLists = ReceiptRuleSetMetadata[];
    export type ReceiptRulesList = ReceiptRule[];
    export type Recipient = string;
    export type RecipientsList = Recipient[];
    export type RemoteMta = string;
    export type ReportingMta = string;
    export type RuleOrRuleSetName = string;
    export type S3BucketName = string;
    export type S3KeyPrefix = string;
    export type SNSActionEncoding = string;
    export type SendDataPointList = SendDataPoint[];
    export type SentLast24Hours = number;
    export type StopScope = string;
    export type Timestamp = number;
    export type TlsPolicy = string;
    export type VerificationAttributes = {[key:string]: IdentityVerificationAttributes};
    export type VerificationStatus = string;
    export type VerificationToken = string;
    export type VerificationTokenList = VerificationToken[];

    export interface AddHeaderAction {
        HeaderName: HeaderName;
        HeaderValue: HeaderValue;
    }
    export interface AlreadyExistsException {
        Name?: RuleOrRuleSetName;
    }
    export interface Body {
        Text?: Content;
        Html?: Content;
    }
    export interface BounceAction {
        TopicArn?: AmazonResourceName;
        SmtpReplyCode: BounceSmtpReplyCode;
        StatusCode?: BounceStatusCode;
        Message: BounceMessage;
        Sender: Address;
    }
    export interface BouncedRecipientInfo {
        Recipient: Address;
        RecipientArn?: AmazonResourceName;
        BounceType?: BounceType;
        RecipientDsnFields?: RecipientDsnFields;
    }
    export interface CannotDeleteException {
        Name?: RuleOrRuleSetName;
    }
    export interface CloneReceiptRuleSetRequest {
        RuleSetName: ReceiptRuleSetName;
        OriginalRuleSetName: ReceiptRuleSetName;
    }
    export interface CloneReceiptRuleSetResponse {
    }
    export interface Content {
        Data: MessageData;
        Charset?: Charset;
    }
    export interface CreateReceiptFilterRequest {
        Filter: ReceiptFilter;
    }
    export interface CreateReceiptFilterResponse {
    }
    export interface CreateReceiptRuleRequest {
        RuleSetName: ReceiptRuleSetName;
        After?: ReceiptRuleName;
        Rule: ReceiptRule;
    }
    export interface CreateReceiptRuleResponse {
    }
    export interface CreateReceiptRuleSetRequest {
        RuleSetName: ReceiptRuleSetName;
    }
    export interface CreateReceiptRuleSetResponse {
    }
    export interface DeleteIdentityPolicyRequest {
        Identity: Identity;
        PolicyName: PolicyName;
    }
    export interface DeleteIdentityPolicyResponse {
    }
    export interface DeleteIdentityRequest {
        Identity: Identity;
    }
    export interface DeleteIdentityResponse {
    }
    export interface DeleteReceiptFilterRequest {
        FilterName: ReceiptFilterName;
    }
    export interface DeleteReceiptFilterResponse {
    }
    export interface DeleteReceiptRuleRequest {
        RuleSetName: ReceiptRuleSetName;
        RuleName: ReceiptRuleName;
    }
    export interface DeleteReceiptRuleResponse {
    }
    export interface DeleteReceiptRuleSetRequest {
        RuleSetName: ReceiptRuleSetName;
    }
    export interface DeleteReceiptRuleSetResponse {
    }
    export interface DeleteVerifiedEmailAddressRequest {
        EmailAddress: Address;
    }
    export interface DescribeActiveReceiptRuleSetRequest {
    }
    export interface DescribeActiveReceiptRuleSetResponse {
        Metadata?: ReceiptRuleSetMetadata;
        Rules?: ReceiptRulesList;
    }
    export interface DescribeReceiptRuleRequest {
        RuleSetName: ReceiptRuleSetName;
        RuleName: ReceiptRuleName;
    }
    export interface DescribeReceiptRuleResponse {
        Rule?: ReceiptRule;
    }
    export interface DescribeReceiptRuleSetRequest {
        RuleSetName: ReceiptRuleSetName;
    }
    export interface DescribeReceiptRuleSetResponse {
        Metadata?: ReceiptRuleSetMetadata;
        Rules?: ReceiptRulesList;
    }
    export interface Destination {
        ToAddresses?: AddressList;
        CcAddresses?: AddressList;
        BccAddresses?: AddressList;
    }
    export interface ExtensionField {
        Name: ExtensionFieldName;
        Value: ExtensionFieldValue;
    }
    export interface GetIdentityDkimAttributesRequest {
        Identities: IdentityList;
    }
    export interface GetIdentityDkimAttributesResponse {
        DkimAttributes: DkimAttributes;
    }
    export interface GetIdentityMailFromDomainAttributesRequest {
        Identities: IdentityList;
    }
    export interface GetIdentityMailFromDomainAttributesResponse {
        MailFromDomainAttributes: MailFromDomainAttributes;
    }
    export interface GetIdentityNotificationAttributesRequest {
        Identities: IdentityList;
    }
    export interface GetIdentityNotificationAttributesResponse {
        NotificationAttributes: NotificationAttributes;
    }
    export interface GetIdentityPoliciesRequest {
        Identity: Identity;
        PolicyNames: PolicyNameList;
    }
    export interface GetIdentityPoliciesResponse {
        Policies: PolicyMap;
    }
    export interface GetIdentityVerificationAttributesRequest {
        Identities: IdentityList;
    }
    export interface GetIdentityVerificationAttributesResponse {
        VerificationAttributes: VerificationAttributes;
    }
    export interface GetSendQuotaResponse {
        Max24HourSend?: Max24HourSend;
        MaxSendRate?: MaxSendRate;
        SentLast24Hours?: SentLast24Hours;
    }
    export interface GetSendStatisticsResponse {
        SendDataPoints?: SendDataPointList;
    }
    export interface IdentityDkimAttributes {
        DkimEnabled: Enabled;
        DkimVerificationStatus: VerificationStatus;
        DkimTokens?: VerificationTokenList;
    }
    export interface IdentityMailFromDomainAttributes {
        MailFromDomain: MailFromDomainName;
        MailFromDomainStatus: CustomMailFromStatus;
        BehaviorOnMXFailure: BehaviorOnMXFailure;
    }
    export interface IdentityNotificationAttributes {
        BounceTopic: NotificationTopic;
        ComplaintTopic: NotificationTopic;
        DeliveryTopic: NotificationTopic;
        ForwardingEnabled: Enabled;
    }
    export interface IdentityVerificationAttributes {
        VerificationStatus: VerificationStatus;
        VerificationToken?: VerificationToken;
    }
    export interface InvalidLambdaFunctionException {
        FunctionArn?: AmazonResourceName;
    }
    export interface InvalidPolicyException {
    }
    export interface InvalidS3ConfigurationException {
        Bucket?: S3BucketName;
    }
    export interface InvalidSnsTopicException {
        Topic?: AmazonResourceName;
    }
    export interface LambdaAction {
        TopicArn?: AmazonResourceName;
        FunctionArn: AmazonResourceName;
        InvocationType?: InvocationType;
    }
    export interface LimitExceededException {
    }
    export interface ListIdentitiesRequest {
        IdentityType?: IdentityType;
        NextToken?: NextToken;
        MaxItems?: MaxItems;
    }
    export interface ListIdentitiesResponse {
        Identities: IdentityList;
        NextToken?: NextToken;
    }
    export interface ListIdentityPoliciesRequest {
        Identity: Identity;
    }
    export interface ListIdentityPoliciesResponse {
        PolicyNames: PolicyNameList;
    }
    export interface ListReceiptFiltersRequest {
    }
    export interface ListReceiptFiltersResponse {
        Filters?: ReceiptFilterList;
    }
    export interface ListReceiptRuleSetsRequest {
        NextToken?: NextToken;
    }
    export interface ListReceiptRuleSetsResponse {
        RuleSets?: ReceiptRuleSetsLists;
        NextToken?: NextToken;
    }
    export interface ListVerifiedEmailAddressesResponse {
        VerifiedEmailAddresses?: AddressList;
    }
    export interface MailFromDomainNotVerifiedException {
    }
    export interface Message {
        Subject: Content;
        Body: Body;
    }
    export interface MessageDsn {
        ReportingMta: ReportingMta;
        ArrivalDate?: ArrivalDate;
        ExtensionFields?: ExtensionFieldList;
    }
    export interface MessageRejected {
    }
    export interface PutIdentityPolicyRequest {
        Identity: Identity;
        PolicyName: PolicyName;
        Policy: Policy;
    }
    export interface PutIdentityPolicyResponse {
    }
    export interface RawMessage {
        Data: RawMessageData;
    }
    export interface ReceiptAction {
        S3Action?: S3Action;
        BounceAction?: BounceAction;
        WorkmailAction?: WorkmailAction;
        LambdaAction?: LambdaAction;
        StopAction?: StopAction;
        AddHeaderAction?: AddHeaderAction;
        SNSAction?: SNSAction;
    }
    export interface ReceiptFilter {
        Name: ReceiptFilterName;
        IpFilter: ReceiptIpFilter;
    }
    export interface ReceiptIpFilter {
        Policy: ReceiptFilterPolicy;
        Cidr: Cidr;
    }
    export interface ReceiptRule {
        Name: ReceiptRuleName;
        Enabled?: Enabled;
        TlsPolicy?: TlsPolicy;
        Recipients?: RecipientsList;
        Actions?: ReceiptActionsList;
        ScanEnabled?: Enabled;
    }
    export interface ReceiptRuleSetMetadata {
        Name?: ReceiptRuleSetName;
        CreatedTimestamp?: Timestamp;
    }
    export interface RecipientDsnFields {
        FinalRecipient?: Address;
        Action: DsnAction;
        RemoteMta?: RemoteMta;
        Status: DsnStatus;
        DiagnosticCode?: DiagnosticCode;
        LastAttemptDate?: LastAttemptDate;
        ExtensionFields?: ExtensionFieldList;
    }
    export interface ReorderReceiptRuleSetRequest {
        RuleSetName: ReceiptRuleSetName;
        RuleNames: ReceiptRuleNamesList;
    }
    export interface ReorderReceiptRuleSetResponse {
    }
    export interface RuleDoesNotExistException {
        Name?: RuleOrRuleSetName;
    }
    export interface RuleSetDoesNotExistException {
        Name?: RuleOrRuleSetName;
    }
    export interface S3Action {
        TopicArn?: AmazonResourceName;
        BucketName: S3BucketName;
        ObjectKeyPrefix?: S3KeyPrefix;
        KmsKeyArn?: AmazonResourceName;
    }
    export interface SNSAction {
        TopicArn: AmazonResourceName;
        Encoding?: SNSActionEncoding;
    }
    export interface SendBounceRequest {
        OriginalMessageId: MessageId;
        BounceSender: Address;
        Explanation?: Explanation;
        MessageDsn?: MessageDsn;
        BouncedRecipientInfoList: BouncedRecipientInfoList;
        BounceSenderArn?: AmazonResourceName;
    }
    export interface SendBounceResponse {
        MessageId?: MessageId;
    }
    export interface SendDataPoint {
        Timestamp?: Timestamp;
        DeliveryAttempts?: Counter;
        Bounces?: Counter;
        Complaints?: Counter;
        Rejects?: Counter;
    }
    export interface SendEmailRequest {
        Source: Address;
        Destination: Destination;
        Message: Message;
        ReplyToAddresses?: AddressList;
        ReturnPath?: Address;
        SourceArn?: AmazonResourceName;
        ReturnPathArn?: AmazonResourceName;
    }
    export interface SendEmailResponse {
        MessageId: MessageId;
    }
    export interface SendRawEmailRequest {
        Source?: Address;
        Destinations?: AddressList;
        RawMessage: RawMessage;
        FromArn?: AmazonResourceName;
        SourceArn?: AmazonResourceName;
        ReturnPathArn?: AmazonResourceName;
    }
    export interface SendRawEmailResponse {
        MessageId: MessageId;
    }
    export interface SetActiveReceiptRuleSetRequest {
        RuleSetName?: ReceiptRuleSetName;
    }
    export interface SetActiveReceiptRuleSetResponse {
    }
    export interface SetIdentityDkimEnabledRequest {
        Identity: Identity;
        DkimEnabled: Enabled;
    }
    export interface SetIdentityDkimEnabledResponse {
    }
    export interface SetIdentityFeedbackForwardingEnabledRequest {
        Identity: Identity;
        ForwardingEnabled: Enabled;
    }
    export interface SetIdentityFeedbackForwardingEnabledResponse {
    }
    export interface SetIdentityMailFromDomainRequest {
        Identity: Identity;
        MailFromDomain?: MailFromDomainName;
        BehaviorOnMXFailure?: BehaviorOnMXFailure;
    }
    export interface SetIdentityMailFromDomainResponse {
    }
    export interface SetIdentityNotificationTopicRequest {
        Identity: Identity;
        NotificationType: NotificationType;
        SnsTopic?: NotificationTopic;
    }
    export interface SetIdentityNotificationTopicResponse {
    }
    export interface SetReceiptRulePositionRequest {
        RuleSetName: ReceiptRuleSetName;
        RuleName: ReceiptRuleName;
        After?: ReceiptRuleName;
    }
    export interface SetReceiptRulePositionResponse {
    }
    export interface StopAction {
        Scope: StopScope;
        TopicArn?: AmazonResourceName;
    }
    export interface UpdateReceiptRuleRequest {
        RuleSetName: ReceiptRuleSetName;
        Rule: ReceiptRule;
    }
    export interface UpdateReceiptRuleResponse {
    }
    export interface VerifyDomainDkimRequest {
        Domain: Domain;
    }
    export interface VerifyDomainDkimResponse {
        DkimTokens: VerificationTokenList;
    }
    export interface VerifyDomainIdentityRequest {
        Domain: Domain;
    }
    export interface VerifyDomainIdentityResponse {
        VerificationToken: VerificationToken;
    }
    export interface VerifyEmailAddressRequest {
        EmailAddress: Address;
    }
    export interface VerifyEmailIdentityRequest {
        EmailAddress: Address;
    }
    export interface VerifyEmailIdentityResponse {
    }
    export interface WorkmailAction {
        TopicArn?: AmazonResourceName;
        OrganizationArn: AmazonResourceName;
    }
  }

  /*
   * apiVersion: 2009-04-15
   * endpointPrefix: sdb
   * serviceAbbreviation: 
   * signatureVersion: v2
   * protocol: query
   */
  export class SimpleDB extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    batchDeleteAttributes(params: SimpleDB.BatchDeleteAttributesRequest, callback?: (err: any, data: any) => void): Request;
    batchPutAttributes(params: SimpleDB.BatchPutAttributesRequest, callback?: (err: SimpleDB.DuplicateItemName|SimpleDB.InvalidParameterValue|SimpleDB.MissingParameter|SimpleDB.NoSuchDomain|SimpleDB.NumberItemAttributesExceeded|SimpleDB.NumberDomainAttributesExceeded|SimpleDB.NumberDomainBytesExceeded|SimpleDB.NumberSubmittedItemsExceeded|SimpleDB.NumberSubmittedAttributesExceeded|any, data: any) => void): Request;
    createDomain(params: SimpleDB.CreateDomainRequest, callback?: (err: SimpleDB.InvalidParameterValue|SimpleDB.MissingParameter|SimpleDB.NumberDomainsExceeded|any, data: any) => void): Request;
    deleteAttributes(params: SimpleDB.DeleteAttributesRequest, callback?: (err: SimpleDB.InvalidParameterValue|SimpleDB.MissingParameter|SimpleDB.NoSuchDomain|SimpleDB.AttributeDoesNotExist|any, data: any) => void): Request;
    deleteDomain(params: SimpleDB.DeleteDomainRequest, callback?: (err: SimpleDB.MissingParameter|any, data: any) => void): Request;
    domainMetadata(params: SimpleDB.DomainMetadataRequest, callback?: (err: SimpleDB.MissingParameter|SimpleDB.NoSuchDomain|any, data: SimpleDB.DomainMetadataResult|any) => void): Request;
    getAttributes(params: SimpleDB.GetAttributesRequest, callback?: (err: SimpleDB.InvalidParameterValue|SimpleDB.MissingParameter|SimpleDB.NoSuchDomain|any, data: SimpleDB.GetAttributesResult|any) => void): Request;
    listDomains(params: SimpleDB.ListDomainsRequest, callback?: (err: SimpleDB.InvalidParameterValue|SimpleDB.InvalidNextToken|any, data: SimpleDB.ListDomainsResult|any) => void): Request;
    putAttributes(params: SimpleDB.PutAttributesRequest, callback?: (err: SimpleDB.InvalidParameterValue|SimpleDB.MissingParameter|SimpleDB.NoSuchDomain|SimpleDB.NumberDomainAttributesExceeded|SimpleDB.NumberDomainBytesExceeded|SimpleDB.NumberItemAttributesExceeded|SimpleDB.AttributeDoesNotExist|any, data: any) => void): Request;
    select(params: SimpleDB.SelectRequest, callback?: (err: SimpleDB.InvalidParameterValue|SimpleDB.InvalidNextToken|SimpleDB.InvalidNumberPredicates|SimpleDB.InvalidNumberValueTests|SimpleDB.InvalidQueryExpression|SimpleDB.MissingParameter|SimpleDB.NoSuchDomain|SimpleDB.RequestTimeout|SimpleDB.TooManyRequestedAttributes|any, data: SimpleDB.SelectResult|any) => void): Request;

  }

  export module SimpleDB {
    export type AttributeList = Attribute[];
    export type AttributeNameList = String[];
    export type Boolean = boolean;
    export type DeletableAttributeList = DeletableAttribute[];
    export type DeletableItemList = DeletableItem[];
    export type DomainNameList = String[];
    export type Float = number;
    export type Integer = number;
    export type ItemList = Item[];
    export type Long = number;
    export type ReplaceableAttributeList = ReplaceableAttribute[];
    export type ReplaceableItemList = ReplaceableItem[];
    export type String = string;

    export interface Attribute {
        Name: String;
        AlternateNameEncoding?: String;
        Value: String;
        AlternateValueEncoding?: String;
    }
    export interface AttributeDoesNotExist {
        BoxUsage?: Float;
    }
    export interface BatchDeleteAttributesRequest {
        DomainName: String;
        Items: DeletableItemList;
    }
    export interface BatchPutAttributesRequest {
        DomainName: String;
        Items: ReplaceableItemList;
    }
    export interface CreateDomainRequest {
        DomainName: String;
    }
    export interface DeletableAttribute {
        Name: String;
        Value?: String;
    }
    export interface DeletableItem {
        Name: String;
        Attributes?: DeletableAttributeList;
    }
    export interface DeleteAttributesRequest {
        DomainName: String;
        ItemName: String;
        Attributes?: DeletableAttributeList;
        Expected?: UpdateCondition;
    }
    export interface DeleteDomainRequest {
        DomainName: String;
    }
    export interface DomainMetadataRequest {
        DomainName: String;
    }
    export interface DomainMetadataResult {
        ItemCount?: Integer;
        ItemNamesSizeBytes?: Long;
        AttributeNameCount?: Integer;
        AttributeNamesSizeBytes?: Long;
        AttributeValueCount?: Integer;
        AttributeValuesSizeBytes?: Long;
        Timestamp?: Integer;
    }
    export interface DuplicateItemName {
        BoxUsage?: Float;
    }
    export interface GetAttributesRequest {
        DomainName: String;
        ItemName: String;
        AttributeNames?: AttributeNameList;
        ConsistentRead?: Boolean;
    }
    export interface GetAttributesResult {
        Attributes?: AttributeList;
    }
    export interface InvalidNextToken {
        BoxUsage?: Float;
    }
    export interface InvalidNumberPredicates {
        BoxUsage?: Float;
    }
    export interface InvalidNumberValueTests {
        BoxUsage?: Float;
    }
    export interface InvalidParameterValue {
        BoxUsage?: Float;
    }
    export interface InvalidQueryExpression {
        BoxUsage?: Float;
    }
    export interface Item {
        Name: String;
        AlternateNameEncoding?: String;
        Attributes: AttributeList;
    }
    export interface ListDomainsRequest {
        MaxNumberOfDomains?: Integer;
        NextToken?: String;
    }
    export interface ListDomainsResult {
        DomainNames?: DomainNameList;
        NextToken?: String;
    }
    export interface MissingParameter {
        BoxUsage?: Float;
    }
    export interface NoSuchDomain {
        BoxUsage?: Float;
    }
    export interface NumberDomainAttributesExceeded {
        BoxUsage?: Float;
    }
    export interface NumberDomainBytesExceeded {
        BoxUsage?: Float;
    }
    export interface NumberDomainsExceeded {
        BoxUsage?: Float;
    }
    export interface NumberItemAttributesExceeded {
        BoxUsage?: Float;
    }
    export interface NumberSubmittedAttributesExceeded {
        BoxUsage?: Float;
    }
    export interface NumberSubmittedItemsExceeded {
        BoxUsage?: Float;
    }
    export interface PutAttributesRequest {
        DomainName: String;
        ItemName: String;
        Attributes: ReplaceableAttributeList;
        Expected?: UpdateCondition;
    }
    export interface ReplaceableAttribute {
        Name: String;
        Value: String;
        Replace?: Boolean;
    }
    export interface ReplaceableItem {
        Name: String;
        Attributes: ReplaceableAttributeList;
    }
    export interface RequestTimeout {
        BoxUsage?: Float;
    }
    export interface SelectRequest {
        SelectExpression: String;
        NextToken?: String;
        ConsistentRead?: Boolean;
    }
    export interface SelectResult {
        Items?: ItemList;
        NextToken?: String;
    }
    export interface TooManyRequestedAttributes {
        BoxUsage?: Float;
    }
    export interface UpdateCondition {
        Name?: String;
        Value?: String;
        Exists?: Boolean;
    }
  }

  /*
   * apiVersion: 2010-03-31
   * endpointPrefix: sns
   * serviceAbbreviation: Amazon SNS
   * signatureVersion: v4
   * protocol: query
   */
  export class SNS extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    addPermission(params: SNS.AddPermissionInput, callback?: (err: SNS.InvalidParameterException|SNS.InternalErrorException|SNS.AuthorizationErrorException|SNS.NotFoundException|any, data: any) => void): Request;
    confirmSubscription(params: SNS.ConfirmSubscriptionInput, callback?: (err: SNS.SubscriptionLimitExceededException|SNS.InvalidParameterException|SNS.NotFoundException|SNS.InternalErrorException|SNS.AuthorizationErrorException|any, data: SNS.ConfirmSubscriptionResponse|any) => void): Request;
    createPlatformApplication(params: SNS.CreatePlatformApplicationInput, callback?: (err: SNS.InvalidParameterException|SNS.InternalErrorException|SNS.AuthorizationErrorException|any, data: SNS.CreatePlatformApplicationResponse|any) => void): Request;
    createPlatformEndpoint(params: SNS.CreatePlatformEndpointInput, callback?: (err: SNS.InvalidParameterException|SNS.InternalErrorException|SNS.AuthorizationErrorException|SNS.NotFoundException|any, data: SNS.CreateEndpointResponse|any) => void): Request;
    createTopic(params: SNS.CreateTopicInput, callback?: (err: SNS.InvalidParameterException|SNS.TopicLimitExceededException|SNS.InternalErrorException|SNS.AuthorizationErrorException|any, data: SNS.CreateTopicResponse|any) => void): Request;
    deleteEndpoint(params: SNS.DeleteEndpointInput, callback?: (err: SNS.InvalidParameterException|SNS.InternalErrorException|SNS.AuthorizationErrorException|any, data: any) => void): Request;
    deletePlatformApplication(params: SNS.DeletePlatformApplicationInput, callback?: (err: SNS.InvalidParameterException|SNS.InternalErrorException|SNS.AuthorizationErrorException|any, data: any) => void): Request;
    deleteTopic(params: SNS.DeleteTopicInput, callback?: (err: SNS.InvalidParameterException|SNS.InternalErrorException|SNS.AuthorizationErrorException|SNS.NotFoundException|any, data: any) => void): Request;
    getEndpointAttributes(params: SNS.GetEndpointAttributesInput, callback?: (err: SNS.InvalidParameterException|SNS.InternalErrorException|SNS.AuthorizationErrorException|SNS.NotFoundException|any, data: SNS.GetEndpointAttributesResponse|any) => void): Request;
    getPlatformApplicationAttributes(params: SNS.GetPlatformApplicationAttributesInput, callback?: (err: SNS.InvalidParameterException|SNS.InternalErrorException|SNS.AuthorizationErrorException|SNS.NotFoundException|any, data: SNS.GetPlatformApplicationAttributesResponse|any) => void): Request;
    getSubscriptionAttributes(params: SNS.GetSubscriptionAttributesInput, callback?: (err: SNS.InvalidParameterException|SNS.InternalErrorException|SNS.NotFoundException|SNS.AuthorizationErrorException|any, data: SNS.GetSubscriptionAttributesResponse|any) => void): Request;
    getTopicAttributes(params: SNS.GetTopicAttributesInput, callback?: (err: SNS.InvalidParameterException|SNS.InternalErrorException|SNS.NotFoundException|SNS.AuthorizationErrorException|any, data: SNS.GetTopicAttributesResponse|any) => void): Request;
    listEndpointsByPlatformApplication(params: SNS.ListEndpointsByPlatformApplicationInput, callback?: (err: SNS.InvalidParameterException|SNS.InternalErrorException|SNS.AuthorizationErrorException|SNS.NotFoundException|any, data: SNS.ListEndpointsByPlatformApplicationResponse|any) => void): Request;
    listPlatformApplications(params: SNS.ListPlatformApplicationsInput, callback?: (err: SNS.InvalidParameterException|SNS.InternalErrorException|SNS.AuthorizationErrorException|any, data: SNS.ListPlatformApplicationsResponse|any) => void): Request;
    listSubscriptions(params: SNS.ListSubscriptionsInput, callback?: (err: SNS.InvalidParameterException|SNS.InternalErrorException|SNS.AuthorizationErrorException|any, data: SNS.ListSubscriptionsResponse|any) => void): Request;
    listSubscriptionsByTopic(params: SNS.ListSubscriptionsByTopicInput, callback?: (err: SNS.InvalidParameterException|SNS.InternalErrorException|SNS.NotFoundException|SNS.AuthorizationErrorException|any, data: SNS.ListSubscriptionsByTopicResponse|any) => void): Request;
    listTopics(params: SNS.ListTopicsInput, callback?: (err: SNS.InvalidParameterException|SNS.InternalErrorException|SNS.AuthorizationErrorException|any, data: SNS.ListTopicsResponse|any) => void): Request;
    publish(params: SNS.PublishInput, callback?: (err: SNS.InvalidParameterException|SNS.InvalidParameterValueException|SNS.InternalErrorException|SNS.NotFoundException|SNS.EndpointDisabledException|SNS.PlatformApplicationDisabledException|SNS.AuthorizationErrorException|any, data: SNS.PublishResponse|any) => void): Request;
    removePermission(params: SNS.RemovePermissionInput, callback?: (err: SNS.InvalidParameterException|SNS.InternalErrorException|SNS.AuthorizationErrorException|SNS.NotFoundException|any, data: any) => void): Request;
    setEndpointAttributes(params: SNS.SetEndpointAttributesInput, callback?: (err: SNS.InvalidParameterException|SNS.InternalErrorException|SNS.AuthorizationErrorException|SNS.NotFoundException|any, data: any) => void): Request;
    setPlatformApplicationAttributes(params: SNS.SetPlatformApplicationAttributesInput, callback?: (err: SNS.InvalidParameterException|SNS.InternalErrorException|SNS.AuthorizationErrorException|SNS.NotFoundException|any, data: any) => void): Request;
    setSubscriptionAttributes(params: SNS.SetSubscriptionAttributesInput, callback?: (err: SNS.InvalidParameterException|SNS.InternalErrorException|SNS.NotFoundException|SNS.AuthorizationErrorException|any, data: any) => void): Request;
    setTopicAttributes(params: SNS.SetTopicAttributesInput, callback?: (err: SNS.InvalidParameterException|SNS.InternalErrorException|SNS.NotFoundException|SNS.AuthorizationErrorException|any, data: any) => void): Request;
    subscribe(params: SNS.SubscribeInput, callback?: (err: SNS.SubscriptionLimitExceededException|SNS.InvalidParameterException|SNS.InternalErrorException|SNS.NotFoundException|SNS.AuthorizationErrorException|any, data: SNS.SubscribeResponse|any) => void): Request;
    unsubscribe(params: SNS.UnsubscribeInput, callback?: (err: SNS.InvalidParameterException|SNS.InternalErrorException|SNS.AuthorizationErrorException|SNS.NotFoundException|any, data: any) => void): Request;

  }

  export module SNS {
    export type ActionsList = action[];
    export type Binary = any;    // type: blob
    export type DelegatesList = delegate[];
    export type ListOfEndpoints = Endpoint[];
    export type ListOfPlatformApplications = PlatformApplication[];
    export type MapStringToString = {[key:string]: String};
    export type MessageAttributeMap = {[key:string]: MessageAttributeValue};
    export type String = string;
    export type SubscriptionAttributesMap = {[key:string]: attributeValue};
    export type SubscriptionsList = Subscription[];
    export type TopicAttributesMap = {[key:string]: attributeValue};
    export type TopicsList = Topic[];
    export type account = string;
    export type action = string;
    export type attributeName = string;
    export type attributeValue = string;
    export type authenticateOnUnsubscribe = string;
    export type delegate = string;
    export type endpoint = string;
    export type label = string;
    export type message = string;
    export type messageId = string;
    export type messageStructure = string;
    export type nextToken = string;
    export type protocol = string;
    export type subject = string;
    export type subscriptionARN = string;
    export type token = string;
    export type topicARN = string;
    export type topicName = string;

    export interface AddPermissionInput {
        TopicArn: topicARN;
        Label: label;
        AWSAccountId: DelegatesList;
        ActionName: ActionsList;
    }
    export interface AuthorizationErrorException {
        message?: string;
    }
    export interface ConfirmSubscriptionInput {
        TopicArn: topicARN;
        Token: token;
        AuthenticateOnUnsubscribe?: authenticateOnUnsubscribe;
    }
    export interface ConfirmSubscriptionResponse {
        SubscriptionArn?: subscriptionARN;
    }
    export interface CreateEndpointResponse {
        EndpointArn?: String;
    }
    export interface CreatePlatformApplicationInput {
        Name: String;
        Platform: String;
        Attributes: MapStringToString;
    }
    export interface CreatePlatformApplicationResponse {
        PlatformApplicationArn?: String;
    }
    export interface CreatePlatformEndpointInput {
        PlatformApplicationArn: String;
        Token: String;
        CustomUserData?: String;
        Attributes?: MapStringToString;
    }
    export interface CreateTopicInput {
        Name: topicName;
    }
    export interface CreateTopicResponse {
        TopicArn?: topicARN;
    }
    export interface DeleteEndpointInput {
        EndpointArn: String;
    }
    export interface DeletePlatformApplicationInput {
        PlatformApplicationArn: String;
    }
    export interface DeleteTopicInput {
        TopicArn: topicARN;
    }
    export interface Endpoint {
        EndpointArn?: String;
        Attributes?: MapStringToString;
    }
    export interface EndpointDisabledException {
        message?: string;
    }
    export interface GetEndpointAttributesInput {
        EndpointArn: String;
    }
    export interface GetEndpointAttributesResponse {
        Attributes?: MapStringToString;
    }
    export interface GetPlatformApplicationAttributesInput {
        PlatformApplicationArn: String;
    }
    export interface GetPlatformApplicationAttributesResponse {
        Attributes?: MapStringToString;
    }
    export interface GetSubscriptionAttributesInput {
        SubscriptionArn: subscriptionARN;
    }
    export interface GetSubscriptionAttributesResponse {
        Attributes?: SubscriptionAttributesMap;
    }
    export interface GetTopicAttributesInput {
        TopicArn: topicARN;
    }
    export interface GetTopicAttributesResponse {
        Attributes?: TopicAttributesMap;
    }
    export interface InternalErrorException {
        message?: string;
    }
    export interface InvalidParameterException {
        message?: string;
    }
    export interface InvalidParameterValueException {
        message?: string;
    }
    export interface ListEndpointsByPlatformApplicationInput {
        PlatformApplicationArn: String;
        NextToken?: String;
    }
    export interface ListEndpointsByPlatformApplicationResponse {
        Endpoints?: ListOfEndpoints;
        NextToken?: String;
    }
    export interface ListPlatformApplicationsInput {
        NextToken?: String;
    }
    export interface ListPlatformApplicationsResponse {
        PlatformApplications?: ListOfPlatformApplications;
        NextToken?: String;
    }
    export interface ListSubscriptionsByTopicInput {
        TopicArn: topicARN;
        NextToken?: nextToken;
    }
    export interface ListSubscriptionsByTopicResponse {
        Subscriptions?: SubscriptionsList;
        NextToken?: nextToken;
    }
    export interface ListSubscriptionsInput {
        NextToken?: nextToken;
    }
    export interface ListSubscriptionsResponse {
        Subscriptions?: SubscriptionsList;
        NextToken?: nextToken;
    }
    export interface ListTopicsInput {
        NextToken?: nextToken;
    }
    export interface ListTopicsResponse {
        Topics?: TopicsList;
        NextToken?: nextToken;
    }
    export interface MessageAttributeValue {
        DataType: String;
        StringValue?: String;
        BinaryValue?: Binary;
    }
    export interface NotFoundException {
        message?: string;
    }
    export interface PlatformApplication {
        PlatformApplicationArn?: String;
        Attributes?: MapStringToString;
    }
    export interface PlatformApplicationDisabledException {
        message?: string;
    }
    export interface PublishInput {
        TopicArn?: topicARN;
        TargetArn?: String;
        Message: message;
        Subject?: subject;
        MessageStructure?: messageStructure;
        MessageAttributes?: MessageAttributeMap;
    }
    export interface PublishResponse {
        MessageId?: messageId;
    }
    export interface RemovePermissionInput {
        TopicArn: topicARN;
        Label: label;
    }
    export interface SetEndpointAttributesInput {
        EndpointArn: String;
        Attributes: MapStringToString;
    }
    export interface SetPlatformApplicationAttributesInput {
        PlatformApplicationArn: String;
        Attributes: MapStringToString;
    }
    export interface SetSubscriptionAttributesInput {
        SubscriptionArn: subscriptionARN;
        AttributeName: attributeName;
        AttributeValue?: attributeValue;
    }
    export interface SetTopicAttributesInput {
        TopicArn: topicARN;
        AttributeName: attributeName;
        AttributeValue?: attributeValue;
    }
    export interface SubscribeInput {
        TopicArn: topicARN;
        Protocol: protocol;
        Endpoint?: endpoint;
    }
    export interface SubscribeResponse {
        SubscriptionArn?: subscriptionARN;
    }
    export interface Subscription {
        SubscriptionArn?: subscriptionARN;
        Owner?: account;
        Protocol?: protocol;
        Endpoint?: endpoint;
        TopicArn?: topicARN;
    }
    export interface SubscriptionLimitExceededException {
        message?: string;
    }
    export interface Topic {
        TopicArn?: topicARN;
    }
    export interface TopicLimitExceededException {
        message?: string;
    }
    export interface UnsubscribeInput {
        SubscriptionArn: subscriptionARN;
    }
  }

  /*
   * apiVersion: 2012-11-05
   * endpointPrefix: sqs
   * serviceAbbreviation: Amazon SQS
   * signatureVersion: v4
   * protocol: query
   */
  export class SQS extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    addPermission(params: SQS.AddPermissionRequest, callback?: (err: SQS.OverLimit|any, data: any) => void): Request;
    changeMessageVisibility(params: SQS.ChangeMessageVisibilityRequest, callback?: (err: SQS.MessageNotInflight|SQS.ReceiptHandleIsInvalid|any, data: any) => void): Request;
    changeMessageVisibilityBatch(params: SQS.ChangeMessageVisibilityBatchRequest, callback?: (err: SQS.TooManyEntriesInBatchRequest|SQS.EmptyBatchRequest|SQS.BatchEntryIdsNotDistinct|SQS.InvalidBatchEntryId|any, data: SQS.ChangeMessageVisibilityBatchResult|any) => void): Request;
    createQueue(params: SQS.CreateQueueRequest, callback?: (err: SQS.QueueDeletedRecently|SQS.QueueNameExists|any, data: SQS.CreateQueueResult|any) => void): Request;
    deleteMessage(params: SQS.DeleteMessageRequest, callback?: (err: SQS.InvalidIdFormat|SQS.ReceiptHandleIsInvalid|any, data: any) => void): Request;
    deleteMessageBatch(params: SQS.DeleteMessageBatchRequest, callback?: (err: SQS.TooManyEntriesInBatchRequest|SQS.EmptyBatchRequest|SQS.BatchEntryIdsNotDistinct|SQS.InvalidBatchEntryId|any, data: SQS.DeleteMessageBatchResult|any) => void): Request;
    deleteQueue(params: SQS.DeleteQueueRequest, callback?: (err: any, data: any) => void): Request;
    getQueueAttributes(params: SQS.GetQueueAttributesRequest, callback?: (err: SQS.InvalidAttributeName|any, data: SQS.GetQueueAttributesResult|any) => void): Request;
    getQueueUrl(params: SQS.GetQueueUrlRequest, callback?: (err: SQS.QueueDoesNotExist|any, data: SQS.GetQueueUrlResult|any) => void): Request;
    listDeadLetterSourceQueues(params: SQS.ListDeadLetterSourceQueuesRequest, callback?: (err: SQS.QueueDoesNotExist|any, data: SQS.ListDeadLetterSourceQueuesResult|any) => void): Request;
    listQueues(params: SQS.ListQueuesRequest, callback?: (err: any, data: SQS.ListQueuesResult|any) => void): Request;
    purgeQueue(params: SQS.PurgeQueueRequest, callback?: (err: SQS.QueueDoesNotExist|SQS.PurgeQueueInProgress|any, data: any) => void): Request;
    receiveMessage(params: SQS.ReceiveMessageRequest, callback?: (err: SQS.OverLimit|any, data: SQS.ReceiveMessageResult|any) => void): Request;
    removePermission(params: SQS.RemovePermissionRequest, callback?: (err: any, data: any) => void): Request;
    sendMessage(params: SQS.SendMessageRequest, callback?: (err: SQS.InvalidMessageContents|SQS.UnsupportedOperation|any, data: SQS.SendMessageResult|any) => void): Request;
    sendMessageBatch(params: SQS.SendMessageBatchRequest, callback?: (err: SQS.TooManyEntriesInBatchRequest|SQS.EmptyBatchRequest|SQS.BatchEntryIdsNotDistinct|SQS.BatchRequestTooLong|SQS.InvalidBatchEntryId|SQS.UnsupportedOperation|any, data: SQS.SendMessageBatchResult|any) => void): Request;
    setQueueAttributes(params: SQS.SetQueueAttributesRequest, callback?: (err: SQS.InvalidAttributeName|any, data: any) => void): Request;

  }

  export module SQS {
    export type AWSAccountIdList = String[];
    export type ActionNameList = String[];
    export type AttributeMap = {[key:string]: String};
    export type AttributeNameList = QueueAttributeName[];
    export type BatchResultErrorEntryList = BatchResultErrorEntry[];
    export type Binary = any;    // type: blob
    export type BinaryList = Binary[];
    export type Boolean = boolean;
    export type ChangeMessageVisibilityBatchRequestEntryList = ChangeMessageVisibilityBatchRequestEntry[];
    export type ChangeMessageVisibilityBatchResultEntryList = ChangeMessageVisibilityBatchResultEntry[];
    export type DeleteMessageBatchRequestEntryList = DeleteMessageBatchRequestEntry[];
    export type DeleteMessageBatchResultEntryList = DeleteMessageBatchResultEntry[];
    export type Integer = number;
    export type MessageAttributeMap = {[key:string]: MessageAttributeValue};
    export type MessageAttributeName = string;
    export type MessageAttributeNameList = MessageAttributeName[];
    export type MessageList = Message[];
    export type QueueAttributeName = string;
    export type QueueUrlList = String[];
    export type SendMessageBatchRequestEntryList = SendMessageBatchRequestEntry[];
    export type SendMessageBatchResultEntryList = SendMessageBatchResultEntry[];
    export type String = string;
    export type StringList = String[];

    export interface AddPermissionRequest {
        QueueUrl: String;
        Label: String;
        AWSAccountIds: AWSAccountIdList;
        Actions: ActionNameList;
    }
    export interface BatchEntryIdsNotDistinct {
    }
    export interface BatchRequestTooLong {
    }
    export interface BatchResultErrorEntry {
        Id: String;
        SenderFault: Boolean;
        Code: String;
        Message?: String;
    }
    export interface ChangeMessageVisibilityBatchRequest {
        QueueUrl: String;
        Entries: ChangeMessageVisibilityBatchRequestEntryList;
    }
    export interface ChangeMessageVisibilityBatchRequestEntry {
        Id: String;
        ReceiptHandle: String;
        VisibilityTimeout?: Integer;
    }
    export interface ChangeMessageVisibilityBatchResult {
        Successful: ChangeMessageVisibilityBatchResultEntryList;
        Failed: BatchResultErrorEntryList;
    }
    export interface ChangeMessageVisibilityBatchResultEntry {
        Id: String;
    }
    export interface ChangeMessageVisibilityRequest {
        QueueUrl: String;
        ReceiptHandle: String;
        VisibilityTimeout: Integer;
    }
    export interface CreateQueueRequest {
        QueueName: String;
        Attributes?: AttributeMap;
    }
    export interface CreateQueueResult {
        QueueUrl?: String;
    }
    export interface DeleteMessageBatchRequest {
        QueueUrl: String;
        Entries: DeleteMessageBatchRequestEntryList;
    }
    export interface DeleteMessageBatchRequestEntry {
        Id: String;
        ReceiptHandle: String;
    }
    export interface DeleteMessageBatchResult {
        Successful: DeleteMessageBatchResultEntryList;
        Failed: BatchResultErrorEntryList;
    }
    export interface DeleteMessageBatchResultEntry {
        Id: String;
    }
    export interface DeleteMessageRequest {
        QueueUrl: String;
        ReceiptHandle: String;
    }
    export interface DeleteQueueRequest {
        QueueUrl: String;
    }
    export interface EmptyBatchRequest {
    }
    export interface GetQueueAttributesRequest {
        QueueUrl: String;
        AttributeNames?: AttributeNameList;
    }
    export interface GetQueueAttributesResult {
        Attributes?: AttributeMap;
    }
    export interface GetQueueUrlRequest {
        QueueName: String;
        QueueOwnerAWSAccountId?: String;
    }
    export interface GetQueueUrlResult {
        QueueUrl?: String;
    }
    export interface InvalidAttributeName {
    }
    export interface InvalidBatchEntryId {
    }
    export interface InvalidIdFormat {
    }
    export interface InvalidMessageContents {
    }
    export interface ListDeadLetterSourceQueuesRequest {
        QueueUrl: String;
    }
    export interface ListDeadLetterSourceQueuesResult {
        queueUrls: QueueUrlList;
    }
    export interface ListQueuesRequest {
        QueueNamePrefix?: String;
    }
    export interface ListQueuesResult {
        QueueUrls?: QueueUrlList;
    }
    export interface Message {
        MessageId?: String;
        ReceiptHandle?: String;
        MD5OfBody?: String;
        Body?: String;
        Attributes?: AttributeMap;
        MD5OfMessageAttributes?: String;
        MessageAttributes?: MessageAttributeMap;
    }
    export interface MessageAttributeValue {
        StringValue?: String;
        BinaryValue?: Binary;
        StringListValues?: StringList;
        BinaryListValues?: BinaryList;
        DataType: String;
    }
    export interface MessageNotInflight {
    }
    export interface OverLimit {
    }
    export interface PurgeQueueInProgress {
    }
    export interface PurgeQueueRequest {
        QueueUrl: String;
    }
    export interface QueueDeletedRecently {
    }
    export interface QueueDoesNotExist {
    }
    export interface QueueNameExists {
    }
    export interface ReceiptHandleIsInvalid {
    }
    export interface ReceiveMessageRequest {
        QueueUrl: String;
        AttributeNames?: AttributeNameList;
        MessageAttributeNames?: MessageAttributeNameList;
        MaxNumberOfMessages?: Integer;
        VisibilityTimeout?: Integer;
        WaitTimeSeconds?: Integer;
    }
    export interface ReceiveMessageResult {
        Messages?: MessageList;
    }
    export interface RemovePermissionRequest {
        QueueUrl: String;
        Label: String;
    }
    export interface SendMessageBatchRequest {
        QueueUrl: String;
        Entries: SendMessageBatchRequestEntryList;
    }
    export interface SendMessageBatchRequestEntry {
        Id: String;
        MessageBody: String;
        DelaySeconds?: Integer;
        MessageAttributes?: MessageAttributeMap;
    }
    export interface SendMessageBatchResult {
        Successful: SendMessageBatchResultEntryList;
        Failed: BatchResultErrorEntryList;
    }
    export interface SendMessageBatchResultEntry {
        Id: String;
        MessageId: String;
        MD5OfMessageBody: String;
        MD5OfMessageAttributes?: String;
    }
    export interface SendMessageRequest {
        QueueUrl: String;
        MessageBody: String;
        DelaySeconds?: Integer;
        MessageAttributes?: MessageAttributeMap;
    }
    export interface SendMessageResult {
        MD5OfMessageBody?: String;
        MD5OfMessageAttributes?: String;
        MessageId?: String;
    }
    export interface SetQueueAttributesRequest {
        QueueUrl: String;
        Attributes: AttributeMap;
    }
    export interface TooManyEntriesInBatchRequest {
    }
    export interface UnsupportedOperation {
    }
  }

  /*
   * apiVersion: 2014-11-06
   * endpointPrefix: ssm
   * serviceAbbreviation: Amazon SSM
   * signatureVersion: v4
   * protocol: json
   */
  export class SSM extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    cancelCommand(params: SSM.CancelCommandRequest, callback?: (err: SSM.InvalidCommandId|SSM.InvalidInstanceId|SSM.DuplicateInstanceId|any, data: SSM.CancelCommandResult|any) => void): Request;
    createAssociation(params: SSM.CreateAssociationRequest, callback?: (err: SSM.AssociationAlreadyExists|SSM.AssociationLimitExceeded|SSM.InternalServerError|SSM.InvalidDocument|SSM.InvalidInstanceId|SSM.UnsupportedPlatformType|SSM.InvalidParameters|any, data: SSM.CreateAssociationResult|any) => void): Request;
    createAssociationBatch(params: SSM.CreateAssociationBatchRequest, callback?: (err: SSM.InternalServerError|SSM.InvalidDocument|SSM.InvalidInstanceId|SSM.InvalidParameters|SSM.DuplicateInstanceId|SSM.AssociationLimitExceeded|SSM.UnsupportedPlatformType|any, data: SSM.CreateAssociationBatchResult|any) => void): Request;
    createDocument(params: SSM.CreateDocumentRequest, callback?: (err: SSM.DocumentAlreadyExists|SSM.MaxDocumentSizeExceeded|SSM.InternalServerError|SSM.InvalidDocumentContent|SSM.DocumentLimitExceeded|any, data: SSM.CreateDocumentResult|any) => void): Request;
    deleteAssociation(params: SSM.DeleteAssociationRequest, callback?: (err: SSM.AssociationDoesNotExist|SSM.InternalServerError|SSM.InvalidDocument|SSM.InvalidInstanceId|SSM.TooManyUpdates|any, data: SSM.DeleteAssociationResult|any) => void): Request;
    deleteDocument(params: SSM.DeleteDocumentRequest, callback?: (err: SSM.InternalServerError|SSM.InvalidDocument|SSM.AssociatedInstances|any, data: SSM.DeleteDocumentResult|any) => void): Request;
    describeAssociation(params: SSM.DescribeAssociationRequest, callback?: (err: SSM.AssociationDoesNotExist|SSM.InternalServerError|SSM.InvalidDocument|SSM.InvalidInstanceId|any, data: SSM.DescribeAssociationResult|any) => void): Request;
    describeDocument(params: SSM.DescribeDocumentRequest, callback?: (err: SSM.InternalServerError|SSM.InvalidDocument|any, data: SSM.DescribeDocumentResult|any) => void): Request;
    describeInstanceInformation(params: SSM.DescribeInstanceInformationRequest, callback?: (err: SSM.InternalServerError|SSM.InvalidInstanceId|SSM.InvalidNextToken|SSM.InvalidInstanceInformationFilterValue|SSM.InvalidFilterKey|any, data: SSM.DescribeInstanceInformationResult|any) => void): Request;
    getDocument(params: SSM.GetDocumentRequest, callback?: (err: SSM.InternalServerError|SSM.InvalidDocument|any, data: SSM.GetDocumentResult|any) => void): Request;
    listAssociations(params: SSM.ListAssociationsRequest, callback?: (err: SSM.InternalServerError|SSM.InvalidNextToken|any, data: SSM.ListAssociationsResult|any) => void): Request;
    listCommandInvocations(params: SSM.ListCommandInvocationsRequest, callback?: (err: SSM.InvalidCommandId|SSM.InvalidInstanceId|SSM.InvalidFilterKey|SSM.InvalidNextToken|any, data: SSM.ListCommandInvocationsResult|any) => void): Request;
    listCommands(params: SSM.ListCommandsRequest, callback?: (err: SSM.InvalidCommandId|SSM.InvalidInstanceId|SSM.InvalidFilterKey|SSM.InvalidNextToken|any, data: SSM.ListCommandsResult|any) => void): Request;
    listDocuments(params: SSM.ListDocumentsRequest, callback?: (err: SSM.InternalServerError|SSM.InvalidNextToken|SSM.InvalidFilterKey|any, data: SSM.ListDocumentsResult|any) => void): Request;
    sendCommand(params: SSM.SendCommandRequest, callback?: (err: SSM.DuplicateInstanceId|SSM.InvalidInstanceId|SSM.InvalidDocument|SSM.InvalidOutputFolder|SSM.InvalidParameters|SSM.UnsupportedPlatformType|any, data: SSM.SendCommandResult|any) => void): Request;
    updateAssociationStatus(params: SSM.UpdateAssociationStatusRequest, callback?: (err: SSM.InternalServerError|SSM.InvalidInstanceId|SSM.InvalidDocument|SSM.AssociationDoesNotExist|SSM.StatusUnchanged|SSM.TooManyUpdates|any, data: SSM.UpdateAssociationStatusResult|any) => void): Request;

  }

  export module SSM {
    export type AssociationDescriptionList = AssociationDescription[];
    export type AssociationFilterKey = string;
    export type AssociationFilterList = AssociationFilter[];    // min: 1
    export type AssociationFilterValue = string;    // min: 1
    export type AssociationList = Association[];
    export type AssociationStatusName = string;
    export type BatchErrorMessage = string;
    export type Boolean = boolean;
    export type CommandFilterKey = string;
    export type CommandFilterList = CommandFilter[];    // max: 3, min: 1
    export type CommandFilterValue = string;    // min: 1
    export type CommandId = string;    // max: 36, min: 36
    export type CommandInvocationList = CommandInvocation[];
    export type CommandInvocationStatus = string;
    export type CommandList = Command[];
    export type CommandMaxResults = number;    // max: 50, min: 1
    export type CommandPluginList = CommandPlugin[];
    export type CommandPluginName = string;    // min: 4
    export type CommandPluginOutput = string;    // max: 2500
    export type CommandPluginStatus = string;
    export type CommandStatus = string;
    export type Comment = string;    // max: 100
    export type CreateAssociationBatchRequestEntries = CreateAssociationBatchRequestEntry[];
    export type DateTime = number;
    export type DescriptionInDocument = string;
    export type DocumentContent = string;    // min: 1
    export type DocumentFilterKey = string;
    export type DocumentFilterList = DocumentFilter[];    // min: 1
    export type DocumentFilterValue = string;    // min: 1
    export type DocumentIdentifierList = DocumentIdentifier[];
    export type DocumentName = string;    // pattern: &quot;^[a-zA-Z0-9_\-.]{3,128}$&quot;
    export type DocumentParameterDefaultValue = string;
    export type DocumentParameterDescrption = string;
    export type DocumentParameterList = DocumentParameter[];
    export type DocumentParameterName = string;
    export type DocumentParameterType = string;
    export type DocumentSha1 = string;
    export type DocumentStatus = string;
    export type FailedCreateAssociationList = FailedCreateAssociation[];
    export type Fault = string;
    export type InstanceId = string;    // pattern: &quot;(^i-(\w{8}|\w{17})$)|(^op-\w{17}$)&quot;
    export type InstanceIdList = InstanceId[];    // max: 50, min: 1
    export type InstanceInformationFilterKey = string;
    export type InstanceInformationFilterList = InstanceInformationFilter[];    // min: 1
    export type InstanceInformationFilterValue = string;    // min: 1
    export type InstanceInformationFilterValueSet = InstanceInformationFilterValue[];    // max: 100, min: 1
    export type InstanceInformationList = InstanceInformation[];
    export type InvocationTraceOutput = string;    // max: 2500
    export type MaxResults = number;    // max: 25, min: 1
    export type MaxResultsEC2Compatible = number;    // max: 50, min: 5
    export type NextToken = string;
    export type ParameterName = string;
    export type ParameterValue = string;
    export type ParameterValueList = ParameterValue[];
    export type Parameters = {[key:string]: ParameterValueList};
    export type PingStatus = string;
    export type PlatformType = string;
    export type PlatformTypeList = PlatformType[];
    export type ResponseCode = number;
    export type S3BucketName = string;    // max: 63, min: 3
    export type S3KeyPrefix = string;    // max: 500
    export type StatusAdditionalInfo = string;    // max: 1024
    export type StatusMessage = string;    // max: 1024
    export type String = string;
    export type TimeoutSeconds = number;    // max: 2592000, min: 30
    export type Version = string;    // pattern: &quot;^[0-9]{1,6}(\.[0-9]{1,6}){2,3}$&quot;

    export interface AssociatedInstances {
    }
    export interface Association {
        Name?: DocumentName;
        InstanceId?: InstanceId;
    }
    export interface AssociationAlreadyExists {
    }
    export interface AssociationDescription {
        Name?: DocumentName;
        InstanceId?: InstanceId;
        Date?: DateTime;
        Status?: AssociationStatus;
        Parameters?: Parameters;
    }
    export interface AssociationDoesNotExist {
    }
    export interface AssociationFilter {
        key: AssociationFilterKey;
        value: AssociationFilterValue;
    }
    export interface AssociationLimitExceeded {
    }
    export interface AssociationStatus {
        Date: DateTime;
        Name: AssociationStatusName;
        Message: StatusMessage;
        AdditionalInfo?: StatusAdditionalInfo;
    }
    export interface CancelCommandRequest {
        CommandId: CommandId;
        InstanceIds?: InstanceIdList;
    }
    export interface CancelCommandResult {
    }
    export interface Command {
        CommandId?: CommandId;
        DocumentName?: DocumentName;
        Comment?: Comment;
        ExpiresAfter?: DateTime;
        Parameters?: Parameters;
        InstanceIds?: InstanceIdList;
        RequestedDateTime?: DateTime;
        Status?: CommandStatus;
        OutputS3BucketName?: S3BucketName;
        OutputS3KeyPrefix?: S3KeyPrefix;
    }
    export interface CommandFilter {
        key: CommandFilterKey;
        value: CommandFilterValue;
    }
    export interface CommandInvocation {
        CommandId?: CommandId;
        InstanceId?: InstanceId;
        Comment?: Comment;
        DocumentName?: DocumentName;
        RequestedDateTime?: DateTime;
        Status?: CommandInvocationStatus;
        TraceOutput?: InvocationTraceOutput;
        CommandPlugins?: CommandPluginList;
    }
    export interface CommandPlugin {
        Name?: CommandPluginName;
        Status?: CommandPluginStatus;
        ResponseCode?: ResponseCode;
        ResponseStartDateTime?: DateTime;
        ResponseFinishDateTime?: DateTime;
        Output?: CommandPluginOutput;
        OutputS3BucketName?: S3BucketName;
        OutputS3KeyPrefix?: S3KeyPrefix;
    }
    export interface CreateAssociationBatchRequest {
        Entries: CreateAssociationBatchRequestEntries;
    }
    export interface CreateAssociationBatchRequestEntry {
        Name?: DocumentName;
        InstanceId?: InstanceId;
        Parameters?: Parameters;
    }
    export interface CreateAssociationBatchResult {
        Successful?: AssociationDescriptionList;
        Failed?: FailedCreateAssociationList;
    }
    export interface CreateAssociationRequest {
        Name: DocumentName;
        InstanceId: InstanceId;
        Parameters?: Parameters;
    }
    export interface CreateAssociationResult {
        AssociationDescription?: AssociationDescription;
    }
    export interface CreateDocumentRequest {
        Content: DocumentContent;
        Name: DocumentName;
    }
    export interface CreateDocumentResult {
        DocumentDescription?: DocumentDescription;
    }
    export interface DeleteAssociationRequest {
        Name: DocumentName;
        InstanceId: InstanceId;
    }
    export interface DeleteAssociationResult {
    }
    export interface DeleteDocumentRequest {
        Name: DocumentName;
    }
    export interface DeleteDocumentResult {
    }
    export interface DescribeAssociationRequest {
        Name: DocumentName;
        InstanceId: InstanceId;
    }
    export interface DescribeAssociationResult {
        AssociationDescription?: AssociationDescription;
    }
    export interface DescribeDocumentRequest {
        Name: DocumentName;
    }
    export interface DescribeDocumentResult {
        Document?: DocumentDescription;
    }
    export interface DescribeInstanceInformationRequest {
        InstanceInformationFilterList?: InstanceInformationFilterList;
        MaxResults?: MaxResultsEC2Compatible;
        NextToken?: NextToken;
    }
    export interface DescribeInstanceInformationResult {
        InstanceInformationList?: InstanceInformationList;
        NextToken?: NextToken;
    }
    export interface DocumentAlreadyExists {
    }
    export interface DocumentDescription {
        Sha1?: DocumentSha1;
        Name?: DocumentName;
        CreatedDate?: DateTime;
        Status?: DocumentStatus;
        Description?: DescriptionInDocument;
        Parameters?: DocumentParameterList;
        PlatformTypes?: PlatformTypeList;
    }
    export interface DocumentFilter {
        key: DocumentFilterKey;
        value: DocumentFilterValue;
    }
    export interface DocumentIdentifier {
        Name?: DocumentName;
        PlatformTypes?: PlatformTypeList;
    }
    export interface DocumentLimitExceeded {
    }
    export interface DocumentParameter {
        Name?: DocumentParameterName;
        Type?: DocumentParameterType;
        Description?: DocumentParameterDescrption;
        DefaultValue?: DocumentParameterDefaultValue;
    }
    export interface DuplicateInstanceId {
    }
    export interface FailedCreateAssociation {
        Entry?: CreateAssociationBatchRequestEntry;
        Message?: BatchErrorMessage;
        Fault?: Fault;
    }
    export interface GetDocumentRequest {
        Name: DocumentName;
    }
    export interface GetDocumentResult {
        Name?: DocumentName;
        Content?: DocumentContent;
    }
    export interface InstanceInformation {
        InstanceId?: InstanceId;
        PingStatus?: PingStatus;
        LastPingDateTime?: DateTime;
        AgentVersion?: Version;
        IsLatestVersion?: Boolean;
        PlatformType?: PlatformType;
        PlatformName?: String;
        PlatformVersion?: String;
    }
    export interface InstanceInformationFilter {
        key: InstanceInformationFilterKey;
        valueSet: InstanceInformationFilterValueSet;
    }
    export interface InternalServerError {
        message?: String;
    }
    export interface InvalidCommandId {
    }
    export interface InvalidDocument {
        message?: String;
    }
    export interface InvalidDocumentContent {
        message?: String;
    }
    export interface InvalidFilterKey {
    }
    export interface InvalidInstanceId {
    }
    export interface InvalidInstanceInformationFilterValue {
        message?: String;
    }
    export interface InvalidNextToken {
    }
    export interface InvalidOutputFolder {
    }
    export interface InvalidParameters {
        message?: String;
    }
    export interface ListAssociationsRequest {
        AssociationFilterList: AssociationFilterList;
        MaxResults?: MaxResults;
        NextToken?: NextToken;
    }
    export interface ListAssociationsResult {
        Associations?: AssociationList;
        NextToken?: NextToken;
    }
    export interface ListCommandInvocationsRequest {
        CommandId?: CommandId;
        InstanceId?: InstanceId;
        MaxResults?: CommandMaxResults;
        NextToken?: NextToken;
        Filters?: CommandFilterList;
        Details?: Boolean;
    }
    export interface ListCommandInvocationsResult {
        CommandInvocations?: CommandInvocationList;
        NextToken?: NextToken;
    }
    export interface ListCommandsRequest {
        CommandId?: CommandId;
        InstanceId?: InstanceId;
        MaxResults?: CommandMaxResults;
        NextToken?: NextToken;
        Filters?: CommandFilterList;
    }
    export interface ListCommandsResult {
        Commands?: CommandList;
        NextToken?: NextToken;
    }
    export interface ListDocumentsRequest {
        DocumentFilterList?: DocumentFilterList;
        MaxResults?: MaxResults;
        NextToken?: NextToken;
    }
    export interface ListDocumentsResult {
        DocumentIdentifiers?: DocumentIdentifierList;
        NextToken?: NextToken;
    }
    export interface MaxDocumentSizeExceeded {
    }
    export interface SendCommandRequest {
        InstanceIds: InstanceIdList;
        DocumentName: DocumentName;
        TimeoutSeconds?: TimeoutSeconds;
        Comment?: Comment;
        Parameters?: Parameters;
        OutputS3BucketName?: S3BucketName;
        OutputS3KeyPrefix?: S3KeyPrefix;
    }
    export interface SendCommandResult {
        Command?: Command;
    }
    export interface StatusUnchanged {
    }
    export interface TooManyUpdates {
    }
    export interface UnsupportedPlatformType {
        message?: String;
    }
    export interface UpdateAssociationStatusRequest {
        Name: DocumentName;
        InstanceId: InstanceId;
        AssociationStatus: AssociationStatus;
    }
    export interface UpdateAssociationStatusResult {
        AssociationDescription?: AssociationDescription;
    }
  }

  /*
   * apiVersion: 2013-06-30
   * endpointPrefix: storagegateway
   * serviceAbbreviation: 
   * signatureVersion: v4
   * protocol: json
   */
  export class StorageGateway extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    activateGateway(params: StorageGateway.ActivateGatewayInput, callback?: (err: StorageGateway.InvalidGatewayRequestException|StorageGateway.InternalServerError|any, data: StorageGateway.ActivateGatewayOutput|any) => void): Request;
    addCache(params: StorageGateway.AddCacheInput, callback?: (err: StorageGateway.InvalidGatewayRequestException|StorageGateway.InternalServerError|any, data: StorageGateway.AddCacheOutput|any) => void): Request;
    addTagsToResource(params: StorageGateway.AddTagsToResourceInput, callback?: (err: StorageGateway.InvalidGatewayRequestException|StorageGateway.InternalServerError|any, data: StorageGateway.AddTagsToResourceOutput|any) => void): Request;
    addUploadBuffer(params: StorageGateway.AddUploadBufferInput, callback?: (err: StorageGateway.InvalidGatewayRequestException|StorageGateway.InternalServerError|any, data: StorageGateway.AddUploadBufferOutput|any) => void): Request;
    addWorkingStorage(params: StorageGateway.AddWorkingStorageInput, callback?: (err: StorageGateway.InvalidGatewayRequestException|StorageGateway.InternalServerError|any, data: StorageGateway.AddWorkingStorageOutput|any) => void): Request;
    cancelArchival(params: StorageGateway.CancelArchivalInput, callback?: (err: StorageGateway.InvalidGatewayRequestException|StorageGateway.InternalServerError|any, data: StorageGateway.CancelArchivalOutput|any) => void): Request;
    cancelRetrieval(params: StorageGateway.CancelRetrievalInput, callback?: (err: StorageGateway.InvalidGatewayRequestException|StorageGateway.InternalServerError|any, data: StorageGateway.CancelRetrievalOutput|any) => void): Request;
    createCachediSCSIVolume(params: StorageGateway.CreateCachediSCSIVolumeInput, callback?: (err: StorageGateway.InvalidGatewayRequestException|StorageGateway.InternalServerError|any, data: StorageGateway.CreateCachediSCSIVolumeOutput|any) => void): Request;
    createSnapshot(params: StorageGateway.CreateSnapshotInput, callback?: (err: StorageGateway.InvalidGatewayRequestException|StorageGateway.InternalServerError|any, data: StorageGateway.CreateSnapshotOutput|any) => void): Request;
    createSnapshotFromVolumeRecoveryPoint(params: StorageGateway.CreateSnapshotFromVolumeRecoveryPointInput, callback?: (err: StorageGateway.InvalidGatewayRequestException|StorageGateway.InternalServerError|any, data: StorageGateway.CreateSnapshotFromVolumeRecoveryPointOutput|any) => void): Request;
    createStorediSCSIVolume(params: StorageGateway.CreateStorediSCSIVolumeInput, callback?: (err: StorageGateway.InvalidGatewayRequestException|StorageGateway.InternalServerError|any, data: StorageGateway.CreateStorediSCSIVolumeOutput|any) => void): Request;
    createTapeWithBarcode(params: StorageGateway.CreateTapeWithBarcodeInput, callback?: (err: StorageGateway.InvalidGatewayRequestException|StorageGateway.InternalServerError|any, data: StorageGateway.CreateTapeWithBarcodeOutput|any) => void): Request;
    createTapes(params: StorageGateway.CreateTapesInput, callback?: (err: StorageGateway.InvalidGatewayRequestException|StorageGateway.InternalServerError|any, data: StorageGateway.CreateTapesOutput|any) => void): Request;
    deleteBandwidthRateLimit(params: StorageGateway.DeleteBandwidthRateLimitInput, callback?: (err: StorageGateway.InvalidGatewayRequestException|StorageGateway.InternalServerError|any, data: StorageGateway.DeleteBandwidthRateLimitOutput|any) => void): Request;
    deleteChapCredentials(params: StorageGateway.DeleteChapCredentialsInput, callback?: (err: StorageGateway.InvalidGatewayRequestException|StorageGateway.InternalServerError|any, data: StorageGateway.DeleteChapCredentialsOutput|any) => void): Request;
    deleteGateway(params: StorageGateway.DeleteGatewayInput, callback?: (err: StorageGateway.InvalidGatewayRequestException|StorageGateway.InternalServerError|any, data: StorageGateway.DeleteGatewayOutput|any) => void): Request;
    deleteSnapshotSchedule(params: StorageGateway.DeleteSnapshotScheduleInput, callback?: (err: StorageGateway.InvalidGatewayRequestException|StorageGateway.InternalServerError|any, data: StorageGateway.DeleteSnapshotScheduleOutput|any) => void): Request;
    deleteTape(params: StorageGateway.DeleteTapeInput, callback?: (err: StorageGateway.InvalidGatewayRequestException|StorageGateway.InternalServerError|any, data: StorageGateway.DeleteTapeOutput|any) => void): Request;
    deleteTapeArchive(params: StorageGateway.DeleteTapeArchiveInput, callback?: (err: StorageGateway.InvalidGatewayRequestException|StorageGateway.InternalServerError|any, data: StorageGateway.DeleteTapeArchiveOutput|any) => void): Request;
    deleteVolume(params: StorageGateway.DeleteVolumeInput, callback?: (err: StorageGateway.InvalidGatewayRequestException|StorageGateway.InternalServerError|any, data: StorageGateway.DeleteVolumeOutput|any) => void): Request;
    describeBandwidthRateLimit(params: StorageGateway.DescribeBandwidthRateLimitInput, callback?: (err: StorageGateway.InvalidGatewayRequestException|StorageGateway.InternalServerError|any, data: StorageGateway.DescribeBandwidthRateLimitOutput|any) => void): Request;
    describeCache(params: StorageGateway.DescribeCacheInput, callback?: (err: StorageGateway.InvalidGatewayRequestException|StorageGateway.InternalServerError|any, data: StorageGateway.DescribeCacheOutput|any) => void): Request;
    describeCachediSCSIVolumes(params: StorageGateway.DescribeCachediSCSIVolumesInput, callback?: (err: StorageGateway.InvalidGatewayRequestException|StorageGateway.InternalServerError|any, data: StorageGateway.DescribeCachediSCSIVolumesOutput|any) => void): Request;
    describeChapCredentials(params: StorageGateway.DescribeChapCredentialsInput, callback?: (err: StorageGateway.InvalidGatewayRequestException|StorageGateway.InternalServerError|any, data: StorageGateway.DescribeChapCredentialsOutput|any) => void): Request;
    describeGatewayInformation(params: StorageGateway.DescribeGatewayInformationInput, callback?: (err: StorageGateway.InvalidGatewayRequestException|StorageGateway.InternalServerError|any, data: StorageGateway.DescribeGatewayInformationOutput|any) => void): Request;
    describeMaintenanceStartTime(params: StorageGateway.DescribeMaintenanceStartTimeInput, callback?: (err: StorageGateway.InvalidGatewayRequestException|StorageGateway.InternalServerError|any, data: StorageGateway.DescribeMaintenanceStartTimeOutput|any) => void): Request;
    describeSnapshotSchedule(params: StorageGateway.DescribeSnapshotScheduleInput, callback?: (err: StorageGateway.InvalidGatewayRequestException|StorageGateway.InternalServerError|any, data: StorageGateway.DescribeSnapshotScheduleOutput|any) => void): Request;
    describeStorediSCSIVolumes(params: StorageGateway.DescribeStorediSCSIVolumesInput, callback?: (err: StorageGateway.InvalidGatewayRequestException|StorageGateway.InternalServerError|any, data: StorageGateway.DescribeStorediSCSIVolumesOutput|any) => void): Request;
    describeTapeArchives(params: StorageGateway.DescribeTapeArchivesInput, callback?: (err: StorageGateway.InvalidGatewayRequestException|StorageGateway.InternalServerError|any, data: StorageGateway.DescribeTapeArchivesOutput|any) => void): Request;
    describeTapeRecoveryPoints(params: StorageGateway.DescribeTapeRecoveryPointsInput, callback?: (err: StorageGateway.InvalidGatewayRequestException|StorageGateway.InternalServerError|any, data: StorageGateway.DescribeTapeRecoveryPointsOutput|any) => void): Request;
    describeTapes(params: StorageGateway.DescribeTapesInput, callback?: (err: StorageGateway.InvalidGatewayRequestException|StorageGateway.InternalServerError|any, data: StorageGateway.DescribeTapesOutput|any) => void): Request;
    describeUploadBuffer(params: StorageGateway.DescribeUploadBufferInput, callback?: (err: StorageGateway.InvalidGatewayRequestException|StorageGateway.InternalServerError|any, data: StorageGateway.DescribeUploadBufferOutput|any) => void): Request;
    describeVTLDevices(params: StorageGateway.DescribeVTLDevicesInput, callback?: (err: StorageGateway.InvalidGatewayRequestException|StorageGateway.InternalServerError|any, data: StorageGateway.DescribeVTLDevicesOutput|any) => void): Request;
    describeWorkingStorage(params: StorageGateway.DescribeWorkingStorageInput, callback?: (err: StorageGateway.InvalidGatewayRequestException|StorageGateway.InternalServerError|any, data: StorageGateway.DescribeWorkingStorageOutput|any) => void): Request;
    disableGateway(params: StorageGateway.DisableGatewayInput, callback?: (err: StorageGateway.InvalidGatewayRequestException|StorageGateway.InternalServerError|any, data: StorageGateway.DisableGatewayOutput|any) => void): Request;
    listGateways(params: StorageGateway.ListGatewaysInput, callback?: (err: StorageGateway.InvalidGatewayRequestException|StorageGateway.InternalServerError|any, data: StorageGateway.ListGatewaysOutput|any) => void): Request;
    listLocalDisks(params: StorageGateway.ListLocalDisksInput, callback?: (err: StorageGateway.InvalidGatewayRequestException|StorageGateway.InternalServerError|any, data: StorageGateway.ListLocalDisksOutput|any) => void): Request;
    listTagsForResource(params: StorageGateway.ListTagsForResourceInput, callback?: (err: StorageGateway.InvalidGatewayRequestException|StorageGateway.InternalServerError|any, data: StorageGateway.ListTagsForResourceOutput|any) => void): Request;
    listVolumeInitiators(params: StorageGateway.ListVolumeInitiatorsInput, callback?: (err: StorageGateway.InvalidGatewayRequestException|StorageGateway.InternalServerError|any, data: StorageGateway.ListVolumeInitiatorsOutput|any) => void): Request;
    listVolumeRecoveryPoints(params: StorageGateway.ListVolumeRecoveryPointsInput, callback?: (err: StorageGateway.InvalidGatewayRequestException|StorageGateway.InternalServerError|any, data: StorageGateway.ListVolumeRecoveryPointsOutput|any) => void): Request;
    listVolumes(params: StorageGateway.ListVolumesInput, callback?: (err: StorageGateway.InvalidGatewayRequestException|StorageGateway.InternalServerError|any, data: StorageGateway.ListVolumesOutput|any) => void): Request;
    removeTagsFromResource(params: StorageGateway.RemoveTagsFromResourceInput, callback?: (err: StorageGateway.InvalidGatewayRequestException|StorageGateway.InternalServerError|any, data: StorageGateway.RemoveTagsFromResourceOutput|any) => void): Request;
    resetCache(params: StorageGateway.ResetCacheInput, callback?: (err: StorageGateway.InvalidGatewayRequestException|StorageGateway.InternalServerError|any, data: StorageGateway.ResetCacheOutput|any) => void): Request;
    retrieveTapeArchive(params: StorageGateway.RetrieveTapeArchiveInput, callback?: (err: StorageGateway.InvalidGatewayRequestException|StorageGateway.InternalServerError|any, data: StorageGateway.RetrieveTapeArchiveOutput|any) => void): Request;
    retrieveTapeRecoveryPoint(params: StorageGateway.RetrieveTapeRecoveryPointInput, callback?: (err: StorageGateway.InvalidGatewayRequestException|StorageGateway.InternalServerError|any, data: StorageGateway.RetrieveTapeRecoveryPointOutput|any) => void): Request;
    shutdownGateway(params: StorageGateway.ShutdownGatewayInput, callback?: (err: StorageGateway.InvalidGatewayRequestException|StorageGateway.InternalServerError|any, data: StorageGateway.ShutdownGatewayOutput|any) => void): Request;
    startGateway(params: StorageGateway.StartGatewayInput, callback?: (err: StorageGateway.InvalidGatewayRequestException|StorageGateway.InternalServerError|any, data: StorageGateway.StartGatewayOutput|any) => void): Request;
    updateBandwidthRateLimit(params: StorageGateway.UpdateBandwidthRateLimitInput, callback?: (err: StorageGateway.InvalidGatewayRequestException|StorageGateway.InternalServerError|any, data: StorageGateway.UpdateBandwidthRateLimitOutput|any) => void): Request;
    updateChapCredentials(params: StorageGateway.UpdateChapCredentialsInput, callback?: (err: StorageGateway.InvalidGatewayRequestException|StorageGateway.InternalServerError|any, data: StorageGateway.UpdateChapCredentialsOutput|any) => void): Request;
    updateGatewayInformation(params: StorageGateway.UpdateGatewayInformationInput, callback?: (err: StorageGateway.InvalidGatewayRequestException|StorageGateway.InternalServerError|any, data: StorageGateway.UpdateGatewayInformationOutput|any) => void): Request;
    updateGatewaySoftwareNow(params: StorageGateway.UpdateGatewaySoftwareNowInput, callback?: (err: StorageGateway.InvalidGatewayRequestException|StorageGateway.InternalServerError|any, data: StorageGateway.UpdateGatewaySoftwareNowOutput|any) => void): Request;
    updateMaintenanceStartTime(params: StorageGateway.UpdateMaintenanceStartTimeInput, callback?: (err: StorageGateway.InvalidGatewayRequestException|StorageGateway.InternalServerError|any, data: StorageGateway.UpdateMaintenanceStartTimeOutput|any) => void): Request;
    updateSnapshotSchedule(params: StorageGateway.UpdateSnapshotScheduleInput, callback?: (err: StorageGateway.InvalidGatewayRequestException|StorageGateway.InternalServerError|any, data: StorageGateway.UpdateSnapshotScheduleOutput|any) => void): Request;
    updateVTLDeviceType(params: StorageGateway.UpdateVTLDeviceTypeInput, callback?: (err: StorageGateway.InvalidGatewayRequestException|StorageGateway.InternalServerError|any, data: StorageGateway.UpdateVTLDeviceTypeOutput|any) => void): Request;

  }

  export module StorageGateway {
    export type ActivationKey = string;    // max: 50, min: 1
    export type BandwidthDownloadRateLimit = number;    // min: 102400
    export type BandwidthType = string;    // max: 25, min: 3
    export type BandwidthUploadRateLimit = number;    // min: 51200
    export type CachediSCSIVolumes = CachediSCSIVolume[];
    export type ChapCredentials = ChapInfo[];
    export type ChapSecret = string;    // max: 100, min: 1
    export type ClientToken = string;    // max: 100, min: 5
    export type DayOfWeek = number;    // max: 6
    export type Description = string;    // max: 255, min: 1
    export type DeviceType = string;    // max: 50, min: 2
    export type DiskAllocationType = string;    // max: 100, min: 3
    export type DiskId = string;    // max: 300, min: 1
    export type DiskIds = DiskId[];
    export type Disks = Disk[];
    export type DoubleObject = number;
    export type ErrorCode = string;
    export type GatewayARN = string;    // max: 500, min: 50
    export type GatewayId = string;    // max: 30, min: 12
    export type GatewayName = string;    // pattern: &quot;^[ -\.0-\[\]-~]*[!-\.0-\[\]-~][ -\.0-\[\]-~]*$&quot;, max: 255, min: 2
    export type GatewayNetworkInterfaces = NetworkInterface[];
    export type GatewayOperationalState = string;    // max: 25, min: 2
    export type GatewayState = string;    // max: 25, min: 2
    export type GatewayTimezone = string;    // max: 10, min: 3
    export type GatewayType = string;    // max: 20, min: 2
    export type Gateways = GatewayInfo[];
    export type HourOfDay = number;    // max: 23
    export type Initiator = string;    // max: 50, min: 1
    export type Initiators = Initiator[];
    export type IqnName = string;    // pattern: &quot;[0-9a-z:.-]+&quot;, max: 255, min: 1
    export type LastSoftwareUpdate = string;    // max: 25, min: 1
    export type Marker = string;    // max: 1000, min: 1
    export type MediumChangerType = string;    // max: 50, min: 2
    export type MinuteOfHour = number;    // max: 59
    export type NetworkInterfaceId = string;    // pattern: &quot;\A(25[0-5]|2[0-4]\d|[0-1]?\d?\d)(\.(25[0-5]|2[0-4]\d|[0-1]?\d?\d)){3}\z&quot;
    export type NextUpdateAvailabilityDate = string;    // max: 25, min: 1
    export type NumTapesToCreate = number;    // max: 10, min: 1
    export type PositiveIntObject = number;    // min: 1
    export type RecurrenceInHours = number;    // max: 24, min: 1
    export type RegionId = string;    // max: 25, min: 1
    export type ResourceARN = string;    // max: 500, min: 50
    export type SnapshotDescription = string;    // max: 255, min: 1
    export type SnapshotId = string;    // pattern: &quot;\Asnap-[0-9a-fA-F]{8}\z&quot;
    export type StorediSCSIVolumes = StorediSCSIVolume[];
    export type TagKey = string;    // pattern: &quot;^([\p{L}\p{Z}\p{N}_.:/=+\-%@]*)$&quot;, max: 128, min: 1
    export type TagKeys = TagKey[];
    export type TagValue = string;    // max: 256
    export type Tags = Tag[];
    export type TapeARN = string;    // max: 500, min: 50
    export type TapeARNs = TapeARN[];
    export type TapeArchiveStatus = string;
    export type TapeArchives = TapeArchive[];
    export type TapeBarcode = string;    // pattern: &quot;^[A-Z0-9]*$&quot;, max: 16, min: 7
    export type TapeBarcodePrefix = string;    // pattern: &quot;^[A-Z]*$&quot;, max: 4, min: 1
    export type TapeDriveType = string;    // max: 50, min: 2
    export type TapeRecoveryPointInfos = TapeRecoveryPointInfo[];
    export type TapeRecoveryPointStatus = string;
    export type TapeSize = number;
    export type TapeStatus = string;
    export type Tapes = Tape[];
    export type TargetARN = string;    // max: 800, min: 50
    export type TargetName = string;    // pattern: &quot;^[-\.;a-z0-9]+$&quot;, max: 200, min: 1
    export type Time = number;
    export type VTLDeviceARN = string;    // max: 500, min: 50
    export type VTLDeviceARNs = VTLDeviceARN[];
    export type VTLDeviceProductIdentifier = string;
    export type VTLDeviceType = string;
    export type VTLDeviceVendor = string;
    export type VTLDevices = VTLDevice[];
    export type VolumeARN = string;    // max: 500, min: 50
    export type VolumeARNs = VolumeARN[];
    export type VolumeId = string;    // max: 30, min: 12
    export type VolumeInfos = VolumeInfo[];
    export type VolumeRecoveryPointInfos = VolumeRecoveryPointInfo[];
    export type VolumeStatus = string;    // max: 50, min: 3
    export type VolumeType = string;    // max: 100, min: 3
    export type double = number;
    export type errorDetails = {[key:string]: string};
    export type integer = number;
    export type long = number;

    export interface ActivateGatewayInput {
        ActivationKey: ActivationKey;
        GatewayName: GatewayName;
        GatewayTimezone: GatewayTimezone;
        GatewayRegion: RegionId;
        GatewayType?: GatewayType;
        TapeDriveType?: TapeDriveType;
        MediumChangerType?: MediumChangerType;
    }
    export interface ActivateGatewayOutput {
        GatewayARN?: GatewayARN;
    }
    export interface AddCacheInput {
        GatewayARN: GatewayARN;
        DiskIds: DiskIds;
    }
    export interface AddCacheOutput {
        GatewayARN?: GatewayARN;
    }
    export interface AddTagsToResourceInput {
        ResourceARN: ResourceARN;
        Tags: Tags;
    }
    export interface AddTagsToResourceOutput {
        ResourceARN?: ResourceARN;
    }
    export interface AddUploadBufferInput {
        GatewayARN: GatewayARN;
        DiskIds: DiskIds;
    }
    export interface AddUploadBufferOutput {
        GatewayARN?: GatewayARN;
    }
    export interface AddWorkingStorageInput {
        GatewayARN: GatewayARN;
        DiskIds: DiskIds;
    }
    export interface AddWorkingStorageOutput {
        GatewayARN?: GatewayARN;
    }
    export interface CachediSCSIVolume {
        VolumeARN?: VolumeARN;
        VolumeId?: VolumeId;
        VolumeType?: VolumeType;
        VolumeStatus?: VolumeStatus;
        VolumeSizeInBytes?: long;
        VolumeProgress?: DoubleObject;
        SourceSnapshotId?: SnapshotId;
        VolumeiSCSIAttributes?: VolumeiSCSIAttributes;
    }
    export interface CancelArchivalInput {
        GatewayARN: GatewayARN;
        TapeARN: TapeARN;
    }
    export interface CancelArchivalOutput {
        TapeARN?: TapeARN;
    }
    export interface CancelRetrievalInput {
        GatewayARN: GatewayARN;
        TapeARN: TapeARN;
    }
    export interface CancelRetrievalOutput {
        TapeARN?: TapeARN;
    }
    export interface ChapInfo {
        TargetARN?: TargetARN;
        SecretToAuthenticateInitiator?: ChapSecret;
        InitiatorName?: IqnName;
        SecretToAuthenticateTarget?: ChapSecret;
    }
    export interface CreateCachediSCSIVolumeInput {
        GatewayARN: GatewayARN;
        VolumeSizeInBytes: long;
        SnapshotId?: SnapshotId;
        TargetName: TargetName;
        NetworkInterfaceId: NetworkInterfaceId;
        ClientToken: ClientToken;
    }
    export interface CreateCachediSCSIVolumeOutput {
        VolumeARN?: VolumeARN;
        TargetARN?: TargetARN;
    }
    export interface CreateSnapshotFromVolumeRecoveryPointInput {
        VolumeARN: VolumeARN;
        SnapshotDescription: SnapshotDescription;
    }
    export interface CreateSnapshotFromVolumeRecoveryPointOutput {
        SnapshotId?: SnapshotId;
        VolumeARN?: VolumeARN;
        VolumeRecoveryPointTime?: string;
    }
    export interface CreateSnapshotInput {
        VolumeARN: VolumeARN;
        SnapshotDescription: SnapshotDescription;
    }
    export interface CreateSnapshotOutput {
        VolumeARN?: VolumeARN;
        SnapshotId?: SnapshotId;
    }
    export interface CreateStorediSCSIVolumeInput {
        GatewayARN: GatewayARN;
        DiskId: DiskId;
        SnapshotId?: SnapshotId;
        PreserveExistingData: boolean;
        TargetName: TargetName;
        NetworkInterfaceId: NetworkInterfaceId;
    }
    export interface CreateStorediSCSIVolumeOutput {
        VolumeARN?: VolumeARN;
        VolumeSizeInBytes?: long;
        TargetARN?: TargetARN;
    }
    export interface CreateTapeWithBarcodeInput {
        GatewayARN: GatewayARN;
        TapeSizeInBytes: TapeSize;
        TapeBarcode: TapeBarcode;
    }
    export interface CreateTapeWithBarcodeOutput {
        TapeARN?: TapeARN;
    }
    export interface CreateTapesInput {
        GatewayARN: GatewayARN;
        TapeSizeInBytes: TapeSize;
        ClientToken: ClientToken;
        NumTapesToCreate: NumTapesToCreate;
        TapeBarcodePrefix: TapeBarcodePrefix;
    }
    export interface CreateTapesOutput {
        TapeARNs?: TapeARNs;
    }
    export interface DeleteBandwidthRateLimitInput {
        GatewayARN: GatewayARN;
        BandwidthType: BandwidthType;
    }
    export interface DeleteBandwidthRateLimitOutput {
        GatewayARN?: GatewayARN;
    }
    export interface DeleteChapCredentialsInput {
        TargetARN: TargetARN;
        InitiatorName: IqnName;
    }
    export interface DeleteChapCredentialsOutput {
        TargetARN?: TargetARN;
        InitiatorName?: IqnName;
    }
    export interface DeleteGatewayInput {
        GatewayARN: GatewayARN;
    }
    export interface DeleteGatewayOutput {
        GatewayARN?: GatewayARN;
    }
    export interface DeleteSnapshotScheduleInput {
        VolumeARN: VolumeARN;
    }
    export interface DeleteSnapshotScheduleOutput {
        VolumeARN?: VolumeARN;
    }
    export interface DeleteTapeArchiveInput {
        TapeARN: TapeARN;
    }
    export interface DeleteTapeArchiveOutput {
        TapeARN?: TapeARN;
    }
    export interface DeleteTapeInput {
        GatewayARN: GatewayARN;
        TapeARN: TapeARN;
    }
    export interface DeleteTapeOutput {
        TapeARN?: TapeARN;
    }
    export interface DeleteVolumeInput {
        VolumeARN: VolumeARN;
    }
    export interface DeleteVolumeOutput {
        VolumeARN?: VolumeARN;
    }
    export interface DescribeBandwidthRateLimitInput {
        GatewayARN: GatewayARN;
    }
    export interface DescribeBandwidthRateLimitOutput {
        GatewayARN?: GatewayARN;
        AverageUploadRateLimitInBitsPerSec?: BandwidthUploadRateLimit;
        AverageDownloadRateLimitInBitsPerSec?: BandwidthDownloadRateLimit;
    }
    export interface DescribeCacheInput {
        GatewayARN: GatewayARN;
    }
    export interface DescribeCacheOutput {
        GatewayARN?: GatewayARN;
        DiskIds?: DiskIds;
        CacheAllocatedInBytes?: long;
        CacheUsedPercentage?: double;
        CacheDirtyPercentage?: double;
        CacheHitPercentage?: double;
        CacheMissPercentage?: double;
    }
    export interface DescribeCachediSCSIVolumesInput {
        VolumeARNs: VolumeARNs;
    }
    export interface DescribeCachediSCSIVolumesOutput {
        CachediSCSIVolumes?: CachediSCSIVolumes;
    }
    export interface DescribeChapCredentialsInput {
        TargetARN: TargetARN;
    }
    export interface DescribeChapCredentialsOutput {
        ChapCredentials?: ChapCredentials;
    }
    export interface DescribeGatewayInformationInput {
        GatewayARN: GatewayARN;
    }
    export interface DescribeGatewayInformationOutput {
        GatewayARN?: GatewayARN;
        GatewayId?: GatewayId;
        GatewayName?: string;
        GatewayTimezone?: GatewayTimezone;
        GatewayState?: GatewayState;
        GatewayNetworkInterfaces?: GatewayNetworkInterfaces;
        GatewayType?: GatewayType;
        NextUpdateAvailabilityDate?: NextUpdateAvailabilityDate;
        LastSoftwareUpdate?: LastSoftwareUpdate;
    }
    export interface DescribeMaintenanceStartTimeInput {
        GatewayARN: GatewayARN;
    }
    export interface DescribeMaintenanceStartTimeOutput {
        GatewayARN?: GatewayARN;
        HourOfDay?: HourOfDay;
        MinuteOfHour?: MinuteOfHour;
        DayOfWeek?: DayOfWeek;
        Timezone?: GatewayTimezone;
    }
    export interface DescribeSnapshotScheduleInput {
        VolumeARN: VolumeARN;
    }
    export interface DescribeSnapshotScheduleOutput {
        VolumeARN?: VolumeARN;
        StartAt?: HourOfDay;
        RecurrenceInHours?: RecurrenceInHours;
        Description?: Description;
        Timezone?: GatewayTimezone;
    }
    export interface DescribeStorediSCSIVolumesInput {
        VolumeARNs: VolumeARNs;
    }
    export interface DescribeStorediSCSIVolumesOutput {
        StorediSCSIVolumes?: StorediSCSIVolumes;
    }
    export interface DescribeTapeArchivesInput {
        TapeARNs?: TapeARNs;
        Marker?: Marker;
        Limit?: PositiveIntObject;
    }
    export interface DescribeTapeArchivesOutput {
        TapeArchives?: TapeArchives;
        Marker?: Marker;
    }
    export interface DescribeTapeRecoveryPointsInput {
        GatewayARN: GatewayARN;
        Marker?: Marker;
        Limit?: PositiveIntObject;
    }
    export interface DescribeTapeRecoveryPointsOutput {
        GatewayARN?: GatewayARN;
        TapeRecoveryPointInfos?: TapeRecoveryPointInfos;
        Marker?: Marker;
    }
    export interface DescribeTapesInput {
        GatewayARN: GatewayARN;
        TapeARNs?: TapeARNs;
        Marker?: Marker;
        Limit?: PositiveIntObject;
    }
    export interface DescribeTapesOutput {
        Tapes?: Tapes;
        Marker?: Marker;
    }
    export interface DescribeUploadBufferInput {
        GatewayARN: GatewayARN;
    }
    export interface DescribeUploadBufferOutput {
        GatewayARN?: GatewayARN;
        DiskIds?: DiskIds;
        UploadBufferUsedInBytes?: long;
        UploadBufferAllocatedInBytes?: long;
    }
    export interface DescribeVTLDevicesInput {
        GatewayARN: GatewayARN;
        VTLDeviceARNs?: VTLDeviceARNs;
        Marker?: Marker;
        Limit?: PositiveIntObject;
    }
    export interface DescribeVTLDevicesOutput {
        GatewayARN?: GatewayARN;
        VTLDevices?: VTLDevices;
        Marker?: Marker;
    }
    export interface DescribeWorkingStorageInput {
        GatewayARN: GatewayARN;
    }
    export interface DescribeWorkingStorageOutput {
        GatewayARN?: GatewayARN;
        DiskIds?: DiskIds;
        WorkingStorageUsedInBytes?: long;
        WorkingStorageAllocatedInBytes?: long;
    }
    export interface DeviceiSCSIAttributes {
        TargetARN?: TargetARN;
        NetworkInterfaceId?: NetworkInterfaceId;
        NetworkInterfacePort?: integer;
        ChapEnabled?: boolean;
    }
    export interface DisableGatewayInput {
        GatewayARN: GatewayARN;
    }
    export interface DisableGatewayOutput {
        GatewayARN?: GatewayARN;
    }
    export interface Disk {
        DiskId?: DiskId;
        DiskPath?: string;
        DiskNode?: string;
        DiskStatus?: string;
        DiskSizeInBytes?: long;
        DiskAllocationType?: DiskAllocationType;
        DiskAllocationResource?: string;
    }
    export interface GatewayInfo {
        GatewayARN?: GatewayARN;
        GatewayType?: GatewayType;
        GatewayOperationalState?: GatewayOperationalState;
        GatewayName?: string;
    }
    export interface InternalServerError {
        message?: string;
        error?: StorageGatewayError;
    }
    export interface InvalidGatewayRequestException {
        message?: string;
        error?: StorageGatewayError;
    }
    export interface ListGatewaysInput {
        Marker?: Marker;
        Limit?: PositiveIntObject;
    }
    export interface ListGatewaysOutput {
        Gateways?: Gateways;
        Marker?: Marker;
    }
    export interface ListLocalDisksInput {
        GatewayARN: GatewayARN;
    }
    export interface ListLocalDisksOutput {
        GatewayARN?: GatewayARN;
        Disks?: Disks;
    }
    export interface ListTagsForResourceInput {
        ResourceARN: ResourceARN;
        Marker?: Marker;
        Limit?: PositiveIntObject;
    }
    export interface ListTagsForResourceOutput {
        ResourceARN?: ResourceARN;
        Marker?: Marker;
        Tags?: Tags;
    }
    export interface ListVolumeInitiatorsInput {
        VolumeARN: VolumeARN;
    }
    export interface ListVolumeInitiatorsOutput {
        Initiators?: Initiators;
    }
    export interface ListVolumeRecoveryPointsInput {
        GatewayARN: GatewayARN;
    }
    export interface ListVolumeRecoveryPointsOutput {
        GatewayARN?: GatewayARN;
        VolumeRecoveryPointInfos?: VolumeRecoveryPointInfos;
    }
    export interface ListVolumesInput {
        GatewayARN: GatewayARN;
        Marker?: Marker;
        Limit?: PositiveIntObject;
    }
    export interface ListVolumesOutput {
        GatewayARN?: GatewayARN;
        Marker?: Marker;
        VolumeInfos?: VolumeInfos;
    }
    export interface NetworkInterface {
        Ipv4Address?: string;
        MacAddress?: string;
        Ipv6Address?: string;
    }
    export interface RemoveTagsFromResourceInput {
        ResourceARN: ResourceARN;
        TagKeys: TagKeys;
    }
    export interface RemoveTagsFromResourceOutput {
        ResourceARN?: ResourceARN;
    }
    export interface ResetCacheInput {
        GatewayARN: GatewayARN;
    }
    export interface ResetCacheOutput {
        GatewayARN?: GatewayARN;
    }
    export interface RetrieveTapeArchiveInput {
        TapeARN: TapeARN;
        GatewayARN: GatewayARN;
    }
    export interface RetrieveTapeArchiveOutput {
        TapeARN?: TapeARN;
    }
    export interface RetrieveTapeRecoveryPointInput {
        TapeARN: TapeARN;
        GatewayARN: GatewayARN;
    }
    export interface RetrieveTapeRecoveryPointOutput {
        TapeARN?: TapeARN;
    }
    export interface ShutdownGatewayInput {
        GatewayARN: GatewayARN;
    }
    export interface ShutdownGatewayOutput {
        GatewayARN?: GatewayARN;
    }
    export interface StartGatewayInput {
        GatewayARN: GatewayARN;
    }
    export interface StartGatewayOutput {
        GatewayARN?: GatewayARN;
    }
    export interface StorageGatewayError {
        errorCode?: ErrorCode;
        errorDetails?: errorDetails;
    }
    export interface StorediSCSIVolume {
        VolumeARN?: VolumeARN;
        VolumeId?: VolumeId;
        VolumeType?: VolumeType;
        VolumeStatus?: VolumeStatus;
        VolumeSizeInBytes?: long;
        VolumeProgress?: DoubleObject;
        VolumeDiskId?: DiskId;
        SourceSnapshotId?: SnapshotId;
        PreservedExistingData?: boolean;
        VolumeiSCSIAttributes?: VolumeiSCSIAttributes;
    }
    export interface Tag {
        Key: TagKey;
        Value: TagValue;
    }
    export interface Tape {
        TapeARN?: TapeARN;
        TapeBarcode?: TapeBarcode;
        TapeSizeInBytes?: TapeSize;
        TapeStatus?: TapeStatus;
        VTLDevice?: VTLDeviceARN;
        Progress?: DoubleObject;
    }
    export interface TapeArchive {
        TapeARN?: TapeARN;
        TapeBarcode?: TapeBarcode;
        TapeSizeInBytes?: TapeSize;
        CompletionTime?: Time;
        RetrievedTo?: GatewayARN;
        TapeStatus?: TapeArchiveStatus;
    }
    export interface TapeRecoveryPointInfo {
        TapeARN?: TapeARN;
        TapeRecoveryPointTime?: Time;
        TapeSizeInBytes?: TapeSize;
        TapeStatus?: TapeRecoveryPointStatus;
    }
    export interface UpdateBandwidthRateLimitInput {
        GatewayARN: GatewayARN;
        AverageUploadRateLimitInBitsPerSec?: BandwidthUploadRateLimit;
        AverageDownloadRateLimitInBitsPerSec?: BandwidthDownloadRateLimit;
    }
    export interface UpdateBandwidthRateLimitOutput {
        GatewayARN?: GatewayARN;
    }
    export interface UpdateChapCredentialsInput {
        TargetARN: TargetARN;
        SecretToAuthenticateInitiator: ChapSecret;
        InitiatorName: IqnName;
        SecretToAuthenticateTarget?: ChapSecret;
    }
    export interface UpdateChapCredentialsOutput {
        TargetARN?: TargetARN;
        InitiatorName?: IqnName;
    }
    export interface UpdateGatewayInformationInput {
        GatewayARN: GatewayARN;
        GatewayName?: GatewayName;
        GatewayTimezone?: GatewayTimezone;
    }
    export interface UpdateGatewayInformationOutput {
        GatewayARN?: GatewayARN;
        GatewayName?: string;
    }
    export interface UpdateGatewaySoftwareNowInput {
        GatewayARN: GatewayARN;
    }
    export interface UpdateGatewaySoftwareNowOutput {
        GatewayARN?: GatewayARN;
    }
    export interface UpdateMaintenanceStartTimeInput {
        GatewayARN: GatewayARN;
        HourOfDay: HourOfDay;
        MinuteOfHour: MinuteOfHour;
        DayOfWeek: DayOfWeek;
    }
    export interface UpdateMaintenanceStartTimeOutput {
        GatewayARN?: GatewayARN;
    }
    export interface UpdateSnapshotScheduleInput {
        VolumeARN: VolumeARN;
        StartAt: HourOfDay;
        RecurrenceInHours: RecurrenceInHours;
        Description?: Description;
    }
    export interface UpdateSnapshotScheduleOutput {
        VolumeARN?: VolumeARN;
    }
    export interface UpdateVTLDeviceTypeInput {
        VTLDeviceARN: VTLDeviceARN;
        DeviceType: DeviceType;
    }
    export interface UpdateVTLDeviceTypeOutput {
        VTLDeviceARN?: VTLDeviceARN;
    }
    export interface VTLDevice {
        VTLDeviceARN?: VTLDeviceARN;
        VTLDeviceType?: VTLDeviceType;
        VTLDeviceVendor?: VTLDeviceVendor;
        VTLDeviceProductIdentifier?: VTLDeviceProductIdentifier;
        DeviceiSCSIAttributes?: DeviceiSCSIAttributes;
    }
    export interface VolumeInfo {
        VolumeARN?: VolumeARN;
        VolumeType?: VolumeType;
    }
    export interface VolumeRecoveryPointInfo {
        VolumeARN?: VolumeARN;
        VolumeSizeInBytes?: long;
        VolumeUsageInBytes?: long;
        VolumeRecoveryPointTime?: string;
    }
    export interface VolumeiSCSIAttributes {
        TargetARN?: TargetARN;
        NetworkInterfaceId?: NetworkInterfaceId;
        NetworkInterfacePort?: integer;
        LunNumber?: PositiveIntObject;
        ChapEnabled?: boolean;
    }
  }

  /*
   * apiVersion: 2011-06-15
   * endpointPrefix: sts
   * serviceAbbreviation: AWS STS
   * signatureVersion: v4
   * protocol: query
   */
  export class STS extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    assumeRole(params: STS.AssumeRoleRequest, callback?: (err: STS.MalformedPolicyDocumentException|STS.PackedPolicyTooLargeException|STS.RegionDisabledException|any, data: STS.AssumeRoleResponse|any) => void): Request;
    assumeRoleWithSAML(params: STS.AssumeRoleWithSAMLRequest, callback?: (err: STS.MalformedPolicyDocumentException|STS.PackedPolicyTooLargeException|STS.IDPRejectedClaimException|STS.InvalidIdentityTokenException|STS.ExpiredTokenException|STS.RegionDisabledException|any, data: STS.AssumeRoleWithSAMLResponse|any) => void): Request;
    assumeRoleWithWebIdentity(params: STS.AssumeRoleWithWebIdentityRequest, callback?: (err: STS.MalformedPolicyDocumentException|STS.PackedPolicyTooLargeException|STS.IDPRejectedClaimException|STS.IDPCommunicationErrorException|STS.InvalidIdentityTokenException|STS.ExpiredTokenException|STS.RegionDisabledException|any, data: STS.AssumeRoleWithWebIdentityResponse|any) => void): Request;
    decodeAuthorizationMessage(params: STS.DecodeAuthorizationMessageRequest, callback?: (err: STS.InvalidAuthorizationMessageException|any, data: STS.DecodeAuthorizationMessageResponse|any) => void): Request;
    getFederationToken(params: STS.GetFederationTokenRequest, callback?: (err: STS.MalformedPolicyDocumentException|STS.PackedPolicyTooLargeException|STS.RegionDisabledException|any, data: STS.GetFederationTokenResponse|any) => void): Request;
    getSessionToken(params: STS.GetSessionTokenRequest, callback?: (err: STS.RegionDisabledException|any, data: STS.GetSessionTokenResponse|any) => void): Request;

    /***
     * Found on JS Sources - Sorry for the inconvenience :)
     * *
     * @overload credentialsFrom(data, credentials = null)
     *   Creates a credentials object from STS response data containing
     *   credentials information. Useful for quickly setting AWS credentials.
     *
     *   @note This is a low-level utility function. If you want to load temporary
     *     credentials into your process for subsequent requests to AWS resources,
     *     you should use {AWS.TemporaryCredentials} instead.
     *   @param data [map] data retrieved from a call to {getFederatedToken},
     *     {getSessionToken}, {assumeRole}, or {assumeRoleWithWebIdentity}.
     *   @param credentials [AWS.Credentials] an optional credentials object to
     *     fill instead of creating a new object. Useful when modifying an
     *     existing credentials object from a refresh call.
     *   @return [AWS.TemporaryCredentials] the set of temporary credentials
     *     loaded from a raw STS operation response.
     *   @example Using credentialsFrom to load global AWS credentials
     *     var sts = new AWS.STS();
     *     sts.getSessionToken(function (err, data) {
     *       if (err) console.log("Error getting credentials");
     *       else {
     *         AWS.config.credentials = sts.credentialsFrom(data);
     *       }
     *     });
     *   @see AWS.TemporaryCredentials
   
     **/
    credentialsFrom(...args: any[]): any
    /***
     * Found on JS Sources - Sorry for the inconvenience :)
     * 
     **/
    assumeRoleWithWebIdentity(...args: any[]): any
    /***
     * Found on JS Sources - Sorry for the inconvenience :)
     * 
     **/
    assumeRoleWithSAML(...args: any[]): any
  }

  export module STS {
    export type Audience = string;
    export type Issuer = string;
    export type NameQualifier = string;
    export type SAMLAssertionType = string;    // max: 50000, min: 4
    export type Subject = string;
    export type SubjectType = string;
    export type accessKeyIdType = string;    // pattern: &quot;[\w]*&quot;, max: 32, min: 16
    export type accessKeySecretType = string;
    export type arnType = string;    // max: 2048, min: 20
    export type assumedRoleIdType = string;    // pattern: &quot;[\w+=,.@:-]*&quot;, max: 96, min: 2
    export type clientTokenType = string;    // max: 2048, min: 4
    export type dateType = number;
    export type decodedMessageType = string;
    export type durationSecondsType = number;    // max: 129600, min: 900
    export type encodedMessageType = string;    // max: 10240, min: 1
    export type expiredIdentityTokenMessage = string;
    export type externalIdType = string;    // pattern: &quot;[\w+=,.@:\/-]*&quot;, max: 1224, min: 2
    export type federatedIdType = string;    // pattern: &quot;[\w+=,.@\:-]*&quot;, max: 96, min: 2
    export type idpCommunicationErrorMessage = string;
    export type idpRejectedClaimMessage = string;
    export type invalidAuthorizationMessage = string;
    export type invalidIdentityTokenMessage = string;
    export type malformedPolicyDocumentMessage = string;
    export type nonNegativeIntegerType = number;
    export type packedPolicyTooLargeMessage = string;
    export type regionDisabledMessage = string;
    export type roleDurationSecondsType = number;    // max: 3600, min: 900
    export type roleSessionNameType = string;    // pattern: &quot;[\w+=,.@-]*&quot;, max: 64, min: 2
    export type serialNumberType = string;    // pattern: &quot;[\w+=/:,.@-]*&quot;, max: 256, min: 9
    export type sessionPolicyDocumentType = string;    // pattern: &quot;[\u0009\u000A\u000D\u0020-\u00FF]+&quot;, max: 2048, min: 1
    export type tokenCodeType = string;    // pattern: &quot;[\d]*&quot;, max: 6, min: 6
    export type tokenType = string;
    export type urlType = string;    // max: 2048, min: 4
    export type userNameType = string;    // pattern: &quot;[\w+=,.@-]*&quot;, max: 32, min: 2
    export type webIdentitySubjectType = string;    // max: 255, min: 6

    export interface AssumeRoleRequest {
        RoleArn: arnType;
        RoleSessionName: roleSessionNameType;
        Policy?: sessionPolicyDocumentType;
        DurationSeconds?: roleDurationSecondsType;
        ExternalId?: externalIdType;
        SerialNumber?: serialNumberType;
        TokenCode?: tokenCodeType;
    }
    export interface AssumeRoleResponse {
        Credentials?: Credentials;
        AssumedRoleUser?: AssumedRoleUser;
        PackedPolicySize?: nonNegativeIntegerType;
    }
    export interface AssumeRoleWithSAMLRequest {
        RoleArn: arnType;
        PrincipalArn: arnType;
        SAMLAssertion: SAMLAssertionType;
        Policy?: sessionPolicyDocumentType;
        DurationSeconds?: roleDurationSecondsType;
    }
    export interface AssumeRoleWithSAMLResponse {
        Credentials?: Credentials;
        AssumedRoleUser?: AssumedRoleUser;
        PackedPolicySize?: nonNegativeIntegerType;
        Subject?: Subject;
        SubjectType?: SubjectType;
        Issuer?: Issuer;
        Audience?: Audience;
        NameQualifier?: NameQualifier;
    }
    export interface AssumeRoleWithWebIdentityRequest {
        RoleArn: arnType;
        RoleSessionName: roleSessionNameType;
        WebIdentityToken: clientTokenType;
        ProviderId?: urlType;
        Policy?: sessionPolicyDocumentType;
        DurationSeconds?: roleDurationSecondsType;
    }
    export interface AssumeRoleWithWebIdentityResponse {
        Credentials?: Credentials;
        SubjectFromWebIdentityToken?: webIdentitySubjectType;
        AssumedRoleUser?: AssumedRoleUser;
        PackedPolicySize?: nonNegativeIntegerType;
        Provider?: Issuer;
        Audience?: Audience;
    }
    export interface AssumedRoleUser {
        AssumedRoleId: assumedRoleIdType;
        Arn: arnType;
    }
    export interface Credentials {
        AccessKeyId: accessKeyIdType;
        SecretAccessKey: accessKeySecretType;
        SessionToken: tokenType;
        Expiration: dateType;
    }
    export interface DecodeAuthorizationMessageRequest {
        EncodedMessage: encodedMessageType;
    }
    export interface DecodeAuthorizationMessageResponse {
        DecodedMessage?: decodedMessageType;
    }
    export interface ExpiredTokenException {
        message?: expiredIdentityTokenMessage;
    }
    export interface FederatedUser {
        FederatedUserId: federatedIdType;
        Arn: arnType;
    }
    export interface GetFederationTokenRequest {
        Name: userNameType;
        Policy?: sessionPolicyDocumentType;
        DurationSeconds?: durationSecondsType;
    }
    export interface GetFederationTokenResponse {
        Credentials?: Credentials;
        FederatedUser?: FederatedUser;
        PackedPolicySize?: nonNegativeIntegerType;
    }
    export interface GetSessionTokenRequest {
        DurationSeconds?: durationSecondsType;
        SerialNumber?: serialNumberType;
        TokenCode?: tokenCodeType;
    }
    export interface GetSessionTokenResponse {
        Credentials?: Credentials;
    }
    export interface IDPCommunicationErrorException {
        message?: idpCommunicationErrorMessage;
    }
    export interface IDPRejectedClaimException {
        message?: idpRejectedClaimMessage;
    }
    export interface InvalidAuthorizationMessageException {
        message?: invalidAuthorizationMessage;
    }
    export interface InvalidIdentityTokenException {
        message?: invalidIdentityTokenMessage;
    }
    export interface MalformedPolicyDocumentException {
        message?: malformedPolicyDocumentMessage;
    }
    export interface PackedPolicyTooLargeException {
        message?: packedPolicyTooLargeMessage;
    }
    export interface RegionDisabledException {
        message?: regionDisabledMessage;
    }
  }

  /*
   * apiVersion: 2013-04-15
   * endpointPrefix: support
   * serviceAbbreviation: 
   * signatureVersion: v4
   * protocol: json
   */
  export class Support extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    addAttachmentsToSet(params: Support.AddAttachmentsToSetRequest, callback?: (err: Support.InternalServerError|Support.AttachmentSetIdNotFound|Support.AttachmentSetExpired|Support.AttachmentSetSizeLimitExceeded|Support.AttachmentLimitExceeded|any, data: Support.AddAttachmentsToSetResponse|any) => void): Request;
    addCommunicationToCase(params: Support.AddCommunicationToCaseRequest, callback?: (err: Support.InternalServerError|Support.CaseIdNotFound|Support.AttachmentSetIdNotFound|Support.AttachmentSetExpired|any, data: Support.AddCommunicationToCaseResponse|any) => void): Request;
    createCase(params: Support.CreateCaseRequest, callback?: (err: Support.InternalServerError|Support.CaseCreationLimitExceeded|Support.AttachmentSetIdNotFound|Support.AttachmentSetExpired|any, data: Support.CreateCaseResponse|any) => void): Request;
    describeAttachment(params: Support.DescribeAttachmentRequest, callback?: (err: Support.InternalServerError|Support.DescribeAttachmentLimitExceeded|Support.AttachmentIdNotFound|any, data: Support.DescribeAttachmentResponse|any) => void): Request;
    describeCases(params: Support.DescribeCasesRequest, callback?: (err: Support.InternalServerError|Support.CaseIdNotFound|any, data: Support.DescribeCasesResponse|any) => void): Request;
    describeCommunications(params: Support.DescribeCommunicationsRequest, callback?: (err: Support.InternalServerError|Support.CaseIdNotFound|any, data: Support.DescribeCommunicationsResponse|any) => void): Request;
    describeServices(params: Support.DescribeServicesRequest, callback?: (err: Support.InternalServerError|any, data: Support.DescribeServicesResponse|any) => void): Request;
    describeSeverityLevels(params: Support.DescribeSeverityLevelsRequest, callback?: (err: Support.InternalServerError|any, data: Support.DescribeSeverityLevelsResponse|any) => void): Request;
    describeTrustedAdvisorCheckRefreshStatuses(params: Support.DescribeTrustedAdvisorCheckRefreshStatusesRequest, callback?: (err: Support.InternalServerError|any, data: Support.DescribeTrustedAdvisorCheckRefreshStatusesResponse|any) => void): Request;
    describeTrustedAdvisorCheckResult(params: Support.DescribeTrustedAdvisorCheckResultRequest, callback?: (err: Support.InternalServerError|any, data: Support.DescribeTrustedAdvisorCheckResultResponse|any) => void): Request;
    describeTrustedAdvisorCheckSummaries(params: Support.DescribeTrustedAdvisorCheckSummariesRequest, callback?: (err: Support.InternalServerError|any, data: Support.DescribeTrustedAdvisorCheckSummariesResponse|any) => void): Request;
    describeTrustedAdvisorChecks(params: Support.DescribeTrustedAdvisorChecksRequest, callback?: (err: Support.InternalServerError|any, data: Support.DescribeTrustedAdvisorChecksResponse|any) => void): Request;
    refreshTrustedAdvisorCheck(params: Support.RefreshTrustedAdvisorCheckRequest, callback?: (err: Support.InternalServerError|any, data: Support.RefreshTrustedAdvisorCheckResponse|any) => void): Request;
    resolveCase(params: Support.ResolveCaseRequest, callback?: (err: Support.InternalServerError|Support.CaseIdNotFound|any, data: Support.ResolveCaseResponse|any) => void): Request;

  }

  export module Support {
    export type AfterTime = string;
    export type AttachmentId = string;
    export type AttachmentSet = AttachmentDetails[];
    export type AttachmentSetId = string;
    export type Attachments = Attachment[];
    export type BeforeTime = string;
    export type Boolean = boolean;
    export type CaseId = string;
    export type CaseIdList = CaseId[];    // max: 100
    export type CaseList = CaseDetails[];
    export type CaseStatus = string;
    export type CategoryCode = string;
    export type CategoryList = Category[];
    export type CategoryName = string;
    export type CcEmailAddress = string;
    export type CcEmailAddressList = CcEmailAddress[];
    export type CommunicationBody = string;
    export type CommunicationList = Communication[];
    export type Data = any;    // type: blob
    export type DisplayId = string;
    export type Double = number;
    export type ErrorMessage = string;
    export type ExpiryTime = string;
    export type FileName = string;
    export type IncludeCommunications = boolean;
    export type IncludeResolvedCases = boolean;
    export type IssueType = string;
    export type Language = string;
    export type Long = number;
    export type MaxResults = number;    // max: 100, min: 10
    export type NextToken = string;
    export type Result = boolean;
    export type ServiceCode = string;    // pattern: &quot;[0-9a-z\-_]+&quot;
    export type ServiceCodeList = ServiceCode[];    // max: 100
    export type ServiceList = Service[];
    export type ServiceName = string;
    export type SeverityCode = string;
    export type SeverityLevelCode = string;
    export type SeverityLevelName = string;
    export type SeverityLevelsList = SeverityLevel[];
    export type Status = string;
    export type String = string;
    export type StringList = String[];
    export type Subject = string;
    export type SubmittedBy = string;
    export type TimeCreated = string;
    export type TrustedAdvisorCheckList = TrustedAdvisorCheckDescription[];
    export type TrustedAdvisorCheckRefreshStatusList = TrustedAdvisorCheckRefreshStatus[];
    export type TrustedAdvisorCheckSummaryList = TrustedAdvisorCheckSummary[];
    export type TrustedAdvisorResourceDetailList = TrustedAdvisorResourceDetail[];

    export interface AddAttachmentsToSetRequest {
        attachmentSetId?: AttachmentSetId;
        attachments: Attachments;
    }
    export interface AddAttachmentsToSetResponse {
        attachmentSetId?: AttachmentSetId;
        expiryTime?: ExpiryTime;
    }
    export interface AddCommunicationToCaseRequest {
        caseId?: CaseId;
        communicationBody: CommunicationBody;
        ccEmailAddresses?: CcEmailAddressList;
        attachmentSetId?: AttachmentSetId;
    }
    export interface AddCommunicationToCaseResponse {
        result?: Result;
    }
    export interface Attachment {
        fileName?: FileName;
        data?: Data;
    }
    export interface AttachmentDetails {
        attachmentId?: AttachmentId;
        fileName?: FileName;
    }
    export interface AttachmentIdNotFound {
        message?: ErrorMessage;
    }
    export interface AttachmentLimitExceeded {
        message?: ErrorMessage;
    }
    export interface AttachmentSetExpired {
        message?: ErrorMessage;
    }
    export interface AttachmentSetIdNotFound {
        message?: ErrorMessage;
    }
    export interface AttachmentSetSizeLimitExceeded {
        message?: ErrorMessage;
    }
    export interface CaseCreationLimitExceeded {
        message?: ErrorMessage;
    }
    export interface CaseDetails {
        caseId?: CaseId;
        displayId?: DisplayId;
        subject?: Subject;
        status?: Status;
        serviceCode?: ServiceCode;
        categoryCode?: CategoryCode;
        severityCode?: SeverityCode;
        submittedBy?: SubmittedBy;
        timeCreated?: TimeCreated;
        recentCommunications?: RecentCaseCommunications;
        ccEmailAddresses?: CcEmailAddressList;
        language?: Language;
    }
    export interface CaseIdNotFound {
        message?: ErrorMessage;
    }
    export interface Category {
        code?: CategoryCode;
        name?: CategoryName;
    }
    export interface Communication {
        caseId?: CaseId;
        body?: CommunicationBody;
        submittedBy?: SubmittedBy;
        timeCreated?: TimeCreated;
        attachmentSet?: AttachmentSet;
    }
    export interface CreateCaseRequest {
        subject: Subject;
        serviceCode?: ServiceCode;
        severityCode?: SeverityCode;
        categoryCode?: CategoryCode;
        communicationBody: CommunicationBody;
        ccEmailAddresses?: CcEmailAddressList;
        language?: Language;
        issueType?: IssueType;
        attachmentSetId?: AttachmentSetId;
    }
    export interface CreateCaseResponse {
        caseId?: CaseId;
    }
    export interface DescribeAttachmentLimitExceeded {
        message?: ErrorMessage;
    }
    export interface DescribeAttachmentRequest {
        attachmentId: AttachmentId;
    }
    export interface DescribeAttachmentResponse {
        attachment?: Attachment;
    }
    export interface DescribeCasesRequest {
        caseIdList?: CaseIdList;
        displayId?: DisplayId;
        afterTime?: AfterTime;
        beforeTime?: BeforeTime;
        includeResolvedCases?: IncludeResolvedCases;
        nextToken?: NextToken;
        maxResults?: MaxResults;
        language?: Language;
        includeCommunications?: IncludeCommunications;
    }
    export interface DescribeCasesResponse {
        cases?: CaseList;
        nextToken?: NextToken;
    }
    export interface DescribeCommunicationsRequest {
        caseId: CaseId;
        beforeTime?: BeforeTime;
        afterTime?: AfterTime;
        nextToken?: NextToken;
        maxResults?: MaxResults;
    }
    export interface DescribeCommunicationsResponse {
        communications?: CommunicationList;
        nextToken?: NextToken;
    }
    export interface DescribeServicesRequest {
        serviceCodeList?: ServiceCodeList;
        language?: Language;
    }
    export interface DescribeServicesResponse {
        services?: ServiceList;
    }
    export interface DescribeSeverityLevelsRequest {
        language?: Language;
    }
    export interface DescribeSeverityLevelsResponse {
        severityLevels?: SeverityLevelsList;
    }
    export interface DescribeTrustedAdvisorCheckRefreshStatusesRequest {
        checkIds: StringList;
    }
    export interface DescribeTrustedAdvisorCheckRefreshStatusesResponse {
        statuses: TrustedAdvisorCheckRefreshStatusList;
    }
    export interface DescribeTrustedAdvisorCheckResultRequest {
        checkId: String;
        language?: String;
    }
    export interface DescribeTrustedAdvisorCheckResultResponse {
        result?: TrustedAdvisorCheckResult;
    }
    export interface DescribeTrustedAdvisorCheckSummariesRequest {
        checkIds: StringList;
    }
    export interface DescribeTrustedAdvisorCheckSummariesResponse {
        summaries: TrustedAdvisorCheckSummaryList;
    }
    export interface DescribeTrustedAdvisorChecksRequest {
        language: String;
    }
    export interface DescribeTrustedAdvisorChecksResponse {
        checks: TrustedAdvisorCheckList;
    }
    export interface InternalServerError {
        message?: ErrorMessage;
    }
    export interface RecentCaseCommunications {
        communications?: CommunicationList;
        nextToken?: NextToken;
    }
    export interface RefreshTrustedAdvisorCheckRequest {
        checkId: String;
    }
    export interface RefreshTrustedAdvisorCheckResponse {
        status: TrustedAdvisorCheckRefreshStatus;
    }
    export interface ResolveCaseRequest {
        caseId?: CaseId;
    }
    export interface ResolveCaseResponse {
        initialCaseStatus?: CaseStatus;
        finalCaseStatus?: CaseStatus;
    }
    export interface Service {
        code?: ServiceCode;
        name?: ServiceName;
        categories?: CategoryList;
    }
    export interface SeverityLevel {
        code?: SeverityLevelCode;
        name?: SeverityLevelName;
    }
    export interface TrustedAdvisorCategorySpecificSummary {
        costOptimizing?: TrustedAdvisorCostOptimizingSummary;
    }
    export interface TrustedAdvisorCheckDescription {
        id: String;
        name: String;
        description: String;
        category: String;
        metadata: StringList;
    }
    export interface TrustedAdvisorCheckRefreshStatus {
        checkId: String;
        status: String;
        millisUntilNextRefreshable: Long;
    }
    export interface TrustedAdvisorCheckResult {
        checkId: String;
        timestamp: String;
        status: String;
        resourcesSummary: TrustedAdvisorResourcesSummary;
        categorySpecificSummary: TrustedAdvisorCategorySpecificSummary;
        flaggedResources: TrustedAdvisorResourceDetailList;
    }
    export interface TrustedAdvisorCheckSummary {
        checkId: String;
        timestamp: String;
        status: String;
        hasFlaggedResources?: Boolean;
        resourcesSummary: TrustedAdvisorResourcesSummary;
        categorySpecificSummary: TrustedAdvisorCategorySpecificSummary;
    }
    export interface TrustedAdvisorCostOptimizingSummary {
        estimatedMonthlySavings: Double;
        estimatedPercentMonthlySavings: Double;
    }
    export interface TrustedAdvisorResourceDetail {
        status: String;
        region: String;
        resourceId: String;
        isSuppressed?: Boolean;
        metadata: StringList;
    }
    export interface TrustedAdvisorResourcesSummary {
        resourcesProcessed: Long;
        resourcesFlagged: Long;
        resourcesIgnored: Long;
        resourcesSuppressed: Long;
    }
  }

  /*
   * apiVersion: 2012-01-25
   * endpointPrefix: swf
   * serviceAbbreviation: Amazon SWF
   * signatureVersion: v4
   * protocol: json
   */
  export class SWF extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    countClosedWorkflowExecutions(params: SWF.CountClosedWorkflowExecutionsInput, callback?: (err: SWF.UnknownResourceFault|SWF.OperationNotPermittedFault|any, data: SWF.WorkflowExecutionCount|any) => void): Request;
    countOpenWorkflowExecutions(params: SWF.CountOpenWorkflowExecutionsInput, callback?: (err: SWF.UnknownResourceFault|SWF.OperationNotPermittedFault|any, data: SWF.WorkflowExecutionCount|any) => void): Request;
    countPendingActivityTasks(params: SWF.CountPendingActivityTasksInput, callback?: (err: SWF.UnknownResourceFault|SWF.OperationNotPermittedFault|any, data: SWF.PendingTaskCount|any) => void): Request;
    countPendingDecisionTasks(params: SWF.CountPendingDecisionTasksInput, callback?: (err: SWF.UnknownResourceFault|SWF.OperationNotPermittedFault|any, data: SWF.PendingTaskCount|any) => void): Request;
    deprecateActivityType(params: SWF.DeprecateActivityTypeInput, callback?: (err: SWF.UnknownResourceFault|SWF.TypeDeprecatedFault|SWF.OperationNotPermittedFault|any, data: any) => void): Request;
    deprecateDomain(params: SWF.DeprecateDomainInput, callback?: (err: SWF.UnknownResourceFault|SWF.DomainDeprecatedFault|SWF.OperationNotPermittedFault|any, data: any) => void): Request;
    deprecateWorkflowType(params: SWF.DeprecateWorkflowTypeInput, callback?: (err: SWF.UnknownResourceFault|SWF.TypeDeprecatedFault|SWF.OperationNotPermittedFault|any, data: any) => void): Request;
    describeActivityType(params: SWF.DescribeActivityTypeInput, callback?: (err: SWF.UnknownResourceFault|SWF.OperationNotPermittedFault|any, data: SWF.ActivityTypeDetail|any) => void): Request;
    describeDomain(params: SWF.DescribeDomainInput, callback?: (err: SWF.UnknownResourceFault|SWF.OperationNotPermittedFault|any, data: SWF.DomainDetail|any) => void): Request;
    describeWorkflowExecution(params: SWF.DescribeWorkflowExecutionInput, callback?: (err: SWF.UnknownResourceFault|SWF.OperationNotPermittedFault|any, data: SWF.WorkflowExecutionDetail|any) => void): Request;
    describeWorkflowType(params: SWF.DescribeWorkflowTypeInput, callback?: (err: SWF.UnknownResourceFault|SWF.OperationNotPermittedFault|any, data: SWF.WorkflowTypeDetail|any) => void): Request;
    getWorkflowExecutionHistory(params: SWF.GetWorkflowExecutionHistoryInput, callback?: (err: SWF.UnknownResourceFault|SWF.OperationNotPermittedFault|any, data: SWF.History|any) => void): Request;
    listActivityTypes(params: SWF.ListActivityTypesInput, callback?: (err: SWF.OperationNotPermittedFault|SWF.UnknownResourceFault|any, data: SWF.ActivityTypeInfos|any) => void): Request;
    listClosedWorkflowExecutions(params: SWF.ListClosedWorkflowExecutionsInput, callback?: (err: SWF.UnknownResourceFault|SWF.OperationNotPermittedFault|any, data: SWF.WorkflowExecutionInfos|any) => void): Request;
    listDomains(params: SWF.ListDomainsInput, callback?: (err: SWF.OperationNotPermittedFault|any, data: SWF.DomainInfos|any) => void): Request;
    listOpenWorkflowExecutions(params: SWF.ListOpenWorkflowExecutionsInput, callback?: (err: SWF.UnknownResourceFault|SWF.OperationNotPermittedFault|any, data: SWF.WorkflowExecutionInfos|any) => void): Request;
    listWorkflowTypes(params: SWF.ListWorkflowTypesInput, callback?: (err: SWF.OperationNotPermittedFault|SWF.UnknownResourceFault|any, data: SWF.WorkflowTypeInfos|any) => void): Request;
    pollForActivityTask(params: SWF.PollForActivityTaskInput, callback?: (err: SWF.UnknownResourceFault|SWF.OperationNotPermittedFault|SWF.LimitExceededFault|any, data: SWF.ActivityTask|any) => void): Request;
    pollForDecisionTask(params: SWF.PollForDecisionTaskInput, callback?: (err: SWF.UnknownResourceFault|SWF.OperationNotPermittedFault|SWF.LimitExceededFault|any, data: SWF.DecisionTask|any) => void): Request;
    recordActivityTaskHeartbeat(params: SWF.RecordActivityTaskHeartbeatInput, callback?: (err: SWF.UnknownResourceFault|SWF.OperationNotPermittedFault|any, data: SWF.ActivityTaskStatus|any) => void): Request;
    registerActivityType(params: SWF.RegisterActivityTypeInput, callback?: (err: SWF.TypeAlreadyExistsFault|SWF.LimitExceededFault|SWF.UnknownResourceFault|SWF.OperationNotPermittedFault|any, data: any) => void): Request;
    registerDomain(params: SWF.RegisterDomainInput, callback?: (err: SWF.DomainAlreadyExistsFault|SWF.LimitExceededFault|SWF.OperationNotPermittedFault|any, data: any) => void): Request;
    registerWorkflowType(params: SWF.RegisterWorkflowTypeInput, callback?: (err: SWF.TypeAlreadyExistsFault|SWF.LimitExceededFault|SWF.UnknownResourceFault|SWF.OperationNotPermittedFault|any, data: any) => void): Request;
    requestCancelWorkflowExecution(params: SWF.RequestCancelWorkflowExecutionInput, callback?: (err: SWF.UnknownResourceFault|SWF.OperationNotPermittedFault|any, data: any) => void): Request;
    respondActivityTaskCanceled(params: SWF.RespondActivityTaskCanceledInput, callback?: (err: SWF.UnknownResourceFault|SWF.OperationNotPermittedFault|any, data: any) => void): Request;
    respondActivityTaskCompleted(params: SWF.RespondActivityTaskCompletedInput, callback?: (err: SWF.UnknownResourceFault|SWF.OperationNotPermittedFault|any, data: any) => void): Request;
    respondActivityTaskFailed(params: SWF.RespondActivityTaskFailedInput, callback?: (err: SWF.UnknownResourceFault|SWF.OperationNotPermittedFault|any, data: any) => void): Request;
    respondDecisionTaskCompleted(params: SWF.RespondDecisionTaskCompletedInput, callback?: (err: SWF.UnknownResourceFault|SWF.OperationNotPermittedFault|any, data: any) => void): Request;
    signalWorkflowExecution(params: SWF.SignalWorkflowExecutionInput, callback?: (err: SWF.UnknownResourceFault|SWF.OperationNotPermittedFault|any, data: any) => void): Request;
    startWorkflowExecution(params: SWF.StartWorkflowExecutionInput, callback?: (err: SWF.UnknownResourceFault|SWF.TypeDeprecatedFault|SWF.WorkflowExecutionAlreadyStartedFault|SWF.LimitExceededFault|SWF.OperationNotPermittedFault|SWF.DefaultUndefinedFault|any, data: SWF.Run|any) => void): Request;
    terminateWorkflowExecution(params: SWF.TerminateWorkflowExecutionInput, callback?: (err: SWF.UnknownResourceFault|SWF.OperationNotPermittedFault|any, data: any) => void): Request;

  }

  export module SWF {
    export type ActivityId = string;    // max: 256, min: 1
    export type ActivityTaskTimeoutType = string;
    export type ActivityTypeInfoList = ActivityTypeInfo[];
    export type Arn = string;    // max: 1224, min: 1
    export type CancelTimerFailedCause = string;
    export type CancelWorkflowExecutionFailedCause = string;
    export type Canceled = boolean;
    export type CauseMessage = string;    // max: 1728
    export type ChildPolicy = string;
    export type CloseStatus = string;
    export type CompleteWorkflowExecutionFailedCause = string;
    export type ContinueAsNewWorkflowExecutionFailedCause = string;
    export type Count = number;
    export type Data = string;    // max: 32768
    export type DecisionList = Decision[];
    export type DecisionTaskTimeoutType = string;
    export type DecisionType = string;
    export type Description = string;    // max: 1024
    export type DomainInfoList = DomainInfo[];
    export type DomainName = string;    // max: 256, min: 1
    export type DurationInDays = string;    // max: 8, min: 1
    export type DurationInSeconds = string;    // max: 8, min: 1
    export type DurationInSecondsOptional = string;    // max: 8
    export type ErrorMessage = string;
    export type EventId = number;
    export type EventType = string;
    export type ExecutionStatus = string;
    export type FailWorkflowExecutionFailedCause = string;
    export type FailureReason = string;    // max: 256
    export type FunctionId = string;    // max: 256, min: 1
    export type FunctionInput = string;    // max: 32768, min: 1
    export type FunctionName = string;    // max: 64, min: 1
    export type HistoryEventList = HistoryEvent[];
    export type Identity = string;    // max: 256
    export type LambdaFunctionTimeoutType = string;
    export type LimitedData = string;    // max: 2048
    export type MarkerName = string;    // max: 256, min: 1
    export type Name = string;    // max: 256, min: 1
    export type OpenDecisionTasksCount = number;    // max: 1
    export type PageSize = number;    // max: 1000
    export type PageToken = string;    // max: 2048
    export type RecordMarkerFailedCause = string;
    export type RegistrationStatus = string;
    export type RequestCancelActivityTaskFailedCause = string;
    export type RequestCancelExternalWorkflowExecutionFailedCause = string;
    export type ReverseOrder = boolean;
    export type RunId = string;    // max: 64, min: 1
    export type RunIdOptional = string;    // max: 64
    export type ScheduleActivityTaskFailedCause = string;
    export type ScheduleLambdaFunctionFailedCause = string;
    export type SignalExternalWorkflowExecutionFailedCause = string;
    export type SignalName = string;    // max: 256, min: 1
    export type StartChildWorkflowExecutionFailedCause = string;
    export type StartLambdaFunctionFailedCause = string;
    export type StartTimerFailedCause = string;
    export type Tag = string;    // max: 256, min: 1
    export type TagList = Tag[];    // max: 5
    export type TaskPriority = string;    // max: 11
    export type TaskToken = string;    // max: 1024, min: 1
    export type TerminateReason = string;    // max: 256
    export type TimerId = string;    // max: 256, min: 1
    export type Timestamp = number;
    export type Truncated = boolean;
    export type Version = string;    // max: 64, min: 1
    export type VersionOptional = string;    // max: 64
    export type WorkflowExecutionCancelRequestedCause = string;
    export type WorkflowExecutionInfoList = WorkflowExecutionInfo[];
    export type WorkflowExecutionTerminatedCause = string;
    export type WorkflowExecutionTimeoutType = string;
    export type WorkflowId = string;    // max: 256, min: 1
    export type WorkflowTypeInfoList = WorkflowTypeInfo[];

    export interface ActivityTask {
        taskToken: TaskToken;
        activityId: ActivityId;
        startedEventId: EventId;
        workflowExecution: WorkflowExecution;
        activityType: ActivityType;
        input?: Data;
    }
    export interface ActivityTaskCancelRequestedEventAttributes {
        decisionTaskCompletedEventId: EventId;
        activityId: ActivityId;
    }
    export interface ActivityTaskCanceledEventAttributes {
        details?: Data;
        scheduledEventId: EventId;
        startedEventId: EventId;
        latestCancelRequestedEventId?: EventId;
    }
    export interface ActivityTaskCompletedEventAttributes {
        result?: Data;
        scheduledEventId: EventId;
        startedEventId: EventId;
    }
    export interface ActivityTaskFailedEventAttributes {
        reason?: FailureReason;
        details?: Data;
        scheduledEventId: EventId;
        startedEventId: EventId;
    }
    export interface ActivityTaskScheduledEventAttributes {
        activityType: ActivityType;
        activityId: ActivityId;
        input?: Data;
        control?: Data;
        scheduleToStartTimeout?: DurationInSecondsOptional;
        scheduleToCloseTimeout?: DurationInSecondsOptional;
        startToCloseTimeout?: DurationInSecondsOptional;
        taskList: TaskList;
        taskPriority?: TaskPriority;
        decisionTaskCompletedEventId: EventId;
        heartbeatTimeout?: DurationInSecondsOptional;
    }
    export interface ActivityTaskStartedEventAttributes {
        identity?: Identity;
        scheduledEventId: EventId;
    }
    export interface ActivityTaskStatus {
        cancelRequested: Canceled;
    }
    export interface ActivityTaskTimedOutEventAttributes {
        timeoutType: ActivityTaskTimeoutType;
        scheduledEventId: EventId;
        startedEventId: EventId;
        details?: LimitedData;
    }
    export interface ActivityType {
        name: Name;
        version: Version;
    }
    export interface ActivityTypeConfiguration {
        defaultTaskStartToCloseTimeout?: DurationInSecondsOptional;
        defaultTaskHeartbeatTimeout?: DurationInSecondsOptional;
        defaultTaskList?: TaskList;
        defaultTaskPriority?: TaskPriority;
        defaultTaskScheduleToStartTimeout?: DurationInSecondsOptional;
        defaultTaskScheduleToCloseTimeout?: DurationInSecondsOptional;
    }
    export interface ActivityTypeDetail {
        typeInfo: ActivityTypeInfo;
        configuration: ActivityTypeConfiguration;
    }
    export interface ActivityTypeInfo {
        activityType: ActivityType;
        status: RegistrationStatus;
        description?: Description;
        creationDate: Timestamp;
        deprecationDate?: Timestamp;
    }
    export interface ActivityTypeInfos {
        typeInfos: ActivityTypeInfoList;
        nextPageToken?: PageToken;
    }
    export interface CancelTimerDecisionAttributes {
        timerId: TimerId;
    }
    export interface CancelTimerFailedEventAttributes {
        timerId: TimerId;
        cause: CancelTimerFailedCause;
        decisionTaskCompletedEventId: EventId;
    }
    export interface CancelWorkflowExecutionDecisionAttributes {
        details?: Data;
    }
    export interface CancelWorkflowExecutionFailedEventAttributes {
        cause: CancelWorkflowExecutionFailedCause;
        decisionTaskCompletedEventId: EventId;
    }
    export interface ChildWorkflowExecutionCanceledEventAttributes {
        workflowExecution: WorkflowExecution;
        workflowType: WorkflowType;
        details?: Data;
        initiatedEventId: EventId;
        startedEventId: EventId;
    }
    export interface ChildWorkflowExecutionCompletedEventAttributes {
        workflowExecution: WorkflowExecution;
        workflowType: WorkflowType;
        result?: Data;
        initiatedEventId: EventId;
        startedEventId: EventId;
    }
    export interface ChildWorkflowExecutionFailedEventAttributes {
        workflowExecution: WorkflowExecution;
        workflowType: WorkflowType;
        reason?: FailureReason;
        details?: Data;
        initiatedEventId: EventId;
        startedEventId: EventId;
    }
    export interface ChildWorkflowExecutionStartedEventAttributes {
        workflowExecution: WorkflowExecution;
        workflowType: WorkflowType;
        initiatedEventId: EventId;
    }
    export interface ChildWorkflowExecutionTerminatedEventAttributes {
        workflowExecution: WorkflowExecution;
        workflowType: WorkflowType;
        initiatedEventId: EventId;
        startedEventId: EventId;
    }
    export interface ChildWorkflowExecutionTimedOutEventAttributes {
        workflowExecution: WorkflowExecution;
        workflowType: WorkflowType;
        timeoutType: WorkflowExecutionTimeoutType;
        initiatedEventId: EventId;
        startedEventId: EventId;
    }
    export interface CloseStatusFilter {
        status: CloseStatus;
    }
    export interface CompleteWorkflowExecutionDecisionAttributes {
        result?: Data;
    }
    export interface CompleteWorkflowExecutionFailedEventAttributes {
        cause: CompleteWorkflowExecutionFailedCause;
        decisionTaskCompletedEventId: EventId;
    }
    export interface ContinueAsNewWorkflowExecutionDecisionAttributes {
        input?: Data;
        executionStartToCloseTimeout?: DurationInSecondsOptional;
        taskList?: TaskList;
        taskPriority?: TaskPriority;
        taskStartToCloseTimeout?: DurationInSecondsOptional;
        childPolicy?: ChildPolicy;
        tagList?: TagList;
        workflowTypeVersion?: Version;
        lambdaRole?: Arn;
    }
    export interface ContinueAsNewWorkflowExecutionFailedEventAttributes {
        cause: ContinueAsNewWorkflowExecutionFailedCause;
        decisionTaskCompletedEventId: EventId;
    }
    export interface CountClosedWorkflowExecutionsInput {
        domain: DomainName;
        startTimeFilter?: ExecutionTimeFilter;
        closeTimeFilter?: ExecutionTimeFilter;
        executionFilter?: WorkflowExecutionFilter;
        typeFilter?: WorkflowTypeFilter;
        tagFilter?: TagFilter;
        closeStatusFilter?: CloseStatusFilter;
    }
    export interface CountOpenWorkflowExecutionsInput {
        domain: DomainName;
        startTimeFilter: ExecutionTimeFilter;
        typeFilter?: WorkflowTypeFilter;
        tagFilter?: TagFilter;
        executionFilter?: WorkflowExecutionFilter;
    }
    export interface CountPendingActivityTasksInput {
        domain: DomainName;
        taskList: TaskList;
    }
    export interface CountPendingDecisionTasksInput {
        domain: DomainName;
        taskList: TaskList;
    }
    export interface Decision {
        decisionType: DecisionType;
        scheduleActivityTaskDecisionAttributes?: ScheduleActivityTaskDecisionAttributes;
        requestCancelActivityTaskDecisionAttributes?: RequestCancelActivityTaskDecisionAttributes;
        completeWorkflowExecutionDecisionAttributes?: CompleteWorkflowExecutionDecisionAttributes;
        failWorkflowExecutionDecisionAttributes?: FailWorkflowExecutionDecisionAttributes;
        cancelWorkflowExecutionDecisionAttributes?: CancelWorkflowExecutionDecisionAttributes;
        continueAsNewWorkflowExecutionDecisionAttributes?: ContinueAsNewWorkflowExecutionDecisionAttributes;
        recordMarkerDecisionAttributes?: RecordMarkerDecisionAttributes;
        startTimerDecisionAttributes?: StartTimerDecisionAttributes;
        cancelTimerDecisionAttributes?: CancelTimerDecisionAttributes;
        signalExternalWorkflowExecutionDecisionAttributes?: SignalExternalWorkflowExecutionDecisionAttributes;
        requestCancelExternalWorkflowExecutionDecisionAttributes?: RequestCancelExternalWorkflowExecutionDecisionAttributes;
        startChildWorkflowExecutionDecisionAttributes?: StartChildWorkflowExecutionDecisionAttributes;
        scheduleLambdaFunctionDecisionAttributes?: ScheduleLambdaFunctionDecisionAttributes;
    }
    export interface DecisionTask {
        taskToken: TaskToken;
        startedEventId: EventId;
        workflowExecution: WorkflowExecution;
        workflowType: WorkflowType;
        events: HistoryEventList;
        nextPageToken?: PageToken;
        previousStartedEventId?: EventId;
    }
    export interface DecisionTaskCompletedEventAttributes {
        executionContext?: Data;
        scheduledEventId: EventId;
        startedEventId: EventId;
    }
    export interface DecisionTaskScheduledEventAttributes {
        taskList: TaskList;
        taskPriority?: TaskPriority;
        startToCloseTimeout?: DurationInSecondsOptional;
    }
    export interface DecisionTaskStartedEventAttributes {
        identity?: Identity;
        scheduledEventId: EventId;
    }
    export interface DecisionTaskTimedOutEventAttributes {
        timeoutType: DecisionTaskTimeoutType;
        scheduledEventId: EventId;
        startedEventId: EventId;
    }
    export interface DefaultUndefinedFault {
        message?: ErrorMessage;
    }
    export interface DeprecateActivityTypeInput {
        domain: DomainName;
        activityType: ActivityType;
    }
    export interface DeprecateDomainInput {
        name: DomainName;
    }
    export interface DeprecateWorkflowTypeInput {
        domain: DomainName;
        workflowType: WorkflowType;
    }
    export interface DescribeActivityTypeInput {
        domain: DomainName;
        activityType: ActivityType;
    }
    export interface DescribeDomainInput {
        name: DomainName;
    }
    export interface DescribeWorkflowExecutionInput {
        domain: DomainName;
        execution: WorkflowExecution;
    }
    export interface DescribeWorkflowTypeInput {
        domain: DomainName;
        workflowType: WorkflowType;
    }
    export interface DomainAlreadyExistsFault {
        message?: ErrorMessage;
    }
    export interface DomainConfiguration {
        workflowExecutionRetentionPeriodInDays: DurationInDays;
    }
    export interface DomainDeprecatedFault {
        message?: ErrorMessage;
    }
    export interface DomainDetail {
        domainInfo: DomainInfo;
        configuration: DomainConfiguration;
    }
    export interface DomainInfo {
        name: DomainName;
        status: RegistrationStatus;
        description?: Description;
    }
    export interface DomainInfos {
        domainInfos: DomainInfoList;
        nextPageToken?: PageToken;
    }
    export interface ExecutionTimeFilter {
        oldestDate: Timestamp;
        latestDate?: Timestamp;
    }
    export interface ExternalWorkflowExecutionCancelRequestedEventAttributes {
        workflowExecution: WorkflowExecution;
        initiatedEventId: EventId;
    }
    export interface ExternalWorkflowExecutionSignaledEventAttributes {
        workflowExecution: WorkflowExecution;
        initiatedEventId: EventId;
    }
    export interface FailWorkflowExecutionDecisionAttributes {
        reason?: FailureReason;
        details?: Data;
    }
    export interface FailWorkflowExecutionFailedEventAttributes {
        cause: FailWorkflowExecutionFailedCause;
        decisionTaskCompletedEventId: EventId;
    }
    export interface GetWorkflowExecutionHistoryInput {
        domain: DomainName;
        execution: WorkflowExecution;
        nextPageToken?: PageToken;
        maximumPageSize?: PageSize;
        reverseOrder?: ReverseOrder;
    }
    export interface History {
        events: HistoryEventList;
        nextPageToken?: PageToken;
    }
    export interface HistoryEvent {
        eventTimestamp: Timestamp;
        eventType: EventType;
        eventId: EventId;
        workflowExecutionStartedEventAttributes?: WorkflowExecutionStartedEventAttributes;
        workflowExecutionCompletedEventAttributes?: WorkflowExecutionCompletedEventAttributes;
        completeWorkflowExecutionFailedEventAttributes?: CompleteWorkflowExecutionFailedEventAttributes;
        workflowExecutionFailedEventAttributes?: WorkflowExecutionFailedEventAttributes;
        failWorkflowExecutionFailedEventAttributes?: FailWorkflowExecutionFailedEventAttributes;
        workflowExecutionTimedOutEventAttributes?: WorkflowExecutionTimedOutEventAttributes;
        workflowExecutionCanceledEventAttributes?: WorkflowExecutionCanceledEventAttributes;
        cancelWorkflowExecutionFailedEventAttributes?: CancelWorkflowExecutionFailedEventAttributes;
        workflowExecutionContinuedAsNewEventAttributes?: WorkflowExecutionContinuedAsNewEventAttributes;
        continueAsNewWorkflowExecutionFailedEventAttributes?: ContinueAsNewWorkflowExecutionFailedEventAttributes;
        workflowExecutionTerminatedEventAttributes?: WorkflowExecutionTerminatedEventAttributes;
        workflowExecutionCancelRequestedEventAttributes?: WorkflowExecutionCancelRequestedEventAttributes;
        decisionTaskScheduledEventAttributes?: DecisionTaskScheduledEventAttributes;
        decisionTaskStartedEventAttributes?: DecisionTaskStartedEventAttributes;
        decisionTaskCompletedEventAttributes?: DecisionTaskCompletedEventAttributes;
        decisionTaskTimedOutEventAttributes?: DecisionTaskTimedOutEventAttributes;
        activityTaskScheduledEventAttributes?: ActivityTaskScheduledEventAttributes;
        activityTaskStartedEventAttributes?: ActivityTaskStartedEventAttributes;
        activityTaskCompletedEventAttributes?: ActivityTaskCompletedEventAttributes;
        activityTaskFailedEventAttributes?: ActivityTaskFailedEventAttributes;
        activityTaskTimedOutEventAttributes?: ActivityTaskTimedOutEventAttributes;
        activityTaskCanceledEventAttributes?: ActivityTaskCanceledEventAttributes;
        activityTaskCancelRequestedEventAttributes?: ActivityTaskCancelRequestedEventAttributes;
        workflowExecutionSignaledEventAttributes?: WorkflowExecutionSignaledEventAttributes;
        markerRecordedEventAttributes?: MarkerRecordedEventAttributes;
        recordMarkerFailedEventAttributes?: RecordMarkerFailedEventAttributes;
        timerStartedEventAttributes?: TimerStartedEventAttributes;
        timerFiredEventAttributes?: TimerFiredEventAttributes;
        timerCanceledEventAttributes?: TimerCanceledEventAttributes;
        startChildWorkflowExecutionInitiatedEventAttributes?: StartChildWorkflowExecutionInitiatedEventAttributes;
        childWorkflowExecutionStartedEventAttributes?: ChildWorkflowExecutionStartedEventAttributes;
        childWorkflowExecutionCompletedEventAttributes?: ChildWorkflowExecutionCompletedEventAttributes;
        childWorkflowExecutionFailedEventAttributes?: ChildWorkflowExecutionFailedEventAttributes;
        childWorkflowExecutionTimedOutEventAttributes?: ChildWorkflowExecutionTimedOutEventAttributes;
        childWorkflowExecutionCanceledEventAttributes?: ChildWorkflowExecutionCanceledEventAttributes;
        childWorkflowExecutionTerminatedEventAttributes?: ChildWorkflowExecutionTerminatedEventAttributes;
        signalExternalWorkflowExecutionInitiatedEventAttributes?: SignalExternalWorkflowExecutionInitiatedEventAttributes;
        externalWorkflowExecutionSignaledEventAttributes?: ExternalWorkflowExecutionSignaledEventAttributes;
        signalExternalWorkflowExecutionFailedEventAttributes?: SignalExternalWorkflowExecutionFailedEventAttributes;
        externalWorkflowExecutionCancelRequestedEventAttributes?: ExternalWorkflowExecutionCancelRequestedEventAttributes;
        requestCancelExternalWorkflowExecutionInitiatedEventAttributes?: RequestCancelExternalWorkflowExecutionInitiatedEventAttributes;
        requestCancelExternalWorkflowExecutionFailedEventAttributes?: RequestCancelExternalWorkflowExecutionFailedEventAttributes;
        scheduleActivityTaskFailedEventAttributes?: ScheduleActivityTaskFailedEventAttributes;
        requestCancelActivityTaskFailedEventAttributes?: RequestCancelActivityTaskFailedEventAttributes;
        startTimerFailedEventAttributes?: StartTimerFailedEventAttributes;
        cancelTimerFailedEventAttributes?: CancelTimerFailedEventAttributes;
        startChildWorkflowExecutionFailedEventAttributes?: StartChildWorkflowExecutionFailedEventAttributes;
        lambdaFunctionScheduledEventAttributes?: LambdaFunctionScheduledEventAttributes;
        lambdaFunctionStartedEventAttributes?: LambdaFunctionStartedEventAttributes;
        lambdaFunctionCompletedEventAttributes?: LambdaFunctionCompletedEventAttributes;
        lambdaFunctionFailedEventAttributes?: LambdaFunctionFailedEventAttributes;
        lambdaFunctionTimedOutEventAttributes?: LambdaFunctionTimedOutEventAttributes;
        scheduleLambdaFunctionFailedEventAttributes?: ScheduleLambdaFunctionFailedEventAttributes;
        startLambdaFunctionFailedEventAttributes?: StartLambdaFunctionFailedEventAttributes;
    }
    export interface LambdaFunctionCompletedEventAttributes {
        scheduledEventId: EventId;
        startedEventId: EventId;
        result?: Data;
    }
    export interface LambdaFunctionFailedEventAttributes {
        scheduledEventId: EventId;
        startedEventId: EventId;
        reason?: FailureReason;
        details?: Data;
    }
    export interface LambdaFunctionScheduledEventAttributes {
        id: FunctionId;
        name: FunctionName;
        input?: FunctionInput;
        startToCloseTimeout?: DurationInSecondsOptional;
        decisionTaskCompletedEventId: EventId;
    }
    export interface LambdaFunctionStartedEventAttributes {
        scheduledEventId: EventId;
    }
    export interface LambdaFunctionTimedOutEventAttributes {
        scheduledEventId: EventId;
        startedEventId: EventId;
        timeoutType?: LambdaFunctionTimeoutType;
    }
    export interface LimitExceededFault {
        message?: ErrorMessage;
    }
    export interface ListActivityTypesInput {
        domain: DomainName;
        name?: Name;
        registrationStatus: RegistrationStatus;
        nextPageToken?: PageToken;
        maximumPageSize?: PageSize;
        reverseOrder?: ReverseOrder;
    }
    export interface ListClosedWorkflowExecutionsInput {
        domain: DomainName;
        startTimeFilter?: ExecutionTimeFilter;
        closeTimeFilter?: ExecutionTimeFilter;
        executionFilter?: WorkflowExecutionFilter;
        closeStatusFilter?: CloseStatusFilter;
        typeFilter?: WorkflowTypeFilter;
        tagFilter?: TagFilter;
        nextPageToken?: PageToken;
        maximumPageSize?: PageSize;
        reverseOrder?: ReverseOrder;
    }
    export interface ListDomainsInput {
        nextPageToken?: PageToken;
        registrationStatus: RegistrationStatus;
        maximumPageSize?: PageSize;
        reverseOrder?: ReverseOrder;
    }
    export interface ListOpenWorkflowExecutionsInput {
        domain: DomainName;
        startTimeFilter: ExecutionTimeFilter;
        typeFilter?: WorkflowTypeFilter;
        tagFilter?: TagFilter;
        nextPageToken?: PageToken;
        maximumPageSize?: PageSize;
        reverseOrder?: ReverseOrder;
        executionFilter?: WorkflowExecutionFilter;
    }
    export interface ListWorkflowTypesInput {
        domain: DomainName;
        name?: Name;
        registrationStatus: RegistrationStatus;
        nextPageToken?: PageToken;
        maximumPageSize?: PageSize;
        reverseOrder?: ReverseOrder;
    }
    export interface MarkerRecordedEventAttributes {
        markerName: MarkerName;
        details?: Data;
        decisionTaskCompletedEventId: EventId;
    }
    export interface OperationNotPermittedFault {
        message?: ErrorMessage;
    }
    export interface PendingTaskCount {
        count: Count;
        truncated?: Truncated;
    }
    export interface PollForActivityTaskInput {
        domain: DomainName;
        taskList: TaskList;
        identity?: Identity;
    }
    export interface PollForDecisionTaskInput {
        domain: DomainName;
        taskList: TaskList;
        identity?: Identity;
        nextPageToken?: PageToken;
        maximumPageSize?: PageSize;
        reverseOrder?: ReverseOrder;
    }
    export interface RecordActivityTaskHeartbeatInput {
        taskToken: TaskToken;
        details?: LimitedData;
    }
    export interface RecordMarkerDecisionAttributes {
        markerName: MarkerName;
        details?: Data;
    }
    export interface RecordMarkerFailedEventAttributes {
        markerName: MarkerName;
        cause: RecordMarkerFailedCause;
        decisionTaskCompletedEventId: EventId;
    }
    export interface RegisterActivityTypeInput {
        domain: DomainName;
        name: Name;
        version: Version;
        description?: Description;
        defaultTaskStartToCloseTimeout?: DurationInSecondsOptional;
        defaultTaskHeartbeatTimeout?: DurationInSecondsOptional;
        defaultTaskList?: TaskList;
        defaultTaskPriority?: TaskPriority;
        defaultTaskScheduleToStartTimeout?: DurationInSecondsOptional;
        defaultTaskScheduleToCloseTimeout?: DurationInSecondsOptional;
    }
    export interface RegisterDomainInput {
        name: DomainName;
        description?: Description;
        workflowExecutionRetentionPeriodInDays: DurationInDays;
    }
    export interface RegisterWorkflowTypeInput {
        domain: DomainName;
        name: Name;
        version: Version;
        description?: Description;
        defaultTaskStartToCloseTimeout?: DurationInSecondsOptional;
        defaultExecutionStartToCloseTimeout?: DurationInSecondsOptional;
        defaultTaskList?: TaskList;
        defaultTaskPriority?: TaskPriority;
        defaultChildPolicy?: ChildPolicy;
        defaultLambdaRole?: Arn;
    }
    export interface RequestCancelActivityTaskDecisionAttributes {
        activityId: ActivityId;
    }
    export interface RequestCancelActivityTaskFailedEventAttributes {
        activityId: ActivityId;
        cause: RequestCancelActivityTaskFailedCause;
        decisionTaskCompletedEventId: EventId;
    }
    export interface RequestCancelExternalWorkflowExecutionDecisionAttributes {
        workflowId: WorkflowId;
        runId?: RunIdOptional;
        control?: Data;
    }
    export interface RequestCancelExternalWorkflowExecutionFailedEventAttributes {
        workflowId: WorkflowId;
        runId?: RunIdOptional;
        cause: RequestCancelExternalWorkflowExecutionFailedCause;
        initiatedEventId: EventId;
        decisionTaskCompletedEventId: EventId;
        control?: Data;
    }
    export interface RequestCancelExternalWorkflowExecutionInitiatedEventAttributes {
        workflowId: WorkflowId;
        runId?: RunIdOptional;
        decisionTaskCompletedEventId: EventId;
        control?: Data;
    }
    export interface RequestCancelWorkflowExecutionInput {
        domain: DomainName;
        workflowId: WorkflowId;
        runId?: RunIdOptional;
    }
    export interface RespondActivityTaskCanceledInput {
        taskToken: TaskToken;
        details?: Data;
    }
    export interface RespondActivityTaskCompletedInput {
        taskToken: TaskToken;
        result?: Data;
    }
    export interface RespondActivityTaskFailedInput {
        taskToken: TaskToken;
        reason?: FailureReason;
        details?: Data;
    }
    export interface RespondDecisionTaskCompletedInput {
        taskToken: TaskToken;
        decisions?: DecisionList;
        executionContext?: Data;
    }
    export interface Run {
        runId?: RunId;
    }
    export interface ScheduleActivityTaskDecisionAttributes {
        activityType: ActivityType;
        activityId: ActivityId;
        control?: Data;
        input?: Data;
        scheduleToCloseTimeout?: DurationInSecondsOptional;
        taskList?: TaskList;
        taskPriority?: TaskPriority;
        scheduleToStartTimeout?: DurationInSecondsOptional;
        startToCloseTimeout?: DurationInSecondsOptional;
        heartbeatTimeout?: DurationInSecondsOptional;
    }
    export interface ScheduleActivityTaskFailedEventAttributes {
        activityType: ActivityType;
        activityId: ActivityId;
        cause: ScheduleActivityTaskFailedCause;
        decisionTaskCompletedEventId: EventId;
    }
    export interface ScheduleLambdaFunctionDecisionAttributes {
        id: FunctionId;
        name: FunctionName;
        input?: FunctionInput;
        startToCloseTimeout?: DurationInSecondsOptional;
    }
    export interface ScheduleLambdaFunctionFailedEventAttributes {
        id: FunctionId;
        name: FunctionName;
        cause: ScheduleLambdaFunctionFailedCause;
        decisionTaskCompletedEventId: EventId;
    }
    export interface SignalExternalWorkflowExecutionDecisionAttributes {
        workflowId: WorkflowId;
        runId?: RunIdOptional;
        signalName: SignalName;
        input?: Data;
        control?: Data;
    }
    export interface SignalExternalWorkflowExecutionFailedEventAttributes {
        workflowId: WorkflowId;
        runId?: RunIdOptional;
        cause: SignalExternalWorkflowExecutionFailedCause;
        initiatedEventId: EventId;
        decisionTaskCompletedEventId: EventId;
        control?: Data;
    }
    export interface SignalExternalWorkflowExecutionInitiatedEventAttributes {
        workflowId: WorkflowId;
        runId?: RunIdOptional;
        signalName: SignalName;
        input?: Data;
        decisionTaskCompletedEventId: EventId;
        control?: Data;
    }
    export interface SignalWorkflowExecutionInput {
        domain: DomainName;
        workflowId: WorkflowId;
        runId?: RunIdOptional;
        signalName: SignalName;
        input?: Data;
    }
    export interface StartChildWorkflowExecutionDecisionAttributes {
        workflowType: WorkflowType;
        workflowId: WorkflowId;
        control?: Data;
        input?: Data;
        executionStartToCloseTimeout?: DurationInSecondsOptional;
        taskList?: TaskList;
        taskPriority?: TaskPriority;
        taskStartToCloseTimeout?: DurationInSecondsOptional;
        childPolicy?: ChildPolicy;
        tagList?: TagList;
        lambdaRole?: Arn;
    }
    export interface StartChildWorkflowExecutionFailedEventAttributes {
        workflowType: WorkflowType;
        cause: StartChildWorkflowExecutionFailedCause;
        workflowId: WorkflowId;
        initiatedEventId: EventId;
        decisionTaskCompletedEventId: EventId;
        control?: Data;
    }
    export interface StartChildWorkflowExecutionInitiatedEventAttributes {
        workflowId: WorkflowId;
        workflowType: WorkflowType;
        control?: Data;
        input?: Data;
        executionStartToCloseTimeout?: DurationInSecondsOptional;
        taskList: TaskList;
        taskPriority?: TaskPriority;
        decisionTaskCompletedEventId: EventId;
        childPolicy: ChildPolicy;
        taskStartToCloseTimeout?: DurationInSecondsOptional;
        tagList?: TagList;
        lambdaRole?: Arn;
    }
    export interface StartLambdaFunctionFailedEventAttributes {
        scheduledEventId?: EventId;
        cause?: StartLambdaFunctionFailedCause;
        message?: CauseMessage;
    }
    export interface StartTimerDecisionAttributes {
        timerId: TimerId;
        control?: Data;
        startToFireTimeout: DurationInSeconds;
    }
    export interface StartTimerFailedEventAttributes {
        timerId: TimerId;
        cause: StartTimerFailedCause;
        decisionTaskCompletedEventId: EventId;
    }
    export interface StartWorkflowExecutionInput {
        domain: DomainName;
        workflowId: WorkflowId;
        workflowType: WorkflowType;
        taskList?: TaskList;
        taskPriority?: TaskPriority;
        input?: Data;
        executionStartToCloseTimeout?: DurationInSecondsOptional;
        tagList?: TagList;
        taskStartToCloseTimeout?: DurationInSecondsOptional;
        childPolicy?: ChildPolicy;
        lambdaRole?: Arn;
    }
    export interface TagFilter {
        tag: Tag;
    }
    export interface TaskList {
        name: Name;
    }
    export interface TerminateWorkflowExecutionInput {
        domain: DomainName;
        workflowId: WorkflowId;
        runId?: RunIdOptional;
        reason?: TerminateReason;
        details?: Data;
        childPolicy?: ChildPolicy;
    }
    export interface TimerCanceledEventAttributes {
        timerId: TimerId;
        startedEventId: EventId;
        decisionTaskCompletedEventId: EventId;
    }
    export interface TimerFiredEventAttributes {
        timerId: TimerId;
        startedEventId: EventId;
    }
    export interface TimerStartedEventAttributes {
        timerId: TimerId;
        control?: Data;
        startToFireTimeout: DurationInSeconds;
        decisionTaskCompletedEventId: EventId;
    }
    export interface TypeAlreadyExistsFault {
        message?: ErrorMessage;
    }
    export interface TypeDeprecatedFault {
        message?: ErrorMessage;
    }
    export interface UnknownResourceFault {
        message?: ErrorMessage;
    }
    export interface WorkflowExecution {
        workflowId: WorkflowId;
        runId: RunId;
    }
    export interface WorkflowExecutionAlreadyStartedFault {
        message?: ErrorMessage;
    }
    export interface WorkflowExecutionCancelRequestedEventAttributes {
        externalWorkflowExecution?: WorkflowExecution;
        externalInitiatedEventId?: EventId;
        cause?: WorkflowExecutionCancelRequestedCause;
    }
    export interface WorkflowExecutionCanceledEventAttributes {
        details?: Data;
        decisionTaskCompletedEventId: EventId;
    }
    export interface WorkflowExecutionCompletedEventAttributes {
        result?: Data;
        decisionTaskCompletedEventId: EventId;
    }
    export interface WorkflowExecutionConfiguration {
        taskStartToCloseTimeout: DurationInSeconds;
        executionStartToCloseTimeout: DurationInSeconds;
        taskList: TaskList;
        taskPriority?: TaskPriority;
        childPolicy: ChildPolicy;
        lambdaRole?: Arn;
    }
    export interface WorkflowExecutionContinuedAsNewEventAttributes {
        input?: Data;
        decisionTaskCompletedEventId: EventId;
        newExecutionRunId: RunId;
        executionStartToCloseTimeout?: DurationInSecondsOptional;
        taskList: TaskList;
        taskPriority?: TaskPriority;
        taskStartToCloseTimeout?: DurationInSecondsOptional;
        childPolicy: ChildPolicy;
        tagList?: TagList;
        workflowType: WorkflowType;
        lambdaRole?: Arn;
    }
    export interface WorkflowExecutionCount {
        count: Count;
        truncated?: Truncated;
    }
    export interface WorkflowExecutionDetail {
        executionInfo: WorkflowExecutionInfo;
        executionConfiguration: WorkflowExecutionConfiguration;
        openCounts: WorkflowExecutionOpenCounts;
        latestActivityTaskTimestamp?: Timestamp;
        latestExecutionContext?: Data;
    }
    export interface WorkflowExecutionFailedEventAttributes {
        reason?: FailureReason;
        details?: Data;
        decisionTaskCompletedEventId: EventId;
    }
    export interface WorkflowExecutionFilter {
        workflowId: WorkflowId;
    }
    export interface WorkflowExecutionInfo {
        execution: WorkflowExecution;
        workflowType: WorkflowType;
        startTimestamp: Timestamp;
        closeTimestamp?: Timestamp;
        executionStatus: ExecutionStatus;
        closeStatus?: CloseStatus;
        parent?: WorkflowExecution;
        tagList?: TagList;
        cancelRequested?: Canceled;
    }
    export interface WorkflowExecutionInfos {
        executionInfos: WorkflowExecutionInfoList;
        nextPageToken?: PageToken;
    }
    export interface WorkflowExecutionOpenCounts {
        openActivityTasks: Count;
        openDecisionTasks: OpenDecisionTasksCount;
        openTimers: Count;
        openChildWorkflowExecutions: Count;
        openLambdaFunctions?: Count;
    }
    export interface WorkflowExecutionSignaledEventAttributes {
        signalName: SignalName;
        input?: Data;
        externalWorkflowExecution?: WorkflowExecution;
        externalInitiatedEventId?: EventId;
    }
    export interface WorkflowExecutionStartedEventAttributes {
        input?: Data;
        executionStartToCloseTimeout?: DurationInSecondsOptional;
        taskStartToCloseTimeout?: DurationInSecondsOptional;
        childPolicy: ChildPolicy;
        taskList: TaskList;
        workflowType: WorkflowType;
        tagList?: TagList;
        taskPriority?: TaskPriority;
        continuedExecutionRunId?: RunIdOptional;
        parentWorkflowExecution?: WorkflowExecution;
        parentInitiatedEventId?: EventId;
        lambdaRole?: Arn;
    }
    export interface WorkflowExecutionTerminatedEventAttributes {
        reason?: TerminateReason;
        details?: Data;
        childPolicy: ChildPolicy;
        cause?: WorkflowExecutionTerminatedCause;
    }
    export interface WorkflowExecutionTimedOutEventAttributes {
        timeoutType: WorkflowExecutionTimeoutType;
        childPolicy: ChildPolicy;
    }
    export interface WorkflowType {
        name: Name;
        version: Version;
    }
    export interface WorkflowTypeConfiguration {
        defaultTaskStartToCloseTimeout?: DurationInSecondsOptional;
        defaultExecutionStartToCloseTimeout?: DurationInSecondsOptional;
        defaultTaskList?: TaskList;
        defaultTaskPriority?: TaskPriority;
        defaultChildPolicy?: ChildPolicy;
        defaultLambdaRole?: Arn;
    }
    export interface WorkflowTypeDetail {
        typeInfo: WorkflowTypeInfo;
        configuration: WorkflowTypeConfiguration;
    }
    export interface WorkflowTypeFilter {
        name: Name;
        version?: VersionOptional;
    }
    export interface WorkflowTypeInfo {
        workflowType: WorkflowType;
        status: RegistrationStatus;
        description?: Description;
        creationDate: Timestamp;
        deprecationDate?: Timestamp;
    }
    export interface WorkflowTypeInfos {
        typeInfos: WorkflowTypeInfoList;
        nextPageToken?: PageToken;
    }
  }

  /*
   * apiVersion: 2015-08-24
   * endpointPrefix: waf
   * serviceAbbreviation: WAF
   * signatureVersion: v4
   * protocol: json
   */
  export class WAF extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    createByteMatchSet(params: WAF.CreateByteMatchSetRequest, callback?: (err: WAF.WAFDisallowedNameException|WAF.WAFInternalErrorException|WAF.WAFInvalidAccountException|WAF.WAFInvalidParameterException|WAF.WAFStaleDataException|WAF.WAFLimitsExceededException|any, data: WAF.CreateByteMatchSetResponse|any) => void): Request;
    createIPSet(params: WAF.CreateIPSetRequest, callback?: (err: WAF.WAFStaleDataException|WAF.WAFInternalErrorException|WAF.WAFInvalidAccountException|WAF.WAFDisallowedNameException|WAF.WAFInvalidParameterException|WAF.WAFLimitsExceededException|any, data: WAF.CreateIPSetResponse|any) => void): Request;
    createRule(params: WAF.CreateRuleRequest, callback?: (err: WAF.WAFStaleDataException|WAF.WAFInternalErrorException|WAF.WAFDisallowedNameException|WAF.WAFInvalidParameterException|WAF.WAFLimitsExceededException|any, data: WAF.CreateRuleResponse|any) => void): Request;
    createSizeConstraintSet(params: WAF.CreateSizeConstraintSetRequest, callback?: (err: WAF.WAFStaleDataException|WAF.WAFInternalErrorException|WAF.WAFInvalidAccountException|WAF.WAFDisallowedNameException|WAF.WAFInvalidParameterException|WAF.WAFLimitsExceededException|any, data: WAF.CreateSizeConstraintSetResponse|any) => void): Request;
    createSqlInjectionMatchSet(params: WAF.CreateSqlInjectionMatchSetRequest, callback?: (err: WAF.WAFDisallowedNameException|WAF.WAFInternalErrorException|WAF.WAFInvalidAccountException|WAF.WAFInvalidParameterException|WAF.WAFStaleDataException|WAF.WAFLimitsExceededException|any, data: WAF.CreateSqlInjectionMatchSetResponse|any) => void): Request;
    createWebACL(params: WAF.CreateWebACLRequest, callback?: (err: WAF.WAFStaleDataException|WAF.WAFInternalErrorException|WAF.WAFInvalidAccountException|WAF.WAFDisallowedNameException|WAF.WAFInvalidParameterException|WAF.WAFLimitsExceededException|any, data: WAF.CreateWebACLResponse|any) => void): Request;
    deleteByteMatchSet(params: WAF.DeleteByteMatchSetRequest, callback?: (err: WAF.WAFInternalErrorException|WAF.WAFInvalidAccountException|WAF.WAFNonexistentItemException|WAF.WAFReferencedItemException|WAF.WAFStaleDataException|WAF.WAFNonEmptyEntityException|any, data: WAF.DeleteByteMatchSetResponse|any) => void): Request;
    deleteIPSet(params: WAF.DeleteIPSetRequest, callback?: (err: WAF.WAFStaleDataException|WAF.WAFInternalErrorException|WAF.WAFInvalidAccountException|WAF.WAFNonexistentItemException|WAF.WAFReferencedItemException|WAF.WAFNonEmptyEntityException|any, data: WAF.DeleteIPSetResponse|any) => void): Request;
    deleteRule(params: WAF.DeleteRuleRequest, callback?: (err: WAF.WAFStaleDataException|WAF.WAFInternalErrorException|WAF.WAFInvalidAccountException|WAF.WAFNonexistentItemException|WAF.WAFReferencedItemException|WAF.WAFNonEmptyEntityException|any, data: WAF.DeleteRuleResponse|any) => void): Request;
    deleteSizeConstraintSet(params: WAF.DeleteSizeConstraintSetRequest, callback?: (err: WAF.WAFStaleDataException|WAF.WAFInternalErrorException|WAF.WAFInvalidAccountException|WAF.WAFNonexistentItemException|WAF.WAFReferencedItemException|WAF.WAFNonEmptyEntityException|any, data: WAF.DeleteSizeConstraintSetResponse|any) => void): Request;
    deleteSqlInjectionMatchSet(params: WAF.DeleteSqlInjectionMatchSetRequest, callback?: (err: WAF.WAFInternalErrorException|WAF.WAFInvalidAccountException|WAF.WAFNonexistentItemException|WAF.WAFReferencedItemException|WAF.WAFStaleDataException|WAF.WAFNonEmptyEntityException|any, data: WAF.DeleteSqlInjectionMatchSetResponse|any) => void): Request;
    deleteWebACL(params: WAF.DeleteWebACLRequest, callback?: (err: WAF.WAFStaleDataException|WAF.WAFInternalErrorException|WAF.WAFInvalidAccountException|WAF.WAFNonexistentItemException|WAF.WAFReferencedItemException|WAF.WAFNonEmptyEntityException|any, data: WAF.DeleteWebACLResponse|any) => void): Request;
    getByteMatchSet(params: WAF.GetByteMatchSetRequest, callback?: (err: WAF.WAFInternalErrorException|WAF.WAFInvalidAccountException|WAF.WAFNonexistentItemException|any, data: WAF.GetByteMatchSetResponse|any) => void): Request;
    getChangeToken(params: WAF.GetChangeTokenRequest, callback?: (err: WAF.WAFInternalErrorException|any, data: WAF.GetChangeTokenResponse|any) => void): Request;
    getChangeTokenStatus(params: WAF.GetChangeTokenStatusRequest, callback?: (err: WAF.WAFNonexistentItemException|WAF.WAFInternalErrorException|any, data: WAF.GetChangeTokenStatusResponse|any) => void): Request;
    getIPSet(params: WAF.GetIPSetRequest, callback?: (err: WAF.WAFInternalErrorException|WAF.WAFInvalidAccountException|WAF.WAFNonexistentItemException|any, data: WAF.GetIPSetResponse|any) => void): Request;
    getRule(params: WAF.GetRuleRequest, callback?: (err: WAF.WAFInternalErrorException|WAF.WAFInvalidAccountException|WAF.WAFNonexistentItemException|any, data: WAF.GetRuleResponse|any) => void): Request;
    getSampledRequests(params: WAF.GetSampledRequestsRequest, callback?: (err: WAF.WAFNonexistentItemException|WAF.WAFInternalErrorException|any, data: WAF.GetSampledRequestsResponse|any) => void): Request;
    getSizeConstraintSet(params: WAF.GetSizeConstraintSetRequest, callback?: (err: WAF.WAFInternalErrorException|WAF.WAFInvalidAccountException|WAF.WAFNonexistentItemException|any, data: WAF.GetSizeConstraintSetResponse|any) => void): Request;
    getSqlInjectionMatchSet(params: WAF.GetSqlInjectionMatchSetRequest, callback?: (err: WAF.WAFInternalErrorException|WAF.WAFInvalidAccountException|WAF.WAFNonexistentItemException|any, data: WAF.GetSqlInjectionMatchSetResponse|any) => void): Request;
    getWebACL(params: WAF.GetWebACLRequest, callback?: (err: WAF.WAFInternalErrorException|WAF.WAFInvalidAccountException|WAF.WAFNonexistentItemException|any, data: WAF.GetWebACLResponse|any) => void): Request;
    listByteMatchSets(params: WAF.ListByteMatchSetsRequest, callback?: (err: WAF.WAFInternalErrorException|WAF.WAFInvalidAccountException|any, data: WAF.ListByteMatchSetsResponse|any) => void): Request;
    listIPSets(params: WAF.ListIPSetsRequest, callback?: (err: WAF.WAFInternalErrorException|WAF.WAFInvalidAccountException|any, data: WAF.ListIPSetsResponse|any) => void): Request;
    listRules(params: WAF.ListRulesRequest, callback?: (err: WAF.WAFInternalErrorException|WAF.WAFInvalidAccountException|any, data: WAF.ListRulesResponse|any) => void): Request;
    listSizeConstraintSets(params: WAF.ListSizeConstraintSetsRequest, callback?: (err: WAF.WAFInternalErrorException|WAF.WAFInvalidAccountException|any, data: WAF.ListSizeConstraintSetsResponse|any) => void): Request;
    listSqlInjectionMatchSets(params: WAF.ListSqlInjectionMatchSetsRequest, callback?: (err: WAF.WAFInternalErrorException|WAF.WAFInvalidAccountException|any, data: WAF.ListSqlInjectionMatchSetsResponse|any) => void): Request;
    listWebACLs(params: WAF.ListWebACLsRequest, callback?: (err: WAF.WAFInternalErrorException|WAF.WAFInvalidAccountException|any, data: WAF.ListWebACLsResponse|any) => void): Request;
    updateByteMatchSet(params: WAF.UpdateByteMatchSetRequest, callback?: (err: WAF.WAFInternalErrorException|WAF.WAFInvalidAccountException|WAF.WAFInvalidOperationException|WAF.WAFInvalidParameterException|WAF.WAFNonexistentContainerException|WAF.WAFNonexistentItemException|WAF.WAFStaleDataException|WAF.WAFLimitsExceededException|any, data: WAF.UpdateByteMatchSetResponse|any) => void): Request;
    updateIPSet(params: WAF.UpdateIPSetRequest, callback?: (err: WAF.WAFStaleDataException|WAF.WAFInternalErrorException|WAF.WAFInvalidAccountException|WAF.WAFInvalidOperationException|WAF.WAFInvalidParameterException|WAF.WAFNonexistentContainerException|WAF.WAFNonexistentItemException|WAF.WAFReferencedItemException|WAF.WAFLimitsExceededException|any, data: WAF.UpdateIPSetResponse|any) => void): Request;
    updateRule(params: WAF.UpdateRuleRequest, callback?: (err: WAF.WAFStaleDataException|WAF.WAFInternalErrorException|WAF.WAFInvalidAccountException|WAF.WAFInvalidOperationException|WAF.WAFInvalidParameterException|WAF.WAFNonexistentContainerException|WAF.WAFNonexistentItemException|WAF.WAFReferencedItemException|WAF.WAFLimitsExceededException|any, data: WAF.UpdateRuleResponse|any) => void): Request;
    updateSizeConstraintSet(params: WAF.UpdateSizeConstraintSetRequest, callback?: (err: WAF.WAFStaleDataException|WAF.WAFInternalErrorException|WAF.WAFInvalidAccountException|WAF.WAFInvalidOperationException|WAF.WAFInvalidParameterException|WAF.WAFNonexistentContainerException|WAF.WAFNonexistentItemException|WAF.WAFReferencedItemException|WAF.WAFLimitsExceededException|any, data: WAF.UpdateSizeConstraintSetResponse|any) => void): Request;
    updateSqlInjectionMatchSet(params: WAF.UpdateSqlInjectionMatchSetRequest, callback?: (err: WAF.WAFInternalErrorException|WAF.WAFInvalidAccountException|WAF.WAFInvalidOperationException|WAF.WAFInvalidParameterException|WAF.WAFNonexistentContainerException|WAF.WAFNonexistentItemException|WAF.WAFStaleDataException|WAF.WAFLimitsExceededException|any, data: WAF.UpdateSqlInjectionMatchSetResponse|any) => void): Request;
    updateWebACL(params: WAF.UpdateWebACLRequest, callback?: (err: WAF.WAFStaleDataException|WAF.WAFInternalErrorException|WAF.WAFInvalidAccountException|WAF.WAFInvalidOperationException|WAF.WAFInvalidParameterException|WAF.WAFNonexistentContainerException|WAF.WAFNonexistentItemException|WAF.WAFReferencedItemException|WAF.WAFLimitsExceededException|any, data: WAF.UpdateWebACLResponse|any) => void): Request;

  }

  export module WAF {
    export type Action = string;
    export type ActivatedRules = ActivatedRule[];
    export type ByteMatchSetSummaries = ByteMatchSetSummary[];
    export type ByteMatchSetUpdates = ByteMatchSetUpdate[];
    export type ByteMatchTargetString = any;    // type: blob
    export type ByteMatchTuples = ByteMatchTuple[];
    export type ChangeAction = string;
    export type ChangeToken = string;
    export type ChangeTokenStatus = string;
    export type ComparisonOperator = string;
    export type Country = string;
    export type HTTPHeaders = HTTPHeader[];
    export type HTTPMethod = string;
    export type HTTPVersion = string;
    export type HeaderName = string;
    export type HeaderValue = string;
    export type IPSetDescriptorType = string;
    export type IPSetDescriptorValue = string;
    export type IPSetDescriptors = IPSetDescriptor[];
    export type IPSetSummaries = IPSetSummary[];
    export type IPSetUpdates = IPSetUpdate[];
    export type IPString = string;
    export type ListMaxItems = number;    // max: 100, min: 1
    export type MatchFieldData = string;
    export type MatchFieldType = string;
    export type MetricName = string;
    export type Negated = boolean;
    export type NextMarker = string;    // min: 1
    export type PaginationLimit = number;    // max: 100, min: 1
    export type ParameterExceptionField = string;
    export type ParameterExceptionParameter = string;    // min: 1
    export type ParameterExceptionReason = string;
    export type PopulationSize = number;
    export type PositionalConstraint = string;
    export type PredicateType = string;
    export type Predicates = Predicate[];
    export type ResourceId = string;    // max: 128, min: 1
    export type ResourceName = string;    // max: 128, min: 1
    export type RulePriority = number;
    export type RuleSummaries = RuleSummary[];
    export type RuleUpdates = RuleUpdate[];
    export type SampleWeight = number;
    export type SampledHTTPRequests = SampledHTTPRequest[];
    export type Size = number;
    export type SizeConstraintSetSummaries = SizeConstraintSetSummary[];
    export type SizeConstraintSetUpdates = SizeConstraintSetUpdate[];
    export type SizeConstraints = SizeConstraint[];
    export type SqlInjectionMatchSetSummaries = SqlInjectionMatchSetSummary[];
    export type SqlInjectionMatchSetUpdates = SqlInjectionMatchSetUpdate[];
    export type SqlInjectionMatchTuples = SqlInjectionMatchTuple[];
    export type TextTransformation = string;
    export type Timestamp = number;
    export type URIString = string;
    export type WafActionType = string;
    export type WebACLSummaries = WebACLSummary[];
    export type WebACLUpdates = WebACLUpdate[];
    export type errorMessage = string;

    export interface ActivatedRule {
        Priority: RulePriority;
        RuleId: ResourceId;
        Action: WafAction;
    }
    export interface ByteMatchSet {
        ByteMatchSetId: ResourceId;
        Name?: ResourceName;
        ByteMatchTuples: ByteMatchTuples;
    }
    export interface ByteMatchSetSummary {
        ByteMatchSetId: ResourceId;
        Name: ResourceName;
    }
    export interface ByteMatchSetUpdate {
        Action: ChangeAction;
        ByteMatchTuple: ByteMatchTuple;
    }
    export interface ByteMatchTuple {
        FieldToMatch: FieldToMatch;
        TargetString: ByteMatchTargetString;
        TextTransformation: TextTransformation;
        PositionalConstraint: PositionalConstraint;
    }
    export interface CreateByteMatchSetRequest {
        Name: ResourceName;
        ChangeToken: ChangeToken;
    }
    export interface CreateByteMatchSetResponse {
        ByteMatchSet?: ByteMatchSet;
        ChangeToken?: ChangeToken;
    }
    export interface CreateIPSetRequest {
        Name: ResourceName;
        ChangeToken: ChangeToken;
    }
    export interface CreateIPSetResponse {
        IPSet?: IPSet;
        ChangeToken?: ChangeToken;
    }
    export interface CreateRuleRequest {
        Name: ResourceName;
        MetricName: MetricName;
        ChangeToken: ChangeToken;
    }
    export interface CreateRuleResponse {
        Rule?: Rule;
        ChangeToken?: ChangeToken;
    }
    export interface CreateSizeConstraintSetRequest {
        Name: ResourceName;
        ChangeToken: ChangeToken;
    }
    export interface CreateSizeConstraintSetResponse {
        SizeConstraintSet?: SizeConstraintSet;
        ChangeToken?: ChangeToken;
    }
    export interface CreateSqlInjectionMatchSetRequest {
        Name: ResourceName;
        ChangeToken: ChangeToken;
    }
    export interface CreateSqlInjectionMatchSetResponse {
        SqlInjectionMatchSet?: SqlInjectionMatchSet;
        ChangeToken?: ChangeToken;
    }
    export interface CreateWebACLRequest {
        Name: ResourceName;
        MetricName: MetricName;
        DefaultAction: WafAction;
        ChangeToken: ChangeToken;
    }
    export interface CreateWebACLResponse {
        WebACL?: WebACL;
        ChangeToken?: ChangeToken;
    }
    export interface DeleteByteMatchSetRequest {
        ByteMatchSetId: ResourceId;
        ChangeToken: ChangeToken;
    }
    export interface DeleteByteMatchSetResponse {
        ChangeToken?: ChangeToken;
    }
    export interface DeleteIPSetRequest {
        IPSetId: ResourceId;
        ChangeToken: ChangeToken;
    }
    export interface DeleteIPSetResponse {
        ChangeToken?: ChangeToken;
    }
    export interface DeleteRuleRequest {
        RuleId: ResourceId;
        ChangeToken: ChangeToken;
    }
    export interface DeleteRuleResponse {
        ChangeToken?: ChangeToken;
    }
    export interface DeleteSizeConstraintSetRequest {
        SizeConstraintSetId: ResourceId;
        ChangeToken: ChangeToken;
    }
    export interface DeleteSizeConstraintSetResponse {
        ChangeToken?: ChangeToken;
    }
    export interface DeleteSqlInjectionMatchSetRequest {
        SqlInjectionMatchSetId: ResourceId;
        ChangeToken: ChangeToken;
    }
    export interface DeleteSqlInjectionMatchSetResponse {
        ChangeToken?: ChangeToken;
    }
    export interface DeleteWebACLRequest {
        WebACLId: ResourceId;
        ChangeToken: ChangeToken;
    }
    export interface DeleteWebACLResponse {
        ChangeToken?: ChangeToken;
    }
    export interface FieldToMatch {
        Type: MatchFieldType;
        Data?: MatchFieldData;
    }
    export interface GetByteMatchSetRequest {
        ByteMatchSetId: ResourceId;
    }
    export interface GetByteMatchSetResponse {
        ByteMatchSet?: ByteMatchSet;
    }
    export interface GetChangeTokenRequest {
    }
    export interface GetChangeTokenResponse {
        ChangeToken?: ChangeToken;
    }
    export interface GetChangeTokenStatusRequest {
        ChangeToken: ChangeToken;
    }
    export interface GetChangeTokenStatusResponse {
        ChangeTokenStatus?: ChangeTokenStatus;
    }
    export interface GetIPSetRequest {
        IPSetId: ResourceId;
    }
    export interface GetIPSetResponse {
        IPSet?: IPSet;
    }
    export interface GetRuleRequest {
        RuleId: ResourceId;
    }
    export interface GetRuleResponse {
        Rule?: Rule;
    }
    export interface GetSampledRequestsRequest {
        WebAclId: ResourceId;
        RuleId: ResourceId;
        TimeWindow: TimeWindow;
        MaxItems: ListMaxItems;
    }
    export interface GetSampledRequestsResponse {
        SampledRequests?: SampledHTTPRequests;
        PopulationSize?: PopulationSize;
        TimeWindow?: TimeWindow;
    }
    export interface GetSizeConstraintSetRequest {
        SizeConstraintSetId: ResourceId;
    }
    export interface GetSizeConstraintSetResponse {
        SizeConstraintSet?: SizeConstraintSet;
    }
    export interface GetSqlInjectionMatchSetRequest {
        SqlInjectionMatchSetId: ResourceId;
    }
    export interface GetSqlInjectionMatchSetResponse {
        SqlInjectionMatchSet?: SqlInjectionMatchSet;
    }
    export interface GetWebACLRequest {
        WebACLId: ResourceId;
    }
    export interface GetWebACLResponse {
        WebACL?: WebACL;
    }
    export interface HTTPHeader {
        Name?: HeaderName;
        Value?: HeaderValue;
    }
    export interface HTTPRequest {
        ClientIP?: IPString;
        Country?: Country;
        URI?: URIString;
        Method?: HTTPMethod;
        HTTPVersion?: HTTPVersion;
        Headers?: HTTPHeaders;
    }
    export interface IPSet {
        IPSetId: ResourceId;
        Name?: ResourceName;
        IPSetDescriptors: IPSetDescriptors;
    }
    export interface IPSetDescriptor {
        Type: IPSetDescriptorType;
        Value: IPSetDescriptorValue;
    }
    export interface IPSetSummary {
        IPSetId: ResourceId;
        Name: ResourceName;
    }
    export interface IPSetUpdate {
        Action: ChangeAction;
        IPSetDescriptor: IPSetDescriptor;
    }
    export interface ListByteMatchSetsRequest {
        NextMarker?: NextMarker;
        Limit: PaginationLimit;
    }
    export interface ListByteMatchSetsResponse {
        NextMarker?: NextMarker;
        ByteMatchSets?: ByteMatchSetSummaries;
    }
    export interface ListIPSetsRequest {
        NextMarker?: NextMarker;
        Limit: PaginationLimit;
    }
    export interface ListIPSetsResponse {
        NextMarker?: NextMarker;
        IPSets?: IPSetSummaries;
    }
    export interface ListRulesRequest {
        NextMarker?: NextMarker;
        Limit: PaginationLimit;
    }
    export interface ListRulesResponse {
        NextMarker?: NextMarker;
        Rules?: RuleSummaries;
    }
    export interface ListSizeConstraintSetsRequest {
        NextMarker?: NextMarker;
        Limit: PaginationLimit;
    }
    export interface ListSizeConstraintSetsResponse {
        NextMarker?: NextMarker;
        SizeConstraintSets?: SizeConstraintSetSummaries;
    }
    export interface ListSqlInjectionMatchSetsRequest {
        NextMarker?: NextMarker;
        Limit: PaginationLimit;
    }
    export interface ListSqlInjectionMatchSetsResponse {
        NextMarker?: NextMarker;
        SqlInjectionMatchSets?: SqlInjectionMatchSetSummaries;
    }
    export interface ListWebACLsRequest {
        NextMarker?: NextMarker;
        Limit: PaginationLimit;
    }
    export interface ListWebACLsResponse {
        NextMarker?: NextMarker;
        WebACLs?: WebACLSummaries;
    }
    export interface Predicate {
        Negated: Negated;
        Type: PredicateType;
        DataId: ResourceId;
    }
    export interface Rule {
        RuleId: ResourceId;
        Name?: ResourceName;
        MetricName?: MetricName;
        Predicates: Predicates;
    }
    export interface RuleSummary {
        RuleId: ResourceId;
        Name: ResourceName;
    }
    export interface RuleUpdate {
        Action: ChangeAction;
        Predicate: Predicate;
    }
    export interface SampledHTTPRequest {
        Request: HTTPRequest;
        Weight: SampleWeight;
        Timestamp?: Timestamp;
        Action?: Action;
    }
    export interface SizeConstraint {
        FieldToMatch: FieldToMatch;
        TextTransformation: TextTransformation;
        ComparisonOperator: ComparisonOperator;
        Size: Size;
    }
    export interface SizeConstraintSet {
        SizeConstraintSetId: ResourceId;
        Name?: ResourceName;
        SizeConstraints: SizeConstraints;
    }
    export interface SizeConstraintSetSummary {
        SizeConstraintSetId: ResourceId;
        Name: ResourceName;
    }
    export interface SizeConstraintSetUpdate {
        Action: ChangeAction;
        SizeConstraint: SizeConstraint;
    }
    export interface SqlInjectionMatchSet {
        SqlInjectionMatchSetId: ResourceId;
        Name?: ResourceName;
        SqlInjectionMatchTuples: SqlInjectionMatchTuples;
    }
    export interface SqlInjectionMatchSetSummary {
        SqlInjectionMatchSetId: ResourceId;
        Name: ResourceName;
    }
    export interface SqlInjectionMatchSetUpdate {
        Action: ChangeAction;
        SqlInjectionMatchTuple: SqlInjectionMatchTuple;
    }
    export interface SqlInjectionMatchTuple {
        FieldToMatch: FieldToMatch;
        TextTransformation: TextTransformation;
    }
    export interface TimeWindow {
        StartTime: Timestamp;
        EndTime: Timestamp;
    }
    export interface UpdateByteMatchSetRequest {
        ByteMatchSetId: ResourceId;
        ChangeToken: ChangeToken;
        Updates: ByteMatchSetUpdates;
    }
    export interface UpdateByteMatchSetResponse {
        ChangeToken?: ChangeToken;
    }
    export interface UpdateIPSetRequest {
        IPSetId: ResourceId;
        ChangeToken: ChangeToken;
        Updates: IPSetUpdates;
    }
    export interface UpdateIPSetResponse {
        ChangeToken?: ChangeToken;
    }
    export interface UpdateRuleRequest {
        RuleId: ResourceId;
        ChangeToken: ChangeToken;
        Updates: RuleUpdates;
    }
    export interface UpdateRuleResponse {
        ChangeToken?: ChangeToken;
    }
    export interface UpdateSizeConstraintSetRequest {
        SizeConstraintSetId: ResourceId;
        ChangeToken: ChangeToken;
        Updates: SizeConstraintSetUpdates;
    }
    export interface UpdateSizeConstraintSetResponse {
        ChangeToken?: ChangeToken;
    }
    export interface UpdateSqlInjectionMatchSetRequest {
        SqlInjectionMatchSetId: ResourceId;
        ChangeToken: ChangeToken;
        Updates: SqlInjectionMatchSetUpdates;
    }
    export interface UpdateSqlInjectionMatchSetResponse {
        ChangeToken?: ChangeToken;
    }
    export interface UpdateWebACLRequest {
        WebACLId: ResourceId;
        ChangeToken: ChangeToken;
        Updates?: WebACLUpdates;
        DefaultAction?: WafAction;
    }
    export interface UpdateWebACLResponse {
        ChangeToken?: ChangeToken;
    }
    export interface WAFDisallowedNameException {
        message?: errorMessage;
    }
    export interface WAFInternalErrorException {
        message?: errorMessage;
    }
    export interface WAFInvalidAccountException {
    }
    export interface WAFInvalidOperationException {
        message?: errorMessage;
    }
    export interface WAFInvalidParameterException {
        field?: ParameterExceptionField;
        parameter?: ParameterExceptionParameter;
        reason?: ParameterExceptionReason;
    }
    export interface WAFLimitsExceededException {
        message?: errorMessage;
    }
    export interface WAFNonEmptyEntityException {
        message?: errorMessage;
    }
    export interface WAFNonexistentContainerException {
        message?: errorMessage;
    }
    export interface WAFNonexistentItemException {
        message?: errorMessage;
    }
    export interface WAFReferencedItemException {
        message?: errorMessage;
    }
    export interface WAFStaleDataException {
        message?: errorMessage;
    }
    export interface WafAction {
        Type: WafActionType;
    }
    export interface WebACL {
        WebACLId: ResourceId;
        Name?: ResourceName;
        MetricName?: MetricName;
        DefaultAction: WafAction;
        Rules: ActivatedRules;
    }
    export interface WebACLSummary {
        WebACLId: ResourceId;
        Name: ResourceName;
    }
    export interface WebACLUpdate {
        Action: ChangeAction;
        ActivatedRule: ActivatedRule;
    }
  }

  /*
   * apiVersion: 2015-04-08
   * endpointPrefix: workspaces
   * serviceAbbreviation: 
   * signatureVersion: v4
   * protocol: json
   */
  export class WorkSpaces extends Service {
    constructor(options?: any);
    endpoint: Endpoint;
    createWorkspaces(params: WorkSpaces.CreateWorkspacesRequest, callback?: (err: WorkSpaces.ResourceLimitExceededException|any, data: WorkSpaces.CreateWorkspacesResult|any) => void): Request;
    describeWorkspaceBundles(params: WorkSpaces.DescribeWorkspaceBundlesRequest, callback?: (err: WorkSpaces.InvalidParameterValuesException|any, data: WorkSpaces.DescribeWorkspaceBundlesResult|any) => void): Request;
    describeWorkspaceDirectories(params: WorkSpaces.DescribeWorkspaceDirectoriesRequest, callback?: (err: WorkSpaces.InvalidParameterValuesException|any, data: WorkSpaces.DescribeWorkspaceDirectoriesResult|any) => void): Request;
    describeWorkspaces(params: WorkSpaces.DescribeWorkspacesRequest, callback?: (err: WorkSpaces.InvalidParameterValuesException|WorkSpaces.ResourceUnavailableException|any, data: WorkSpaces.DescribeWorkspacesResult|any) => void): Request;
    rebootWorkspaces(params: WorkSpaces.RebootWorkspacesRequest, callback?: (err: any, data: WorkSpaces.RebootWorkspacesResult|any) => void): Request;
    rebuildWorkspaces(params: WorkSpaces.RebuildWorkspacesRequest, callback?: (err: any, data: WorkSpaces.RebuildWorkspacesResult|any) => void): Request;
    terminateWorkspaces(params: WorkSpaces.TerminateWorkspacesRequest, callback?: (err: any, data: WorkSpaces.TerminateWorkspacesResult|any) => void): Request;

  }

  export module WorkSpaces {
    export type ARN = string;    // pattern: &quot;^arn:aws:[A-Za-z0-9][A-za-z0-9_/.-]{0,62}:[A-za-z0-9_/.-]{0,63}:[A-za-z0-9_/.-]{0,63}:[A-Za-z0-9][A-za-z0-9_/.-]{0,127}$&quot;
    export type Alias = string;
    export type BooleanObject = boolean;
    export type BundleId = string;    // pattern: &quot;^wsb-[0-9a-z]{8,63}$&quot;
    export type BundleIdList = BundleId[];    // max: 25, min: 1
    export type BundleList = WorkspaceBundle[];
    export type BundleOwner = string;
    export type Compute = string;
    export type ComputerName = string;
    export type DefaultOu = string;
    export type Description = string;
    export type DirectoryId = string;    // pattern: &quot;^d-[0-9a-f]{8,63}$&quot;
    export type DirectoryIdList = DirectoryId[];    // max: 25, min: 1
    export type DirectoryList = WorkspaceDirectory[];
    export type DirectoryName = string;
    export type DnsIpAddresses = IpAddress[];
    export type ErrorType = string;
    export type ExceptionMessage = string;
    export type FailedCreateWorkspaceRequests = FailedCreateWorkspaceRequest[];
    export type FailedRebootWorkspaceRequests = FailedWorkspaceChangeRequest[];
    export type FailedRebuildWorkspaceRequests = FailedWorkspaceChangeRequest[];
    export type FailedTerminateWorkspaceRequests = FailedWorkspaceChangeRequest[];
    export type IpAddress = string;
    export type Limit = number;    // max: 25, min: 1
    export type NonEmptyString = string;    // min: 1
    export type PaginationToken = string;    // max: 63, min: 1
    export type RebootWorkspaceRequests = RebootRequest[];    // max: 25, min: 1
    export type RebuildWorkspaceRequests = RebuildRequest[];    // max: 1, min: 1
    export type RegistrationCode = string;    // max: 20, min: 1
    export type SecurityGroupId = string;    // pattern: &quot;^(sg-[0-9a-f]{8})$&quot;
    export type SubnetId = string;    // pattern: &quot;^(subnet-[0-9a-f]{8})$&quot;
    export type SubnetIds = SubnetId[];
    export type TerminateWorkspaceRequests = TerminateRequest[];    // max: 25, min: 1
    export type UserName = string;    // max: 63, min: 1
    export type VolumeEncryptionKey = string;
    export type WorkspaceDirectoryState = string;
    export type WorkspaceDirectoryType = string;
    export type WorkspaceErrorCode = string;
    export type WorkspaceId = string;    // pattern: &quot;^ws-[0-9a-z]{8,63}$&quot;
    export type WorkspaceIdList = WorkspaceId[];    // max: 25, min: 1
    export type WorkspaceList = Workspace[];
    export type WorkspaceRequestList = WorkspaceRequest[];    // max: 25, min: 1
    export type WorkspaceState = string;

    export interface ComputeType {
        Name?: Compute;
    }
    export interface CreateWorkspacesRequest {
        Workspaces: WorkspaceRequestList;
    }
    export interface CreateWorkspacesResult {
        FailedRequests?: FailedCreateWorkspaceRequests;
        PendingRequests?: WorkspaceList;
    }
    export interface DefaultWorkspaceCreationProperties {
        EnableWorkDocs?: BooleanObject;
        EnableInternetAccess?: BooleanObject;
        DefaultOu?: DefaultOu;
        CustomSecurityGroupId?: SecurityGroupId;
        UserEnabledAsLocalAdministrator?: BooleanObject;
    }
    export interface DescribeWorkspaceBundlesRequest {
        BundleIds?: BundleIdList;
        Owner?: BundleOwner;
        NextToken?: PaginationToken;
    }
    export interface DescribeWorkspaceBundlesResult {
        Bundles?: BundleList;
        NextToken?: PaginationToken;
    }
    export interface DescribeWorkspaceDirectoriesRequest {
        DirectoryIds?: DirectoryIdList;
        NextToken?: PaginationToken;
    }
    export interface DescribeWorkspaceDirectoriesResult {
        Directories?: DirectoryList;
        NextToken?: PaginationToken;
    }
    export interface DescribeWorkspacesRequest {
        WorkspaceIds?: WorkspaceIdList;
        DirectoryId?: DirectoryId;
        UserName?: UserName;
        BundleId?: BundleId;
        Limit?: Limit;
        NextToken?: PaginationToken;
    }
    export interface DescribeWorkspacesResult {
        Workspaces?: WorkspaceList;
        NextToken?: PaginationToken;
    }
    export interface FailedCreateWorkspaceRequest {
        WorkspaceRequest?: WorkspaceRequest;
        ErrorCode?: ErrorType;
        ErrorMessage?: Description;
    }
    export interface FailedWorkspaceChangeRequest {
        WorkspaceId?: WorkspaceId;
        ErrorCode?: ErrorType;
        ErrorMessage?: Description;
    }
    export interface InvalidParameterValuesException {
        message?: ExceptionMessage;
    }
    export interface RebootRequest {
        WorkspaceId: WorkspaceId;
    }
    export interface RebootWorkspacesRequest {
        RebootWorkspaceRequests: RebootWorkspaceRequests;
    }
    export interface RebootWorkspacesResult {
        FailedRequests?: FailedRebootWorkspaceRequests;
    }
    export interface RebuildRequest {
        WorkspaceId: WorkspaceId;
    }
    export interface RebuildWorkspacesRequest {
        RebuildWorkspaceRequests: RebuildWorkspaceRequests;
    }
    export interface RebuildWorkspacesResult {
        FailedRequests?: FailedRebuildWorkspaceRequests;
    }
    export interface ResourceLimitExceededException {
        message?: ExceptionMessage;
    }
    export interface ResourceUnavailableException {
        message?: ExceptionMessage;
        ResourceId?: NonEmptyString;
    }
    export interface TerminateRequest {
        WorkspaceId: WorkspaceId;
    }
    export interface TerminateWorkspacesRequest {
        TerminateWorkspaceRequests: TerminateWorkspaceRequests;
    }
    export interface TerminateWorkspacesResult {
        FailedRequests?: FailedTerminateWorkspaceRequests;
    }
    export interface UserStorage {
        Capacity?: NonEmptyString;
    }
    export interface Workspace {
        WorkspaceId?: WorkspaceId;
        DirectoryId?: DirectoryId;
        UserName?: UserName;
        IpAddress?: IpAddress;
        State?: WorkspaceState;
        BundleId?: BundleId;
        SubnetId?: SubnetId;
        ErrorMessage?: Description;
        ErrorCode?: WorkspaceErrorCode;
        ComputerName?: ComputerName;
        VolumeEncryptionKey?: VolumeEncryptionKey;
        UserVolumeEncryptionEnabled?: BooleanObject;
        RootVolumeEncryptionEnabled?: BooleanObject;
    }
    export interface WorkspaceBundle {
        BundleId?: BundleId;
        Name?: NonEmptyString;
        Owner?: BundleOwner;
        Description?: Description;
        UserStorage?: UserStorage;
        ComputeType?: ComputeType;
    }
    export interface WorkspaceDirectory {
        DirectoryId?: DirectoryId;
        Alias?: Alias;
        DirectoryName?: DirectoryName;
        RegistrationCode?: RegistrationCode;
        SubnetIds?: SubnetIds;
        DnsIpAddresses?: DnsIpAddresses;
        CustomerUserName?: UserName;
        IamRoleId?: ARN;
        DirectoryType?: WorkspaceDirectoryType;
        WorkspaceSecurityGroupId?: SecurityGroupId;
        State?: WorkspaceDirectoryState;
        WorkspaceCreationProperties?: DefaultWorkspaceCreationProperties;
    }
    export interface WorkspaceRequest {
        DirectoryId: DirectoryId;
        UserName: UserName;
        BundleId: BundleId;
        VolumeEncryptionKey?: VolumeEncryptionKey;
        UserVolumeEncryptionEnabled?: BooleanObject;
        RootVolumeEncryptionEnabled?: BooleanObject;
    }
  }


}
